Springer Texts in Statistics

Series Editors:
G. Casella
S. Fienberg
I. Olkin

For further volumes:
http://www.springer.com/series/417

Gareth James • Daniela Witten • Trevor Hastie
Robert Tibshirani

An Introduction to
Statistical Learning

with Applications in R

123

Gareth James
Department of Data Sciences and 

Operations

University of Southern California
Los Angeles, CA, USA

Trevor Hastie
Department of Statistics
Stanford University
Stanford, CA, USA

Daniela Witten
Department of Biostatistics
University of Washington
Seattle, WA, USA

Robert Tibshirani
Department of Statistics
Stanford University
Stanford, CA, USA

ISSN 1431-875X
ISBN 978-1-4614-7137-0
DOI 10.1007/978-1-4614-7138-7
Springer New York Heidelberg Dordrecht London

ISBN 978-1-4614-7138-7 (eBook)

Library of Congress Control Number: 2013936251

th printing 2017)
8

© Springer Science+Business Media New York 2013 (Corrected at
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part
of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations,
recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and transmission or
information storage and retrieval, electronic adaptation, computer software, or by similar or dissim-
ilar methodology now known or hereafter developed. Exempted from this legal reservation are brief
excerpts in connection with reviews or scholarly analysis or material supplied speciﬁcally for the pur-
pose of being entered and executed on a computer system, for exclusive use by the purchaser of the
work. Duplication of this publication or parts thereof is permitted only under the provisions of the
Copyright Law of the Publisher’s location, in its current version, and permission for use must always
be obtained from Springer. Permissions for use may be obtained through RightsLink at the Copyright
Clearance Center. Violations are liable to prosecution under the respective Copyright Law.
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publi-
cation does not imply, even in the absence of a speciﬁc statement, that such names are exempt from
the relevant protective laws and regulations and therefore free for general use.
While the advice and information in this book are believed to be true and accurate at the date of
publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for
any errors or omissions that may be made. The publisher makes no warranty, express or implied, with
respect to the material contained herein.

Printed on acid-free paper

Springer is part of Springer Science+Business Media (www.springer.com)

To our parents:

Alison and Michael James

Chiara Nappi and Edward Witten

Valerie and Patrick Hastie

Vera and Sami Tibshirani

and to our families:

Michael, Daniel, and Catherine

Tessa, Theo, and Ari

Samantha, Timothy, and Lynda

Charlie, Ryan, Julie, and Cheryl

Preface

Statistical learning refers to a set of tools for modeling and understanding
complex datasets. It is a recently developed area in statistics and blends
with parallel developments in computer science and, in particular, machine
learning. The ﬁeld encompasses many methods such as the lasso and sparse
regression, classiﬁcation and regression trees, and boosting and support
vector machines.

With the explosion of “Big Data” problems, statistical learning has be-
come a very hot ﬁeld in many scientiﬁc areas as well as marketing, ﬁnance,
and other business disciplines. People with statistical learning skills are in
high demand.

One of the ﬁrst books in this area—The Elements of Statistical Learning
(ESL) (Hastie, Tibshirani, and Friedman)—was published in 2001, with a
second edition in 2009. ESL has become a popular text not only in statis-
tics but also in related ﬁelds. One of the reasons for ESL’s popularity is
its relatively accessible style. But ESL is intended for individuals with ad-
vanced training in the mathematical sciences. An Introduction to Statistical
Learning (ISL) arose from the perceived need for a broader and less tech-
nical treatment of these topics. In this new book, we cover many of the
same topics as ESL, but we concentrate more on the applications of the
methods and less on the mathematical details. We have created labs illus-
trating how to implement each of the statistical learning methods using the
popular statistical software package R. These labs provide the reader with
valuable hands-on experience.

This book is appropriate for advanced undergraduates or master’s stu-
dents in statistics or related quantitative ﬁelds or for individuals in other

vii

viii

Preface

disciplines who wish to use statistical learning tools to analyze their data.
It can be used as a textbook for a course spanning one or two semesters.

We would like to thank several readers for valuable comments on prelim-
inary drafts of this book: Pallavi Basu, Alexandra Chouldechova, Patrick
Danaher, Will Fithian, Luella Fu, Sam Gross, Max Grazier G’Sell, Court-
ney Paulson, Xinghao Qiao, Elisa Sheng, Noah Simon, Kean Ming Tan,
and Xin Lu Tan.

It’s tough to make predictions, especially about the future.

Los Angeles, USA
Seattle, USA
Palo Alto, USA
Palo Alto, USA

-Yogi Berra

Gareth James
Daniela Witten
Trevor Hastie
Robert Tibshirani

Contents

Preface

1 Introduction

2 Statistical Learning

2.1 What Is Statistical Learning? . . . . . . . . . . . . . . . . .
2.1.1 Why Estimate f ? . . . . . . . . . . . . . . . . . . . .
2.1.2 How Do We Estimate f ?
. . . . . . . . . . . . . . .
2.1.3 The Trade-Oﬀ Between Prediction Accuracy

and Model Interpretability . . . . . . . . . . . . . .
2.1.4
Supervised Versus Unsupervised Learning . . . . . .
2.1.5 Regression Versus Classiﬁcation Problems . . . . . .
2.2 Assessing Model Accuracy . . . . . . . . . . . . . . . . . . .
2.2.1 Measuring the Quality of Fit
. . . . . . . . . . . . .
2.2.2 The Bias-Variance Trade-Oﬀ . . . . . . . . . . . . .
2.2.3 The Classiﬁcation Setting . . . . . . . . . . . . . . .
2.3 Lab: Introduction to R . . . . . . . . . . . . . . . . . . . . .
2.3.1 Basic Commands . . . . . . . . . . . . . . . . . . . .
2.3.2 Graphics
. . . . . . . . . . . . . . . . . . . . . . . .
Indexing Data . . . . . . . . . . . . . . . . . . . . .
2.3.3
2.3.4 Loading Data . . . . . . . . . . . . . . . . . . . . . .
2.3.5 Additional Graphical and Numerical Summaries
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.4 Exercises

vii

1

15
15
17
21

24
26
28
29
29
33
37
42
42
45
47
48
49
52

ix

x

Contents

3 Linear Regression

3.1 Simple Linear Regression . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . .

3.1.1 Estimating the Coeﬃcients
3.1.2 Assessing the Accuracy of the Coeﬃcient

59
61
61

Some Important Questions

Estimates . . . . . . . . . . . . . . . . . . . . . . . .
3.1.3 Assessing the Accuracy of the Model . . . . . . . . .
3.2 Multiple Linear Regression . . . . . . . . . . . . . . . . . .
3.2.1 Estimating the Regression Coeﬃcients . . . . . . . .
3.2.2
. . . . . . . . . . . . . .
3.3 Other Considerations in the Regression Model . . . . . . . .
3.3.1 Qualitative Predictors . . . . . . . . . . . . . . . . .
3.3.2 Extensions of the Linear Model . . . . . . . . . . . .
3.3.3 Potential Problems . . . . . . . . . . . . . . . . . . .

63
68
71
72
75
82
82
86
92
3.4 The Marketing Plan . . . . . . . . . . . . . . . . . . . . . . 102
3.5 Comparison of Linear Regression with K-Nearest

Neighbors . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104
3.6 Lab: Linear Regression . . . . . . . . . . . . . . . . . . . . . 109
3.6.1 Libraries . . . . . . . . . . . . . . . . . . . . . . . . . 109
3.6.2
Simple Linear Regression . . . . . . . . . . . . . . . 110
3.6.3 Multiple Linear Regression . . . . . . . . . . . . . . 113
3.6.4
. . . . . . . . . . . . . . . . . . . 115
3.6.5 Non-linear Transformations of the Predictors . . . . 115
3.6.6 Qualitative Predictors . . . . . . . . . . . . . . . . . 117
3.6.7 Writing Functions
. . . . . . . . . . . . . . . . . . . 119
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 120

Interaction Terms

3.7 Exercises

4 Classiﬁcation

127
4.1 An Overview of Classiﬁcation . . . . . . . . . . . . . . . . . 128
4.2 Why Not Linear Regression? . . . . . . . . . . . . . . . . . 129
4.3 Logistic Regression . . . . . . . . . . . . . . . . . . . . . . . 130
4.3.1 The Logistic Model . . . . . . . . . . . . . . . . . . . 131
4.3.2 Estimating the Regression Coeﬃcients . . . . . . . . 133
4.3.3 Making Predictions . . . . . . . . . . . . . . . . . . . 134
4.3.4 Multiple Logistic Regression . . . . . . . . . . . . . . 135
4.3.5 Logistic Regression for >2 Response Classes . . . . . 137
4.4 Linear Discriminant Analysis . . . . . . . . . . . . . . . . . 138
4.4.1 Using Bayes’ Theorem for Classiﬁcation . . . . . . . 138
4.4.2 Linear Discriminant Analysis for p = 1 . . . . . . . . 139
4.4.3 Linear Discriminant Analysis for p >1 . . . . . . . . 142
4.4.4 Quadratic Discriminant Analysis . . . . . . . . . . . 149
4.5 A Comparison of Classiﬁcation Methods . . . . . . . . . . . 151
4.6 Lab: Logistic Regression, LDA, QDA, and KNN . . . . . . 154
4.6.1 The Stock Market Data . . . . . . . . . . . . . . . . 154
4.6.2 Logistic Regression . . . . . . . . . . . . . . . . . . . 156
4.6.3 Linear Discriminant Analysis . . . . . . . . . . . . . 161

Contents

xi

4.6.4 Quadratic Discriminant Analysis . . . . . . . . . . . 163
4.6.5 K-Nearest Neighbors . . . . . . . . . . . . . . . . . . 163
4.6.6 An Application to Caravan Insurance Data . . . . . 165
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 168

4.7 Exercises

5 Resampling Methods

175
5.1 Cross-Validation . . . . . . . . . . . . . . . . . . . . . . . . 176
5.1.1 The Validation Set Approach . . . . . . . . . . . . . 176
5.1.2 Leave-One-Out Cross-Validation . . . . . . . . . . . 178
k-Fold Cross-Validation . . . . . . . . . . . . . . . . 181
5.1.3
5.1.4 Bias-Variance Trade-Oﬀ for k-Fold

Cross-Validation . . . . . . . . . . . . . . . . . . . . 183
5.1.5 Cross-Validation on Classiﬁcation Problems . . . . . 184
5.2 The Bootstrap . . . . . . . . . . . . . . . . . . . . . . . . . 187
5.3 Lab: Cross-Validation and the Bootstrap . . . . . . . . . . . 190
5.3.1 The Validation Set Approach . . . . . . . . . . . . . 191
5.3.2 Leave-One-Out Cross-Validation . . . . . . . . . . . 192
k-Fold Cross-Validation . . . . . . . . . . . . . . . . 193
5.3.3
5.3.4 The Bootstrap . . . . . . . . . . . . . . . . . . . . . 194
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 197

5.4 Exercises

6 Linear Model Selection and Regularization

6.3 Dimension Reduction Methods

203
6.1 Subset Selection . . . . . . . . . . . . . . . . . . . . . . . . 205
6.1.1 Best Subset Selection . . . . . . . . . . . . . . . . . 205
Stepwise Selection . . . . . . . . . . . . . . . . . . . 207
6.1.2
6.1.3 Choosing the Optimal Model
. . . . . . . . . . . . . 210
6.2 Shrinkage Methods . . . . . . . . . . . . . . . . . . . . . . . 214
6.2.1 Ridge Regression . . . . . . . . . . . . . . . . . . . . 215
6.2.2 The Lasso . . . . . . . . . . . . . . . . . . . . . . . . 219
Selecting the Tuning Parameter . . . . . . . . . . . . 227
6.2.3
. . . . . . . . . . . . . . . . 228
6.3.1 Principal Components Regression . . . . . . . . . . . 230
. . . . . . . . . . . . . . . . . 237
6.3.2 Partial Least Squares
6.4 Considerations in High Dimensions . . . . . . . . . . . . . . 238
6.4.1 High-Dimensional Data . . . . . . . . . . . . . . . . 238
6.4.2 What Goes Wrong in High Dimensions? . . . . . . . 239
6.4.3 Regression in High Dimensions . . . . . . . . . . . . 241
6.4.4
Interpreting Results in High Dimensions . . . . . . . 243
6.5 Lab 1: Subset Selection Methods . . . . . . . . . . . . . . . 244
6.5.1 Best Subset Selection . . . . . . . . . . . . . . . . . 244
6.5.2 Forward and Backward Stepwise Selection . . . . . . 247
6.5.3 Choosing Among Models Using the Validation

Set Approach and Cross-Validation . . . . . . . . . . 248

xii

Contents

6.6 Lab 2: Ridge Regression and the Lasso . . . . . . . . . . . . 251
6.6.1 Ridge Regression . . . . . . . . . . . . . . . . . . . . 251
6.6.2 The Lasso . . . . . . . . . . . . . . . . . . . . . . . . 255
6.7 Lab 3: PCR and PLS Regression . . . . . . . . . . . . . . . 256
6.7.1 Principal Components Regression . . . . . . . . . . . 256
6.7.2 Partial Least Squares
. . . . . . . . . . . . . . . . . 258
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 259

6.8 Exercises

7 Moving Beyond Linearity

265
7.1 Polynomial Regression . . . . . . . . . . . . . . . . . . . . . 266
7.2 Step Functions
. . . . . . . . . . . . . . . . . . . . . . . . . 268
7.3 Basis Functions . . . . . . . . . . . . . . . . . . . . . . . . . 270
7.4 Regression Splines
. . . . . . . . . . . . . . . . . . . . . . . 271
7.4.1 Piecewise Polynomials . . . . . . . . . . . . . . . . . 271
7.4.2 Constraints and Splines . . . . . . . . . . . . . . . . 271
7.4.3 The Spline Basis Representation . . . . . . . . . . . 273
7.4.4 Choosing the Number and Locations

of the Knots

7.5 Smoothing Splines

. . . . . . . . . . . . . . . . . . . . . . 274
7.4.5 Comparison to Polynomial Regression . . . . . . . . 276
. . . . . . . . . . . . . . . . . . . . . . . 277
7.5.1 An Overview of Smoothing Splines . . . . . . . . . . 277
7.5.2 Choosing the Smoothing Parameter λ . . . . . . . . 278
7.6 Local Regression . . . . . . . . . . . . . . . . . . . . . . . . 280
7.7 Generalized Additive Models
. . . . . . . . . . . . . . . . . 282
7.7.1 GAMs for Regression Problems . . . . . . . . . . . . 283
. . . . . . . . . . 286
7.7.2 GAMs for Classiﬁcation Problems
7.8 Lab: Non-linear Modeling . . . . . . . . . . . . . . . . . . . 287
. . . . . 288
7.8.1 Polynomial Regression and Step Functions
Splines . . . . . . . . . . . . . . . . . . . . . . . . . . 293
7.8.2
7.8.3 GAMs . . . . . . . . . . . . . . . . . . . . . . . . . . 294
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 297

7.9 Exercises

8 Tree-Based Methods

8.1 The Basics of Decision Trees

303
. . . . . . . . . . . . . . . . . 303
8.1.1 Regression Trees . . . . . . . . . . . . . . . . . . . . 304
8.1.2 Classiﬁcation Trees . . . . . . . . . . . . . . . . . . . 311
8.1.3 Trees Versus Linear Models . . . . . . . . . . . . . . 314
8.1.4 Advantages and Disadvantages of Trees
. . . . . . . 315
8.2 Bagging, Random Forests, Boosting . . . . . . . . . . . . . 316
8.2.1 Bagging . . . . . . . . . . . . . . . . . . . . . . . . . 316
8.2.2 Random Forests
. . . . . . . . . . . . . . . . . . . . 319
8.2.3 Boosting . . . . . . . . . . . . . . . . . . . . . . . . . 321
8.3 Lab: Decision Trees . . . . . . . . . . . . . . . . . . . . . . . 323
8.3.1 Fitting Classiﬁcation Trees
. . . . . . . . . . . . . . 323
8.3.2 Fitting Regression Trees . . . . . . . . . . . . . . . . 327

8.3.3 Bagging and Random Forests . . . . . . . . . . . . . 328
8.3.4 Boosting . . . . . . . . . . . . . . . . . . . . . . . . . 330
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 332

8.4 Exercises

Contents

xiii

9 Support Vector Machines

337
9.1 Maximal Margin Classiﬁer . . . . . . . . . . . . . . . . . . . 338
9.1.1 What Is a Hyperplane? . . . . . . . . . . . . . . . . 338
9.1.2 Classiﬁcation Using a Separating Hyperplane . . . . 339
9.1.3 The Maximal Margin Classiﬁer . . . . . . . . . . . . 341
9.1.4 Construction of the Maximal Margin Classiﬁer . . . 342
9.1.5 The Non-separable Case . . . . . . . . . . . . . . . . 343
9.2 Support Vector Classiﬁers . . . . . . . . . . . . . . . . . . . 344
9.2.1 Overview of the Support Vector Classiﬁer . . . . . . 344
9.2.2 Details of the Support Vector Classiﬁer
. . . . . . . 345
. . . . . . . . . . . . . . . . . . . 349

9.3 Support Vector Machines

9.3.1 Classiﬁcation with Non-linear Decision

Boundaries

. . . . . . . . . . . . . . . . . . . . . . . 349
9.3.2 The Support Vector Machine . . . . . . . . . . . . . 350
9.3.3 An Application to the Heart Disease Data . . . . . . 354
9.4 SVMs with More than Two Classes . . . . . . . . . . . . . . 355
9.4.1 One-Versus-One Classiﬁcation . . . . . . . . . . . . . 355
9.4.2 One-Versus-All Classiﬁcation . . . . . . . . . . . . . 356
9.5 Relationship to Logistic Regression . . . . . . . . . . . . . . 356
9.6 Lab: Support Vector Machines
. . . . . . . . . . . . . . . . 359
Support Vector Classiﬁer
. . . . . . . . . . . . . . . 359
9.6.1
Support Vector Machine . . . . . . . . . . . . . . . . 363
9.6.2
. . . . . . . . . . . . . . . . . . . . . . 365
9.6.3 ROC Curves
SVM with Multiple Classes . . . . . . . . . . . . . . 366
9.6.4
9.6.5 Application to Gene Expression Data . . . . . . . . 366
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 368

9.7 Exercises

10 Unsupervised Learning

373
10.1 The Challenge of Unsupervised Learning . . . . . . . . . . . 373
10.2 Principal Components Analysis . . . . . . . . . . . . . . . . 374
10.2.1 What Are Principal Components? . . . . . . . . . . 375
10.2.2 Another Interpretation of Principal Components . . 379
10.2.3 More on PCA . . . . . . . . . . . . . . . . . . . . . . 380
10.2.4 Other Uses for Principal Components
. . . . . . . . 385
10.3 Clustering Methods . . . . . . . . . . . . . . . . . . . . . . . 385
10.3.1 K-Means Clustering . . . . . . . . . . . . . . . . . . 386
10.3.2 Hierarchical Clustering . . . . . . . . . . . . . . . . . 390
10.3.3 Practical Issues in Clustering . . . . . . . . . . . . . 399
10.4 Lab 1: Principal Components Analysis . . . . . . . . . . . . 401

xiv

Contents

10.5 Lab 2: Clustering . . . . . . . . . . . . . . . . . . . . . . . . 404
10.5.1 K-Means Clustering . . . . . . . . . . . . . . . . . . 404
10.5.2 Hierarchical Clustering . . . . . . . . . . . . . . . . . 406
. . . . . . . . . . . . . . . . . 407
10.6.1 PCA on the NCI60 Data
. . . . . . . . . . . . . . . 408
10.6.2 Clustering the Observations of the NCI60 Data . . . 410
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 413

10.6 Lab 3: NCI60 Data Example

10.7 Exercises

Index

419

1
Introduction

An Overview of Statistical Learning

Statistical learning refers to a vast set of tools for understanding data. These
tools can be classiﬁed as supervised or unsupervised. Broadly speaking,
supervised statistical learning involves building a statistical model for pre-
dicting, or estimating, an output based on one or more inputs. Problems of
this nature occur in ﬁelds as diverse as business, medicine, astrophysics, and
public policy. With unsupervised statistical learning, there are inputs but
no supervising output; nevertheless we can learn relationships and struc-
ture from such data. To provide an illustration of some applications of
statistical learning, we brieﬂy discuss three real-world data sets that are
considered in this book.

Wage Data

In this application (which we refer to as the Wage data set throughout this
book), we examine a number of factors that relate to wages for a group of
males from the Atlantic region of the United States. In particular, we wish
to understand the association between an employee’s age and education, as
well as the calendar year, on his wage. Consider, for example, the left-hand
panel of Figure 1.1, which displays wage versus age for each of the individu-
als in the data set. There is evidence that wage increases with age but then
decreases again after approximately age 60. The blue line, which provides
an estimate of the average wage for a given age, makes this trend clearer.

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 1,
© Springer Science+Business Media New York 2013

1

2

1. Introduction

e
g
a
W

0
0
3

0
0
2

0
0
1

0
5

e
g
a
W

0
0
3

0
0
2

0
0
1

0
5

e
g
a
W

0
0
3

0
0
2

0
0
1

0
5

20

40

60

80

2003

2006

2009

Age

Year

1

2

3

4

5

Education Level

FIGURE 1.1. Wage data, which contains income survey information for males
from the central Atlantic region of the United States. Left: wage as a function of
age. On average, wage increases with age until about 60 years of age, at which
point it begins to decline. Center: wage as a function of year. There is a slow
but steady increase of approximately $10,000 in the average wage between 2003
and 2009. Right: Boxplots displaying wage as a function of education, with 1
indicating the lowest level (no high school diploma) and 5 the highest level (an
advanced graduate degree). On average, wage increases with the level of education.

Given an employee’s age, we can use this curve to predict his wage. However,
it is also clear from Figure 1.1 that there is a signiﬁcant amount of vari-
ability associated with this average value, and so age alone is unlikely to
provide an accurate prediction of a particular man’s wage.

We also have information regarding each employee’s education level and
the year in which the wage was earned. The center and right-hand panels of
Figure 1.1, which display wage as a function of both year and education, in-
dicate that both of these factors are associated with wage. Wages increase
by approximately $10,000, in a roughly linear (or straight-line) fashion,
between 2003 and 2009, though this rise is very slight relative to the vari-
ability in the data. Wages are also typically greater for individuals with
higher education levels: men with the lowest education level (1) tend to
have substantially lower wages than those with the highest education level
(5). Clearly, the most accurate prediction of a given man’s wage will be
obtained by combining his age, his education, and the year. In Chapter 3,
we discuss linear regression, which can be used to predict wage from this
data set. Ideally, we should predict wage in a way that accounts for the
non-linear relationship between wage and age. In Chapter 7, we discuss a
class of approaches for addressing this problem.

Stock Market Data

The Wage data involves predicting a continuous or quantitative output value.
This is often referred to as a regression problem. However, in certain cases
we may instead wish to predict a non-numerical value—that is, a categorical

Yesterday

Two Days Previous

Three Days Previous

1. Introduction

3

6

4

2

0

2
−

4
−

P
&
S
n

 

i
 

e
g
n
a
h
c
 
e
g
a
n
e
c
r
e
P

t

6

4

2

0

2
−

4
−

P
&
S
n

 

i
 

e
g
n
a
h
c
 
e
g
a

t

n
e
c
r
e
P

6

4

2

0

2
−

4
−

P
&
S
n

 

i
 

e
g
n
a
h
c
 
e
g
a
n
e
c
r
e
P

t

Down

Up

Today’s Direction

Down

Up

Today’s Direction

Down

Up

Today’s Direction

FIGURE 1.2. Left: Boxplots of the previous day’s percentage change in the S&P
index for the days for which the market increased or decreased, obtained from the
Smarket data. Center and Right: Same as left panel, but the percentage changes
for 2 and 3 days previous are shown.

or qualitative output. For example, in Chapter 4 we examine a stock mar-
ket data set that contains the daily movements in the Standard & Poor’s
500 (S&P) stock index over a 5-year period between 2001 and 2005. We
refer to this as the Smarket data. The goal is to predict whether the index
will increase or decrease on a given day using the past 5 days’ percentage
changes in the index. Here the statistical learning problem does not in-
volve predicting a numerical value. Instead it involves predicting whether
a given day’s stock market performance will fall into the Up bucket or the
Down bucket. This is known as a classiﬁcation problem. A model that could
accurately predict the direction in which the market will move would be
very useful!

The left-hand panel of Figure 1.2 displays two boxplots of the previous
day’s percentage changes in the stock index: one for the 648 days for which
the market increased on the subsequent day, and one for the 602 days for
which the market decreased. The two plots look almost identical, suggest-
ing that there is no simple strategy for using yesterday’s movement in the
S&P to predict today’s returns. The remaining panels, which display box-
plots for the percentage changes 2 and 3 days previous to today, similarly
indicate little association between past and present returns. Of course, this
lack of pattern is to be expected: in the presence of strong correlations be-
tween successive days’ returns, one could adopt a simple trading strategy
to generate proﬁts from the market. Nevertheless, in Chapter 4, we explore
these data using several diﬀerent statistical learning methods. Interestingly,
there are hints of some weak trends in the data that suggest that, at least
for this 5-year period, it is possible to correctly predict the direction of
movement in the market approximately 60% of the time (Figure 1.3).

4

1. Introduction

y
t
i
l
i

b
a
b
o
r
P
d
e

 

i

t
c
d
e
r
P

2
5

.

0

0
5

.

0

8
4

.

0

6
4

.

0

Down

Up

Today’s Direction

FIGURE 1.3. We ﬁt a quadratic discriminant analysis model to the subset
of the Smarket data corresponding to the 2001–2004 time period, and predicted
the probability of a stock market decrease using the 2005 data. On average, the
predicted probability of decrease is higher for the days in which the market does
decrease. Based on these results, we are able to correctly predict the direction of
movement in the market 60% of the time.

Gene Expression Data

The previous two applications illustrate data sets with both input and
output variables. However, another important class of problems involves
situations in which we only observe input variables, with no corresponding
output. For example, in a marketing setting, we might have demographic
information for a number of current or potential customers. We may wish to
understand which types of customers are similar to each other by grouping
individuals according to their observed characteristics. This is known as a
clustering problem. Unlike in the previous examples, here we are not trying
to predict an output variable.

We devote Chapter 10 to a discussion of statistical learning methods
for problems in which no natural output variable is available. We consider
the NCI60 data set, which consists of 6,830 gene expression measurements
for each of 64 cancer cell lines. Instead of predicting a particular output
variable, we are interested in determining whether there are groups, or
clusters, among the cell lines based on their gene expression measurements.
This is a diﬃcult question to address, in part because there are thousands
of gene expression measurements per cell line, making it hard to visualize
the data.

The left-hand panel of Figure 1.4 addresses this problem by represent-
ing each of the 64 cell lines using just two numbers, Z1 and Z2. These
are the ﬁrst two principal components of the data, which summarize the
6, 830 expression measurements for each cell line down to two numbers or
dimensions. While it is likely that this dimension reduction has resulted in

1. Introduction

5

2
Z

0
2

0

0
2
−

0
4
−

0
6
−

2
Z

0
2

0

0
2
−

0
4
−

0
6
−

−40

−20

0

20

40

60

−40

−20

0

20

40

60

Z1

Z1

FIGURE 1.4. Left: Representation of the NCI60 gene expression data set in
a two-dimensional space, Z1 and Z2. Each point corresponds to one of the 64
cell lines. There appear to be four groups of cell lines, which we have represented
using diﬀerent colors. Right: Same as left panel except that we have represented
each of the 14 diﬀerent types of cancer using a diﬀerent colored symbol. Cell lines
corresponding to the same cancer type tend to be nearby in the two-dimensional
space.

some loss of information, it is now possible to visually examine the data for
evidence of clustering. Deciding on the number of clusters is often a diﬃ-
cult problem. But the left-hand panel of Figure 1.4 suggests at least four
groups of cell lines, which we have represented using separate colors. We
can now examine the cell lines within each cluster for similarities in their
types of cancer, in order to better understand the relationship between
gene expression levels and cancer.

In this particular data set, it turns out that the cell lines correspond
to 14 diﬀerent types of cancer. (However, this information was not used
to create the left-hand panel of Figure 1.4.) The right-hand panel of Fig-
ure 1.4 is identical to the left-hand panel, except that the 14 cancer types
are shown using distinct colored symbols. There is clear evidence that cell
lines with the same cancer type tend to be located near each other in this
two-dimensional representation. In addition, even though the cancer infor-
mation was not used to produce the left-hand panel, the clustering obtained
does bear some resemblance to some of the actual cancer types observed
in the right-hand panel. This provides some independent veriﬁcation of the
accuracy of our clustering analysis.

A Brief History of Statistical Learning

Though the term statistical learning is fairly new, many of the concepts
that underlie the ﬁeld were developed long ago. At the beginning of the
nineteenth century, Legendre and Gauss published papers on the method

6

1. Introduction

of least squares, which implemented the earliest form of what is now known
as linear regression. The approach was ﬁrst successfully applied to problems
in astronomy. Linear regression is used for predicting quantitative values,
such as an individual’s salary. In order to predict qualitative values, such as
whether a patient survives or dies, or whether the stock market increases
or decreases, Fisher proposed linear discriminant analysis in 1936. In the
1940s, various authors put forth an alternative approach, logistic regression.
In the early 1970s, Nelder and Wedderburn coined the term generalized
linear models for an entire class of statistical learning methods that include
both linear and logistic regression as special cases.

By the end of the 1970s, many more techniques for learning from data
were available. However, they were almost exclusively linear methods, be-
cause ﬁtting non-linear relationships was computationally infeasible at the
time. By the 1980s, computing technology had ﬁnally improved suﬃciently
that non-linear methods were no longer computationally prohibitive. In mid
1980s Breiman, Friedman, Olshen and Stone introduced classiﬁcation and
regression trees, and were among the ﬁrst to demonstrate the power of a
detailed practical implementation of a method, including cross-validation
for model selection. Hastie and Tibshirani coined the term generalized addi-
tive models in 1986 for a class of non-linear extensions to generalized linear
models, and also provided a practical software implementation.

Since that time, inspired by the advent of machine learning and other
disciplines, statistical learning has emerged as a new subﬁeld in statistics,
focused on supervised and unsupervised modeling and prediction. In recent
years, progress in statistical learning has been marked by the increasing
availability of powerful and relatively user-friendly software, such as the
popular and freely available R system. This has the potential to continue
the transformation of the ﬁeld from a set of techniques used and developed
by statisticians and computer scientists to an essential toolkit for a much
broader community.

This Book

The Elements of Statistical Learning (ESL) by Hastie, Tibshirani, and
Friedman was ﬁrst published in 2001. Since that time, it has become an
important reference on the fundamentals of statistical machine learning.
Its success derives from its comprehensive and detailed treatment of many
important topics in statistical learning, as well as the fact that (relative to
many upper-level statistics textbooks) it is accessible to a wide audience.
However, the greatest factor behind the success of ESL has been its topical
nature. At the time of its publication, interest in the ﬁeld of statistical

1. Introduction

7

learning was starting to explode. ESL provided one of the ﬁrst accessible
and comprehensive introductions to the topic.

Since ESL was ﬁrst published, the ﬁeld of statistical learning has con-
tinued to ﬂourish. The ﬁeld’s expansion has taken two forms. The most
obvious growth has involved the development of new and improved statis-
tical learning approaches aimed at answering a range of scientiﬁc questions
across a number of ﬁelds. However, the ﬁeld of statistical learning has
also expanded its audience. In the 1990s, increases in computational power
generated a surge of interest in the ﬁeld from non-statisticians who were
eager to use cutting-edge statistical tools to analyze their data. Unfortu-
nately, the highly technical nature of these approaches meant that the user
community remained primarily restricted to experts in statistics, computer
science, and related ﬁelds with the training (and time) to understand and
implement them.

In recent years, new and improved software packages have signiﬁcantly
eased the implementation burden for many statistical learning methods.
At the same time, there has been growing recognition across a number of
ﬁelds, from business to health care to genetics to the social sciences and
beyond, that statistical learning is a powerful tool with important practical
applications. As a result, the ﬁeld has moved from one of primarily academic
interest to a mainstream discipline, with an enormous potential audience.
This trend will surely continue with the increasing availability of enormous
quantities of data and the software to analyze it.

The purpose of An Introduction to Statistical Learning (ISL) is to facili-
tate the transition of statistical learning from an academic to a mainstream
ﬁeld. ISL is not intended to replace ESL, which is a far more comprehen-
sive text both in terms of the number of approaches considered and the
depth to which they are explored. We consider ESL to be an important
companion for professionals (with graduate degrees in statistics, machine
learning, or related ﬁelds) who need to understand the technical details
behind statistical learning approaches. However, the community of users of
statistical learning techniques has expanded to include individuals with a
wider range of interests and backgrounds. Therefore, we believe that there
is now a place for a less technical and more accessible version of ESL.

In teaching these topics over the years, we have discovered that they are
of interest to master’s and PhD students in ﬁelds as disparate as business
administration, biology, and computer science, as well as to quantitatively-
oriented upper-division undergraduates. It is important for this diverse
group to be able to understand the models, intuitions, and strengths and
weaknesses of the various approaches. But for this audience, many of the
technical details behind statistical learning methods, such as optimiza-
tion algorithms and theoretical properties, are not of primary interest.
We believe that these students do not need a deep understanding of these
aspects in order to become informed users of the various methodologies, and

8

1. Introduction

in order to contribute to their chosen ﬁelds through the use of statistical
learning tools.

ISLR is based on the following four premises.

1. Many statistical learning methods are relevant and useful in a wide
range of academic and non-academic disciplines, beyond just the sta-
tistical sciences. We believe that many contemporary statistical learn-
ing procedures should, and will, become as widely available and used
as is currently the case for classical methods such as linear regres-
sion. As a result, rather than attempting to consider every possible
approach (an impossible task), we have concentrated on presenting
the methods that we believe are most widely applicable.

2. Statistical learning should not be viewed as a series of black boxes. No
single approach will perform well in all possible applications. With-
out understanding all of the cogs inside the box, or the interaction
between those cogs, it is impossible to select the best box. Hence, we
have attempted to carefully describe the model, intuition, assump-
tions, and trade-oﬀs behind each of the methods that we consider.

3. While it is important to know what job is performed by each cog, it
is not necessary to have the skills to construct the machine inside the
box! Thus, we have minimized discussion of technical details related
to ﬁtting procedures and theoretical properties. We assume that the
reader is comfortable with basic mathematical concepts, but we do
not assume a graduate degree in the mathematical sciences. For in-
stance, we have almost completely avoided the use of matrix algebra,
and it is possible to understand the entire book without a detailed
knowledge of matrices and vectors.

4. We presume that the reader is interested in applying statistical learn-
ing methods to real-world problems. In order to facilitate this, as well
as to motivate the techniques discussed, we have devoted a section
within each chapter to R computer labs. In each lab, we walk the
reader through a realistic application of the methods considered in
that chapter. When we have taught this material in our courses,
we have allocated roughly one-third of classroom time to working
through the labs, and we have found them to be extremely useful.
Many of the less computationally-oriented students who were ini-
tially intimidated by R’s command level interface got the hang of
things over the course of the quarter or semester. We have used R
because it is freely available and is powerful enough to implement all
of the methods discussed in the book. It also has optional packages
that can be downloaded to implement literally thousands of addi-
tional methods. Most importantly, R is the language of choice for
academic statisticians, and new approaches often become available in

1. Introduction

9

R years before they are implemented in commercial packages. How-
ever, the labs in ISL are self-contained, and can be skipped if the
reader wishes to use a diﬀerent software package or does not wish to
apply the methods discussed to real-world problems.

Who Should Read This Book?

This book is intended for anyone who is interested in using modern statis-
tical methods for modeling and prediction from data. This group includes
scientists, engineers, data analysts, or quants, but also less technical indi-
viduals with degrees in non-quantitative ﬁelds such as the social sciences or
business. We expect that the reader will have had at least one elementary
course in statistics. Background in linear regression is also useful, though
not required, since we review the key concepts behind linear regression in
Chapter 3. The mathematical level of this book is modest, and a detailed
knowledge of matrix operations is not required. This book provides an in-
troduction to the statistical programming language R. Previous exposure
to a programming language, such as MATLAB or Python, is useful but not
required.

We have successfully taught material at this level to master’s and PhD
students in business, computer science, biology, earth sciences, psychology,
and many other areas of the physical and social sciences. This book could
also be appropriate for advanced undergraduates who have already taken
a course on linear regression. In the context of a more mathematically
rigorous course in which ESL serves as the primary textbook, ISL could
be used as a supplementary text for teaching computational aspects of the
various approaches.

Notation and Simple Matrix Algebra

Choosing notation for a textbook is always a diﬃcult task. For the most
part we adopt the same notational conventions as ESL.

We will use n to represent the number of distinct data points, or observa-
tions, in our sample. We will let p denote the number of variables that are
available for use in making predictions. For example, the Wage data set con-
sists of 12 variables for 3,000 people, so we have n = 3,000 observations and
p = 12 variables (such as year, age,
, and more). Note that throughout
this book, we indicate variable names using colored font: Variable Name.

sex

In some examples, p might be quite large, such as on the order of thou-
sands or even millions; this situation arises quite often, for example, in the
analysis of modern biological data or web-based advertising data.

10

1. Introduction

In general, we will let xij represent the value of the jth variable for the
ith observation, where i = 1, 2, . . . , n and j = 1, 2, . . . , p. Throughout this
book, i will be used to index the samples or observations (from 1 to n) and
j will be used to index the variables (from 1 to p). We let X denote a n× p
matrix whose (i, j)th element is xij. That is,

⎛

⎜⎜⎜⎝

X =

⎞

⎟⎟⎟⎠ .

x11
x12
x21
x22
...
...
xn1 xn2

. . . x1p
. . . x2p
...
. . .
. . . xnp

For readers who are unfamiliar with matrices, it is useful to visualize X as
a spreadsheet of numbers with n rows and p columns.

At times we will be interested in the rows of X, which we write as
x1, x2, . . . , xn. Here xi is a vector of length p, containing the p variable
measurements for the ith observation. That is,

⎞

⎟⎟⎟⎠ .

⎛

⎜⎜⎜⎝

xi1
xi2
...
xip

xi =

(1.1)

(Vectors are by default represented as columns.) For example, for the Wage
data, xi is a vector of length 12, consisting of year, age,
, and other
values for the ith individual. At other times we will instead be interested
in the columns of X, which we write as x1, x2, . . . , xp. Each is a vector of
length n. That is,

sex

⎞

⎟⎟⎟⎠ .

⎛

⎜⎜⎜⎝

x1j
x2j
...
xnj

xj =

For example, for the Wage data, x1 contains the n = 3,000 values for year.

Using this notation, the matrix X can be written as

X =

or

(cid:8)
x1 x2

··· xp

(cid:9)

,

⎞

⎟⎟⎟⎠ .

⎜⎜⎜⎝

⎛
xT
1
xT
2
...
xT
n

X =

1. Introduction

11

The T notation denotes the transpose of a matrix or vector. So, for example,

⎛

⎜⎜⎜⎝

XT =

⎞

⎟⎟⎟⎠ ,

x11 x21
x12 x22
...
...
x1p x2p

. . . xn1
. . . xn2
...
. . . xnp

while

(cid:8)
xi1 xi2

···

(cid:9)

.

xip

xT
i =

We use yi to denote the ith observation of the variable on which we
wish to make predictions, such as wage. Hence, we write the set of all n
observations in vector form as

⎞

⎟⎟⎟⎠ .

⎛

⎜⎜⎜⎝

y1
y2
...
yn

y =

Then our observed data consists of {(x1, y1), (x2, y2), . . . , (xn, yn)}, where
each xi is a vector of length p. (If p = 1, then xi is simply a scalar.)

In this text, a vector of length n will always be denoted in lower case

bold ; e.g.

⎞

⎟⎟⎟⎠ .

⎛

⎜⎜⎜⎝

a1
a2
...
an

a =

However, vectors that are not of length n (such as feature vectors of length
p, as in (1.1)) will be denoted in lower case normal font, e.g. a. Scalars will
also be denoted in lower case normal font, e.g. a. In the rare cases in which
these two uses for lower case normal font lead to ambiguity, we will clarify
which use is intended. Matrices will be denoted using bold capitals, such
as A. Random variables will be denoted using capital normal font, e.g. A,
regardless of their dimensions.
Occasionally we will want to indicate the dimension of a particular ob-
ject. To indicate that an object is a scalar, we will use the notation a ∈ R.
To indicate that it is a vector of length k, we will use a ∈ Rk (or a ∈ Rn
if it is of length n). We will indicate that an object is a r × s matrix using
A ∈ Rr×s.

We have avoided using matrix algebra whenever possible. However, in
a few instances it becomes too cumbersome to avoid it entirely. In these
rare instances it is important to understand the concept of multiplying
two matrices. Suppose that A ∈ Rr×d and B ∈ Rd×s. Then the product

12

1. Introduction

of A and B is denoted AB. The (i, j)th element of AB is computed by
multiplying each element of the ith row of A by the corresponding element
d
of the jth column of B. That is, (AB)ij =
k=1 aikbkj. As an example,
(cid:11)
consider
5
7

(cid:11)
1 2
3 4

(cid:12)
6
8

and B =

A =

(cid:10)

(cid:12)

.

Then

(cid:11)
1 2
3 4

(cid:12)(cid:11)

(cid:12)

5 6
7 8

(cid:11)
1 × 5 + 2 × 7 1 × 6 + 2 × 8
3 × 5 + 4 × 7 3 × 6 + 4 × 8

=

AB =
.
Note that this operation produces an r × s matrix. It is only possible to
compute AB if the number of columns of A is the same as the number of
rows of B.

=

(cid:12)

(cid:11)

(cid:12)
19 22
43 50

Organization of This Book

Chapter 2 introduces the basic terminology and concepts behind statisti-
cal learning. This chapter also presents the K-nearest neighbor classiﬁer, a
very simple method that works surprisingly well on many problems. Chap-
ters 3 and 4 cover classical linear methods for regression and classiﬁcation.
In particular, Chapter 3 reviews linear regression, the fundamental start-
ing point for all regression methods. In Chapter 4 we discuss two of the
most important classical classiﬁcation methods, logistic regression and lin-
ear discriminant analysis.

A central problem in all statistical learning situations involves choosing
the best method for a given application. Hence, in Chapter 5 we intro-
duce cross-validation and the bootstrap, which can be used to estimate the
accuracy of a number of diﬀerent methods in order to choose the best one.
Much of the recent research in statistical learning has concentrated on
non-linear methods. However, linear methods often have advantages over
their non-linear competitors in terms of interpretability and sometimes also
accuracy. Hence, in Chapter 6 we consider a host of linear methods, both
classical and more modern, which oﬀer potential improvements over stan-
dard linear regression. These include stepwise selection, ridge regression,
principal components regression, partial least squares, and the lasso.

The remaining chapters move into the world of non-linear statistical
learning. We ﬁrst introduce in Chapter 7 a number of non-linear methods
that work well for problems with a single input variable. We then show how
these methods can be used to ﬁt non-linear additive models for which there
is more than one input. In Chapter 8, we investigate tree-based methods,
including bagging, boosting, and random forests. Support vector machines,
a set of approaches for performing both linear and non-linear classiﬁcation,

1. Introduction

13

are discussed in Chapter 9. Finally, in Chapter 10, we consider a setting
in which we have input variables but no output variable. In particular, we
present principal components analysis, K-means clustering, and hierarchi-
cal clustering.

At the end of each chapter, we present one or more R lab sections in
which we systematically work through applications of the various meth-
ods discussed in that chapter. These labs demonstrate the strengths and
weaknesses of the various approaches, and also provide a useful reference
for the syntax required to implement the various methods. The reader may
choose to work through the labs at his or her own pace, or the labs may
be the focus of group sessions as part of a classroom environment. Within
each R lab, we present the results that we obtained when we performed
the lab at the time of writing this book. However, new versions of R are
continuously released, and over time, the packages called in the labs will be
updated. Therefore, in the future, it is possible that the results shown in
the lab sections may no longer correspond precisely to the results obtained
by the reader who performs the labs. As necessary, we will post updates to
the labs on the book website.

We use the

symbol to denote sections or exercises that contain more
challenging concepts. These can be easily skipped by readers who do not
wish to delve as deeply into the material, or who lack the mathematical
background.

Data Sets Used in Labs and Exercises

In this textbook, we illustrate statistical learning methods using applica-
tions from marketing, ﬁnance, biology, and other areas. The ISLR package
available on the book website contains a number of data sets that are
required in order to perform the labs and exercises associated with this
book. One other data set is contained in the MASS library, and yet another
is part of the base R distribution. Table 1.1 contains a summary of the data
sets required to perform the labs and exercises. A couple of these data sets
are also available as text ﬁles on the book website, for use in Chapter 2.

Book Website

The website for this book is located at

www.StatLearning.com

14

1. Introduction

Description

Gas mileage, horsepower, and other information for cars.
Housing values and other information about Boston suburbs.
Information about individuals oﬀered caravan insurance.
Information about car seat sales in 400 stores.
Demographic characteristics, tuition, and more for USA colleges.
Customer default records for a credit card company.
Records and salaries for baseball players.
Gene expression measurements for four cancer types.
Gene expression measurements for 64 cancer cell lines.
Sales information for Citrus Hill and Minute Maid orange juice.

Name
Auto
Boston
Caravan
Carseats
College
Default
Hitters
Khan
NCI60
OJ
Portfolio Past values of ﬁnancial assets, for use in portfolio allocation.
Daily percentage returns for S&P 500 over a 5-year period.
Smarket
USArrests Crime statistics per 100,000 residents in 50 states of USA.
Wage
Weekly

Income survey data for males in central Atlantic region of USA.
1,089 weekly stock market returns for 21 years.

TABLE 1.1. A list of data sets needed to perform the labs and exercises in this
textbook. All data sets are available in the ISLR library, with the exception of
Boston (part of MASS) and USArrests (part of the base R distribution).

It contains a number of resources, including the R package associated with
this book, and some additional data sets.

Acknowledgements

A few of the plots in this book were taken from ESL: Figures 6.7, 8.3,
and 10.12. All other plots are new to this book.

2
Statistical Learning

2.1 What Is Statistical Learning?

In order to motivate our study of statistical learning, we begin with a
simple example. Suppose that we are statistical consultants hired by a
client to provide advice on how to improve sales of a particular product. The
Advertising data set consists of the sales of that product in 200 diﬀerent
markets, along with advertising budgets for the product in each of those
markets for three diﬀerent media: TV, radio, and newspaper. The data are
displayed in Figure 2.1. It is not possible for our client to directly increase
sales of the product. On the other hand, they can control the advertising
expenditure in each of the three media. Therefore, if we determine that
there is an association between advertising and sales, then we can instruct
our client to adjust advertising budgets, thereby indirectly increasing sales.
In other words, our goal is to develop an accurate model that can be used
to predict sales on the basis of the three media budgets.

In this setting, the advertising budgets are input variables while sales
is an output variable. The input variables are typically denoted using the
symbol X, with a subscript to distinguish them. So X1 might be the TV
budget, X2 the radio budget, and X3 the newspaper budget. The inputs
go by diﬀerent names, such as predictors, independent variables, features,
or sometimes just variables. The output variable—in this case, sales—is
often called the response or dependent variable, and is typically denoted
using the symbol Y . Throughout this book, we will use all of these terms
interchangeably.

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 2,
© Springer Science+Business Media New York 2013

15

input
variable
output
variable

predictor

independent
variable
feature
variable
response

dependent
variable

16

2. Statistical Learning

5
2

0
2

5
1

0
1

5

l

s
e
a
S

5
2

0
2

5
1

0
1

5

l

s
e
a
S

5
2

0
2

5
1

0
1

5

l

s
e
a
S

0

50 100

200

300

0

10

20

30

40

50

0

20

40

60

80

100

TV

Radio

Newspaper

FIGURE 2.1. The Advertising data set. The plot displays sales, in thousands
of units, as a function of TV, radio, and newspaper budgets, in thousands of
dollars, for 200 diﬀerent markets. In each plot we show the simple least squares
ﬁt of sales to that variable, as described in Chapter 3. In other words, each blue
line represents a simple model that can be used to predict sales using TV, radio,
and newspaper, respectively.

More generally, suppose that we observe a quantitative response Y and p
diﬀerent predictors, X1, X2, . . . , Xp. We assume that there is some
relationship between Y and X = (X1, X2, . . . , Xp), which can be written
in the very general form

Y = f (X) + .

(2.1)

Here f is some ﬁxed but unknown function of X1, . . . , Xp, and  is a random
error term, which is independent of X and has mean zero. In this formula-
tion, f represents the systematic information that X provides about Y .

As another example, consider the left-hand panel of Figure 2.2, a plot of
income versus years of education for 30 individuals in the Income data set.
The plot suggests that one might be able to predict income using years of
education. However, the function f that connects the input variable to the
output variable is in general unknown. In this situation one must estimate
f based on the observed points. Since Income is a simulated data set, f is
known and is shown by the blue curve in the right-hand panel of Figure 2.2.
The vertical lines represent the error terms . We note that some of the
30 observations lie above the blue curve and some lie below it; overall, the
errors have approximately mean zero.

In general, the function f may involve more than one input variable.
In Figure 2.3 we plot income as a function of years of education and
seniority. Here f is a two-dimensional surface that must be estimated
based on the observed data.

error term

systematic

2.1 What Is Statistical Learning?

17

0
8

0
7

0
6

0
5

0
4

0
3

0
2

e
m
o
c
n

I

0
8

0
7

0
6

0
5

0
4

0
3

0
2

e
m
o
c
n

I

10

12

14

16

18

20

22

10

12

14

16

18

20

22

Years of Education

Years of Education

FIGURE 2.2. The Income data set. Left: The red dots are the observed values
of income (in tens of thousands of dollars) and years of education for 30 indi-
viduals. Right: The blue curve represents the true underlying relationship between
income and years of education, which is generally unknown (but is known in
this case because the data were simulated). The black lines represent the error
associated with each observation. Note that some errors are positive (if an ob-
servation lies above the blue curve) and some are negative (if an observation lies
below the curve). Overall, these errors have approximately mean zero.

In essence, statistical learning refers to a set of approaches for estimating
f . In this chapter we outline some of the key theoretical concepts that arise
in estimating f , as well as tools for evaluating the estimates obtained.

2.1.1 Why Estimate f ?

There are two main reasons that we may wish to estimate f : prediction
and inference. We discuss each in turn.

Prediction

In many situations, a set of inputs X are readily available, but the output
Y cannot be easily obtained. In this setting, since the error term averages
to zero, we can predict Y using

ˆY = ˆf (X),

(2.2)

where ˆf represents our estimate for f , and ˆY represents the resulting pre-
diction for Y . In this setting, ˆf is often treated as a black box, in the sense
that one is not typically concerned with the exact form of ˆf , provided that
it yields accurate predictions for Y .

18

2. Statistical Learning

I

n

c

o

m

e

Ye

ars of E

d

ucatio

n

Seniority

FIGURE 2.3. The plot displays income as a function of years of education
and seniority in the Income data set. The blue surface represents the true un-
derlying relationship between income and years of education and seniority,
which is known since the data are simulated. The red dots indicate the observed
values of these quantities for 30 individuals.

As an example, suppose that X1, . . . , Xp are characteristics of a patient’s
blood sample that can be easily measured in a lab, and Y is a variable
encoding the patient’s risk for a severe adverse reaction to a particular
drug. It is natural to seek to predict Y using X, since we can then avoid
giving the drug in question to patients who are at high risk of an adverse
reaction—that is, patients for whom the estimate of Y is high.

The accuracy of ˆY as a prediction for Y depends on two quantities,
which we will call the reducible error and the irreducible error. In general,
ˆf will not be a perfect estimate for f , and this inaccuracy will introduce
some error. This error is reducible because we can potentially improve the
accuracy of ˆf by using the most appropriate statistical learning technique to
estimate f . However, even if it were possible to form a perfect estimate for
f , so that our estimated response took the form ˆY = f (X), our prediction
would still have some error in it! This is because Y is also a function of
, which, by deﬁnition, cannot be predicted using X. Therefore, variability
associated with  also aﬀects the accuracy of our predictions. This is known
as the irreducible error, because no matter how well we estimate f , we
cannot reduce the error introduced by .

Why is the irreducible error larger than zero? The quantity  may con-
tain unmeasured variables that are useful in predicting Y : since we don’t
measure them, f cannot use them for its prediction. The quantity  may
also contain unmeasurable variation. For example, the risk of an adverse
reaction might vary for a given patient on a given day, depending on

reducible
error
irreducible
error

2.1 What Is Statistical Learning?

19

manufacturing variation in the drug itself or the patient’s general feeling
of well-being on that day.

Consider a given estimate ˆf and a set of predictors X, which yields the
prediction ˆY = ˆf (X). Assume for a moment that both ˆf and X are ﬁxed.
Then, it is easy to show that

E(Y − ˆY )2 = E[f (X) +  − ˆf (X)]2

= [f (X) − ˆf (X)]2
(cid:16)

(cid:14)(cid:15)

(cid:13)

(cid:13) (cid:14)(cid:15) (cid:16)
+ Var()

,

(2.3)

expected
value

variance

Reducible

Irreducible

where E(Y − ˆY )2 represents the average, or expected value, of the squared
diﬀerence between the predicted and actual value of Y , and Var() repre-
sents the variance associated with the error term .

The focus of this book is on techniques for estimating f with the aim of
minimizing the reducible error. It is important to keep in mind that the
irreducible error will always provide an upper bound on the accuracy of
our prediction for Y . This bound is almost always unknown in practice.

Inference

We are often interested in understanding the way that Y is aﬀected as
X1, . . . , Xp change. In this situation we wish to estimate f , but our goal is
not necessarily to make predictions for Y . We instead want to understand
the relationship between X and Y , or more speciﬁcally, to understand how
Y changes as a function of X1, . . . , Xp. Now ˆf cannot be treated as a black
box, because we need to know its exact form. In this setting, one may be
interested in answering the following questions:

• Which predictors are associated with the response? It is often the case
that only a small fraction of the available predictors are substantially
associated with Y . Identifying the few important predictors among a
large set of possible variables can be extremely useful, depending on
the application.

• What is the relationship between the response and each predictor?
Some predictors may have a positive relationship with Y , in the sense
that increasing the predictor is associated with increasing values of
Y . Other predictors may have the opposite relationship. Depending
on the complexity of f , the relationship between the response and a
given predictor may also depend on the values of the other predictors.
• Can the relationship between Y and each predictor be adequately sum-
marized using a linear equation, or is the relationship more compli-
cated? Historically, most methods for estimating f have taken a linear
form. In some situations, such an assumption is reasonable or even de-
sirable. But often the true relationship is more complicated, in which
case a linear model may not provide an accurate representation of
the relationship between the input and output variables.

20

2. Statistical Learning

In this book, we will see a number of examples that fall into the prediction

setting, the inference setting, or a combination of the two.

For instance, consider a company that is interested in conducting a
direct-marketing campaign. The goal is to identify individuals who will
respond positively to a mailing, based on observations of demographic vari-
ables measured on each individual. In this case, the demographic variables
serve as predictors, and response to the marketing campaign (either pos-
itive or negative) serves as the outcome. The company is not interested
in obtaining a deep understanding of the relationships between each in-
dividual predictor and the response; instead, the company simply wants
an accurate model to predict the response using the predictors. This is an
example of modeling for prediction.

In contrast, consider the Advertising data illustrated in Figure 2.1. One

may be interested in answering questions such as:

– Which media contribute to sales?

– Which media generate the biggest boost in sales? or

– How much increase in sales is associated with a given increase in TV

advertising?

This situation falls into the inference paradigm. Another example involves
modeling the brand of a product that a customer might purchase based on
variables such as price, store location, discount levels, competition price,
and so forth. In this situation one might really be most interested in how
each of the individual variables aﬀects the probability of purchase. For
instance, what eﬀect will changing the price of a product have on sales?
This is an example of modeling for inference.

Finally, some modeling could be conducted both for prediction and infer-
ence. For example, in a real estate setting, one may seek to relate values of
homes to inputs such as crime rate, zoning, distance from a river, air qual-
ity, schools, income level of community, size of houses, and so forth. In this
case one might be interested in how the individual input variables aﬀect
the prices—that is, how much extra will a house be worth if it has a view
of the river? This is an inference problem. Alternatively, one may simply
be interested in predicting the value of a home given its characteristics: is
this house under- or over-valued? This is a prediction problem.

Depending on whether our ultimate goal is prediction, inference, or a
combination of the two, diﬀerent methods for estimating f may be appro-
priate. For example, linear models allow for relatively simple and inter-
pretable inference, but may not yield as accurate predictions as some other
approaches. In contrast, some of the highly non-linear approaches that we
discuss in the later chapters of this book can potentially provide quite accu-
rate predictions for Y , but this comes at the expense of a less interpretable
model for which inference is more challenging.

linear model

2.1 What Is Statistical Learning?

21

2.1.2 How Do We Estimate f ?

Throughout this book, we explore many linear and non-linear approaches
for estimating f . However, these methods generally share certain charac-
teristics. We provide an overview of these shared characteristics in this
section. We will always assume that we have observed a set of n diﬀerent
data points. For example in Figure 2.2 we observed n = 30 data points.
These observations are called the training data because we will use these
observations to train, or teach, our method how to estimate f . Let xij
represent the value of the jth predictor, or input, for observation i, where
i = 1, 2, . . . , n and j = 1, 2, . . . , p. Correspondingly, let yi represent the
response variable for the ith observation. Then our training data consist of
{(x1, y1), (x2, y2), . . . , (xn, yn)} where xi = (xi1, xi2, . . . , xip)T .

Our goal is to apply a statistical learning method to the training data
in order to estimate the unknown function f . In other words, we want to
ﬁnd a function ˆf such that Y ≈ ˆf (X) for any observation (X, Y ). Broadly
speaking, most statistical learning methods for this task can be character-
ized as either parametric or non-parametric. We now brieﬂy discuss these
two types of approaches.

Parametric Methods

Parametric methods involve a two-step model-based approach.

1. First, we make an assumption about the functional form, or shape,
of f . For example, one very simple assumption is that f is linear in
X:

f (X) = β0 + β1X1 + β2X2 + . . . + βpXp.

(2.4)

This is a linear model, which will be discussed extensively in Chap-
ter 3. Once we have assumed that f is linear, the problem of estimat-
ing f is greatly simpliﬁed. Instead of having to estimate an entirely
arbitrary p-dimensional function f (X), one only needs to estimate
the p + 1 coeﬃcients β0, β1, . . . , βp.

training data

parametric
non-
parametric

2. After a model has been selected, we need a procedure that uses the
training data to ﬁt or train the model. In the case of the linear model
(2.4), we need to estimate the parameters β0, β1, . . . , βp. That is, we
want to ﬁnd values of these parameters such that

Y ≈ β0 + β1X1 + β2X2 + . . . + βpXp.

ﬁt
train

The most common approach to ﬁtting the model (2.4) is referred to
as (ordinary) least squares, which we discuss in Chapter 3. However,
least squares is one of many possible ways to ﬁt the linear model. In
Chapter 6, we discuss other approaches for estimating the parameters
in (2.4).

least squares

The model-based approach just described is referred to as parametric;
it reduces the problem of estimating f down to one of estimating a set of

22

2. Statistical Learning

I

n

c

o

m

e

Ye

ars of E

d

ucatio

n

Seniority

FIGURE 2.4. A linear model ﬁt by least squares to the Income data from Fig-
ure 2.3. The observations are shown in red, and the yellow plane indicates the
least squares ﬁt to the data.

parameters. Assuming a parametric form for f simpliﬁes the problem of
estimating f because it is generally much easier to estimate a set of pa-
rameters, such as β0, β1, . . . , βp in the linear model (2.4), than it is to ﬁt
an entirely arbitrary function f . The potential disadvantage of a paramet-
ric approach is that the model we choose will usually not match the true
unknown form of f . If the chosen model is too far from the true f , then
our estimate will be poor. We can try to address this problem by choos-
ing ﬂexible models that can ﬁt many diﬀerent possible functional forms
for f . But in general, ﬁtting a more ﬂexible model requires estimating a
greater number of parameters. These more complex models can lead to a
phenomenon known as overﬁtting the data, which essentially means they
follow the errors, or noise, too closely. These issues are discussed through-
out this book.

Figure 2.4 shows an example of the parametric approach applied to the

Income data from Figure 2.3. We have ﬁt a linear model of the form

income ≈ β0 + β1 × education + β2 × seniority.

Since we have assumed a linear relationship between the response and the
two predictors, the entire ﬁtting problem reduces to estimating β0, β1, and
β2, which we do using least squares linear regression. Comparing Figure 2.3
to Figure 2.4, we can see that the linear ﬁt given in Figure 2.4 is not quite
right: the true f has some curvature that is not captured in the linear ﬁt.
However, the linear ﬁt still appears to do a reasonable job of capturing the
positive relationship between years of education and income, as well as the

ﬂexible

overﬁtting

noise

2.1 What Is Statistical Learning?

23

Seniority

I

n

c

o

m

e

ars of E

d

Ye

ucatio

n

FIGURE 2.5. A smooth thin-plate spline ﬁt to the Income data from Figure 2.3
is shown in yellow; the observations are displayed in red. Splines are discussed in
Chapter 7.

slightly less positive relationship between seniority and income. It may be
that with such a small number of observations, this is the best we can do.

Non-parametric Methods

Non-parametric methods do not make explicit assumptions about the func-
tional form of f . Instead they seek an estimate of f that gets as close to the
data points as possible without being too rough or wiggly. Such approaches
can have a major advantage over parametric approaches: by avoiding the
assumption of a particular functional form for f , they have the potential
to accurately ﬁt a wider range of possible shapes for f . Any parametric
approach brings with it the possibility that the functional form used to
estimate f is very diﬀerent from the true f , in which case the resulting
model will not ﬁt the data well. In contrast, non-parametric approaches
completely avoid this danger, since essentially no assumption about the
form of f is made. But non-parametric approaches do suﬀer from a major
disadvantage: since they do not reduce the problem of estimating f to a
small number of parameters, a very large number of observations (far more
than is typically needed for a parametric approach) is required in order to
obtain an accurate estimate for f .

An example of a non-parametric approach to ﬁtting the Income data is
shown in Figure 2.5. A thin-plate spline is used to estimate f . This ap-
proach does not impose any pre-speciﬁed model on f . It instead attempts
to produce an estimate for f that is as close as possible to the observed
data, subject to the ﬁt—that is, the yellow surface in Figure 2.5—being

thin-plate
spline

24

2. Statistical Learning

I

n

c

o

m

e

Ye

ars of E

d

ucatio

n

Seniority

FIGURE 2.6. A rough thin-plate spline ﬁt to the Income data from Figure 2.3.
This ﬁt makes zero errors on the training data.

smooth. In this case, the non-parametric ﬁt has produced a remarkably ac-
curate estimate of the true f shown in Figure 2.3. In order to ﬁt a thin-plate
spline, the data analyst must select a level of smoothness. Figure 2.6 shows
the same thin-plate spline ﬁt using a lower level of smoothness, allowing
for a rougher ﬁt. The resulting estimate ﬁts the observed data perfectly!
However, the spline ﬁt shown in Figure 2.6 is far more variable than the
true function f , from Figure 2.3. This is an example of overﬁtting the
data, which we discussed previously. It is an undesirable situation because
the ﬁt obtained will not yield accurate estimates of the response on new
observations that were not part of the original training data set. We dis-
cuss methods for choosing the correct amount of smoothness in Chapter 5.
Splines are discussed in Chapter 7.

As we have seen, there are advantages and disadvantages to parametric
and non-parametric methods for statistical learning. We explore both types
of methods throughout this book.

2.1.3 The Trade-Oﬀ Between Prediction Accuracy and Model

Interpretability

Of the many methods that we examine in this book, some are less ﬂexible,
or more restrictive, in the sense that they can produce just a relatively
small range of shapes to estimate f . For example, linear regression is a
relatively inﬂexible approach, because it can only generate linear functions
such as the lines shown in Figure 2.1 or the plane shown in Figure 2.4.

2.1 What Is Statistical Learning?

25

h
g
H

i

Subset Selection

Lasso

y
t
i
l
i

b
a
t
e
r
p
r
e
t
n
I

w
o
L

Low

Least Squares

Generalized Additive Models

Trees

Bagging, Boosting

Support Vector Machines

Flexibility

High

FIGURE 2.7. A representation of the tradeoﬀ between ﬂexibility and inter-
pretability, using diﬀerent statistical learning methods. In general, as the ﬂexibil-
ity of a method increases, its interpretability decreases.

Other methods, such as the thin plate splines shown in Figures 2.5 and 2.6,
are considerably more ﬂexible because they can generate a much wider
range of possible shapes to estimate f .

One might reasonably ask the following question: why would we ever
choose to use a more restrictive method instead of a very ﬂexible approach?
There are several reasons that we might prefer a more restrictive model.
If we are mainly interested in inference, then restrictive models are much
more interpretable. For instance, when inference is the goal, the linear
model may be a good choice since it will be quite easy to understand
the relationship between Y and X1, X2, . . . , Xp. In contrast, very ﬂexible
approaches, such as the splines discussed in Chapter 7 and displayed in
Figures 2.5 and 2.6, and the boosting methods discussed in Chapter 8, can
lead to such complicated estimates of f that it is diﬃcult to understand
how any individual predictor is associated with the response.

Figure 2.7 provides an illustration of the trade-oﬀ between ﬂexibility and
interpretability for some of the methods that we cover in this book. Least
squares linear regression, discussed in Chapter 3, is relatively inﬂexible but
is quite interpretable. The lasso, discussed in Chapter 6, relies upon the
linear model (2.4) but uses an alternative ﬁtting procedure for estimating
the coeﬃcients β0, β1, . . . , βp. The new procedure is more restrictive in es-
timating the coeﬃcients, and sets a number of them to exactly zero. Hence
in this sense the lasso is a less ﬂexible approach than linear regression.
It is also more interpretable than linear regression, because in the ﬁnal
model the response variable will only be related to a small subset of the
predictors—namely, those with nonzero coeﬃcient estimates. Generalized

lasso

generalized
additive
model

bagging

boosting

support
vector
machine

26

2. Statistical Learning

additive models (GAMs), discussed in Chapter 7, instead extend the lin-
ear model (2.4) to allow for certain non-linear relationships. Consequently,
GAMs are more ﬂexible than linear regression. They are also somewhat
less interpretable than linear regression, because the relationship between
each predictor and the response is now modeled using a curve. Finally, fully
non-linear methods such as bagging, boosting, and support vector machines
with non-linear kernels, discussed in Chapters 8 and 9, are highly ﬂexible
approaches that are harder to interpret.

We have established that when inference is the goal, there are clear ad-
vantages to using simple and relatively inﬂexible statistical learning meth-
ods. In some settings, however, we are only interested in prediction, and
the interpretability of the predictive model is simply not of interest. For
instance, if we seek to develop an algorithm to predict the price of a
stock, our sole requirement for the algorithm is that it predict accurately—
interpretability is not a concern. In this setting, we might expect that it
will be best to use the most ﬂexible model available. Surprisingly, this is
not always the case! We will often obtain more accurate predictions using
a less ﬂexible method. This phenomenon, which may seem counterintuitive
at ﬁrst glance, has to do with the potential for overﬁtting in highly ﬂexible
methods. We saw an example of overﬁtting in Figure 2.6. We will discuss
this very important concept further in Section 2.2 and throughout this
book.

2.1.4 Supervised Versus Unsupervised Learning

Most statistical learning problems fall into one of two categories: supervised
or unsupervised. The examples that we have discussed so far in this chap-
ter all fall into the supervised learning domain. For each observation of the
predictor measurement(s) xi, i = 1, . . . , n there is an associated response
measurement yi. We wish to ﬁt a model that relates the response to the
predictors, with the aim of accurately predicting the response for future
observations (prediction) or better understanding the relationship between
the response and the predictors (inference). Many classical statistical learn-
ing methods such as linear regression and logistic regression (Chapter 4), as
well as more modern approaches such as GAM, boosting, and support vec-
tor machines, operate in the supervised learning domain. The vast majority
of this book is devoted to this setting.

In contrast, unsupervised learning describes the somewhat more chal-
lenging situation in which for every observation i = 1, . . . , n, we observe
a vector of measurements xi but no associated response yi. It is not pos-
sible to ﬁt a linear regression model, since there is no response variable
to predict. In this setting, we are in some sense working blind; the sit-
uation is referred to as unsupervised because we lack a response vari-
able that can supervise our analysis. What sort of statistical analysis is

supervised

unsupervised

logistic
regression

2.1 What Is Statistical Learning?

27

2
1

0
1

8

6

4

2

8

6

4

2

0

2

4

6

8

10

12

0

2

4

6

FIGURE 2.8. A clustering data set involving three groups. Each group is shown
using a diﬀerent colored symbol. Left: The three groups are well-separated. In
this setting, a clustering approach should successfully identify the three groups.
Right: There is some overlap among the groups. Now the clustering task is more
challenging.

possible? We can seek to understand the relationships between the variables
or between the observations. One statistical learning tool that we may use
in this setting is cluster analysis, or clustering. The goal of cluster analysis
is to ascertain, on the basis of x1, . . . , xn, whether the observations fall into
relatively distinct groups. For example, in a market segmentation study we
might observe multiple characteristics (variables) for potential customers,
such as zip code, family income, and shopping habits. We might believe
that the customers fall into diﬀerent groups, such as big spenders versus
low spenders. If the information about each customer’s spending patterns
were available, then a supervised analysis would be possible. However, this
information is not available—that is, we do not know whether each poten-
tial customer is a big spender or not. In this setting, we can try to cluster
the customers on the basis of the variables measured, in order to identify
distinct groups of potential customers. Identifying such groups can be of
interest because it might be that the groups diﬀer with respect to some
property of interest, such as spending habits.

Figure 2.8 provides a simple illustration of the clustering problem. We
have plotted 150 observations with measurements on two variables, X1
and X2. Each observation corresponds to one of three distinct groups. For
illustrative purposes, we have plotted the members of each group using
diﬀerent colors and symbols. However, in practice the group memberships
are unknown, and the goal is to determine the group to which each ob-
servation belongs. In the left-hand panel of Figure 2.8, this is a relatively
easy task because the groups are well-separated. In contrast, the right-hand
panel illustrates a more challenging problem in which there is some overlap

cluster
analysis

28

2. Statistical Learning

between the groups. A clustering method could not be expected to assign
all of the overlapping points to their correct group (blue, green, or orange).
In the examples shown in Figure 2.8, there are only two variables, and
so one can simply visually inspect the scatterplots of the observations in
order to identify clusters. However, in practice, we often encounter data
sets that contain many more than two variables. In this case, we cannot
easily plot the observations. For instance, if there are p variables in our
data set, then p(p − 1)/2 distinct scatterplots can be made, and visual
inspection is simply not a viable way to identify clusters. For this reason,
automated clustering methods are important. We discuss clustering and
other unsupervised learning approaches in Chapter 10.

Many problems fall naturally into the supervised or unsupervised learn-
ing paradigms. However, sometimes the question of whether an analysis
should be considered supervised or unsupervised is less clear-cut. For in-
stance, suppose that we have a set of n observations. For m of the observa-
tions, where m < n, we have both predictor measurements and a response
measurement. For the remaining n − m observations, we have predictor
measurements but no response measurement. Such a scenario can arise if
the predictors can be measured relatively cheaply but the corresponding
responses are much more expensive to collect. We refer to this setting as
a semi-supervised learning problem. In this setting, we wish to use a sta-
tistical learning method that can incorporate the m observations for which
response measurements are available as well as the n − m observations for
which they are not. Although this is an interesting topic, it is beyond the
scope of this book.

semi-
supervised
learning

2.1.5 Regression Versus Classiﬁcation Problems

Variables can be characterized as either quantitative or qualitative (also
known as categorical). Quantitative variables take on numerical values.
Examples include a person’s age, height, or income, the value of a house,
and the price of a stock. In contrast, qualitative variables take on val-
ues in one of K diﬀerent classes, or categories. Examples of qualitative
variables include a person’s gender (male or female), the brand of prod-
uct purchased (brand A, B, or C), whether a person defaults on a debt
(yes or no), or a cancer diagnosis (Acute Myelogenous Leukemia, Acute
Lymphoblastic Leukemia, or No Leukemia). We tend to refer to problems
with a quantitative response as regression problems, while those involv-
ing a qualitative response are often referred to as classiﬁcation problems.
However, the distinction is not always that crisp. Least squares linear re-
gression (Chapter 3) is used with a quantitative response, whereas logistic
regression (Chapter 4) is typically used with a qualitative (two-class, or
binary) response. As such it is often used as a classiﬁcation method. But
since it estimates class probabilities, it can be thought of as a regression

quantitative

qualitative

categorical

class

regression

classiﬁcation

binary

2.2 Assessing Model Accuracy

29

method as well. Some statistical methods, such as K-nearest neighbors
(Chapters 2 and 4) and boosting (Chapter 8), can be used in the case of
either quantitative or qualitative responses.

We tend to select statistical learning methods on the basis of whether
the response is quantitative or qualitative; i.e. we might use linear regres-
sion when quantitative and logistic regression when qualitative. However,
whether the predictors are qualitative or quantitative is generally consid-
ered less important. Most of the statistical learning methods discussed in
this book can be applied regardless of the predictor variable type, provided
that any qualitative predictors are properly coded before the analysis is
performed. This is discussed in Chapter 3.

2.2 Assessing Model Accuracy

One of the key aims of this book is to introduce the reader to a wide range
of statistical learning methods that extend far beyond the standard linear
regression approach. Why is it necessary to introduce so many diﬀerent
statistical learning approaches, rather than just a single best method? There
is no free lunch in statistics: no one method dominates all others over all
possible data sets. On a particular data set, one speciﬁc method may work
best, but some other method may work better on a similar but diﬀerent
data set. Hence it is an important task to decide for any given set of data
which method produces the best results. Selecting the best approach can
be one of the most challenging parts of performing statistical learning in
practice.

In this section, we discuss some of the most important concepts that
arise in selecting a statistical learning procedure for a speciﬁc data set. As
the book progresses, we will explain how the concepts presented here can
be applied in practice.

2.2.1 Measuring the Quality of Fit

In order to evaluate the performance of a statistical learning method on
a given data set, we need some way to measure how well its predictions
actually match the observed data. That is, we need to quantify the extent
to which the predicted response value for a given observation is close to
the true response value for that observation. In the regression setting, the
most commonly-used measure is the mean squared error (MSE), given by mean

M SE =

1
n

(yi − ˆf (xi))2,

squared
error

(2.5)

n(cid:17)

i=1

30

2. Statistical Learning

where ˆf (xi) is the prediction that ˆf gives for the ith observation. The MSE
will be small if the predicted responses are very close to the true responses,
and will be large if for some of the observations, the predicted and true
responses diﬀer substantially.

The MSE in (2.5) is computed using the training data that was used to
ﬁt the model, and so should more accurately be referred to as the training
MSE. But in general, we do not really care how well the method works
on the training data. Rather, we are interested in the accuracy of the pre-
dictions that we obtain when we apply our method to previously unseen
test data. Why is this what we care about? Suppose that we are interested
in developing an algorithm to predict a stock’s price based on previous
stock returns. We can train the method using stock returns from the past
6 months. But we don’t really care how well our method predicts last week’s
stock price. We instead care about how well it will predict tomorrow’s price
or next month’s price. On a similar note, suppose that we have clinical
measurements (e.g. weight, blood pressure, height, age, family history of
disease) for a number of patients, as well as information about whether each
patient has diabetes. We can use these patients to train a statistical learn-
ing method to predict risk of diabetes based on clinical measurements. In
practice, we want this method to accurately predict diabetes risk for future
patients based on their clinical measurements. We are not very interested
in whether or not the method accurately predicts diabetes risk for patients
used to train the model, since we already know which of those patients
have diabetes.

To state it more mathematically, suppose that we ﬁt our statistical learn-

ing method on our training observations {(x1, y1), (x2, y2), . . . , (xn, yn)},
and we obtain the estimate ˆf . We can then compute ˆf (x1), ˆf (x2), . . . , ˆf (xn).
If these are approximately equal to y1, y2, . . . , yn, then the training MSE
given by (2.5) is small. However, we are really not interested in whether
ˆf (xi) ≈ yi; instead, we want to know whether ˆf (x0) is approximately equal
to y0, where (x0, y0) is a previously unseen test observation not used to train
the statistical learning method. We want to choose the method that gives
the lowest test MSE, as opposed to the lowest training MSE. In other words,
if we had a large number of test observations, we could compute

Ave(y0 − ˆf (x0))2,

(2.6)

the average squared prediction error for these test observations (x0, y0).
We’d like to select the model for which the average of this quantity—the
test MSE—is as small as possible.

How can we go about trying to select a method that minimizes the test
MSE? In some settings, we may have a test data set available—that is,
we may have access to a set of observations that were not used to train
the statistical learning method. We can then simply evaluate (2.6) on the
test observations, and select the learning method for which the test MSE is

training
MSE

test data

test MSE

2.2 Assessing Model Accuracy

31

Y

2
1

0
1

8

6

4

2

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

5

.

2

0

.

2

5

.

1

0

.

1

5

.

0

0

.

0

0

20

40

60

80

100

2

5

10

20

X

Flexibility

FIGURE 2.9. Left: Data simulated from f , shown in black. Three estimates of
f are shown: the linear regression line (orange curve), and two smoothing spline
ﬁts (blue and green curves). Right: Training MSE (grey curve), test MSE (red
curve), and minimum possible test MSE over all methods (dashed line). Squares
represent the training and test MSEs for the three ﬁts shown in the left-hand
panel.

smallest. But what if no test observations are available? In that case, one
might imagine simply selecting a statistical learning method that minimizes
the training MSE (2.5). This seems like it might be a sensible approach,
since the training MSE and the test MSE appear to be closely related.
Unfortunately, there is a fundamental problem with this strategy: there
is no guarantee that the method with the lowest training MSE will also
have the lowest test MSE. Roughly speaking, the problem is that many
statistical methods speciﬁcally estimate coeﬃcients so as to minimize the
training set MSE. For these methods, the training set MSE can be quite
small, but the test MSE is often much larger.

Figure 2.9 illustrates this phenomenon on a simple example. In the left-
hand panel of Figure 2.9, we have generated observations from (2.1) with
the true f given by the black curve. The orange, blue and green curves illus-
trate three possible estimates for f obtained using methods with increasing
levels of ﬂexibility. The orange line is the linear regression ﬁt, which is rela-
tively inﬂexible. The blue and green curves were produced using smoothing
splines, discussed in Chapter 7, with diﬀerent levels of smoothness. It is
clear that as the level of ﬂexibility increases, the curves ﬁt the observed
data more closely. The green curve is the most ﬂexible and matches the
data very well; however, we observe that it ﬁts the true f (shown in black)
poorly because it is too wiggly. By adjusting the level of ﬂexibility of the
smoothing spline ﬁt, we can produce many diﬀerent ﬁts to this data.

smoothing
spline

degrees of
freedom

32

2. Statistical Learning

We now move on to the right-hand panel of Figure 2.9. The grey curve
displays the average training MSE as a function of ﬂexibility, or more for-
mally the degrees of freedom, for a number of smoothing splines. The de-
grees of freedom is a quantity that summarizes the ﬂexibility of a curve; it
is discussed more fully in Chapter 7. The orange, blue and green squares
indicate the MSEs associated with the corresponding curves in the left-
hand panel. A more restricted and hence smoother curve has fewer degrees
of freedom than a wiggly curve—note that in Figure 2.9, linear regression
is at the most restrictive end, with two degrees of freedom. The training
MSE declines monotonically as ﬂexibility increases. In this example the
true f is non-linear, and so the orange linear ﬁt is not ﬂexible enough to
estimate f well. The green curve has the lowest training MSE of all three
methods, since it corresponds to the most ﬂexible of the three curves ﬁt in
the left-hand panel.

In this example, we know the true function f , and so we can also com-
pute the test MSE over a very large test set, as a function of ﬂexibility. (Of
course, in general f is unknown, so this will not be possible.) The test MSE
is displayed using the red curve in the right-hand panel of Figure 2.9. As
with the training MSE, the test MSE initially declines as the level of ﬂex-
ibility increases. However, at some point the test MSE levels oﬀ and then
starts to increase again. Consequently, the orange and green curves both
have high test MSE. The blue curve minimizes the test MSE, which should
not be surprising given that visually it appears to estimate f the best in the
left-hand panel of Figure 2.9. The horizontal dashed line indicates Var(),
the irreducible error in (2.3), which corresponds to the lowest achievable
test MSE among all possible methods. Hence, the smoothing spline repre-
sented by the blue curve is close to optimal.

In the right-hand panel of Figure 2.9, as the ﬂexibility of the statistical
learning method increases, we observe a monotone decrease in the training
MSE and a U-shape in the test MSE. This is a fundamental property of
statistical learning that holds regardless of the particular data set at hand
and regardless of the statistical method being used. As model ﬂexibility
increases, training MSE will decrease, but the test MSE may not. When
a given method yields a small training MSE but a large test MSE, we are
said to be overﬁtting the data. This happens because our statistical learning
procedure is working too hard to ﬁnd patterns in the training data, and
may be picking up some patterns that are just caused by random chance
rather than by true properties of the unknown function f . When we overﬁt
the training data, the test MSE will be very large because the supposed
patterns that the method found in the training data simply don’t exist
in the test data. Note that regardless of whether or not overﬁtting has
occurred, we almost always expect the training MSE to be smaller than
the test MSE because most statistical learning methods either directly or
indirectly seek to minimize the training MSE. Overﬁtting refers speciﬁcally
to the case in which a less ﬂexible model would have yielded a smaller
test MSE.

2.2 Assessing Model Accuracy

33

Y

2
1

0
1

8

6

4

2

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

5

.

2

0

.

2

5

.

1

0

.

1

5

.

0

0

.

0

0

20

40

60

80

100

2

5

10

20

X

Flexibility

FIGURE 2.10. Details are as in Figure 2.9, using a diﬀerent true f that is
much closer to linear. In this setting, linear regression provides a very good ﬁt to
the data.

Figure 2.10 provides another example in which the true f is approxi-
mately linear. Again we observe that the training MSE decreases mono-
tonically as the model ﬂexibility increases, and that there is a U-shape in
the test MSE. However, because the truth is close to linear, the test MSE
only decreases slightly before increasing again, so that the orange least
squares ﬁt is substantially better than the highly ﬂexible green curve. Fi-
nally, Figure 2.11 displays an example in which f is highly non-linear. The
training and test MSE curves still exhibit the same general patterns, but
now there is a rapid decrease in both curves before the test MSE starts to
increase slowly.

In practice, one can usually compute the training MSE with relative
ease, but estimating test MSE is considerably more diﬃcult because usually
no test data are available. As the previous three examples illustrate, the
ﬂexibility level corresponding to the model with the minimal test MSE can
vary considerably among data sets. Throughout this book, we discuss a
variety of approaches that can be used in practice to estimate this minimum
point. One important method is cross-validation (Chapter 5), which is a cross-
method for estimating test MSE using the training data.

validation

2.2.2 The Bias-Variance Trade-Oﬀ

The U-shape observed in the test MSE curves (Figures 2.9–2.11) turns out
to be the result of two competing properties of statistical learning methods.
Though the mathematical proof is beyond the scope of this book, it is
possible to show that the expected test MSE, for a given value x0, can

34

2. Statistical Learning

Y

0
2

0
1

0

0
1
−

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
2

5
1

0
1

5

0

0

20

40

60

80

100

2

5

10

20

X

Flexibility

FIGURE 2.11. Details are as in Figure 2.9, using a diﬀerent f that is far from
linear. In this setting, linear regression provides a very poor ﬁt to the data.

always be decomposed into the sum of three fundamental quantities: the
variance of ˆf (x0), the squared bias of ˆf (x0) and the variance of the error
terms . That is,

= Var( ˆf (x0)) + [Bias( ˆf (x0))]2 + Var().

(2.7)

E

(cid:18)

(cid:19)2
y0 − ˆf (x0)
(cid:18)

(cid:19)2
y0 − ˆf (x0)

Here the notation E
deﬁnes the expected test MSE, and refers
to the average test MSE that we would obtain if we repeatedly estimated
f using a large number of training sets, and tested each at x0. The overall

(cid:19)2
(cid:18)
y0 − ˆf (x0)

over all

expected test MSE can be computed by averaging E
possible values of x0 in the test set.

Equation 2.7 tells us that in order to minimize the expected test error,
we need to select a statistical learning method that simultaneously achieves
low variance and low bias. Note that variance is inherently a nonnegative
quantity, and squared bias is also nonnegative. Hence, we see that the
expected test MSE can never lie below Var(), the irreducible error from
(2.3).

What do we mean by the variance and bias of a statistical learning
method? Variance refers to the amount by which ˆf would change if we
estimated it using a diﬀerent training data set. Since the training data
are used to ﬁt the statistical learning method, diﬀerent training data sets
will result in a diﬀerent ˆf . But ideally the estimate for f should not vary
too much between training sets. However, if a method has high variance
then small changes in the training data can result in large changes in ˆf . In
general, more ﬂexible statistical methods have higher variance. Consider the

variance
bias

expected
test MSE

2.2 Assessing Model Accuracy

35

green and orange curves in Figure 2.9. The ﬂexible green curve is following
the observations very closely. It has high variance because changing any
one of these data points may cause the estimate ˆf to change considerably.
In contrast, the orange least squares line is relatively inﬂexible and has low
variance, because moving any single observation will likely cause only a
small shift in the position of the line.

On the other hand, bias refers to the error that is introduced by approxi-
mating a real-life problem, which may be extremely complicated, by a much
simpler model. For example, linear regression assumes that there is a linear
relationship between Y and X1, X2, . . . , Xp. It is unlikely that any real-life
problem truly has such a simple linear relationship, and so performing lin-
ear regression will undoubtedly result in some bias in the estimate of f . In
Figure 2.11, the true f is substantially non-linear, so no matter how many
training observations we are given, it will not be possible to produce an
accurate estimate using linear regression. In other words, linear regression
results in high bias in this example. However, in Figure 2.10 the true f is
very close to linear, and so given enough data, it should be possible for
linear regression to produce an accurate estimate. Generally, more ﬂexible
methods result in less bias.

As a general rule, as we use more ﬂexible methods, the variance will
increase and the bias will decrease. The relative rate of change of these
two quantities determines whether the test MSE increases or decreases. As
we increase the ﬂexibility of a class of methods, the bias tends to initially
decrease faster than the variance increases. Consequently, the expected
test MSE declines. However, at some point increasing ﬂexibility has little
impact on the bias but starts to signiﬁcantly increase the variance. When
this happens the test MSE increases. Note that we observed this pattern
of decreasing test MSE followed by increasing test MSE in the right-hand
panels of Figures 2.9–2.11.

The three plots in Figure 2.12 illustrate Equation 2.7 for the examples in
Figures 2.9–2.11. In each case the blue solid curve represents the squared
bias, for diﬀerent levels of ﬂexibility, while the orange curve corresponds to
the variance. The horizontal dashed line represents Var(), the irreducible
error. Finally, the red curve, corresponding to the test set MSE, is the sum
of these three quantities. In all three cases, the variance increases and the
bias decreases as the method’s ﬂexibility increases. However, the ﬂexibility
level corresponding to the optimal test MSE diﬀers considerably among the
three data sets, because the squared bias and variance change at diﬀerent
rates in each of the data sets. In the left-hand panel of Figure 2.12, the
bias initially decreases rapidly, resulting in an initial sharp decrease in the
expected test MSE. On the other hand, in the center panel of Figure 2.12
the true f is close to linear, so there is only a small decrease in bias as ﬂex-
ibility increases, and the test MSE only declines slightly before increasing
rapidly as the variance increases. Finally, in the right-hand panel of Fig-
ure 2.12, as ﬂexibility increases, there is a dramatic decline in bias because

36

2. Statistical Learning

5

.

2

0

.

2

5

.

1

0

.

1

5

.

0

0

.

0

5

.

2

0

.

2

5

.

1

0

.

1

5

.

0

0

.

0

MSE
Bias
Var

0
2

5
1

0
1

5

0

2

5

10

20

2

5

10

20

2

5

10

20

Flexibility

Flexibility

Flexibility

FIGURE 2.12. Squared bias (blue curve), variance (orange curve), Var()
(dashed line), and test MSE (red curve) for the three data sets in Figures 2.9–2.11.
The vertical dotted line indicates the ﬂexibility level corresponding to the smallest
test MSE.

the true f is very non-linear. There is also very little increase in variance
as ﬂexibility increases. Consequently, the test MSE declines substantially
before experiencing a small increase as model ﬂexibility increases.

The relationship between bias, variance, and test set MSE given in Equa-
tion 2.7 and displayed in Figure 2.12 is referred to as the bias-variance
trade-oﬀ. Good test set performance of a statistical learning method re-
quires low variance as well as low squared bias. This is referred to as a
trade-oﬀ because it is easy to obtain a method with extremely low bias but
high variance (for instance, by drawing a curve that passes through every
single training observation) or a method with very low variance but high
bias (by ﬁtting a horizontal line to the data). The challenge lies in ﬁnding
a method for which both the variance and the squared bias are low. This
trade-oﬀ is one of the most important recurring themes in this book.

In a real-life situation in which f is unobserved, it is generally not pos-
sible to explicitly compute the test MSE, bias, or variance for a statistical
learning method. Nevertheless, one should always keep the bias-variance
trade-oﬀ in mind. In this book we explore methods that are extremely
ﬂexible and hence can essentially eliminate bias. However, this does not
guarantee that they will outperform a much simpler method such as linear
regression. To take an extreme example, suppose that the true f is linear.
In this situation linear regression will have no bias, making it very hard
for a more ﬂexible method to compete. In contrast, if the true f is highly
non-linear and we have an ample number of training observations, then
we may do better using a highly ﬂexible approach, as in Figure 2.11. In
Chapter 5 we discuss cross-validation, which is a way to estimate the test
MSE using the training data.

bias-variance
trade-oﬀ

2.2 Assessing Model Accuracy

37

2.2.3 The Classiﬁcation Setting

Thus far, our discussion of model accuracy has been focused on the regres-
sion setting. But many of the concepts that we have encountered, such
as the bias-variance trade-oﬀ, transfer over to the classiﬁcation setting
with only some modiﬁcations due to the fact that yi is no longer numer-
ical. Suppose that we seek to estimate f on the basis of training obser-
vations {(x1, y1), . . . , (xn, yn)}, where now y1, . . . , yn are qualitative. The
most common approach for quantifying the accuracy of our estimate ˆf is
the training error rate, the proportion of mistakes that are made if we apply
our estimate ˆf to the training observations:

n(cid:17)

i=1

1
n

I(yi (cid:4)= ˆyi).

(2.8)

Here ˆyi is the predicted class label for the ith observation using ˆf . And
I(yi (cid:4)= ˆyi) is an indicator variable that equals 1 if yi (cid:4)= ˆyi and zero if yi = ˆyi.
If I(yi (cid:4)= ˆyi) = 0 then the ith observation was classiﬁed correctly by our

classiﬁcation method; otherwise it was misclassiﬁed. Hence Equation 2.8
computes the fraction of incorrect classiﬁcations.

Equation 2.8 is referred to as the training error rate because it is com-
puted based on the data that was used to train our classiﬁer. As in the
regression setting, we are most interested in the error rates that result from
applying our classiﬁer to test observations that were not used in training.
The test error rate associated with a set of test observations of the form
(x0, y0) is given by

Ave (I(y0 (cid:4)= ˆy0)) ,

(2.9)

error rate

indicator
variable

training
error

test error

where ˆy0 is the predicted class label that results from applying the classiﬁer
to the test observation with predictor x0. A good classiﬁer is one for which
the test error (2.9) is smallest.

The Bayes Classiﬁer

It is possible to show (though the proof is outside of the scope of this
book) that the test error rate given in (2.9) is minimized, on average, by a
very simple classiﬁer that assigns each observation to the most likely class,
given its predictor values. In other words, we should simply assign a test
observation with predictor vector x0 to the class j for which

Pr(Y = j|X = x0)

(2.10)

is largest. Note that (2.10) is a conditional probability: it is the probability
that Y = j, given the observed predictor vector x0. This very simple clas-
siﬁer is called the Bayes classiﬁer. In a two-class problem where there are
only two possible response values, say class 1 or class 2, the Bayes classiﬁer

conditional
probability

Bayes
classiﬁer

38

2. Statistical Learning

o

o

o
o
o
o
o

o
o
o
o
o
o
o
o
o
o
o
o
o
oo o
o
o
o
o

o

o

o

o
o
o
o
o
o
o
o

o

o

o

o
o

o

o

o
o
o
o
o
o
o
o
o

o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o
o
o
oo
o
o

o

o
o
o

o

o

o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o
o
o
o
o
o
o
o
o
o
o

o
o
o
o

o

o

o
o
o

o

o
o

o

o
o

o

o

o

o
o

o

o

o

o

FIGURE 2.13. A simulated data set consisting of 100 observations in each of
two groups, indicated in blue and in orange. The purple dashed line represents
the Bayes decision boundary. The orange background grid indicates the region
in which a test observation will be assigned to the orange class, and the blue
background grid indicates the region in which a test observation will be assigned
to the blue class.

corresponds to predicting class one if Pr(Y = 1|X = x0) > 0.5, and class

two otherwise.

Figure 2.13 provides an example using a simulated data set in a two-
dimensional space consisting of predictors X1 and X2. The orange and
blue circles correspond to training observations that belong to two diﬀerent
classes. For each value of X1 and X2, there is a diﬀerent probability of the
response being orange or blue. Since this is simulated data, we know how
the data were generated and we can calculate the conditional probabilities
for each value of X1 and X2. The orange shaded region reﬂects the set of
points for which Pr(Y = orange|X) is greater than 50 %, while the blue
shaded region indicates the set of points for which the probability is below
50 %. The purple dashed line represents the points where the probability
is exactly 50 %. This is called the Bayes decision boundary. The Bayes
classiﬁer’s prediction is determined by the Bayes decision boundary; an
observation that falls on the orange side of the boundary will be assigned
to the orange class, and similarly an observation on the blue side of the
boundary will be assigned to the blue class.

The Bayes classiﬁer produces the lowest possible test error rate, called
the Bayes error rate. Since the Bayes classiﬁer will always choose the class

for which (2.10) is largest, the error rate at X = x0 will be 1−maxj Pr(Y =
j|X = x0). In general, the overall Bayes error rate is given by

(cid:11)
max

(cid:12)
Pr(Y = j|X)

1 − E

j

,

(2.11)

Bayes
decision
boundary

Bayes error
rate

K-nearest
neighbors

2.2 Assessing Model Accuracy

39

where the expectation averages the probability over all possible values of
X. For our simulated data, the Bayes error rate is 0.1304. It is greater than
zero, because the classes overlap in the true population so maxj Pr(Y =
j|X = x0) < 1 for some values of x0. The Bayes error rate is analogous to

the irreducible error, discussed earlier.

K-Nearest Neighbors

In theory we would always like to predict qualitative responses using the
Bayes classiﬁer. But for real data, we do not know the conditional distri-
bution of Y given X, and so computing the Bayes classiﬁer is impossi-
ble. Therefore, the Bayes classiﬁer serves as an unattainable gold standard
against which to compare other methods. Many approaches attempt to
estimate the conditional distribution of Y given X, and then classify a
given observation to the class with highest estimated probability. One such
method is the K-nearest neighbors (KNN) classiﬁer. Given a positive in-
teger K and a test observation x0, the KNN classiﬁer ﬁrst identiﬁes the
K points in the training data that are closest to x0, represented by N0.
points in N0 whose response values equal j:

It then estimates the conditional probability for class j as the fraction of

Pr(Y = j|X = x0) =

(cid:17)

i∈N0

1
K

I(yi = j).

(2.12)

Finally, KNN applies Bayes rule and classiﬁes the test observation x0 to
the class with the largest probability.

Figure 2.14 provides an illustrative example of the KNN approach. In
the left-hand panel, we have plotted a small training data set consisting of
six blue and six orange observations. Our goal is to make a prediction for
the point labeled by the black cross. Suppose that we choose K = 3. Then
KNN will ﬁrst identify the three observations that are closest to the cross.
This neighborhood is shown as a circle. It consists of two blue points and
one orange point, resulting in estimated probabilities of 2/3 for the blue
class and 1/3 for the orange class. Hence KNN will predict that the black
cross belongs to the blue class. In the right-hand panel of Figure 2.14 we
have applied the KNN approach with K = 3 at all of the possible values for
X1 and X2, and have drawn in the corresponding KNN decision boundary.
Despite the fact that it is a very simple approach, KNN can often pro-
duce classiﬁers that are surprisingly close to the optimal Bayes classiﬁer.
Figure 2.15 displays the KNN decision boundary, using K = 10, when ap-
plied to the larger simulated data set from Figure 2.13. Notice that even
though the true distribution is not known by the KNN classiﬁer, the KNN
decision boundary is very close to that of the Bayes classiﬁer. The test error
rate using KNN is 0.1363, which is close to the Bayes error rate of 0.1304.

40

2. Statistical Learning

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

o

FIGURE 2.14. The KNN approach, using K = 3, is illustrated in a simple
situation with six blue observations and six orange observations. Left: a test ob-
servation at which a predicted class label is desired is shown as a black cross. The
three closest points to the test observation are identiﬁed, and it is predicted that
the test observation belongs to the most commonly-occurring class, in this case
blue. Right: The KNN decision boundary for this example is shown in black. The
blue grid indicates the region in which a test observation will be assigned to the
blue class, and the orange grid indicates the region in which it will be assigned to
the orange class.

The choice of K has a drastic eﬀect on the KNN classiﬁer obtained.
Figure 2.16 displays two KNN ﬁts to the simulated data from Figure 2.13,
using K = 1 and K = 100. When K = 1, the decision boundary is overly
ﬂexible and ﬁnds patterns in the data that don’t correspond to the Bayes
decision boundary. This corresponds to a classiﬁer that has low bias but
very high variance. As K grows, the method becomes less ﬂexible and
produces a decision boundary that is close to linear. This corresponds to
a low-variance but high-bias classiﬁer. On this simulated data set, neither
K = 1 nor K = 100 give good predictions: they have test error rates of
0.1695 and 0.1925, respectively.

Just as in the regression setting, there is not a strong relationship be-
tween the training error rate and the test error rate. With K = 1, the
KNN training error rate is 0, but the test error rate may be quite high. In
general, as we use more ﬂexible classiﬁcation methods, the training error
rate will decline but the test error rate may not. In Figure 2.17, we have
plotted the KNN test and training errors as a function of 1/K. As 1/K in-
creases, the method becomes more ﬂexible. As in the regression setting, the
training error rate consistently declines as the ﬂexibility increases. However,
the test error exhibits a characteristic U-shape, declining at ﬁrst (with a
minimum at approximately K = 10) before increasing again when the
method becomes excessively ﬂexible and overﬁts.

2.2 Assessing Model Accuracy

41

KNN: K=10

o

o

o
o
o
o
o

o

o

o

o
o
o
o
o
o
o
o

o

o

o

o
o

o

o

o
o
o
o
o
o
o
o
o

o
o
o
o
o
o
o
o

o
o
o

o
o
o
o

o

o

o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
oo o
o
o
o
o

o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o
oo
o
o

o
o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o

o
o

o

o

o

o
o

o

o

o

o

FIGURE 2.15. The black curve indicates the KNN decision boundary on the
data from Figure 2.13, using K = 10. The Bayes decision boundary is shown as
a purple dashed line. The KNN and Bayes decision boundaries are very similar.

KNN: K=1

KNN: K=100

o

o

o

o

o

o

o
o
o
o
o

o
o

o

o

o
o
o
o
o
o
o
o

o

o

o

o

o
o

o
o
o
o
o
o
o
o

o

o

o
o
o
o
o
o
o
o

o
o
o
o
o
o
oo o
o
o
o
o

o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o
o

o
o
o
o
o
o

o

o
o
o
o
o
o
o

o

o
o
o

o
o

o

o

o
o
o

o

o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
o

o
o

o

o

o

o
o
o
o
o
o o
o
o
o
o

o

o
o
o
o

o
o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o

o

o

o
o

o

o

o

o
o

o

o

o

o

o

o

o

o

o

o

o
o
o
o
o

o
o

o

o

o
o
o
o
o
o
o
o

o

o

o

o

o
o

o
o
o
o
o
o
o
o

o

o

o
o
o
o
o
o
o
o

o
o
o
o
o
o
oo o
o
o
o
o

o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o
o

o
o
o
o
o
o

o

o
o
o
o
o
o
o

o

o
o
o

o
o

o

o

o
o
o

o

o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
o

o
o

o

o

o

o
o
o
o
o
o o
o
o
o
o

o

o
o
o
o

o
o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o

o

o

o
o

o

o

o

o
o

o

o

o

o

FIGURE 2.16. A comparison of the KNN decision boundaries (solid black
curves) obtained using K = 1 and K = 100 on the data from Figure 2.13. With
K = 1, the decision boundary is overly ﬂexible, while with K = 100 it is not
suﬃciently ﬂexible. The Bayes decision boundary is shown as a purple dashed
line.

42

2. Statistical Learning

e

t

a
R

 
r
o
r
r

E

0
2

.

0

5
1

.

0

0
1
.
0

5
0

.

0

0
0

.

0

Training Errors
Test Errors

0.01

0.02

0.05

0.20

0.50

1.00

0.10

1/K

FIGURE 2.17. The KNN training error rate (blue, 200 observations) and test
error rate (orange, 5,000 observations) on the data from Figure 2.13, as the
level of ﬂexibility (assessed using 1/K) increases, or equivalently as the number
of neighbors K decreases. The black dashed line indicates the Bayes error rate.
The jumpiness of the curves is due to the small size of the training data set.

In both the regression and classiﬁcation settings, choosing the correct
level of ﬂexibility is critical to the success of any statistical learning method.
The bias-variance tradeoﬀ, and the resulting U-shape in the test error, can
make this a diﬃcult task. In Chapter 5, we return to this topic and discuss
various methods for estimating test error rates and thereby choosing the
optimal level of ﬂexibility for a given statistical learning method.

2.3 Lab: Introduction to R

In this lab, we will introduce some simple R commands. The best way to
learn a new language is to try out the commands. R can be downloaded from

http://cran.r-project.org/

2.3.1 Basic Commands

R uses functions to perform operations. To run a function called funcname,
we type funcname(input1, input2), where the inputs (or arguments) input1

function

argument

2.3 Lab: Introduction to R

43

and input2 tell R how to run the function. A function can have any number
of inputs. For example, to create a vector of numbers, we use the function
c() (for concatenate). Any numbers inside the parentheses are joined to-
gether. The following command instructs R to join together the numbers
1, 3, 2, and 5, and to save them as a vector named x. When we type x, it
gives us back the vector.

c()

vector

> x <- c (1 ,3 ,2 ,5)
> x
[1] 1 3 2 5

Note that the > is not part of the command; rather, it is printed by R to
indicate that it is ready for another command to be entered. We can also
save things using = rather than <-:

> x = c (1 ,6 ,2)
> x
[1] 1 6 2
> y = c (1 ,4 ,3)

Hitting the up arrow multiple times will display the previous commands,
which can then be edited. This is useful since one often wishes to repeat
a similar command. In addition, typing ?funcname will always cause R to
open a new help ﬁle window with additional information about the function
funcname.

We can tell R to add two sets of numbers together. It will then add the
ﬁrst number from x to the ﬁrst number from y, and so on. However, x and
y should be the same length. We can check their length using the length()
function.

length()

> length ( x )
[1] 3
> length ( y )
[1] 3
> x + y
[1]

2 10

5

The ls() function allows us to look at a list of all of the objects, such
as data and functions, that we have saved so far. The rm() function can be
used to delete any that we don’t want.

ls()

rm()

> ls ()
[1] " x " " y "
> rm (x , y )
> ls ()
character (0)

It’s also possible to remove all objects at once:

> rm ( list = ls () )

44

2. Statistical Learning

The matrix() function can be used to create a matrix of numbers. Before

we use the matrix() function, we can learn more about it:

matrix()

> ? matrix

The help ﬁle reveals that the matrix() function takes a number of inputs,
but for now we focus on the ﬁrst three: the data (the entries in the matrix),
the number of rows, and the number of columns. First, we create a simple
matrix.

> x = matrix ( data = c (1 ,2 ,3 ,4) , nrow =2 , ncol =2)
> x

[ ,1] [ ,2]
3
4

1
2

[1 ,]
[2 ,]

Note that we could just as well omit typing data=, nrow=, and ncol= in the
matrix() command above: that is, we could just type

> x = matrix ( c (1 ,2 ,3 ,4) ,2 ,2)

and this would have the same eﬀect. However, it can sometimes be useful to
specify the names of the arguments passed in, since otherwise R will assume
that the function arguments are passed into the function in the same order
that is given in the function’s help ﬁle. As this example illustrates, by
default R creates matrices by successively ﬁlling in columns. Alternatively,
the byrow=TRUE option can be used to populate the matrix in order of the
rows.

> matrix ( c (1 ,2 ,3 ,4) ,2 ,2 , byrow = TRUE )

[ ,1] [ ,2]
2
4

1
3

[1 ,]
[2 ,]

Notice that in the above command we did not assign the matrix to a value
such as x. In this case the matrix is printed to the screen but is not saved
for future calculations. The sqrt() function returns the square root of each
element of a vector or matrix. The command x^2 raises each element of x
to the power 2; any powers are possible, including fractional or negative
powers.

sqrt()

> sqrt ( x )

[ ,1] [ ,2]
[1 ,] 1.00 1.73
[2 ,] 1.41 2.00
> x ^2

[ ,1] [ ,2]
9
16

1
4

[1 ,]
[2 ,]

The rnorm() function generates a vector of random normal variables,
with ﬁrst argument n the sample size. Each time we call this function, we
will get a diﬀerent answer. Here we create two correlated sets of numbers,
x and y, and use the cor() function to compute the correlation between
them.

rnorm()

cor()

2.3 Lab: Introduction to R

45

> x = rnorm (50)
> y = x + rnorm (50 , mean =50 , sd =.1)
> cor ( x , y )
[1] 0.995

By default, rnorm() creates standard normal random variables with a mean
of 0 and a standard deviation of 1. However, the mean and standard devi-
ation can be altered using the mean and sd arguments, as illustrated above.
Sometimes we want our code to reproduce the exact same set of random
numbers; we can use the set.seed() function to do this. The set.seed()
function takes an (arbitrary) integer argument.

set.seed()

> set . seed (1303)
> rnorm (50)
[1] -1.1440
. . .

1.3421

2.1854

0.5364

0.0632

0.5022 -0.0004

We use set.seed() throughout the labs whenever we perform calculations
involving random quantities. In general this should allow the user to re-
produce our results. However, it should be noted that as new versions of
R become available it is possible that some small discrepancies may form
between the book and the output from R.

The mean() and var() functions can be used to compute the mean and
variance of a vector of numbers. Applying sqrt() to the output of var()
will give the standard deviation. Or we can simply use the sd() function.

mean()

var()

sd()

> set . seed (3)
> y = rnorm (100)
> mean ( y )
[1] 0.0110
> var ( y )
[1] 0.7329
> sqrt ( var ( y ) )
[1] 0.8561
> sd ( y )
[1] 0.8561

2.3.2 Graphics

The plot() function is the primary way to plot data in R. For instance,
plot(x,y) produces a scatterplot of the numbers in x versus the numbers
in y. There are many additional options that can be passed in to the plot()
function. For example, passing in the argument xlab will result in a label
on the x-axis. To ﬁnd out more information about the plot() function,
type ?plot.

plot()

> x = rnorm (100)
> y = rnorm (100)
> plot (x , y )
> plot (x ,y , xlab =" this is the x - axis " , ylab =" this is the y - axis " ,

main =" Plot of X vs Y ")

46

2. Statistical Learning

We will often want to save the output of an R plot. The command that we
use to do this will depend on the ﬁle type that we would like to create. For
instance, to create a pdf, we use the pdf() function, and to create a jpeg,
we use the jpeg() function.

pdf()

jpeg()

> pdf (" Figure . pdf ")
> plot (x ,y , col =" green ")
> dev . off ()
null device
1

The function dev.off() indicates to R that we are done creating the plot.
Alternatively, we can simply copy the plot window and paste it into an
appropriate ﬁle type, such as a Word document.

The function seq() can be used to create a sequence of numbers. For
instance, seq(a,b) makes a vector of integers between a and b. There are
many other options: for instance, seq(0,1,length=10) makes a sequence of
10 numbers that are equally spaced between 0 and 1. Typing 3:11 is a
shorthand for seq(3,11) for integer arguments.

dev.off()

seq()

> x = seq (1 ,10)
> x

[1]

1

2

3

4

5

6

7

8

9 10

> x =1:10
> x

[1]

7
> x = seq ( - pi , pi , length =50)

1

5

2

3

4

6

8

9 10

We will now create some more sophisticated plots. The contour() func-
tion produces a contour plot in order to represent three-dimensional data;
it is like a topographical map. It takes three arguments:

contour()

contour plot

1. A vector of the x values (the ﬁrst dimension),

2. A vector of the y values (the second dimension), and

3. A matrix whose elements correspond to the z value (the third dimen-

sion) for each pair of (x,y) coordinates.

As with the plot() function, there are many other inputs that can be used
to ﬁne-tune the output of the contour() function. To learn more about
these, take a look at the help ﬁle by typing ?contour.

> y = x
> f = outer (x ,y , function (x , y ) cos ( y ) /(1+ x ^2) )
> contour (x ,y , f )
> contour (x ,y ,f , nlevels =45 , add = T )
> fa =( f - t ( f ) ) /2
> contour (x ,y , fa , nlevels =15)

The image() function works the same way as contour(), except that it
produces a color-coded plot whose colors depend on the z value. This is

image()

2.3 Lab: Introduction to R

47

known as a heatmap, and is sometimes used to plot temperature in weather
forecasts. Alternatively, persp() can be used to produce a three-dimensional
plot. The arguments theta and phi control the angles at which the plot is
viewed.

heatmap

persp()

> image (x ,y , fa )
> persp (x ,y , fa )
> persp (x ,y , fa , theta =30)
> persp (x ,y , fa , theta =30 , phi =20)
> persp (x ,y , fa , theta =30 , phi =70)
> persp (x ,y , fa , theta =30 , phi =40)

2.3.3 Indexing Data

We often wish to examine part of a set of data. Suppose that our data is
stored in the matrix A.

> A = matrix (1:16 ,4 ,4)
> A

[ ,1] [ ,2] [ ,3] [ ,4]
13
14
15
16

9
10
11
12

1
2
3
4

5
6
7
8

[1 ,]
[2 ,]
[3 ,]
[4 ,]

Then, typing

> A [2 ,3]
[1] 10

will select the element corresponding to the second row and the third col-
umn. The ﬁrst number after the open-bracket symbol [ always refers to
the row, and the second number always refers to the column. We can also
select multiple rows and columns at a time, by providing vectors as the
indices.

> A [ c (1 ,3) , c (2 ,4) ]

[ ,1] [ ,2]
13
15

[1 ,]
[2 ,]
> A [1:3 ,2:4]

5
7

[ ,1] [ ,2] [ ,3]
13
14
15

9
10
11

[1 ,]
5
[2 ,]
6
[3 ,]
7
> A [1:2 ,]

[ ,1] [ ,2] [ ,3] [ ,4]
13
14

9
10

5
6

1
[1 ,]
[2 ,]
2
> A [ ,1:2]

[ ,1] [ ,2]
5
6

1
2

[1 ,]
[2 ,]

48

2. Statistical Learning

[3 ,]
[4 ,]

3
4

7
8

The last two examples include either no index for the columns or no index
for the rows. These indicate that R should include all columns or all rows,
respectively. R treats a single row or column of a matrix as a vector.

> A [1 ,]
[1]

1

5

9 13

The use of a negative sign - in the index tells R to keep all rows or columns
except those indicated in the index.

> A [ - c (1 ,3) ,]

[ ,1] [ ,2] [ ,3] [ ,4]
14
16

[1 ,]
[2 ,]
> A [ - c (1 ,3) ,-c (1 ,3 ,4) ]
[1] 6 8

2
4

6
8

10
12

The dim() function outputs the number of rows followed by the number of
columns of a given matrix.

dim()

> dim ( A )
[1] 4 4

2.3.4 Loading Data

For most analyses, the ﬁrst step involves importing a data set into R. The
read.table() function is one of the primary ways to do this. The help ﬁle
contains details about how to use this function. We can use the function
write.table() to export data.

Before attempting to load a data set, we must make sure that R knows
to search for the data in the proper directory. For example on a Windows
system one could select the directory using the Change dir. . . option under
the File menu. However, the details of how to do this depend on the op-
erating system (e.g. Windows, Mac, Unix) that is being used, and so we
do not give further details here. We begin by loading in the Auto data set.
This data is part of the ISLR library (we discuss libraries in Chapter 3) but
to illustrate the read.table() function we load it now from a text ﬁle. The
following command will load the Auto.data ﬁle into R and store it as an
object called Auto, in a format referred to as a data frame. (The text ﬁle
can be obtained from this book’s website.) Once the data has been loaded,
the fix() function can be used to view it in a spreadsheet like window.
However, the window must be closed before further R commands can be
entered.

read.table()

write.
table()

data frame

> Auto = read . table (" Auto . data ")
> fix ( Auto )

2.3 Lab: Introduction to R

49

Note that Auto.data is simply a text ﬁle, which you could alternatively
open on your computer using a standard text editor. It is often a good idea
to view a data set using a text editor or other software such as Excel before
loading it into R.

This particular data set has not been loaded correctly, because R has
assumed that the variable names are part of the data and so has included
them in the ﬁrst row. The data set also includes a number of missing
observations, indicated by a question mark ?. Missing values are a common
occurrence in real data sets. Using the option header=T (or header=TRUE) in
the read.table() function tells R that the ﬁrst line of the ﬁle contains the
variable names, and using the option na.strings tells R that any time it
sees a particular character or set of characters (such as a question mark),
it should be treated as a missing element of the data matrix.

> Auto = read . table (" Auto . data " , header =T , na . strings ="?")
> fix ( Auto )

Excel is a common-format data storage program. An easy way to load such
data into R is to save it as a csv (comma separated value) ﬁle and then use
the read.csv() function to load it in.

> Auto = read . csv (" Auto . csv " , header =T , na . strings ="?")
> fix ( Auto )
> dim ( Auto )
[1] 397 9
> Auto [1:4 ,]

The dim() function tells us that the data has 397 observations, or rows, and
nine variables, or columns. There are various ways to deal with the missing
data. In this case, only ﬁve of the rows contain missing observations, and
so we choose to use the na.omit() function to simply remove these rows.

> Auto = na . omit ( Auto )
> dim ( Auto )
[1] 392
9

Once the data are loaded correctly, we can use names() to check the

variable names.

> names ( Auto )
[1] " mpg "
[5] " weight "
[9] " name "

" cylinders "
" a c c e l e r a t i o n " " year "

" d i s p l a c e m e n t " " horsepower "

" origin "

dim()

na.omit()

names()

2.3.5 Additional Graphical and Numerical Summaries

We can use the plot() function to produce scatterplots of the quantitative
variables. However, simply typing the variable names will produce an error
message, because R does not know to look in the Auto data set for those
variables.

scatterplot

50

2. Statistical Learning

> plot ( cylinders , mpg )
Error in plot ( cylinders , mpg ) : object ’ cylinders ’ not found

To refer to a variable, we must type the data set and the variable name
joined with a $ symbol. Alternatively, we can use the attach() function in
order to tell R to make the variables in this data frame available by name.

attach()

> plot ( Auto$cylinders , Auto$mpg )
> attach ( Auto )
> plot ( cylinders , mpg )

The cylinders variable is stored as a numeric vector, so R has treated it
as quantitative. However, since there are only a small number of possible
values for cylinders, one may prefer to treat it as a qualitative variable.
The as.factor() function converts quantitative variables into qualitative
variables.

as.factor()

> cylinders = as . factor ( cylinders )

If the variable plotted on the x-axis is categorial, then boxplots will
automatically be produced by the plot() function. As usual, a number
of options can be speciﬁed in order to customize the plots.

boxplot

> plot ( cylinders , mpg )
> plot ( cylinders , mpg , col =" red ")
> plot ( cylinders , mpg , col =" red " , varwidth = T )
> plot ( cylinders , mpg , col =" red " , varwidth =T , horizontal = T )
> plot ( cylinders , mpg , col =" red " , varwidth =T , xlab =" cylinders " ,

ylab =" MPG ")

The hist() function can be used to plot a histogram. Note that col=2

has the same eﬀect as col="red".

> hist ( mpg )
> hist ( mpg , col =2)
> hist ( mpg , col =2 , breaks =15)

hist()
histogram

The pairs() function creates a scatterplot matrix i.e. a scatterplot for every
pair of variables for any given data set. We can also produce scatterplots
for just a subset of the variables.

scatterplot
matrix

> pairs ( Auto )

> pairs (∼ mpg + d i s p l a c e m e n t + horsepowe r + weight +

acceleration , Auto )

In conjunction with the plot() function, identify() provides a useful
interactive method for identifying the value for a particular variable for
points on a plot. We pass in three arguments to identify(): the x-axis
variable, the y-axis variable, and the variable whose values we would like
to see printed for each point. Then clicking on a given point in the plot
will cause R to print the value of the variable of interest. Right-clicking on
the plot will exit the identify() function (control-click on a Mac). The
numbers printed under the identify() function correspond to the rows for
the selected points.

identify()

> plot ( horsepower , mpg )
> identify ( horsepower , mpg , name )

2.3 Lab: Introduction to R

51

The summary() function produces a numerical summary of each variable in
a particular data set.

summary()

> summary ( Auto )

mpg

Min .
: 9.00
1 st Qu .:17.00
Median :22.75
Mean
:23.45
3 rd Qu .:29.00
:46.60
Max .

horsepower

Min .
: 46.0
1 st Qu .: 75.0
Median : 93.5
Mean
:104.5
3 rd Qu .:126.0
Max .
:230.0

cylinders

Min .
:3.000
1 st Qu .:4.000
Median :4.000
Mean
:5.472
3 rd Qu .:8.000
:8.000
Max .

d i s p l a c e m e n t
Min .
: 68.0
1 st Qu .:105.0
Median :151.0
Mean
:194.4
3 rd Qu .:275.8
:455.0
Max .

weight

Min .
:1613
1 st Qu .:2225
Median :2804
Mean
:2978
3 rd Qu .:3615
Max .
:5140

a c c e l e r a t i o n
Min .
: 8.00
1 st Qu .:13.78
Median :15.50
Mean
:15.54
3 rd Qu .:17.02
Max .
:24.80

year

origin

name

Min .
:70.00
1 st Qu .:73.00
Median :76.00
Mean
:75.98
3 rd Qu .:79.00
Max .
:82.00

Min .
:1.000
1 st Qu .:1.000
Median :1.000
Mean
:1.577
3 rd Qu .:2.000
Max .
:3.000

:
amc matador
:
ford pinto
:
toyota corolla
:
amc gremlin
amc hornet
:
chevrolet chevette :
( Other )

5
5
5
4
4
4
:365

For qualitative variables such as name, R will list the number of observations
that fall in each category. We can also produce a summary of just a single
variable.

> summary ( mpg )

Min . 1 st Qu .
9.00
17.00

Median
22.75

Mean 3 rd Qu .
29.00

23.45

Max .
46.60

Once we have ﬁnished using R, we type q() in order to shut it down, or
quit. When exiting R, we have the option to save the current workspace so
that all objects (such as data sets) that we have created in this R session
will be available next time. Before exiting R, we may want to save a record
of all of the commands that we typed in the most recent session; this can
be accomplished using the savehistory() function. Next time we enter R,
we can load that history using the loadhistory() function.

q()

workspace

savehistory()

loadhistory()

52

2. Statistical Learning

2.4 Exercises

Conceptual

1. For each of parts (a) through (d), indicate whether we would generally
expect the performance of a ﬂexible statistical learning method to be
better or worse than an inﬂexible method. Justify your answer.

(a) The sample size n is extremely large, and the number of predic-

tors p is small.

(b) The number of predictors p is extremely large, and the number

of observations n is small.

(c) The relationship between the predictors and response is highly

non-linear.

(d) The variance of the error terms, i.e. σ2 = Var(), is extremely

high.

2. Explain whether each scenario is a classiﬁcation or regression prob-
lem, and indicate whether we are most interested in inference or pre-
diction. Finally, provide n and p.

(a) We collect a set of data on the top 500 ﬁrms in the US. For each
ﬁrm we record proﬁt, number of employees, industry and the
CEO salary. We are interested in understanding which factors
aﬀect CEO salary.

(b) We are considering launching a new product and wish to know
whether it will be a success or a failure. We collect data on 20
similar products that were previously launched. For each prod-
uct we have recorded whether it was a success or failure, price
charged for the product, marketing budget, competition price,
and ten other variables.

(c) We are interest

ed

in predicting the % change in the USD/Euro
exchange rate in relation to the weekly changes in the world
stock markets. Hence we collect weekly data for all of 2012. For
each week we record the % change in the USD/Euro, the %
change in the US market, the % change in the British market,
and the % change in the German market.

3. We now revisit the bias-variance decomposition.

(a) Provide a sketch of typical (squared) bias, variance, training er-
ror, test error, and Bayes (or irreducible) error curves, on a sin-
gle plot, as we go from less ﬂexible statistical learning methods
towards more ﬂexible approaches. The x-axis should represent

2.4 Exercises

53

the amount of ﬂexibility in the method, and the y-axis should
represent the values for each curve. There should be ﬁve curves.
Make sure to label each one.

(b) Explain why each of the ﬁve curves has the shape displayed in

part (a).

4. You will now think of some real-life applications for statistical learn-

ing.

(a) Describe three real-life applications in which classiﬁcation might
be useful. Describe the response, as well as the predictors. Is the
goal of each application inference or prediction? Explain your
answer.

(b) Describe three real-life applications in which regression might
be useful. Describe the response, as well as the predictors. Is the
goal of each application inference or prediction? Explain your
answer.

(c) Describe three real-life applications in which cluster analysis

might be useful.

5. What are the advantages and disadvantages of a very ﬂexible (versus
a less ﬂexible) approach for regression or classiﬁcation? Under what
circumstances might a more ﬂexible approach be preferred to a less
ﬂexible approach? When might a less ﬂexible approach be preferred?

6. Describe the diﬀerences between a parametric and a non-parametric
statistical learning approach. What are the advantages of a para-
metric approach to regression or classiﬁcation (as opposed to a non-
parametric approach)? What are its disadvantages?

7. The table below provides a training data set containing six observa-

tions, three predictors, and one qualitative response variable.

Obs. X1 X2 X3
1
2
3
4
5
6

0
2
0
0
−1
1

3
0
1
1
0
1

Y

0 Red
0 Red
3 Red
2 Green
1 Green
1 Red

Suppose we wish to use this data set to make a prediction for Y when
X1 = X2 = X3 = 0 using K-nearest neighbors.

(a) Compute the Euclidean distance between each observation and

the test point, X1 = X2 = X3 = 0.

54

2. Statistical Learning

(b) What is our prediction with K = 1? Why?

(c) What is our prediction with K = 3? Why?

(d) If the Bayes decision boundary in this problem is highly non-
linear, then would we expect the best value for K to be large or
small? Why?

Applied

8. This exercise relates to the College data set, which can be found in
the ﬁle College.csv. It contains a number of variables for 777 diﬀerent
universities and colleges in the US. The variables are

• Private : Public/private indicator
• Apps : Number of applications received
• Accept : Number of applicants accepted
• Enroll : Number of new students enrolled
• Top10perc : New students from top 10 % of high school class
• Top25perc : New students from top 25 % of high school class
• F.Undergrad : Number of full-time undergraduates
• P.Undergrad : Number of part-time undergraduates
• Outstate : Out-of-state tuition
• Room.Board : Room and board costs
• Books : Estimated book costs
• Personal : Estimated personal spending
• PhD : Percent of faculty with Ph.D.’s
• Terminal : Percent of faculty with terminal degree
• S.F.Ratio : Student/faculty ratio
• perc.alumni : Percent of alumni who donate
• Expend : Instructional expenditure per student
• Grad.Rate : Graduation rate

Before reading the data into R, it can be viewed in Excel or a text
editor.

(a) Use the read.csv() function to read the data into R. Call the
loaded data college. Make sure that you have the directory set
to the correct location for the data.

(b) Look at the data using the fix() function. You should notice
that the ﬁrst column is just the name of each university. We don’t
really want R to treat this as data. However, it may be handy to
have these names for later. Try the following commands:

2.4 Exercises

55

> rownames ( college ) = college [ ,1]
> fix ( college )

You should see that there is now a row.names column with the
name of each university recorded. This means that R has given
each row a name corresponding to the appropriate university. R
will not try to perform calculations on the row names. However,
we still need to eliminate the ﬁrst column in the data where the
names are stored. Try

> college = college [ , -1]
> fix ( college )

Now you should see that the ﬁrst data column is Private. Note
that another column labeled row.names now appears before the
Private column. However, this is not a data column but rather
the name that R is giving to each row.

(c)

i. Use the summary() function to produce a numerical summary

of the variables in the data set.

ii. Use the pairs() function to produce a scatterplot matrix of
the ﬁrst ten columns or variables of the data. Recall that
you can reference the ﬁrst ten columns of a matrix A using
A[,1:10].

iii. Use the plot() function to produce side-by-side boxplots of

Outstate versus Private.

iv. Create a new qualitative variable, called Elite, by binning
the Top10perc variable. We are going to divide universities
into two groups based on whether or not the proportion
of students coming from the top 10 % of their high school
classes exceeds 50 %.

> Elite = rep (" No " , nrow ( college ) )
> Elite [ college$Top1 0 pe rc >50]=" Yes "
> Elite = as . factor ( Elite )
> college = data . frame ( college , Elite )

Use the summary() function to see how many elite univer-
sities there are. Now use the plot() function to produce
side-by-side boxplots of Outstate versus Elite.

v. Use the hist() function to produce some histograms with
diﬀering numbers of bins for a few of the quantitative vari-
ables. You may ﬁnd the command par(mfrow=c(2,2)) useful:
it will divide the print window into four regions so that four
plots can be made simultaneously. Modifying the arguments
to this function will divide the screen in other ways.

vi. Continue exploring the data, and provide a brief summary

of what you discover.

56

2. Statistical Learning

9. This exercise involves the Auto data set studied in the lab. Make sure

that the missing values have been removed from the data.

(a) Which of the predictors are quantitative, and which are quali-

tative?

(b) What is the range of each quantitative predictor? You can an-

swer this using the range() function.

(c) What is the mean and standard deviation of each quantitative

range()

predictor?

(d) Now remove the 10th through 85th observations. What is the
range, mean, and standard deviation of each predictor in the
subset of the data that remains?

(e) Using the full data set, investigate the predictors graphically,
using scatterplots or other tools of your choice. Create some plots
highlighting the relationships among the predictors. Comment
on your ﬁndings.

(f) Suppose that we wish to predict gas mileage (mpg) on the basis
of the other variables. Do your plots suggest that any of the
other variables might be useful in predicting mpg? Justify your
answer.

10. This exercise involves the Boston housing data set.

(a) To begin, load in the Boston data set. The Boston data set is

part of the MASS library in R.

> library ( MASS )

Now the data set is contained in the object Boston.

> Boston

Read about the data set:

> ? Boston

How many rows are in this data set? How many columns? What
do the rows and columns represent?

(b) Make some pairwise scatterplots of the predictors (columns) in

this data set. Describe your ﬁndings.

(c) Are any of the predictors associated with per capita crime rate?

If so, explain the relationship.

(d) Do any of the suburbs of Boston appear to have particularly
high crime rates? Tax rates? Pupil-teacher ratios? Comment on
the range of each predictor.

(e) How many of the suburbs in this data set bound the Charles

river?

2.4 Exercises

57

(f) What is the median pupil-teacher ratio among the towns in this

data set?

(g) Which suburb of Boston has lowest median value of owner-
occupied homes? What are the values of the other predictors
for that suburb, and how do those values compare to the overall
ranges for those predictors? Comment on your ﬁndings.

(h) In this data set, how many of the suburbs average more than
seven rooms per dwelling? More than eight rooms per dwelling?
Comment on the suburbs that average more than eight rooms
per dwelling.

3
Linear Regression

This chapter is about linear regression, a very simple approach for
supervised learning. In particular, linear regression is a useful tool for pre-
dicting a quantitative response. Linear regression has been around for a
long time and is the topic of innumerable textbooks. Though it may seem
somewhat dull compared to some of the more modern statistical learning
approaches described in later chapters of this book, linear regression is still
a useful and widely used statistical learning method. Moreover, it serves
as a good jumping-oﬀ point for newer approaches: as we will see in later
chapters, many fancy statistical learning approaches can be seen as gener-
alizations or extensions of linear regression. Consequently, the importance
of having a good understanding of linear regression before studying more
complex learning methods cannot be overstated. In this chapter, we review
some of the key ideas underlying the linear regression model, as well as the
least squares approach that is most commonly used to ﬁt this model.

Recall the Advertising data from Chapter 2. Figure 2.1 displays sales
(in thousands of units) for a particular product as a function of advertis-
ing budgets (in thousands of dollars) for TV, radio, and newspaper media.
Suppose that in our role as statistical consultants we are asked to suggest,
on the basis of this data, a marketing plan for next year that will result in
high product sales. What information would be useful in order to provide
such a recommendation? Here are a few important questions that we might
seek to address:

1. Is there a relationship between advertising budget and sales?

Our ﬁrst goal should be to determine whether the data provide

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 3,
© Springer Science+Business Media New York 2013

59

60

3. Linear Regression

evidence of an association between advertising expenditure and sales.
If the evidence is weak, then one might argue that no money should
be spent on advertising!

2. How strong is the relationship between advertising budget and sales?
Assuming that there is a relationship between advertising and sales,
we would like to know the strength of this relationship. In other
words, given a certain advertising budget, can we predict sales with
a high level of accuracy? This would be a strong relationship. Or is
a prediction of sales based on advertising expenditure only slightly
better than a random guess? This would be a weak relationship.

3. Which media contribute to sales?

Do all three media—TV, radio, and newspaper—contribute to sales,
or do just one or two of the media contribute? To answer this question,
we must ﬁnd a way to separate out the individual eﬀects of each
medium when we have spent money on all three media.

4. How accurately can we estimate the eﬀect of each medium on sales?
For every dollar spent on advertising in a particular medium, by
what amount will sales increase? How accurately can we predict this
amount of increase?

5. How accurately can we predict future sales?

For any given level of television, radio, or newspaper advertising, what
is our prediction for sales, and what is the accuracy of this prediction?

6. Is the relationship linear?

If there is approximately a straight-line relationship between advertis-
ing expenditure in the various media and sales, then linear regression
is an appropriate tool. If not, then it may still be possible to trans-
form the predictor or the response so that linear regression can be
used.

7. Is there synergy among the advertising media?

Perhaps spending $50,000 on television advertising and $50,000 on
radio advertising results in more sales than allocating $100,000 to
either television or radio individually. In marketing, this is known as
a synergy eﬀect, while in statistics it is called an interaction eﬀect.

It turns out that linear regression can be used to answer each of these
questions. We will ﬁrst discuss all of these questions in a general context,
and then return to them in this speciﬁc context in Section 3.4.

synergy

interaction

3.1 Simple Linear Regression

3.1 Simple Linear Regression

61

Simple linear regression lives up to its name: it is a very straightforward
approach for predicting a quantitative response Y on the basis of a sin-
gle predictor variable X. It assumes that there is approximately a linear
relationship between X and Y . Mathematically, we can write this linear
relationship as

(3.1)
You might read “≈” as “is approximately modeled as”. We will sometimes
describe (3.1) by saying that we are regressing Y on X (or Y onto X).
For example, X may represent TV advertising and Y may represent sales.
Then we can regress sales onto TV by ﬁtting the model

Y ≈ β0 + β1X.

sales ≈ β0 + β1 × TV.

simple linear
regression

In Equation 3.1, β0 and β1 are two unknown constants that represent
the intercept and slope terms in the linear model. Together, β0 and β1 are
known as the model coeﬃcients or parameters. Once we have used our
training data to produce estimates ˆβ0 and ˆβ1 for the model coeﬃcients, we
can predict future sales on the basis of a particular value of TV advertising
by computing

intercept

slope

coeﬃcient
parameter

ˆy = ˆβ0 + ˆβ1x,

(3.2)

where ˆy indicates a prediction of Y on the basis of X = x. Here we use a
hat symbol, ˆ , to denote the estimated value for an unknown parameter
or coeﬃcient, or to denote the predicted value of the response.

3.1.1 Estimating the Coeﬃcients

In practice, β0 and β1 are unknown. So before we can use (3.1) to make
predictions, we must use data to estimate the coeﬃcients. Let

(x1, y1), (x2, y2), . . . , (xn, yn)

represent n observation pairs, each of which consists of a measurement
of X and a measurement of Y . In the Advertising example, this data
set consists of the TV advertising budget and product sales in n = 200
diﬀerent markets. (Recall that the data are displayed in Figure 2.1.) Our
goal is to obtain coeﬃcient estimates ˆβ0 and ˆβ1 such that the linear model
(3.1) ﬁts the available data well—that is, so that yi ≈ ˆβ0 + ˆβ1xi for i =
1, . . . , n. In other words, we want to ﬁnd an intercept ˆβ0 and a slope ˆβ1 such
that the resulting line is as close as possible to the n = 200 data points.
There are a number of ways of measuring closeness. However, by far the
most common approach involves minimizing the least squares criterion,
and we take that approach in this chapter. Alternative approaches will be
considered in Chapter 6.

least squares

62

3. Linear Regression

5
2

0
2

5
1

0
1

5

l

s
e
a
S

0

50

100

150

TV

200

250

300

FIGURE 3.1. For the Advertising data, the least squares ﬁt for the regression
of sales onto TV is shown. The ﬁt is found by minimizing the sum of squared
errors. Each grey line segment represents an error, and the ﬁt makes a compro-
mise by averaging their squares. In this case a linear ﬁt captures the essence of
the relationship, although it is somewhat deﬁcient in the left of the plot.

Let ˆyi = ˆβ0 + ˆβ1xi be the prediction for Y based on the ith value of X.
Then ei = yi − ˆyi represents the ith residual—this is the diﬀerence between

the ith observed response value and the ith response value that is predicted
by our linear model. We deﬁne the residual sum of squares (RSS) as

RSS = e2

1 + e2

2 + ··· + e2
n,

or equivalently as

residual

residual sum
of squares

RSS = (y1− ˆβ0− ˆβ1x1)2 + (y2− ˆβ0− ˆβ1x2)2 + . . .+ (yn− ˆβ0− ˆβ1xn)2. (3.3)
The least squares approach chooses ˆβ0 and ˆβ1 to minimize the RSS. Using
some calculus, one can show that the minimizers are

where ¯y ≡ 1
n
i=1 xi are the sample means. In other
words, (3.4) deﬁnes the least squares coeﬃcient estimates for simple linear
regression.

i=1 yi and ¯x ≡ 1

n

n

n

Figure 3.1 displays the simple linear regression ﬁt to the Advertising
data, where ˆβ0 = 7.03 and ˆβ1 = 0.0475. In other words, according to

(cid:10)

n

i=1(xi − ¯x)(yi − ¯y)
(cid:10)
ˆβ1 =
i=1(xi − ¯x)2
ˆβ0 = ¯y − ˆβ1 ¯x,
(cid:10)

n

(cid:10)

,

(3.4)

3.1 Simple Linear Regression

63

 3 

 3 

1

β

6
0

.

0

5
0

.

0

4
0

.

0

3
0

.

0

 3 

5

6

 2.5 

 2.15 

 2.2 

 2.3 

7
β0

R

S

S

 3 

8

9

β0

β1

FIGURE 3.2. Contour and three-dimensional plots of
the RSS on the
Advertising data, using sales as the response and TV as the predictor. The
red dots correspond to the least squares estimates ˆβ0 and ˆβ1, given by (3.4).

this approximation, an additional $1,000 spent on TV advertising is asso-
ciated with selling approximately 47.5 additional units of the product. In
Figure 3.2, we have computed RSS for a number of values of β0 and β1,
using the advertising data with sales as the response and TV as the predic-
tor. In each plot, the red dot represents the pair of least squares estimates
( ˆβ0, ˆβ1) given by (3.4). These values clearly minimize the RSS.

3.1.2 Assessing the Accuracy of the Coeﬃcient Estimates

Recall from (2.1) that we assume that the true relationship between X and
Y takes the form Y = f (X) +  for some unknown function f , where 
is a mean-zero random error term. If f is to be approximated by a linear
function, then we can write this relationship as

Y = β0 + β1X + .

(3.5)

Here β0 is the intercept term—that is, the expected value of Y when X = 0,
and β1 is the slope—the average increase in Y associated with a one-unit
increase in X. The error term is a catch-all for what we miss with this
simple model: the true relationship is probably not linear, there may be
other variables that cause variation in Y , and there may be measurement
error. We typically assume that the error term is independent of X.

The model given by (3.5) deﬁnes the population regression line, which
is the best linear approximation to the true relationship between X and
Y .1 The least squares regression coeﬃcient estimates (3.4) characterize the
least squares line (3.2). The left-hand panel of Figure 3.3 displays these

1The assumption of linearity is often a useful working model. However, despite what

many textbooks might tell us, we seldom believe that the true relationship is linear.

population
regression
line

least squares
line

64

3. Linear Regression

Y

0
1

5

0

5
−

0
1
−

Y

0
1

5

0

5
−

0
1
−

−2

−1

0

X

1

2

−2

−1

1

2

0

X

FIGURE 3.3. A simulated data set. Left: The red line represents the true rela-
tionship, f (X) = 2 + 3X, which is known as the population regression line. The
blue line is the least squares line; it is the least squares estimate for f (X) based
on the observed data, shown in black. Right: The population regression line is
again shown in red, and the least squares line in dark blue. In light blue, ten least
squares lines are shown, each computed on the basis of a separate random set of
observations. Each least squares line is diﬀerent, but on average, the least squares
lines are quite close to the population regression line.

two lines in a simple simulated example. We created 100 random Xs, and
generated 100 corresponding Y s from the model

Y = 2 + 3X + ,

(3.6)

where  was generated from a normal distribution with mean zero. The
red line in the left-hand panel of Figure 3.3 displays the true relationship,
f (X) = 2 + 3X, while the blue line is the least squares estimate based
on the observed data. The true relationship is generally not known for
real data, but the least squares line can always be computed using the
coeﬃcient estimates given in (3.4). In other words, in real applications,
we have access to a set of observations from which we can compute the
least squares line; however, the population regression line is unobserved.
In the right-hand panel of Figure 3.3 we have generated ten diﬀerent data
sets from the model given by (3.6) and plotted the corresponding ten least
squares lines. Notice that diﬀerent data sets generated from the same true
model result in slightly diﬀerent least squares lines, but the unobserved
population regression line does not change.

At ﬁrst glance, the diﬀerence between the population regression line and
the least squares line may seem subtle and confusing. We only have one
data set, and so what does it mean that two diﬀerent lines describe the
relationship between the predictor and the response? Fundamentally, the

3.1 Simple Linear Regression

65

concept of these two lines is a natural extension of the standard statistical
approach of using information from a sample to estimate characteristics of a
large population. For example, suppose that we are interested in knowing
the population mean μ of some random variable Y . Unfortunately, μ is
unknown, but we do have access to n observations from Y , which we can
write as y1, . . . , yn, and which we can use to estimate μ. A reasonable
n
estimate is ˆμ = ¯y, where ¯y = 1
i=1 yi is the sample mean. The sample
n
mean and the population mean are diﬀerent, but in general the sample
mean will provide a good estimate of the population mean. In the same
way, the unknown coeﬃcients β0 and β1 in linear regression deﬁne the
population regression line. We seek to estimate these unknown coeﬃcients
using ˆβ0 and ˆβ1 given in (3.4). These coeﬃcient estimates deﬁne the least
squares line.

(cid:10)

The analogy between linear regression and estimation of the mean of a
random variable is an apt one based on the concept of bias. If we use the
sample mean ˆμ to estimate μ, this estimate is unbiased, in the sense that
on average, we expect ˆμ to equal μ. What exactly does this mean? It means
that on the basis of one particular set of observations y1, . . . , yn, ˆμ might
overestimate μ, and on the basis of another set of observations, ˆμ might
underestimate μ. But if we could average a huge number of estimates of
μ obtained from a huge number of sets of observations, then this average
would exactly equal μ. Hence, an unbiased estimator does not systematically
over- or under-estimate the true parameter. The property of unbiasedness
holds for the least squares coeﬃcient estimates given by (3.4) as well: if
we estimate β0 and β1 on the basis of a particular data set, then our
estimates won’t be exactly equal to β0 and β1. But if we could average
the estimates obtained over a huge number of data sets, then the average
of these estimates would be spot on! In fact, we can see from the right-
hand panel of Figure 3.3 that the average of many least squares lines, each
estimated from a separate data set, is pretty close to the true population
regression line.

We continue the analogy with the estimation of the population mean
μ of a random variable Y . A natural question is as follows: how accurate
is the sample mean ˆμ as an estimate of μ? We have established that the
average of ˆμ’s over many data sets will be very close to μ, but that a
single estimate ˆμ may be a substantial underestimate or overestimate of μ.
How far oﬀ will that single estimate of ˆμ be? In general, we answer this
question by computing the standard error of ˆμ, written as SE(ˆμ). We have
the well-known formula

bias

unbiased

standard
error

Var(ˆμ) = SE(ˆμ)2 =

σ2
n

,

(3.7)

66

3. Linear Regression

(cid:20)

1
n

(cid:21)

,

where σ is the standard deviation of each of the realizations yi of Y .2
Roughly speaking, the standard error tells us the average amount that this
estimate ˆμ diﬀers from the actual value of μ. Equation 3.7 also tells us how
this deviation shrinks with n—the more observations we have, the smaller
the standard error of ˆμ. In a similar vein, we can wonder how close ˆβ0
and ˆβ1 are to the true values β0 and β1. To compute the standard errors
associated with ˆβ0 and ˆβ1, we use the following formulas:

¯x2

σ2

=

n

+

n

2
SE( ˆβ0)

= σ2

2
SE( ˆβ1)

(cid:10)
i=1(xi − ¯x)2

(cid:10)
i=1(xi − ¯x)2 , (3.8)
where σ2 = Var(). For these formulas to be strictly valid, we need to as-
sume that the errors i for each observation are uncorrelated with common
variance σ2. This is clearly not true in Figure 3.1, but the formula still
turns out to be a good approximation. Notice in the formula that SE( ˆβ1) is
smaller when the xi are more spread out; intuitively we have more leverage
to estimate a slope when this is the case. We also see that SE( ˆβ0) would be
the same as SE(ˆμ) if ¯x were zero (in which case ˆβ0 would be equal to ¯y). In
general, σ2 is not known, but can be estimated from the data. The estimate
of σ is known as the residual standard error, and is given by the formula
RSS/(n − 2). Strictly speaking, when σ2 is estimated from the
RSE =
data we should write (cid:23)SE( ˆβ1) to indicate that an estimate has been made,

(cid:22)

but for simplicity of notation we will drop this extra “hat”.

Standard errors can be used to compute conﬁdence intervals. A 95 %
conﬁdence interval is deﬁned as a range of values such that with 95 %
probability, the range will contain the true unknown value of the parameter.
The range is deﬁned in terms of lower and upper limits computed from the
sample of data. For linear regression, the 95 % conﬁdence interval for β1
approximately takes the form

That is, there is approximately a 95 % chance that the interval

(cid:24)

(cid:25)
ˆβ1 − 2 · SE( ˆβ1), ˆβ1 + 2 · SE( ˆβ1)

will contain the true value of β1.3 Similarly, a conﬁdence interval for β0
approximately takes the form

ˆβ1 ± 2 · SE( ˆβ1).

ˆβ0 ± 2 · SE( ˆβ0).

residual
standard
error

conﬁdence
interval

(3.9)

(3.10)

(3.11)

2This formula holds provided that the n observations are uncorrelated.
3Approximately for several reasons. Equation 3.10 relies on the assumption that the
errors are Gaussian. Also, the factor of 2 in front of the SE( ˆβ1) term will vary slightly
depending on the number of observations n in the linear regression. To be precise, rather
than the number 2, (3.10) should contain the 97.5 % quantile of a t-distribution with
n−2 degrees of freedom. Details of how to compute the 95 % conﬁdence interval precisely
in R will be provided later in this chapter.

3.1 Simple Linear Regression

67

In the case of the advertising data, the 95 % conﬁdence interval for β0
is [6.130, 7.935] and the 95 % conﬁdence interval for β1 is [0.042, 0.053].
Therefore, we can conclude that in the absence of any advertising, sales will,
on average, fall somewhere between 6,130 and 7,940 units. Furthermore,
for each $1,000 increase in television advertising, there will be an average
increase in sales of between 42 and 53 units.

Standard errors can also be used to perform hypothesis tests on the
coeﬃcients. The most common hypothesis test involves testing the null
hypothesis of

H0 : There is no relationship between X and Y

(3.12)

versus the alternative hypothesis

Ha : There is some relationship between X and Y .

(3.13)

hypothesis
test

null
hypothesis

alternative
hypothesis

Mathematically, this corresponds to testing

versus

H0 : β1 = 0

Ha : β1 (cid:4)= 0,

since if β1 = 0 then the model (3.5) reduces to Y = β0 + , and X is
not associated with Y . To test the null hypothesis, we need to determine
whether ˆβ1, our estimate for β1, is suﬃciently far from zero that we can
be conﬁdent that β1 is non-zero. How far is far enough? This of course
depends on the accuracy of ˆβ1—that is, it depends on SE( ˆβ1). If SE( ˆβ1) is
small, then even relatively small values of ˆβ1 may provide strong evidence
that β1 (cid:4)= 0, and hence that there is a relationship between X and Y . In
contrast, if SE( ˆβ1) is large, then ˆβ1 must be large in absolute value in order
for us to reject the null hypothesis. In practice, we compute a t-statistic,
given by

t-statistic

ˆβ1 − 0
SE( ˆβ1)

t =

,

(3.14)

which measures the number of standard deviations that ˆβ1 is away from
0. If there really is no relationship between X and Y , then we expect
that (3.14) will have a t-distribution with n − 2 degrees of freedom. The t-
distribution has a bell shape and for values of n greater than approximately
30 it is quite similar to the normal distribution. Consequently, it is a simple
matter to compute the probability of observing any number equal to |t| or
larger in absolute value, assuming β1 = 0. We call this probability the p-value.
Roughly speaking, we interpret the p-value as follows: a small p-value indicates
that it is unlikely to observe such a substant
ial association between the pre-
dictor and the response due to chance, in the absence of any real association
between the predictor and the response. Hence, if we see a small p-value,

p-value

68

3. Linear Regression

then we can infer that there is an association between the predictor and the
response. We reject the null hypothesis—that is, we declare a relationship
to exist between X and Y —if the p-value is small enough. Typical p-value
cutoﬀs for rejecting the null hypothesis are 5 or 1 %. When n = 30, these
correspond to t-statistics (3.14) of around 2 and 2.75, respectively.

Intercept
TV

Coeﬃcient
7.0325
0.0475

Std. error
0.4578
0.0027

t-statistic

p-value
15.36 < 0.0001
17.67 < 0.0001

TABLE 3.1. For the Advertising data, coeﬃcients of the least squares model
for the regression of number of units sold on TV advertising budget. An increase
of $1,000 in the TV advertising budget is associated with an increase in sales by
around 50 units (Recall that the sales variable is in thousands of units, and the
TV variable is in thousands of dollars).

Table 3.1 provides details of the least squares model for the regression of
number of units sold on TV advertising budget for the Advertising data.
Notice that the coeﬃcients for ˆβ0 and ˆβ1 are very large relative to their
standard errors, so the t-statistics are also large; the probabilities of seeing
such values if H0 is true are virtually zero. Hence we can conclude that
β0 (cid:4)= 0 and β1 (cid:4)= 0.4

3.1.3 Assessing the Accuracy of the Model

Once we have rejected the null hypothesis (3.12) in favor of the alternative
hypothesis (3.13), it is natural to want to quantify the extent to which the
model ﬁts the data. The quality of a linear regression ﬁt is typically assessed
using two related quantities: the residual standard error (RSE) and the R2
statistic.

Table 3.2 displays the RSE, the R2 statistic, and the F-statistic (to be
described in Section 3.2.2) for the linear regression of number of units sold
on TV advertising budget.

R2

Residual Standard Error

Recall from the model (3.5) that associated with each observation is an
error term . Due to the presence of these error terms, even if we knew the
true regression line (i.e. even if β0 and β1 were known), we would not be
able to perfectly predict Y from X. The RSE is an estimate of the standard

4In Table 3.1, a small p-value for the intercept indicates that we can reject the null
hypothesis that β0 = 0, and a small p-value for TV indicates that we can reject the null
hypothesis that β1 = 0. Rejecting the latter null hypothesis allows us to conclude that
there is a relationship between TV and sales. Rejecting the former allows us to conclude
that in the absence of TV expenditure, sales are non-zero.

3.1 Simple Linear Regression

69

Quantity
Residual standard error
R2
F-statistic

Value
3.26
0.612
312.1

TABLE 3.2. For the Advertising data, more information about the least squares
model for the regression of number of units sold on TV advertising budget.

deviation of . Roughly speaking, it is the average amount that the response
will deviate from the true regression line. It is computed using the formula

(cid:26)

RSE =

1
n − 2

RSS =

(cid:27)(cid:28)(cid:28)(cid:29) 1
n − 2

n(cid:17)

i=1

(yi − ˆyi)2.

(3.15)

Note that RSS was deﬁned in Section 3.1.1, and is given by the formula

n(cid:17)

RSS =

i=1

(yi − ˆyi)2.

(3.16)

In the case of the advertising data, we see from the linear regression
output in Table 3.2 that the RSE is 3.26. In other words, actual sales in
each market deviate from the true regression line by approximately 3,260
units, on average. Another way to think about this is that even if the
model were correct and the true values of the unknown coeﬃcients β0
and β1 were known exactly, any prediction of sales on the basis of TV
advertising would still be oﬀ by about 3,260 units on average. Of course,
whether or not 3,260 units is an acceptable prediction error depends on the
problem context. In the advertising data set, the mean value of sales over
all markets is approximately 14,000 units, and so the percentage error is
3,260/14,000 = 23 %.

The RSE is considered a measure of the lack of ﬁt of the model (3.5) to
the data. If the predictions obtained using the model are very close to the

true outcome values—that is, if ˆyi ≈ yi for i = 1, . . . , n—then (3.15) will

be small, and we can conclude that the model ﬁts the data very well. On
the other hand, if ˆyi is very far from yi for one or more observations, then
the RSE may be quite large, indicating that the model doesn’t ﬁt the data
well.

R2 Statistic

The RSE provides an absolute measure of lack of ﬁt of the model (3.5)
to the data. But since it is measured in the units of Y , it is not always
clear what constitutes a good RSE. The R2 statistic provides an alternative
measure of ﬁt. It takes the form of a proportion—the proportion of variance
explained—and so it always takes on a value between 0 and 1, and is
independent of the scale of Y .

70

3. Linear Regression

To calculate R2, we use the formula
TSS − RSS

R2 =

TSS

= 1 − RSS
TSS

(3.17)

(cid:10)

(yi − ¯y)2 is the total sum of squares, and RSS is deﬁned

where TSS =
in (3.16). TSS measures the total variance in the response Y , and can be
thought of as the amount of variability inherent in the response before the
regression is performed. In contrast, RSS measures the amount of variability
that is left unexplained after performing the regression. Hence, TSS− RSS
measures the amount of variability in the response that is explained (or
removed) by performing the regression, and R2 measures the proportion
of variability in Y that can be explained using X. An R2 statistic that is
close to 1 indicates that a large proportion of the variability in the response
has been explained by the regression. A number near 0 indicates that the
regression did not explain much of the variability in the response; this might
occur because the linear model is wrong, or the inherent error σ2 is high,
or both. In Table 3.2, the R2 was 0.61, and so just under two-thirds of the
variability in sales is explained by a linear regression on TV.

total sum of
squares

The R2 statistic (3.17) has an interpretational advantage over the RSE
(3.15), since unlike the RSE, it always lies between 0 and 1. However, it can
still be challenging to determine what is a good R2 value, and in general,
this will depend on the application. For instance, in certain problems in
physics, we may know that the data truly comes from a linear model with
a small residual error. In this case, we would expect to see an R2 value that
is extremely close to 1, and a substantially smaller R2 value might indicate a
serious problem with the experiment in which the data were generated. On
the other hand, in typical applications in biology, psychology, marketing,
and other domains, the linear model (3.5) is at best an extremely rough
approximation to the data, and residual errors due to other unmeasured
factors are often very large. In this setting, we would expect only a very
small proportion of the variance in the response to be explained by the
predictor, and an R2 value well below 0.1 might be more realistic!

The R2 statistic is a measure of the linear relationship between X and

Y . Recall that correlation, deﬁned as
(cid:10)
i=1(xi − x)2

Cor(X, Y ) =

(cid:22)(cid:10)

n

n

i=1(xi − x)(yi − y)

(cid:22)(cid:10)

n

i=1(yi − y)2

correlation

,

(3.18)

is also a measure of the linear relationship between X and Y .5 This sug-
gests that we might be able to use r = Cor(X, Y ) instead of R2 in order to
assess the ﬁt of the linear model. In fact, it can be shown that in the simple
linear regression setting, R2 = r2. In other words, the squared correlation

5We note that in fact, the right-hand side of (3.18) is the sample correlation; thus,
it would be more correct to write (cid:2)Cor(X, Y ); however, we omit the “hat” for ease of
notation.

3.2 Multiple Linear Regression

71

and the R2 statistic are identical. However, in the next section we will
discuss the multiple linear regression problem, in which we use several pre-
dictors simultaneously to predict the response. The concept of correlation
between the predictors and the response does not extend automatically to
this setting, since correlation quantiﬁes the association between a single
pair of variables rather than between a larger number of variables. We will
see that R2 ﬁlls this role.

3.2 Multiple Linear Regression

Simple linear regression is a useful approach for predicting a response on the
basis of a single predictor variable. However, in practice we often have more
than one predictor. For example, in the Advertising data, we have examined
the relationship between sales and TV advertising. We also have data for
the amount of money spent advertising on the radio and in newspapers,
and we may want to know whether either of these two media is associated
with sales. How can we extend our analysis of the advertising data in order
to accommodate these two additional predictors?

One option is to run three separate simple linear regressions, each of
which uses a diﬀerent advertising medium as a predictor. For instance,
we can ﬁt a simple linear regression to predict sales on the basis of the
amount spent on radio advertisements. Results are shown in Table 3.3 (top
table). We ﬁnd that a $1,000 increase in spending on radio advertising is
associated with an increase in sales by around 203 units. Table 3.3 (bottom
table) contains the least squares coeﬃcients for a simple linear regression of
sales onto newspaper advertising budget. A $1,000 increase in newspaper
advertising budget is associated with an increase in sales by approximately
55 units.

However, the approach of ﬁtting a separate simple linear regression model
for each predictor is not entirely satisfactory. First of all, it is unclear how to
make a single prediction of sales given levels of the three advertising media
budgets, since each of the budgets is associated with a separate regression
equation. Second, each of the three regression equations ignores the other
two media in forming estimates for the regression coeﬃcients. We will see
shortly that if the media budgets are correlated with each other in the 200
markets that constitute our data set, then this can lead to very misleading
estimates of the individual media eﬀects on sales.

Instead of ﬁtting a separate simple linear regression model for each pre-
dictor, a better approach is to extend the simple linear regression model
(3.5) so that it can directly accommodate multiple predictors. We can do
this by giving each predictor a separate slope coeﬃcient in a single model.
In general, suppose that we have p distinct predictors. Then the multiple
linear regression model takes the form

Y = β0 + β1X1 + β2X2 + ··· + βpXp + ,

(3.19)

72

3. Linear Regression

Simple regression of sales on radio

Intercept
radio

Coeﬃcient
9.312
0.203

Std. error
0.563
0.020

t-statistic

p-value
16.54 < 0.0001
9.92 < 0.0001

Simple regression of sales on newspaper

Intercept
newspaper

Coeﬃcient
12.351
0.055

Std. error
0.621
0.017

t-statistic

p-value
19.88 < 0.0001
3.30

0.00115

TABLE 3.3. More simple linear regression models for the Advertising data. Co-
eﬃcients of the simple linear regression model for number of units sold on Top:
radio advertising budget and Bottom: newspaper advertising budget. A $1,000 in-
crease in spending on radio advertising is associated with an average increase in
sales by around 203 units, while the same increase in spending on newspaper ad-
vertising is associated with an average increase in sales by around 55 units (Note
that the sales variable is in thousands of units, and the radio and newspaper
variables are in thousands of dollars).

where Xj represents the jth predictor and βj quantiﬁes the association
between that variable and the response. We interpret βj as the average
eﬀect on Y of a one unit increase in Xj, holding all other predictors ﬁxed.
In the advertising example, (3.19) becomes

sales = β0 + β1 × TV + β2 × radio + β3 × newspaper + .

(3.20)

3.2.1 Estimating the Regression Coeﬃcients

As was the case in the simple linear regression setting, the regression coef-
ﬁcients β0, β1, . . . , βp in (3.19) are unknown, and must be estimated. Given
estimates ˆβ0, ˆβ1, . . . , ˆβp, we can make predictions using the formula

ˆy = ˆβ0 + ˆβ1x1 + ˆβ2x2 + ··· + ˆβpxp.

(3.21)

The parameters are estimated using the same least squares approach that
we saw in the context of simple linear regression. We choose β0, β1, . . . , βp
to minimize the sum of squared residuals

n(cid:17)

RSS =

i=1

n(cid:17)

i=1

=

(yi − ˆyi)2

(yi − ˆβ0 − ˆβ1xi1 − ˆβ2xi2 − ··· − ˆβpxip)2.

(3.22)

3.2 Multiple Linear Regression

73

Y

X2

X1

FIGURE 3.4. In a three-dimensional setting, with two predictors and one re-
sponse, the least squares regression line becomes a plane. The plane is chosen
to minimize the sum of the squared vertical distances between each observation
(shown in red) and the plane.

The values ˆβ0, ˆβ1, . . . , ˆβp that minimize (3.22) are the multiple least squares
regression coeﬃcient estimates. Unlike the simple linear
regression
estimates given in (3.4), the multiple regression coeﬃcient estimates have
somewhat complicated forms that are most easily represented using ma-
trix algebra. For this reason, we do not provide them here. Any statistical
software package can be used to compute these coeﬃcient estimates, and
later in this chapter we will show how this can be done in R. Figure 3.4
illustrates an example of the least squares ﬁt to a toy data set with p = 2
predictors.

Table 3.4 displays the multiple regression coeﬃcient estimates when TV,
radio, and newspaper advertising budgets are used to predict product sales
using the Advertising data. We interpret these results as follows: for a given
amount of TV and newspaper advertising, spending an additional $1,000
on radio advertising leads to an increase in sales by approximately 189
units. Comparing these coeﬃcient estimates to those displayed in Tables 3.1
and 3.3, we notice that the multiple regression coeﬃcient estimates for
TV and radio are pretty similar to the simple linear regression coeﬃcient
estimates. However, while the newspaper regression coeﬃcient estimate in
Table 3.3 was signiﬁcantly non-zero, the coeﬃcient estimate for newspaper
in the multiple regression model is close to zero, and the corresponding
p-value is no longer signiﬁcant, with a value around 0.86. This illustrates

74

3. Linear Regression

Intercept
TV
radio
newspaper

Coeﬃcient
2.939
0.046
0.189
−0.001

Std. error
0.3119
0.0014
0.0086
0.0059

t-statistic

p-value
9.42 < 0.0001
32.81 < 0.0001
21.89 < 0.0001
−0.18
0.8599

TABLE 3.4. For the Advertising data, least squares coeﬃcient estimates of the
multiple linear regression of number of units sold on radio, TV, and newspaper
advertising budgets.

that the simple and multiple regression coeﬃcients can be quite diﬀerent.
This diﬀerence stems from the fact that in the simple regression case, the
slope term represents the average eﬀect of a $1,000 increase in newspaper
advertising, ignoring other predictors such as TV and radio. In contrast, in
the multiple regression setting, the coeﬃcient for newspaper represents the
average eﬀect of increasing newspaper spending by $1,000 while holding TV
and radio ﬁxed.

Does it make sense for the multiple regression to suggest no relationship
between sales and newspaper while the simple linear regression implies the
opposite? In fact it does. Consider the correlation matrix for the three
predictor variables and response variable, displayed in Table 3.5. Notice
that the correlation between radio and newspaper is 0.35. This reveals a
tendency to spend more on newspaper advertising in markets where more
is spent on radio advertising. Now suppose that the multiple regression is
correct and newspaper advertising has no direct impact on sales, but radio
advertising does increase sales. Then in markets where we spend more
on radio our sales will tend to be higher, and as our correlation matrix
shows, we also tend to spend more on newspaper advertising in those same
markets. Hence, in a simple linear regression which only examines sales
versus newspaper, we will observe that higher values of newspaper tend to be
associated with higher values of sales, even though newspaper advertising
does not actually aﬀect sales. So newspaper sales are a surrogate for radio
advertising; newspaper gets “credit” for the eﬀect of radio on sales.

This slightly counterintuitive result is very common in many real life
situations. Consider an absurd example to illustrate the point. Running
a regression of shark attacks versus ice cream sales for data collected at
a given beach community over a period of time would show a positive
relationship, similar to that seen between sales and newspaper. Of course
no one (yet) has suggested that ice creams should be banned at beaches
to reduce shark attacks. In reality, higher temperatures cause more people
to visit the beach, which in turn results in more ice cream sales and more
shark attacks. A multiple regression of attacks versus ice cream sales and
temperature reveals that, as intuition implies, the former predictor is no
longer signiﬁcant after adjusting for temperature.

3.2 Multiple Linear Regression

75

TV
radio
newspaper
sales

TV

1.0000

radio
0.0548
1.0000

newspaper

0.0567
0.3541
1.0000

sales
0.7822
0.5762
0.2283
1.0000

TABLE 3.5. Correlation matrix for TV, radio, newspaper, and sales for the
Advertising data.

3.2.2 Some Important Questions

When we perform multiple linear regression, we usually are interested in
answering a few important questions.

1. Is at least one of the predictors X1, X2, . . . , Xp useful in predicting

the response?

2. Do all the predictors help to explain Y , or is only a subset of the

predictors useful?

3. How well does the model ﬁt the data?

4. Given a set of predictor values, what response value should we predict,

and how accurate is our prediction?

We now address each of these questions in turn.

One: Is There a Relationship Between the Response and Predictors?

Recall that in the simple linear regression setting, in order to determine
whether there is a relationship between the response and the predictor we
can simply check whether β1 = 0. In the multiple regression setting with p
predictors, we need to ask whether all of the regression coeﬃcients are zero,
i.e. whether β1 = β2 = ··· = βp = 0. As in the simple linear regression

setting, we use a hypothesis test to answer this question. We test the null
hypothesis,

H0 : β1 = β2 = ··· = βp = 0

versus the alternative

Ha : at least one βj is non-zero.

This hypothesis test is performed by computing the F-statistic,

(TSS − RSS)/p
RSS/(n − p − 1)

,

F =

F-statistic

(3.23)

76

3. Linear Regression

Quantity
Residual standard error
R2
F-statistic

Value
1.69
0.897
570

TABLE 3.6. More information about the least squares model for the regression
of number of units sold on TV, newspaper, and radio advertising budgets in the
Advertising data. Other information about this model was displayed in Table 3.4.
(cid:10)
where, as with simple linear regression, TSS =

(yi − ¯y)2 and RSS =
(yi− ˆyi)2. If the linear model assumptions are correct, one can show that

(cid:10)

E{RSS/(n − p − 1)} = σ2

and that, provided H0 is true,

E{(TSS − RSS)/p} = σ2.

Hence, when there is no relationship between the response and predictors,
one would expect the F-statistic to take on a value close to 1. On the other

hand, if Ha is true, then E{(TSS − RSS)/p} > σ2, so we expect F to be

greater than 1.

The F-statistic for the multiple linear regression model obtained by re-
gressing sales onto radio, TV, and newspaper is shown in Table 3.6. In this
example the F-statistic is 570. Since this is far larger than 1, it provides
compelling evidence against the null hypothesis H0. In other words, the
large F-statistic suggests that at least one of the advertising media must
be related to sales. However, what if the F-statistic had been closer to
1? How large does the F-statistic need to be before we can reject H0 and
conclude that there is a relationship? It turns out that the answer depends
on the values of n and p. When n is large, an F-statistic that is just a
little larger than 1 might still provide evidence against H0. In contrast,
a larger F-statistic is needed to reject H0 if n is small. When H0 is true
and the errors i have a normal distribution, the F-statistic follows an
F-distribution.6 For any given value of n and p, any statistical software
package can be used to compute the p-value associated with the F-statistic
using this distribution. Based on this p-value, we can determine whether
or not to reject H0. For the advertising data, the p-value associated with
the F-statistic in Table 3.6 is essentially zero, so we have extremely strong
evidence that at least one of the media is associated with increased sales.
In (3.23) we are testing H0 that all the coeﬃcients are zero. Sometimes
we want to test that a particular subset of q of the coeﬃcients are zero.
This corresponds to a null hypothesis

H0 :

βp−q+1 = βp−q+2 = . . . = βp = 0,

6Even if the errors are not normally-distributed, the F-statistic approximately follows

an F-distribution provided that the sample size n is large.

3.2 Multiple Linear Regression

77

where for convenience we have put the variables chosen for omission at the
end of the list. In this case we ﬁt a second model that uses all the variables
except those last q. Suppose that the residual sum of squares for that model
is RSS0. Then the appropriate F-statistic is

(RSS0 − RSS)/q
RSS/(n − p − 1)

.

F =

(3.24)

Notice that in Table 3.4, for each individual predictor a t-statistic and
a p-value were reported. These provide information about whether each
individual predictor is related to the response, after adjusting for the other
predictors. It turns out that each of these are exactly equivalent7 to the
F-test that omits that single variable from the model, leaving all the others
in—i.e. q=1 in (3.24). So it reports the partial eﬀect of adding that variable
to the model. For instance, as we discussed earlier, these p-values indicate
that TV and radio are related to sales, but that there is no evidence that
newspaper is associated with sales, in the presence of these two.

Given these individual p-values for each variable, why do we need to look
at the overall F-statistic? After all, it seems likely that if any one of the
p-values for the individual variables is very small, then at least one of the
predictors is related to the response. However, this logic is ﬂawed, especially
when the number of predictors p is large.

For instance, consider an example in which p = 100 and H0 : β1 = β2 =
. . . = βp = 0 is true, so no variable is truly associated with the response. In
this situation, about 5 % of the p-values associated with each variable (of
the type shown in Table 3.4) will be below 0.05 by chance. In other words,
we expect to see approximately ﬁve small p-values even in the absence of
any true association between the predictors and the response. In fact, we
are almost guaranteed that we will observe at least one p-value below 0.05
by chance! Hence, if we use the individual t-statistics and associated p-
values in order to decide whether or not there is any association between
the variables and the response, there is a very high chance that we will
incorrectly conclude that there is a relationship. However, the F-statistic
does not suﬀer from this problem because it adjusts for the number of
predictors. Hence, if H0 is true, there is only a 5 % chance that the F-
statistic will result in a p-value below 0.05, regardless of the number of
predictors or the number of observations.

The approach of using an F-statistic to test for any association between
the predictors and the response works when p is relatively small, and cer-
tainly small compared to n. However, sometimes we have a very large num-
ber of variables. If p > n then there are more coeﬃcients βj to estimate
than observations from which to estimate them. In this case we cannot
even ﬁt the multiple linear regression model using least squares, so the

7The square of each t-statistic is the corresponding F-statistic.

78

3. Linear Regression

F-statistic cannot be used, and neither can most of the other concepts that
we have seen so far in this chapter. When p is large, some of the approaches
discussed in the next section, such as forward selection, can be used. This
high-dimensional setting is discussed in greater detail in Chapter 6.

high-
dimensional

Two: Deciding on Important Variables

As discussed in the previous section, the ﬁrst step in a multiple regression
analysis is to compute the F-statistic and to examine the associated p-
value. If we conclude on the basis of that p-value that at least one of the
predictors is related to the response, then it is natural to wonder which are
the guilty ones! We could look at the individual p-values as in Table 3.4,
but as discussed, if p is large we are likely to make some false discoveries.
It is possible that all of the predictors are associated with the response,
but it is more often the case that the response is only related to a subset of
the predictors. The task of determining which predictors are associated with
the response, in order to ﬁt a single model involving only those predictors,
is referred to as variable selection. The variable selection problem is studied
extensively in Chapter 6, and so here we will provide only a brief outline
of some classical approaches.

Ideally, we would like to perform variable selection by trying out a lot of
diﬀerent models, each containing a diﬀerent subset of the predictors. For
instance, if p = 2, then we can consider four models: (1) a model contain-
ing no variables, (2) a model containing X1 only, (3) a model containing
X2 only, and (4) a model containing both X1 and X2. We can then se-
lect the best model out of all of the models that we have considered. How
do we determine which model is best? Various statistics can be used to
judge the quality of a model. These include Mallow’s Cp, Akaike informa-
tion criterion (AIC), Bayesian information criterion (BIC), and adjusted
R2. These are discussed in more detail in Chapter 6. We can also deter-
mine which model is best by plotting various model outputs, such as the
residuals, in order to search for patterns.

Unfortunately, there are a total of 2p models that contain subsets of p
variables. This means that even for moderate p, trying out every possible
subset of the predictors is infeasible. For instance, we saw that if p = 2, then
there are 22 = 4 models to consider. But if p = 30, then we must consider
230 = 1,073,741,824 models! This is not practical. Therefore, unless p is very
small, we cannot consider all 2p models, and instead we need an automated
and eﬃcient approach to choose a smaller set of models to consider. There
are three classical approaches for this task:

variable
selection

Mallow’s Cp

Akaike
information
criterion
Bayesian
information
criterion
adjusted R2

• Forward selection. We begin with the null model—a model that con-
tains an intercept but no predictors. We then ﬁt p simple linear re-
gressions and add to the null model the variable that results in the
lowest RSS. We then add to that model the variable that results

forward
selection
null model

3.2 Multiple Linear Regression

79

in the lowest RSS for the new two-variable model. This approach is
continued until some stopping rule is satisﬁed.

• Backward selection. We start with all variables in the model, and
remove the variable with the largest p-value—that is, the variable
that is the least statistically signiﬁcant. The new (p − 1)-variable
model is ﬁt, and the variable with the largest p-value is removed. This
procedure continues until a stopping rule is reached. For instance, we
may stop when all remaining variables have a p-value below some
threshold.

• Mixed selection. This is a combination of forward and backward se-
lection. We start with no variables in the model, and as with forward
selection, we add the variable that provides the best ﬁt. We con-
tinue to add variables one-by-one. Of course, as we noted with the
Advertising example, the p-values for variables can become larger as
new predictors are added to the model. Hence, if at any point the
p-value for one of the variables in the model rises above a certain
threshold, then we remove that variable from the model. We con-
tinue to perform these forward and backward steps until all variables
in the model have a suﬃciently low p-value, and all variables outside
the model would have a large p-value if added to the model.

backward
selection

mixed
selection

Backward selection cannot be used if p > n, while forward selection can
always be used. Forward selection is a greedy approach, and might include
variables early that later become redundant. Mixed selection can remedy
this.

Three: Model Fit

Two of the most common numerical measures of model ﬁt are the RSE and
R2, the fraction of variance explained. These quantities are computed and
interpreted in the same fashion as for simple linear regression.

Recall that in simple regression, R2 is the square of the correlation of the
response and the variable. In multiple linear regression, it turns out that it
equals Cor(Y, ˆY )2, the square of the correlation between the response and
the ﬁtted linear model; in fact one property of the ﬁtted linear model is
that it maximizes this correlation among all possible linear models.

An R2 value close to 1 indicates that the model explains a large portion
of the variance in the response variable. As an example, we saw in Table 3.6
that for the Advertising data, the model that uses all three advertising me-
dia to predict sales has an R2 of 0.8972. On the other hand, the model that
uses only TV and radio to predict sales has an R2 value of 0.89719. In other
words, there is a small increase in R2 if we include newspaper advertising
in the model that already contains TV and radio advertising, even though
we saw earlier that the p-value for newspaper advertising in Table 3.4 is not
signiﬁcant. It turns out that R2 will always increase when more variables

80

3. Linear Regression

are added to the model, even if those variables are only weakly associated
with the response. This is due to the fact that adding another variable to
the least squares equations must allow us to ﬁt the training data (though
not necessarily the testing data) more accurately. Thus, the R2 statistic,
which is also computed on the training data, must increase. The fact that
adding newspaper advertising to the model containing only TV and radio
advertising leads to just a tiny increase in R2 provides additional evidence
that newspaper can be dropped from the model. Essentially, newspaper pro-
vides no real improvement in the model ﬁt to the training samples, and its
inclusion will likely lead to poor results on independent test samples due
to overﬁtting.

In contrast, the model containing only TV as a predictor had an R2 of 0.61
(Table 3.2). Adding radio to the model leads to a substantial improvement
in R2. This implies that a model that uses TV and radio expenditures to
predict sales is substantially better than one that uses only TV advertis-
ing. We could further quantify this improvement by looking at the p-value
for the radio coeﬃcient in a model that contains only TV and radio as
predictors.

The model that contains only TV and radio as predictors has an RSE
of 1.681, and the model that also contains newspaper as a predictor has
an RSE of 1.686 (Table 3.6). In contrast, the model that contains only TV
has an RSE of 3.26 (Table 3.2). This corroborates our previous conclusion
that a model that uses TV and radio expenditures to predict sales is much
more accurate (on the training data) than one that only uses TV spending.
Furthermore, given that TV and radio expenditures are used as predictors,
there is no point in also using newspaper spending as a predictor in the
model. The observant reader may wonder how RSE can increase when
newspaper is added to the model given that RSS must decrease. In general
RSE is deﬁned as

(cid:26)

RSE =

1

n − p − 1

RSS,

(3.25)

which simpliﬁes to (3.15) for a simple linear regression. Thus, models with
more variables can have higher RSE if the decrease in RSS is small relative
to the increase in p.

In addition to looking at the RSE and R2 statistics just discussed, it
can be useful to plot the data. Graphical summaries can reveal problems
with a model that are not visible from numerical statistics. For example,
Figure 3.5 displays a three-dimensional plot of TV and radio versus sales.
We see that some observations lie above and some observations lie below
the least squares regression plane. In particular, the linear model seems to
overestimate sales for instances in which most of the advertising money
was spent exclusively on either TV or radio. It underestimates sales for
instances where the budget was split between the two media. This pro-
nounced non-linear pattern cannot be modeled accurately using linear re-

Sales

3.2 Multiple Linear Regression

81

TV

Radio

FIGURE 3.5. For the Advertising data, a linear regression ﬁt to sales using
TV and radio as predictors. From the pattern of the residuals, we can see that
there is a pronounced non-linear relationship in the data. The positive residuals
(those visible above the surface), tend to lie along the 45-degree line, where TV
and Radio budgets are split evenly. The negative residuals (most not visible), tend
to lie away from this line, where budgets are more lopsided.

gression. It suggests a synergy or interaction eﬀect between the advertising
media, whereby combining the media together results in a bigger boost to
sales than using any single medium. In Section 3.3.2, we will discuss ex-
tending the linear model to accommodate such synergistic eﬀects through
the use of interaction terms.

Four: Predictions

Once we have ﬁt the multiple regression model, it is straightforward to
apply (3.21) in order to predict the response Y on the basis of a set of
values for the predictors X1, X2, . . . , Xp. However, there are three sorts of
uncertainty associated with this prediction.

1. The coeﬃcient estimates ˆβ0, ˆβ1, . . . , ˆβp are estimates for β0, β1, . . . , βp.

That is, the least squares plane

ˆY = ˆβ0 + ˆβ1X1 + ··· + ˆβpXp

is only an estimate for the true population regression plane

f (X) = β0 + β1X1 + ··· + βpXp.

The inaccuracy in the coeﬃcient estimates is related to the reducible
error from Chapter 2. We can compute a conﬁdence interval in order
to determine how close ˆY will be to f (X).

82

3. Linear Regression

2. Of course, in practice assuming a linear model for f (X) is almost
always an approximation of reality, so there is an additional source of
potentially reducible error which we call model bias. So when we use a
linear model, we are in fact estimating the best linear approximation
to the true surface. However, here we will ignore this discrepancy,
and operate as if the linear model were correct.

3. Even if we knew f (X)—that is, even if we knew the true values
for β0, β1, . . . , βp—the response value cannot be predicted perfectly
because of the random error  in the model (3.21). In Chapter 2, we
referred to this as the irreducible error. How much will Y vary from
ˆY ? We use prediction intervals to answer this question. Prediction
intervals are always wider than conﬁdence intervals, because they
incorporate both the error in the estimate for f (X) (the reducible
error) and the uncertainty as to how much an individual point will
diﬀer from the population regression plane (the irreducible error).

We use a conﬁdence interval to quantify the uncertainty surrounding
the average sales over a large number of cities. For example, given that
$100,000 is spent on TV advertising and $20,000 is spent on radio advertising
in each city, the 95 % conﬁdence interval is [10,985, 11,528]. We interpret
this to mean that 95 % of intervals of this form will contain the true value of
f (X).8 On the other hand, a prediction interval can be used to quantify the
uncertainty surrounding sales for a particular city. Given that $100,000 is
spent on TV advertising and $20,000 is spent on radio advertising in that city
the 95 % prediction interval is [7,930, 14,580]. We interpret this to mean
that 95 % of intervals of this form will contain the true value of Y for this
city. Note that both intervals are centered at 11,256, but that the prediction
interval is substantially wider than the conﬁdence interval, reﬂecting the
increased uncertainty about sales for a given city in comparison to the
average sales over many locations.

conﬁdence
interval

prediction
interval

3.3 Other Considerations in the Regression Model

3.3.1 Qualitative Predictors

In our discussion so far, we have assumed that all variables in our linear
regression model are quantitative. But in practice, this is not necessarily
the case; often some predictors are qualitative.

8In other words, if we collect a large number of data sets like the Advertising data
set, and we construct a conﬁdence interval for the average sales on the basis of each
data set (given $100,000 in TV and $20,000 in radio advertising), then 95 % of these
conﬁdence intervals will contain the true value of average sales.

3.3 Other Considerations in the Regression Model

83

For example, the Credit data set displayed in Figure 3.6 records balance
(average credit card debt for a number of individuals) as well as several
quantitative predictors: age, cards (number of credit cards), education
(years of education), income (in thousands of dollars), limit (credit limit),
and rating (credit rating). Each panel of Figure 3.6 is a scatterplot for a
pair of variables whose identities are given by the corresponding row and
column labels. For example, the scatterplot directly to the right of the word
“Balance” depicts balance versus age, while the plot directly to the right
of “Age” corresponds to age versus cards. In addition to these quantitative
variables, we also have four qualitative variables: gender, student (student
status), status (marital status), and ethnicity (Caucasian, African Amer-
ican or Asian).

20 40 60 80 100

5

10

15

20

2000

8000 14000

Balance

Age

Cards

0
0
1

0
8

0
6

0
4

0
2

0
2

5
1

0
1

5

0
0
0
4
1

0
0
0
8

0
0
0
2

0
0
5
1

0
0
5

0

8

6

4

2

0
5
1

0
0
1

0
5

0
0
0
1

0
0
6

0
0
2

Education

Income

Limit

Rating

0 500

1500

2

4

6

8

50 100 150

200

600

1000

FIGURE 3.6. The Credit data set contains information about balance, age,
cards, education, income, limit, and rating for a number of potential cus-
tomers.

84

3. Linear Regression

Intercept
gender[Female]

Coeﬃcient
509.80
19.73

Std. error
33.13
46.05

t-statistic

p-value
15.389 < 0.0001
0.6690

0.429

TABLE 3.7. Least squares coeﬃcient estimates associated with the regression of
balance onto gender in the Credit data set. The linear model is given in (3.27).
That is, gender is encoded as a dummy variable, as in (3.26).

Predictors with Only Two Levels

Suppose that we wish to investigate diﬀerences in credit card balance be-
tween males and females, ignoring the other variables for the moment. If a
qualitative predictor (also known as a factor) only has two levels, or possi-
ble values, then incorporating it into a regression model is very simple. We
simply create an indicator or dummy variable that takes on two possible
numerical values. For example, based on the gender variable, we can create
a new variable that takes the form

(cid:30)

factor
level

dummy
variable

xi =

1
0

if ith person is female
if ith person is male,

(3.26)

and use this variable as a predictor in the regression equation. This results
in the model

(cid:30)

yi = β0 + β1xi + i =

β0 + β1 + i
β0 + i

if ith person is female
if ith person is male.

(3.27)

Now β0 can be interpreted as the average credit card balance among males,
β0 + β1 as the average credit card balance among females, and β1 as the
average diﬀerence in credit card balance between females and males.

Table 3.7 displays the coeﬃcient estimates and other information asso-
ciated with the model (3.27). The average credit card debt for males is
estimated to be $509.80, whereas females are estimated to carry $19.73 in
additional debt for a total of $509.80 + $19.73 = $529.53. However, we
notice that the p-value for the dummy variable is very high. This indicates
that there is no statistical evidence of a diﬀerence in average credit card
balance between the genders.

The decision to code females as 1 and males as 0 in (3.27) is arbitrary, and
has no eﬀect on the regression ﬁt, but does alter the interpretation of the
coeﬃcients. If we had coded males as 1 and females as 0, then the estimates
for β0 and β1 would have been 529.53 and −19.73, respectively, leading once
again to a prediction of credit card debt of $529.53 − $19.73 = $509.80 for
males and a prediction of $529.53 for females. Alternatively, instead of a
0/1 coding scheme, we could create a dummy variable

3.3 Other Considerations in the Regression Model

(cid:30)

85

xi =

1
−1

if ith person is female
if ith person is male

and use this variable in the regression equation. This results in the model

yi = β0 + β1xi + i =

(cid:30)
β0 + β1 + i
β0 − β1 + i

if ith person is female
if ith person is male.

Now β0 can be interpreted as the overall average credit card balance (ig-
noring the gender eﬀect), and β1 is the amount that females are above the
average and males are below the average. In this example, the estimate for
β0 would be $519.665, halfway between the male and female averages of
$509.80 and $529.53. The estimate for β1 would be $9.865, which is half of
$19.73, the average diﬀerence between females and males. It is important to
note that the ﬁnal predictions for the credit balances of males and females
will be identical regardless of the coding scheme used. The only diﬀerence
is in the way that the coeﬃcients are interpreted.

Qualitative Predictors with More than Two Levels

When a qualitative predictor has more than two levels, a single dummy
variable cannot represent all possible values. In this situation, we can create
additional dummy variables. For example, for the ethnicity variable we
create two dummy variables. The ﬁrst could be

(cid:30)

xi1 =

1
0

if ith person is Asian
if ith person is not Asian,

and the second could be
(cid:30)

xi2 =

1
0

if ith person is Caucasian
if ith person is not Caucasian.

(3.28)

(3.29)

Then both of these variables can be used in the regression equation, in
order to obtain the model

yi = β0+β1xi1+β2xi2+i =

⎧
⎪⎨

⎪⎩

β0+β1+i
β0+β2+i
β0+i

if ith person is Asian
if ith person is Caucasian
if ith person is African American.

(3.30)
Now β0 can be interpreted as the average credit card balance for African
Americans, β1 can be interpreted as the diﬀerence in the average balance
between the Asian and African American categories, and β2 can be inter-
preted as the diﬀerence in the average balance between the Caucasian and

86

3. Linear Regression

Intercept
ethnicity[Asian]
ethnicity[Caucasian]

Coeﬃcient
531.00
−18.69
−12.50

Std. error
46.32
65.02
56.68

t-statistic
p-value
11.464 < 0.0001
−0.287
0.7740
−0.221
0.8260

TABLE 3.8. Least squares coeﬃcient estimates associated with the regression
of balance onto ethnicity in the Credit data set. The linear model is given in
(3.30). That is, ethnicity is encoded via two dummy variables (3.28) and (3.29).

African American categories. There will always be one fewer dummy vari-
able than the number of levels. The level with no dummy variable—African
American in this example—is known as the baseline.

From Table 3.8, we see that the estimated balance for the baseline,
African American, is $531.00. It is estimated that the Asian category will
have $18.69 less debt than the African American category, and that the
Caucasian category will have $12.50 less debt than the African American
category. However, the p-values associated with the coeﬃcient estimates for
the two dummy variables are very large, suggesting no statistical evidence
of a real diﬀerence in credit card balance between the ethnicities. Once
again, the level selected as the baseline category is arbitrary, and the ﬁnal
predictions for each group will be the same regardless of this choice. How-
ever, the coeﬃcients and their p-values do depend on the choice of dummy
variable coding. Rather than rely on the individual coeﬃcients, we can use
an F-test to test H0 : β1 = β2 = 0; this does not depend on the coding.
This F-test has a p-value of 0.96, indicating that we cannot reject the null
hypothesis that there is no relationship between balance and ethnicity.

Using this dummy variable approach presents no diﬃculties when in-
corporating both quantitative and qualitative predictors. For example, to
regress balance on both a quantitative variable such as income and a qual-
itative variable such as student, we must simply create a dummy variable
for student and then ﬁt a multiple regression model using income and the
dummy variable as predictors for credit card balance.

There are many diﬀerent ways of coding qualitative variables besides
the dummy variable approach taken here. All of these approaches lead to
equivalent model ﬁts, but the coeﬃcients are diﬀerent and have diﬀerent
interpretations, and are designed to measure particular contrasts. This topic
is beyond the scope of the book, and so we will not pursue it further.

3.3.2 Extensions of the Linear Model

The standard linear regression model (3.19) provides interpretable results
and works quite well on many real-world problems. However, it makes sev-
eral highly restrictive assumptions that are often violated in practice. Two
of the most important assumptions state that the relationship between the
predictors and response are additive and linear. The additive assumption

baseline

contrast

additive
linear

3.3 Other Considerations in the Regression Model

87

means that the eﬀect of changes in a predictor Xj on the response Y is
independent of the values of the other predictors. The linear assumption
states that the change in the response Y due to a one-unit change in Xj is
constant, regardless of the value of Xj. In this book, we examine a number
of sophisticated methods that relax these two assumptions. Here, we brieﬂy
examine some common classical approaches for extending the linear model.

Removing the Additive Assumption

In our previous analysis of the Advertising data, we concluded that both TV
and radio seem to be associated with sales. The linear models that formed
the basis for this conclusion assumed that the eﬀect on sales of increasing
one advertising medium is independent of the amount spent on the other
media. For example, the linear model (3.20) states that the average eﬀect
on sales of a one-unit increase in TV is always β1, regardless of the amount
spent on radio.

However, this simple model may be incorrect. Suppose that spending
money on radio advertising actually increases the eﬀectiveness of TV ad-
vertising, so that the slope term for TV should increase as radio increases.
In this situation, given a ﬁxed budget of $100,000, spending half on radio
and half on TV may increase sales more than allocating the entire amount
to either TV or to radio. In marketing, this is known as a synergy eﬀect,
and in statistics it is referred to as an interaction eﬀect. Figure 3.5 sug-
gests that such an eﬀect may be present in the advertising data. Notice
that when levels of either TV or radio are low, then the true sales are lower
than predicted by the linear model. But when advertising is split between
the two media, then the model tends to underestimate sales.

Consider the standard linear regression model with two variables,

Y = β0 + β1X1 + β2X2 + .

According to this model, if we increase X1 by one unit, then Y will increase
by an average of β1 units. Notice that the presence of X2 does not alter
this statement—that is, regardless of the value of X2, a one-unit increase
in X1 will lead to a β1-unit increase in Y . One way of extending this model
to allow for interaction eﬀects is to include a third predictor, called an
interaction term, which is constructed by computing the product of X1
and X2. This results in the model

Y = β0 + β1X1 + β2X2 + β3X1X2 + .

(3.31)

How does inclusion of this interaction term relax the additive assumption?
Notice that (3.31) can be rewritten as

Y = β0 + (β1 + β3X2)X1 + β2X2 + 

(3.32)

= β0 + ˜β1X1 + β2X2 + 

88

3. Linear Regression

Intercept
TV
radio

TV×radio

Coeﬃcient
6.7502
0.0191
0.0289
0.0011

Std. error
0.248
0.002
0.009
0.000

t-statistic

p-value
27.23 < 0.0001
12.70 < 0.0001
3.24
0.0014
20.73 < 0.0001

TABLE 3.9. For the Advertising data, least squares coeﬃcient estimates asso-
ciated with the regression of sales onto TV and radio, with an interaction term,
as in (3.33).

where ˜β1 = β1 + β3X2. Since ˜β1 changes with X2, the eﬀect of X1 on Y is
no longer constant: adjusting X2 will change the impact of X1 on Y .

For example, suppose that we are interested in studying the productiv-
ity of a factory. We wish to predict the number of units produced on the
basis of the number of production lines and the total number of workers.
It seems likely that the eﬀect of increasing the number of production lines
will depend on the number of workers, since if no workers are available
to operate the lines, then increasing the number of lines will not increase
production. This suggests that it would be appropriate to include an inter-
action term between lines and workers in a linear model to predict units.
Suppose that when we ﬁt the model, we obtain
units ≈ 1.2 + 3.4 × lines + 0.22 × workers + 1.4 × (lines × workers)

= 1.2 + (3.4 + 1.4 × workers) × lines + 0.22 × workers.

In other words, adding an additional line will increase the number of units
produced by 3.4 + 1.4 × workers. Hence the more workers we have, the
stronger will be the eﬀect of lines.

We now return to the Advertising example. A linear model that uses
radio, TV, and an interaction between the two to predict sales takes the
form

sales = β0 + β1 × TV + β2 × radio + β3 × (radio × TV) + 

= β0 + (β1 + β3 × radio) × TV + β2 × radio + .

(3.33)

We can interpret β3 as the increase in the eﬀectiveness of TV advertising
for a one unit increase in radio advertising (or vice-versa). The coeﬃcients
that result from ﬁtting the model (3.33) are given in Table 3.9.

The results in Table 3.9 strongly suggest that the model that includes the
interaction term is superior to the model that contains only main eﬀects.
The p-value for the interaction term, TV×radio, is extremely low, indicating
that there is strong evidence for Ha : β3 (cid:4)= 0. In other words, it is clear that
the true relationship is not additive. The R2 for the model (3.33) is 96.8 %,
compared to only 89.7 % for the model that predicts sales using TV and
radio without an interaction term. This means that (96.8 − 89.7)/(100 −
89.7) = 69 % of the variability in sales that remains after ﬁtting the ad-
ditive model has been explained by the interaction term. The coeﬃcient

main eﬀect

3.3 Other Considerations in the Regression Model

89

estimates in Table 3.9 suggest that an increase in TV advertising of $1,000 is

associated with increased sales of ( ˆβ1 + ˆβ3×radio)×1,000 = 19+1.1×radio
an increase in sales of ( ˆβ2 + ˆβ3 × TV) × 1,000 = 29 + 1.1 × TV units.

units. And an increase in radio advertising of $1,000 will be associated with

In this example, the p-values associated with TV, radio, and the interac-
tion term all are statistically signiﬁcant (Table 3.9), and so it is obvious
that all three variables should be included in the model. However, it is
sometimes the case that an interaction term has a very small p-value, but
the associated main eﬀects (in this case, TV and radio) do not. The hier-
archical principle states that if we include an interaction in a model, we
should also include the main eﬀects, even if the p-values associated with
their coeﬃcients are not signiﬁcant. In other words, if the interaction be-
tween X1 and X2 seems important, then we should include both X1 and
X2 in the model even if their coeﬃcient estimates have large p-values. The
rationale for this principle is that if X1 × X2 is related to the response,
then whether or not the coeﬃcients of X1 or X2 are exactly zero is of lit-
tle interest. Also X1 × X2 is typically correlated with X1 and X2, and so

leaving them out tends to alter the meaning of the interaction.

hierarchical
principle

In the previous example, we considered an interaction between TV and
radio, both of which are quantitative variables. However, the concept of
interactions applies just as well to qualitative variables, or to a combination
of quantitative and qualitative variables. In fact, an interaction between
a qualitative variable and a quantitative variable has a particularly nice
interpretation. Consider the Credit data set from Section 3.3.1, and suppose
that we wish to predict balance using the income (quantitative) and student
(qualitative) variables. In the absence of an interaction term, the model
takes the form

(cid:30)

balancei ≈ β0 + β1 × incomei +

β2
0

if ith person is a student
if ith person is not a student

(cid:30)

= β1 × incomei +

β0 + β2
β0

if ith person is a student
if ith person is not a student.

(3.34)

Notice that this amounts to ﬁtting two parallel lines to the data, one for
students and one for non-students. The lines for students and non-students
have diﬀerent intercepts, β0 + β2 versus β0, but the same slope, β1. This
is illustrated in the left-hand panel of Figure 3.7. The fact that the lines
are parallel means that the average eﬀect on balance of a one-unit increase
in income does not depend on whether or not the individual is a student.
This represents a potentially serious limitation of the model, since in fact a
change in income may have a very diﬀerent eﬀect on the credit card balance
of a student versus a non-student.

This limitation can be addressed by adding an interaction variable, cre-
ated by multiplying income with the dummy variable for student. Our

90

3. Linear Regression

e
c
n
a
a
B

l

0
0
4
1

0
0
0
1

0
0
6

0
0
2

student
non−student

e
c
n
a
a
B

l

0
0
4
1

0
0
0
1

0
0
6

0
0
2

0

50

100

150

0

50

100

150

Income

Income

FIGURE 3.7. For the Credit data, the least squares lines are shown for pre-
diction of balance from income for students and non-students. Left: The model
(3.34) was ﬁt. There is no interaction between income and student. Right: The
model (3.35) was ﬁt. There is an interaction term between income and student.

model now becomes

balancei ≈ β0 + β1 × incomei +

(cid:30)

β2 + β3 × incomei

0

if student
if not student

(cid:30)

=

(β0 + β2) + (β1 + β3) × incomei
β0 + β1 × incomei

if student
if not student

(3.35)

Once again, we have two diﬀerent regression lines for the students and
the non-students. But now those regression lines have diﬀerent intercepts,
β0+β2 versus β0, as well as diﬀerent slopes, β1+β3 versus β1. This allows for
the possibility that changes in income may aﬀect the credit card balances
of students and non-students diﬀerently. The right-hand panel of Figure 3.7
shows the estimated relationships between income and balance for students
and non-students in the model (3.35). We note that the slope for students
is lower than the slope for non-students. This suggests that increases in
income are associated with smaller increases in credit card balance among
students as compared to non-students.

Non-linear Relationships

As discussed previously, the linear regression model (3.19) assumes a linear
relationship between the response and predictors. But in some cases, the
true relationship between the response and the predictors may be non-
linear. Here we present a very simple way to directly extend the linear model
to accommodate non-linear relationships, using polynomial regression. In
later chapters, we will present more complex approaches for performing
non-linear ﬁts in more general settings.

Consider Figure 3.8, in which the mpg (gas mileage in miles per gallon)
versus horsepower is shown for a number of cars in the Auto data set. The

polynomial
regression

3.3 Other Considerations in the Regression Model

91

Linear
Degree 2
Degree 5

0
5

0
4

0
3

0
2

0
1

n
o

l
l

a
g

 
r
e
p
 
s
e

l
i

M

50

100

150

200

Horsepower

FIGURE 3.8. The Auto data set. For a number of cars, mpg and horsepower are
shown. The linear regression ﬁt is shown in orange. The linear regression ﬁt for a
2 is shown as a blue curve. The linear regression
model that includes horsepower
ﬁt for a model that includes all polynomials of horsepower up to ﬁfth-degree is
shown in green.

orange line represents the linear regression ﬁt. There is a pronounced rela-
tionship between mpg and horsepower, but it seems clear that this relation-
ship is in fact non-linear: the data suggest a curved relationship. A simple
approach for incorporating non-linear associations in a linear model is to
include transformed versions of the predictors in the model. For example,
the points in Figure 3.8 seem to have a quadratic shape, suggesting that a
model of the form

mpg = β0 + β1 × horsepower + β2 × horsepower

2 + 

(3.36)

quadratic

may provide a better ﬁt. Equation 3.36 involves predicting mpg using a
non-linear function of horsepower. But it is still a linear model! That is,
(3.36) is simply a multiple linear regression model with X1 = horsepower
2. So we can use standard linear regression software to
and X2 = horsepower
estimate β0, β1, and β2 in order to produce a non-linear ﬁt. The blue curve
in Figure 3.8 shows the resulting quadratic ﬁt to the data. The quadratic
ﬁt appears to be substantially better than the ﬁt obtained when just the
linear term is included. The R2 of the quadratic ﬁt is 0.688, compared to
0.606 for the linear ﬁt, and the p-value in Table 3.10 for the quadratic term
is highly signiﬁcant.

If including horsepower

2 led to such a big improvement in the model, why
5? The green curve

4, or even horsepower

not include horsepower

3, horsepower

92

3. Linear Regression

Intercept
horsepower
2
horsepower

Coeﬃcient
56.9001
−0.4662
0.0012

Std. error
1.8004
0.0311
0.0001

t-statistic

p-value
31.6 < 0.0001
−15.0 < 0.0001
10.1 < 0.0001

TABLE 3.10. For the Auto data set, least squares coeﬃcient estimates associated
with the regression of mpg onto horsepower and horsepower

2.

in Figure 3.8 displays the ﬁt that results from including all polynomials up
to ﬁfth degree in the model (3.36). The resulting ﬁt seems unnecessarily
wiggly—that is, it is unclear that including the additional terms really has
led to a better ﬁt to the data.

The approach that we have just described for extending the linear model
to accommodate non-linear relationships is known as polynomial regres-
sion, since we have included polynomial functions of the predictors in the
regression model. We further explore this approach and other non-linear
extensions of the linear model in Chapter 7.

3.3.3 Potential Problems

When we ﬁt a linear regression model to a particular data set, many prob-
lems may occur. Most common among these are the following:

1. Non-linearity of the response-predictor relationships.

2. Correlation of error terms.

3. Non-constant variance of error terms.

4. Outliers.

5. High-leverage points.

6. Collinearity.

In practice, identifying and overcoming these problems is as much an
art as a science. Many pages in countless books have been written on this
topic. Since the linear regression model is not our primary focus here, we
will provide only a brief summary of some key points.

1. Non-linearity of the Data

The linear regression model assumes that there is a straight-line relation-
ship between the predictors and the response. If the true relationship is
far from linear, then virtually all of the conclusions that we draw from the
ﬁt are suspect. In addition, the prediction accuracy of the model can be
signiﬁcantly reduced.

Residual plots are a useful graphical tool for identifying non-linearity.
Given a simple linear regression model, we can plot the residuals, ei =
yi − ˆyi, versus the predictor xi. In the case of a multiple regression model,

residual plot

3.3 Other Considerations in the Regression Model

93

Residual Plot for Linear Fit

Residual Plot for Quadratic Fit

l

s
a
u
d
s
e
R

i

323
330

334

0
2

5
1

0
1

5

0

5
−

0
1
−

5
1
−

l

s
a
u
d
s
e
R

i

5
1

0
1

5

0

5
−

0
1
−

5
1
−

334

323

155

ﬁtted

5

10

15

20

25

30

15

20

25

30

35

Fitted values

Fitted values

FIGURE 3.9. Plots of residuals versus predicted (or ﬁtted) values for the Auto
data set. In each plot, the red line is a smooth ﬁt to the residuals, intended to make
it easier to identify a trend. Left: A linear regression of mpg on horsepower. A
strong pattern in the residuals indicates non-linearity in the data. Right: A linear
2. There is little pattern in the
regression of mpg on horsepower and horsepower
residuals.

since there are multiple predictors, we instead plot the residuals versus
the predicted (or ﬁtted) values ˆyi. Ideally, the residual plot will show no
discernible pattern. The presence of a pattern may indicate a problem with
some aspect of the linear model.

The left panel of Figure 3.9 displays a residual plot from the linear
regression of mpg onto horsepower on the Auto data set that was illustrated
in Figure 3.8. The red line is a smooth ﬁt to the residuals, which is displayed
in order to make it easier to identify any trends. The residuals exhibit a
clear U-shape, which provides a strong indication of non-linearity in the
data. In contrast, the right-hand panel of Figure 3.9 displays the residual
plot that results from the model (3.36), which contains a quadratic term.
There appears to be little pattern in the residuals, suggesting that the
quadratic term improves the ﬁt to the data.

If the residual plot indicates that there are non-linear associations in the
data, then a simple approach is to use non-linear transformations of the
X, and X 2, in the regression model. In the
predictors, such as log X,
later chapters of this book, we will discuss other more advanced non-linear
approaches for addressing this issue.

√

2. Correlation of Error Terms

An important assumption of the linear regression model is that the error
terms, 1, 2, . . . , n, are uncorrelated. What does this mean? For instance,
if the errors are uncorrelated, then the fact that i is positive provides
little or no information about the sign of i+1. The standard errors that
are computed for the estimated regression coeﬃcients or the ﬁtted values

94

3. Linear Regression

are based on the assumption of uncorrelated error terms. If in fact there
is correlation among the error terms, then the estimated standard errors
will tend to underestimate the true standard errors. As a result, conﬁ-
dence and prediction intervals will be narrower than they should be. For
example, a 95 % conﬁdence interval may in reality have a much lower prob-
ability than 0.95 of containing the true value of the parameter. In addition,
p-values associated with the model will be lower than they should be; this
could cause us to erroneously conclude that a parameter is statistically
signiﬁcant. In short, if the error terms are correlated, we may have an
unwarranted sense of conﬁdence in our model.

As an extreme example, suppose we accidentally doubled our data, lead-
ing to observations and error terms identical in pairs. If we ignored this, our
standard error calculations would be as if we had a sample of size 2n, when
in fact we have only n samples. Our estimated parameters would be the
same for the 2n samples as for the n samples, but the conﬁdence intervals
would be narrower by a factor of

√
2!

Why might correlations among the error terms occur? Such correlations
frequently occur in the context of time series data, which consists of ob-
servations for which measurements are obtained at discrete points in time.
In many cases, observations that are obtained at adjacent time points will
have positively correlated errors. In order to determine if this is the case for
a given data set, we can plot the residuals from our model as a function of
time. If the errors are uncorrelated, then there should be no discernible pat-
tern. On the other hand, if the error terms are positively correlated, then
we may see tracking in the residuals—that is, adjacent residuals may have
similar values. Figure 3.10 provides an illustration. In the top panel, we see
the residuals from a linear regression ﬁt to data generated with uncorre-
lated errors. There is no evidence of a time-related trend in the residuals.
In contrast, the residuals in the bottom panel are from a data set in which
adjacent errors had a correlation of 0.9. Now there is a clear pattern in the
residuals—adjacent residuals tend to take on similar values. Finally, the
center panel illustrates a more moderate case in which the residuals had a
correlation of 0.5. There is still evidence of tracking, but the pattern is less
clear.

Many methods have been developed to properly take account of corre-
lations in the error terms in time series data. Correlation among the error
terms can also occur outside of time series data. For instance, consider a
study in which individuals’ heights are predicted from their weights. The
assumption of uncorrelated errors could be violated if some of the individ-
uals in the study are members of the same family, or eat the same diet,
or have been exposed to the same environmental factors. In general, the
assumption of uncorrelated errors is extremely important for linear regres-
sion as well as for other statistical methods, and good experimental design
is crucial in order to mitigate the risk of such correlations.

time series

tracking

l

i

a
u
d
s
e
R

l

i

a
u
d
s
e
R

l

i

a
u
d
s
e
R

3

2

1

0

1
−

3
−

2

1

0

2
−

4
−

5
1

.

.

5
0

.

5
0
−

.

5
1
−

0

0

0

3.3 Other Considerations in the Regression Model

95

ρ=0.0

20

40

60

80

100

ρ=0.5

20

40

60

80

100

ρ=0.9

20

40

60

80

100

Observation

FIGURE 3.10. Plots of residuals from simulated time series data sets generated
with diﬀering levels of correlation ρ between error terms for adjacent time points.

3. Non-constant Variance of Error Terms

Another important assumption of the linear regression model is that the
error terms have a constant variance, Var(i) = σ2. The standard errors,
conﬁdence intervals, and hypothesis tests associated with the linear model
rely upon this assumption.

Unfortunately, it is often the case that the variances of the error terms are
non-constant. For instance, the variances of the error terms may increase
with the value of the response. One can identify non-constant variances in
the errors, or heteroscedasticity, from the presence of a funnel shape in
the residual plot. An example is shown in the left-hand panel of Figure 3.11,
in which the magnitude of the residuals tends to increase with the ﬁtted
√
values. When faced with this problem, one possible solution is to trans-
Y . Such
form the response Y using a concave function such as log Y or
a transformation results in a greater amount of shrinkage of the larger re-
sponses, leading to a reduction in heteroscedasticity. The right-hand panel
of Figure 3.11 displays the residual plot after transforming the response

heterosceda-
sticity

96

3. Linear Regression

Response Y

Response log(Y)

l

s
a
u
d
s
e
R

i

998
975

845

5
1

0
1

5

0

5
−

0
1
−

l

s
a
u
d
s
e
R

i

4
.
0

2
.
0

0
.
0

2
.
0
−

4
.
0
−

6

.

0
−

8

.

0
−

605

671

437

10

15

20

25

30

2.4

2.6

2.8

3.0

3.2

3.4

Fitted values

Fitted values

FIGURE 3.11. Residual plots. In each plot, the red line is a smooth ﬁt to the
residuals, intended to make it easier to identify a trend. The blue lines track the
outer quantiles of the residuals, and emphasize patterns. Left: The funnel shape
indicates heteroscedasticity. Right: The response has been log transformed, and
there is now no evidence of heteroscedasticity.

using log Y . The residuals now appear to have constant variance, though
there is some evidence of a slight non-linear relationship in the data.

Sometimes we have a good idea of the variance of each response. For
example, the ith response could be an average of ni raw observations. If
each of these raw observations is uncorrelated with variance σ2, then their
average has variance σ2
i = σ2/ni. In this case a simple remedy is to ﬁt our
model by weighted least squares, with weights proportional to the inverse
variances—i.e. wi = ni in this case. Most linear regression software allows
for observation weights.

4. Outliers

An outlier is a point for which yi is far from the value predicted by the
model. Outliers can arise for a variety of reasons, such as incorrect recording
of an observation during data collection.

The red point (observation 20) in the left-hand panel of Figure 3.12
illustrates a typical outlier. The red solid line is the least squares regression
ﬁt, while the blue dashed line is the least squares ﬁt after removal of the
outlier. In this case, removing the outlier has little eﬀect on the least squares
line: it leads to almost no change in the slope, and a miniscule reduction
in the intercept. It is typical for an outlier that does not have an unusual
predictor value to have little eﬀect on the least squares ﬁt. However, even
if an outlier does not have much eﬀect on the least squares ﬁt, it can cause
other problems. For instance, in this example, the RSE is 1.09 when the
outlier is included in the regression, but it is only 0.77 when the outlier
is removed. Since the RSE is used to compute all conﬁdence intervals and

weighted
least squares

outlier

3.3 Other Considerations in the Regression Model

97

20

20

6

4

Y

2

0

2
−

4
−

l

s
a
u
d
s
e
R

i

4

3

2

1

0

1
−

20

6

4

2

0

l

i

s
a
u
d
s
e
R
d
e
z
i
t

 

n
e
d
u
S

t

−2

−1

0

1

2

−2

0

2

4

6

−2

0

2

4

6

X

Fitted Values

Fitted Values

FIGURE 3.12. Left: The least squares regression line is shown in red, and the
regression line after removing the outlier is shown in blue. Center: The residual
plot clearly identiﬁes the outlier. Right: The outlier has a studentized residual of
6; typically we expect values between −3 and 3.

p-values, such a dramatic increase caused by a single data point can have
implications for the interpretation of the ﬁt. Similarly, inclusion of the
outlier causes the R2 to decline from 0.892 to 0.805.

Residual plots can be used to identify outliers. In this example, the out-
lier is clearly visible in the residual plot illustrated in the center panel of
Figure 3.12. But in practice, it can be diﬃcult to decide how large a resid-
ual needs to be before we consider the point to be an outlier. To address
this problem, instead of plotting the residuals, we can plot the studentized
residuals, computed by dividing each residual ei by its estimated standard
error. Observations whose studentized residuals are greater than 3 in abso-
lute value are possible outliers. In the right-hand panel of Figure 3.12, the
outlier’s studentized residual exceeds 6, while all other observations have
studentized residuals between −2 and 2.

If we believe that an outlier has occurred due to an error in data collec-
tion or recording, then one solution is to simply remove the observation.
However, care should be taken, since an outlier may instead indicate a
deﬁciency with the model, such as a missing predictor.

5. High Leverage Points

We just saw that outliers are observations for which the response yi is
unusual given the predictor xi. In contrast, observations with high leverage
have an unusual value for xi. For example, observation 41 in the left-hand
panel of Figure 3.13 has high leverage, in that the predictor value for this
observation is large relative to the other observations. (Note that the data
displayed in Figure 3.13 are the same as the data displayed in Figure 3.12,
but with the addition of a single high leverage observation.) The red solid
line is the least squares ﬁt to the data, while the blue dashed line is the
ﬁt produced when observation 41 is removed. Comparing the left-hand
panels of Figures 3.12 and 3.13, we observe that removing the high leverage
observation has a much more substantial impact on the least squares line

studentized
residual

high leverage

98

3. Linear Regression

0
1

Y

5

0

41

20

2
X

2

1

0

1
−

2
−

20

41

5

4

3

2

1

0

1
−

l

i

s
a
u
d
s
e
R
d
e
z
i
t

 

n
e
d
u
S

t

−2

−1

0

1

X

2

3

4

−2

−1

0

X1

1

2

0.00 0.05 0.10 0.15 0.20 0.25

Leverage

FIGURE 3.13. Left: Observation 41 is a high leverage point, while 20 is not.
The red line is the ﬁt to all the data, and the blue line is the ﬁt with observation
41 removed. Center: The red observation is not unusual in terms of its X1 value
or its X2 value, but still falls outside the bulk of the data, and hence has high
leverage. Right: Observation 41 has a high leverage and a high residual.

than removing the outlier. In fact, high leverage observations tend to have
a sizable impact on the estimated regression line. It is cause for concern if
the least squares line is heavily aﬀected by just a couple of observations,
because any problems with these points may invalidate the entire ﬁt. For
this reason, it is important to identify high leverage observations.

In a simple linear regression, high leverage observations are fairly easy to
identify, since we can simply look for observations for which the predictor
value is outside of the normal range of the observations. But in a multiple
linear regression with many predictors, it is possible to have an observation
that is well within the range of each individual predictor’s values, but that
is unusual in terms of the full set of predictors. An example is shown in
the center panel of Figure 3.13, for a data set with two predictors, X1 and
X2. Most of the observations’ predictor values fall within the blue dashed
ellipse, but the red observation is well outside of this range. But neither its
value for X1 nor its value for X2 is unusual. So if we examine just X1 or
just X2, we will fail to notice this high leverage point. This problem is more
pronounced in multiple regression settings with more than two predictors,
because then there is no simple way to plot all dimensions of the data
simultaneously.

In order to quantify an observation’s leverage, we compute the leverage
statistic. A large value of this statistic indicates an observation with high
leverage. For a simple linear regression,

hi =

(cid:10)

+

1
n

(xi − ¯x)2
i(cid:2)=1(xi(cid:2) − ¯x)2 .

n

(3.37)

It is clear from this equation that hi increases with the distance of xi from ¯x.
There is a simple extension of hi to the case of multiple predictors, though
we do not provide the formula here. The leverage statistic hi is always
between 1/n and 1, and the average leverage for all the observations is
always equal to (p + 1)/n. So if a given observation has a leverage statistic

leverage
statistic

3.3 Other Considerations in the Regression Model

99

e
g
A

0
8

0
7

0
6

0
5

0
4

0
3

g
n

i
t

a
R

0
0
8

0
0
6

0
0
4

0
0
2

2000 4000 6000 8000

12000

2000 4000 6000 8000

12000

Limit

Limit

FIGURE 3.14. Scatterplots of the observations from the Credit data set. Left:
A plot of age versus limit. These two variables are not collinear. Right: A plot
of rating versus limit. There is high collinearity.

that greatly exceeds (p+ 1)/n, then we may suspect that the corresponding
point has high leverage.

The right-hand panel of Figure 3.13 provides a plot of the studentized
residuals versus hi for the data in the left-hand panel of Figure 3.13. Ob-
servation 41 stands out as having a very high leverage statistic as well as a
high studentized residual. In other words, it is an outlier as well as a high
leverage observation. This is a particularly dangerous combination! This
plot also reveals the reason that observation 20 had relatively little eﬀect
on the least squares ﬁt in Figure 3.12: it has low leverage.

6. Collinearity

Collinearity refers to the situation in which two or more predictor variables
are closely related to one another. The concept of collinearity is illustrated
in Figure 3.14 using the Credit data set. In the left-hand panel of Fig-
ure 3.14, the two predictors limit and age appear to have no obvious rela-
tionship. In contrast, in the right-hand panel of Figure 3.14, the predictors
limit and rating are very highly correlated with each other, and we say
that they are collinear. The presence of collinearity can pose problems in
the regression context, since it can be diﬃcult to separate out the indi-
vidual eﬀects of collinear variables on the response. In other words, since
limit and rating tend to increase or decrease together, it can be diﬃcult to
determine how each one separately is associated with the response, balance.

collinearity

Figure 3.15 illustrates some of the diﬃculties that can result from collinear-

ity. The left-hand panel of Figure 3.15 is a contour plot of the RSS (3.22)
associated with diﬀerent possible coeﬃcient estimates for the regression
of balance on limit and age. Each ellipse represents a set of coeﬃcients
that correspond to the same RSS, with ellipses nearest to the center tak-
ing on the lowest values of RSS. The black dots and associated dashed

100

3. Linear Regression

e
g
A
β

0

1
−

2
−

3
−

4
−

5
−

 21.8 

 21.5 

 21.25 

 2
1.8 

 2
1.5 

g
n
i
t
a
R
β

5

4

3

2

1

0

0.16

0.17

0.18

0.19

βLimit

−0.1

0.0
βLimit

0.1

0.2

FIGURE 3.15. Contour plots for the RSS values as a function of the parameters
β for various regressions involving the Credit data set. In each plot, the black
dots represent the coeﬃcient values corresponding to the minimum RSS. Left:
A contour plot of RSS for the regression of balance onto age and limit. The
minimum value is well deﬁned. Right: A contour plot of RSS for the regression
of balance onto rating and limit. Because of the collinearity, there are many
pairs (βLimit, βRating) with a similar value for RSS.

lines represent the coeﬃcient estimates that result in the smallest possible
RSS—in other words, these are the least squares estimates. The axes for
limit and age have been scaled so that the plot includes possible coeﬃ-
cient estimates that are up to four standard errors on either side of the
least squares estimates. Thus the plot includes all plausible values for the
coeﬃcients. For example, we see that the true limit coeﬃcient is almost
certainly somewhere between 0.15 and 0.20.

In contrast, the right-hand panel of Figure 3.15 displays contour plots
of the RSS associated with possible coeﬃcient estimates for the regression
of balance onto limit and rating, which we know to be highly collinear.
Now the contours run along a narrow valley; there is a broad range of
values for the coeﬃcient estimates that result in equal values for RSS.
Hence a small change in the data could cause the pair of coeﬃcient values
that yield the smallest RSS—that is, the least squares estimates—to move
anywhere along this valley. This results in a great deal of uncertainty in the
coeﬃcient estimates. Notice that the scale for the limit coeﬃcient now runs
from roughly −0.2 to 0.2; this is an eight-fold increase over the plausible
range of the limit coeﬃcient in the regression with age. Interestingly, even
though the limit and rating coeﬃcients now have much more individual
uncertainty, they will almost certainly lie somewhere in this contour valley.
For example, we would not expect the true value of the limit and rating
coeﬃcients to be −0.1 and 1 respectively, even though such a value is
plausible for each coeﬃcient individually.

3.3 Other Considerations in the Regression Model

101

Model 1

Model 2

Intercept
age
limit
Intercept
rating
limit

Coeﬃcient
−173.411
−2.292
0.173
−377.537
2.202
0.025

Std. error
43.828
0.672
0.005
45.254
0.952
0.064

t-statistic
p-value
−3.957 < 0.0001
−3.407
0.0007
34.496 < 0.0001
−8.343 < 0.0001
0.0213
2.312
0.384
0.7012

TABLE 3.11. The results for two multiple regression models involving the
Credit data set are shown. Model 1 is a regression of balance on age and limit,
and Model 2 a regression of balance on rating and limit. The standard error
of ˆβlimit increases 12-fold in the second regression, due to collinearity.

Since collinearity reduces the accuracy of the estimates of the regression
coeﬃcients, it causes the standard error for ˆβj to grow. Recall that the
t-statistic for each predictor is calculated by dividing ˆβj by its standard
error. Consequently, collinearity results in a decline in the t-statistic. As a
result, in the presence of collinearity, we may fail to reject H0 : βj = 0. This
means that the power of the hypothesis test—the probability of correctly power
detecting a non-zero coeﬃcient—is reduced by collinearity.

Table 3.11 compares the coeﬃcient estimates obtained from two separate
multiple regression models. The ﬁrst is a regression of balance on age and
limit, and the second is a regression of balance on rating and limit. In the
ﬁrst regression, both age and limit are highly signiﬁcant with very small p-
values. In the second, the collinearity between limit and rating has caused
the standard error for the limit coeﬃcient estimate to increase by a factor
of 12 and the p-value to increase to 0.701. In other words, the importance
of the limit variable has been masked due to the presence of collinearity.
To avoid such a situation, it is desirable to identify and address potential
collinearity problems while ﬁtting the model.

A simple way to detect collinearity is to look at the correlation matrix
of the predictors. An element of this matrix that is large in absolute value
indicates a pair of highly correlated variables, and therefore a collinearity
problem in the data. Unfortunately, not all collinearity problems can be
detected by inspection of the correlation matrix: it is possible for collinear-
ity to exist between three or more variables even if no pair of variables
has a particularly high correlation. We call this situation multicollinearity.
Instead of inspecting the correlation matrix, a better way to assess multi-
collinearity is to compute the variance inﬂation factor (VIF). The VIF is
the ratio of the variance of ˆβj when ﬁtting the full model divided by the
variance of ˆβj if ﬁt on its own. The smallest possible value for VIF is 1,
which indicates the complete absence of collinearity. Typically in practice
there is a small amount of collinearity among the predictors. As a rule of
thumb, a VIF value that exceeds 5 or 10 indicates a problematic amount of

multi-
collinearity

variance
inﬂation
factor

102

3. Linear Regression

collinearity. The VIF for each variable can be computed using the formula

VIF( ˆβj ) =

1
1 − R2
Xj|X−j

,

Xj|X−j

where R2
predictors. If R2
the VIF will be large.

is the R2 from a regression of Xj onto all of the other
Xj|X−j is close to one, then collinearity is present, and so

In the Credit data, a regression of balance on age, rating, and limit
indicates that the predictors have VIF values of 1.01, 160.67, and 160.59.
As we suspected, there is considerable collinearity in the data!

When faced with the problem of collinearity, there are two simple solu-
tions. The ﬁrst is to drop one of the problematic variables from the regres-
sion. This can usually be done without much compromise to the regression
ﬁt, since the presence of collinearity implies that the information that this
variable provides about the response is redundant in the presence of the
other variables. For instance, if we regress balance onto age and limit,
without the rating predictor, then the resulting VIF values are close to
the minimum possible value of 1, and the R2 drops from 0.754 to 0.75.
So dropping rating from the set of predictors has eﬀectively solved the
collinearity problem without compromising the ﬁt. The second solution is
to combine the collinear variables together into a single predictor. For in-
stance, we might take the average of standardized versions of limit and
rating in order to create a new variable that measures credit worthiness.

3.4 The Marketing Plan

We now brieﬂy return to the seven questions about the Advertising data
that we set out to answer at the beginning of this chapter.

1. Is there a relationship between advertising sales and budget?

This question can be answered by ﬁtting a multiple regression model
of sales onto TV, radio, and newspaper, as in (3.20), and testing the
hypothesis H0 : βTV = βradio = βnewspaper = 0. In Section 3.2.2,
we showed that the F-statistic can be used to determine whether or
not we should reject this null hypothesis. In this case the p-value
corresponding to the F-statistic in Table 3.6 is very low, indicating
clear evidence of a relationship between advertising and sales.

2. How strong is the relationship?

We discussed two measures of model accuracy in Section 3.1.3. First,
the RSE estimates the standard deviation of the response from the
population regression line. For the Advertising data, the RSE is 1,681

3.4 The Marketing Plan

103

units while the mean value for the response is 14,022, indicating a
percentage error of roughly 12 %. Second, the R2 statistic records
the percentage of variability in the response that is explained by
the predictors. The predictors explain almost 90 % of the variance in
sales. The RSE and R2 statistics are displayed in Table 3.6.

3. Which media contribute to sales?

To answer this question, we can examine the p-values associated with
each predictor’s t-statistic (Section 3.1.2). In the multiple linear re-
gression displayed in Table 3.4, the p-values for TV and radio are low,
but the p-value for newspaper is not. This suggests that only TV and
radio are related to sales. In Chapter 6 we explore this question in
greater detail.

4. How large is the eﬀect of each medium on sales?

We saw in Section 3.1.2 that the standard error of ˆβj can be used
to construct conﬁdence intervals for βj. For the Advertising data,
the 95 % conﬁdence intervals are as follows: (0.043, 0.049) for TV,
(0.172, 0.206) for radio, and (−0.013, 0.011) for newspaper. The conﬁ-
dence intervals for TV and radio are narrow and far from zero, provid-
ing evidence that these media are related to sales. But the interval
for newspaper includes zero, indicating that the variable is not statis-
tically signiﬁcant given the values of TV and radio.

We saw in Section 3.3.3 that collinearity can result in very wide stan-
dard errors. Could collinearity be the reason that the conﬁdence in-
terval associated with newspaper is so wide? The VIF scores are 1.005,
1.145, and 1.145 for TV, radio, and newspaper, suggesting no evidence
of collinearity.

In order to assess the association of each medium individually on
sales, we can perform three separate simple linear regressions. Re-
sults are shown in Tables 3.1 and 3.3. There is evidence of an ex-
tremely strong association between TV and sales and between radio
and sales. There is evidence of a mild association between newspaper
and sales, when the values of TV and radio are ignored.

5. How accurately can we predict future sales?

The response can be predicted using (3.21). The accuracy associ-
ated with this estimate depends on whether we wish to predict an
individual response, Y = f (X) + , or the average response, f (X)
(Section 3.2.2). If the former, we use a prediction interval, and if the
latter, we use a conﬁdence interval. Prediction intervals will always
be wider than conﬁdence intervals because they account for the un-
certainty associated with , the irreducible error.

104

3. Linear Regression

6. Is the relationship linear?

In Section 3.3.3, we saw that residual plots can be used in order to
identify non-linearity. If the relationships are linear, then the residual
plots should display no pattern. In the case of the Advertising data,
we observe a non-linear eﬀect in Figure 3.5, though this eﬀect could
also be observed in a residual plot. In Section 3.3.2, we discussed the
inclusion of transformations of the predictors in the linear regression
model in order to accommodate non-linear relationships.

7. Is there synergy among the advertising media?

The standard linear regression model assumes an additive relation-
ship between the predictors and the response. An additive model is
easy to interpret because the eﬀect of each predictor on the response is
unrelated to the values of the other predictors. However, the additive
assumption may be unrealistic for certain data sets. In Section 3.3.2,
we showed how to include an interaction term in the regression model
in order to accommodate non-additive relationships. A small p-value
associated with the interaction term indicates the presence of such
relationships. Figure 3.5 suggested that the Advertising data may
not be additive. Including an interaction term in the model results in
a substantial increase in R2, from around 90 % to almost 97 %.

3.5 Comparison of Linear Regression

with K-Nearest Neighbors

As discussed in Chapter 2, linear regression is an example of a parametric
approach because it assumes a linear functional form for f (X). Parametric
methods have several advantages. They are often easy to ﬁt, because one
need estimate only a small number of coeﬃcients. In the case of linear re-
gression, the coeﬃcients have simple interpretations, and tests of statistical
signiﬁcance can be easily performed. But parametric methods do have a
disadvantage: by construction, they make strong assumptions about the
form of f (X). If the speciﬁed functional form is far from the truth, and
prediction accuracy is our goal, then the parametric method will perform
poorly. For instance, if we assume a linear relationship between X and Y
but the true relationship is far from linear, then the resulting model will
provide a poor ﬁt to the data, and any conclusions drawn from it will be
suspect.

In contrast, non-parametric methods do not explicitly assume a para-
metric form for f (X), and thereby provide an alternative and more ﬂexi-
ble approach for performing regression. We discuss various non-parametric
methods in this book. Here we consider one of the simplest and best-known
non-parametric methods, K-nearest neighbors regression (KNN regression).

K-nearest
neighbors
regression

3.5 Comparison of Linear Regression with K-Nearest Neighbors

105

y

y

x2

x2

x1

x1

FIGURE 3.16. Plots of ˆf (X) using KNN regression on a two-dimensional data
set with 64 observations (orange dots). Left: K = 1 results in a rough step func-
tion ﬁt. Right: K = 9 produces a much smoother ﬁt.

The KNN regression method is closely related to the KNN classiﬁer dis-
cussed in Chapter 2. Given a value for K and a prediction point x0, KNN
regression ﬁrst identiﬁes the K training observations that are closest to
x0, represented by N0. It then estimates f (x0) using the average of all the
training responses in N0. In other words,
(cid:17)

ˆf (x0) =

1
K

yi.

xi∈N0

Figure 3.16 illustrates two KNN ﬁts on a data set with p = 2 predictors.
The ﬁt with K = 1 is shown in the left-hand panel, while the right-hand
panel corresponds to K = 9. We see that when K = 1, the KNN ﬁt perfectly
interpolates the training observations, and consequently takes the form of
a step function. When K = 9, the KNN ﬁt still is a step function, but
averaging over nine observations results in much smaller regions of constant
prediction, and consequently a smoother ﬁt. In general, the optimal value
for K will depend on the bias-variance tradeoﬀ, which we introduced in
Chapter 2. A small value for K provides the most ﬂexible ﬁt, which will
have low bias but high variance. This variance is due to the fact that the
prediction in a given region is entirely dependent on just one observation.
In contrast, larger values of K provide a smoother and less variable ﬁt; the
prediction in a region is an average of several points, and so changing one
observation has a smaller eﬀect. However, the smoothing may cause bias by
masking some of the structure in f (X). In Chapter 5, we introduce several
approaches for estimating test error rates. These methods can be used to
identify the optimal value of K in KNN regression.

106

3. Linear Regression

In what setting will a parametric approach such as least squares linear re-
gression outperform a non-parametric approach such as KNN regression?
The answer is simple: the parametric approach will outperform the non-
parametric approach if the parametric form that has been selected is close
to the true form of f . Figure 3.17 provides an example with data generated
from a one-dimensional linear regression model. The black solid lines rep-
resent f (X), while the blue curves correspond to the KNN ﬁts using K = 1
and K = 9. In this case, the K = 1 predictions are far too variable, while
the smoother K = 9 ﬁt is much closer to f (X). However, since the true
relationship is linear, it is hard for a non-parametric approach to compete
with linear regression: a non-parametric approach incurs a cost in variance
that is not oﬀset by a reduction in bias. The blue dashed line in the left-
hand panel of Figure 3.18 represents the linear regression ﬁt to the same
data. It is almost perfect. The right-hand panel of Figure 3.18 reveals that
linear regression outperforms KNN for this data. The green solid line, plot-
ted as a function of 1/K, represents the test set mean squared error (MSE)
for KNN. The KNN errors are well above the black dashed line, which is
the test MSE for linear regression. When the value of K is large, then KNN
performs only a little worse than least squares regression in terms of MSE.
It performs far worse when K is small.

In practice, the true relationship between X and Y is rarely exactly lin-
ear. Figure 3.19 examines the relative performances of least squares regres-
sion and KNN under increasing levels of non-linearity in the relationship
between X and Y . In the top row, the true relationship is nearly linear.
In this case we see that the test MSE for linear regression is still superior
to that of KNN for low values of K. However, for K ≥ 4, KNN out-
performs linear regression. The second row illustrates a more substantial
deviation from linearity. In this situation, KNN substantially outperforms
linear regression for all values of K. Note that as the extent of non-linearity
increases, there is little change in the test set MSE for the non-parametric
KNN method, but there is a large increase in the test set MSE of linear
regression.

Figures 3.18 and 3.19 display situations in which KNN performs slightly
worse than linear regression when the relationship is linear, but much better
than linear regression for non-linear situations. In a real life situation in
which the true relationship is unknown, one might draw the conclusion that
KNN should be favored over linear regression because it will at worst be
slightly inferior than linear regression if the true relationship is linear, and
may give substantially better results if the true relationship is non-linear.
But in reality, even when the true relationship is highly non-linear, KNN
may still provide inferior results to linear regression. In particular, both
Figures 3.18 and 3.19 illustrate settings with p = 1 predictor. But in higher
dimensions, KNN often performs worse than linear regression.

Figure 3.20 considers the same strongly non-linear situation as in the
second row of Figure 3.19, except that we have added additional noise

3.5 Comparison of Linear Regression with K-Nearest Neighbors

107

4

3

y

2

1

4

3

y

2

1

−1.0

−0.5

0.0
x

0.5

1.0

−1.0

−0.5

0.5

1.0

0.0
x

FIGURE 3.17. Plots of ˆf (X) using KNN regression on a one-dimensional data
set with 100 observations. The true relationship is given by the black solid line.
Left: The blue curve corresponds to K = 1 and interpolates (i.e. passes directly
through) the training data. Right: The blue curve corresponds to K = 9, and
represents a smoother ﬁt.

4

3

y

2

1

r
o
r
r

E
 
d
e
r
a
u
q
S
 
n
a
e
M

5
1
.
0

0
1
0

.

5
0
.
0

0
0
0

.

−1.0

−0.5

0.0
x

0.5

1.0

0.2

0.5

1.0

1/K

FIGURE 3.18. The same data set shown in Figure 3.17 is investigated further.
Left: The blue dashed line is the least squares ﬁt to the data. Since f (X) is in
fact linear (displayed as the black line), the least squares regression line provides
a very good estimate of f (X). Right: The dashed horizontal line represents the
least squares test set MSE, while the green solid line corresponds to the MSE
for KNN as a function of 1/K (on the log scale). Linear regression achieves a
lower test MSE than does KNN regression, since f (X) is in fact linear. For KNN
regression, the best results occur with a very large value of K, corresponding to a
small value of 1/K.

108

3. Linear Regression

−1.0

−0.5

0.5

1.0

0.0
x

y

y

5
3

.

0
3

.

5
2

.

0

.

2

5
1

.

0

.

1

5

.

0

5

.

3

0

.

3

5

.

2

0
2

.

5

.

1

0

.

1

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0.2

0.5

1.0

1/K

8
0
0

.

6
0

.

0

4
0

.

0

2
0
0

.

0
0

.

0

5
1

.

0

0
1
0

.

5
0
0

.

0
0

.

0

−1.0

−0.5

0.0
x

0.5

1.0

0.2

0.5

1.0

1/K

FIGURE 3.19. Top Left: In a setting with a slightly non-linear relationship
between X and Y (solid black line), the KNN ﬁts with K = 1 (blue) and K = 9
(red) are displayed. Top Right: For the slightly non-linear data, the test set MSE
for least squares regression (horizontal black) and KN N with various values of
1/K (green) are displayed. Bottom Left and Bottom Right: As in the top panel,
but with a strongly non-linear relationship between X and Y .

predictors that are not associated with the response. When p = 1 or p = 2,
KNN outperforms linear regression. But for p = 3 the results are mixed,
and for p ≥ 4 linear regression is superior to KNN. In fact, the increase in
dimension has only caused a small deterioration in the linear regression test
set MSE, but it has caused more than a ten-fold increase in the MSE for
KNN. This decrease in performance as the dimension increases is a common
problem for KNN, and results from the fact that in higher dimensions
there is eﬀectively a reduction in sample size. In this data set there are
100 training observations; when p = 1, this provides enough information to
accurately estimate f (X). However, spreading 100 observations over p = 20
dimensions results in a phenomenon in which a given observation has no
nearby neighbors—this is the so-called curse of dimensionality. That is,
the K observations that are nearest to a given test observation x0 may be
very far away from x0 in p-dimensional space when p is large, leading to a

curse of di-
mensionality

3.6 Lab: Linear Regression

109

p=1

p=2

p=3

p=4

p=10

p=20

0

.

1

8

.

0

6

.

0

4

.

0

2

.

0

0

.

0

0

.

1

8

.

0

6

.

0

4

.

0

2

.

0

0
.
0

0

.

1

8

.

0

6

.

0

4

.

0

2

.

0

0
.
0

0

.

1

8

.

0

6

.

0

4

.

0

2

.

0

0
.
0

0

.

1

8

.

0

6

.

0

4

.

0

2

.

0

0
.
0

0

.

1

8

.

0

6

.

0

4

.

0

2

.

0

0
.
0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0.2

0.5 1.0

0.2

0.5 1.0

0.2

0.5 1.0

0.2

0.5 1.0

0.2

0.5 1.0

0.2

0.5 1.0

1/K

FIGURE 3.20. Test MSE for linear regression (black dashed lines) and KNN
(green curves) as the number of variables p increases. The true function is non–
linear in the ﬁrst variable, as in the lower panel in Figure 3.19, and does not
depend on the additional variables. The performance of linear regression deteri-
orates slowly in the presence of these additional noise variables, whereas KNN’s
performance degrades much more quickly as p increases.

very poor prediction of f (x0) and hence a poor KNN ﬁt. As a general rule,
parametric methods will tend to outperform non-parametric approaches
when there is a small number of observations per predictor.

Even in problems in which the dimension is small, we might prefer linear
regression to KNN from an interpretability standpoint. If the test MSE
of KNN is only slightly lower than that of linear regression, we might be
willing to forego a little bit of prediction accuracy for the sake of a simple
model that can be described in terms of just a few coeﬃcients, and for
which p-values are available.

3.6 Lab: Linear Regression

3.6.1 Libraries

The library() function is used to load libraries, or groups of functions and
data sets that are not included in the base R distribution. Basic functions
that perform least squares linear regression and other simple analyses come
standard with the base distribution, but more exotic functions require ad-
ditional libraries. Here we load the MASS package, which is a very large
collection of data sets and functions. We also load the ISLR package, which
includes the data sets associated with this book.

library()

> library ( MASS )
> library ( ISLR )

If you receive an error message when loading any of these libraries, it
likely indicates that the corresponding library has not yet been installed
on your system. Some libraries, such as MASS, come with R and do not need to
be separately installed on your computer. However, other packages, such as

110

3. Linear Regression

ISLR, must be downloaded the ﬁrst time they are used. This can be done di-
rectly from within R. For example, on a Windows system, select the Install
package option under the Packages tab. After you select any mirror site, a
list of available packages will appear. Simply select the package you wish to
install and R will automatically download the package. Alternatively, this
can be done at the R command line via install.packages("ISLR"). This in-
stallation only needs to be done the ﬁrst time you use a package. However,
the library() function must be called each time you wish to use a given
package.

3.6.2 Simple Linear Regression

The MASS library contains the Boston data set, which records medv (median
house value) for 506 neighborhoods around Boston. We will seek to predict
medv using 13 predictors such as rm (average number of rooms per house),
age (average age of houses), and lstat (percent of households with low
socioeconomic status).

> fix ( Boston )
> names ( Boston )

[1] " crim "
[8] " dis "

" zn "
" rad "

" indus "
" tax "

" chas "

" nox "
" ptratio " " black "

" rm "

" lstat "

" age "
" medv "

To ﬁnd out more about the data set, we can type ?Boston.

We will start by using the lm() function to ﬁt a simple linear regression
model, with medv as the response and lstat as the predictor. The basic
syntax is lm(y∼x,data), where y is the response, x is the predictor, and
data is the data set in which these two variables are kept.
> lm . fit = lm ( medv∼lstat )

Error in eval ( expr , envir , enclos ) : Object " medv " not found

lm()

The command causes an error because R does not know where to ﬁnd
the variables medv and lstat. The next line tells R that the variables are
in Boston. If we attach Boston, the ﬁrst line works ﬁne because R now
recognizes the variables.
> lm . fit = lm ( medv∼lstat , data = Boston )
> lm . fit = lm ( medv∼lstat )

> attach ( Boston )

If we type lm.fit, some basic information about the model is output.
For more detailed information, we use summary(lm.fit). This gives us p-
values and standard errors for the coeﬃcients, as well as the R2 statistic
and F-statistic for the model.

> lm . fit

Call :

lm ( formula = medv ∼ lstat )

3.6 Lab: Linear Regression

111

C o e f f i c i e n t s :
( Intercept )
34.55

lstat
-0.95

> summary ( lm . fit )

Call :

lm ( formula = medv ∼ lstat )

Residuals :

Min
-15.17

1 Q Median
-1.32

-3.99

3 Q
2.03

Max
24.50

C o e f f i c i e n t s :

Estimate Std . Error t value Pr ( >| t |)

( Intercept )
lstat
---
Signif . codes :

34.5538
-0.9500

0.5626
0.0387

61.4
-24.5

<2e -16 ***
<2e -16 ***

0 *** 0.001 ** 0.01 * 0.05 . 0.1

1

Residual standard error : 6.22 on 504 degrees of freedom
Multiple R - squared : 0.544 ,
F - statistic :

602 on 1 and 504 DF ,

Adjusted R - squared : 0.543

p - value : <2e -16

We can use the names() function in order to ﬁnd out what other pieces
of information are stored in lm.fit. Although we can extract these quan-
tities by name—e.g. lm.fit$coefficients—it is safer to use the extractor
functions like coef() to access them.

names()

coef()

> names ( lm . fit )

[1] " c o e f f i c i e n t s "
[4] " rank "
[7] " qr "

[10] " call "
> coef ( lm . fit )
( Intercept )
34.55

lstat
-0.95

" effects "

" residuals "
" fitted . values " " assign "
" df . residual "
" terms "

" xlevels "
" model "

In order to obtain a conﬁdence interval for the coeﬃcient estimates, we can
use the confint() command.

confint()

> confint ( lm . fit )

2.5 % 97.5 %
( Intercept ) 33.45 35.659
lstat
-1.03 -0.874

The predict() function can be used to produce conﬁdence intervals and
prediction intervals for the prediction of medv for a given value of lstat.

predict()

> predict ( lm . fit , data . frame ( lstat = c (5 ,10 ,15) ) ,

interval =" confidenc e ")

lwr

fit

upr
1 29.80 29.01 30.60
2 25.05 24.47 25.63
3 20.30 19.73 20.87

112

3. Linear Regression

> predict ( lm . fit , data . frame ( lstat = c (5 ,10 ,15) ) ,

interval =" predictio n ")

lwr

fit

upr
1 29.80 17.566 42.04
2 25.05 12.828 37.28
8.078 32.53
3 20.30

For instance, the 95 % conﬁdence interval associated with a lstat value of
10 is (24.47, 25.63), and the 95 % prediction interval is (12.828, 37.28). As
expected, the conﬁdence and prediction intervals are centered around the
same point (a predicted value of 25.05 for medv when lstat equals 10), but
the latter are substantially wider.

We will now plot medv and lstat along with the least squares regression

line using the plot() and abline() functions.

abline()

> plot ( lstat , medv )
> abline ( lm . fit )

There is some evidence for non-linearity in the relationship between lstat
and medv. We will explore this issue later in this lab.

The abline() function can be used to draw any line, not just the least
squares regression line. To draw a line with intercept a and slope b, we
type abline(a,b). Below we experiment with some additional settings for
plotting lines and points. The lwd=3 command causes the width of the
regression line to be increased by a factor of 3; this works for the plot()
and lines() functions also. We can also use the pch option to create diﬀerent
plotting symbols.

> abline ( lm . fit , lwd =3)
> abline ( lm . fit , lwd =3 , col =" red ")
> plot ( lstat , medv , col =" red ")
> plot ( lstat , medv , pch =20)
> plot ( lstat , medv , pch ="+")
> plot (1:20 ,1:20 , pch =1:20)

Next we examine some diagnostic plots, several of which were discussed
in Section 3.3.3. Four diagnostic plots are automatically produced by ap-
plying the plot() function directly to the output from lm(). In general, this
command will produce one plot at a time, and hitting Enter will generate
the next plot. However, it is often convenient to view all four plots together.
We can achieve this by using the par() function, which tells R to split the
display screen into separate panels so that multiple plots can be viewed si-
multaneously. For example, par(mfrow=c(2,2)) divides the plotting region
into a 2 × 2 grid of panels.

par()

> par ( mfrow = c (2 ,2) )
> plot ( lm . fit )

Alternatively, we can compute the residuals from a linear regression ﬁt
using the residuals() function. The function rstudent() will return the
studentized residuals, and we can use this function to plot the residuals
against the ﬁtted values.

residuals()

rstudent()

3.6 Lab: Linear Regression

113

> plot ( predict ( lm . fit ) , residuals ( lm . fit ) )
> plot ( predict ( lm . fit ) , rstudent ( lm . fit ) )

On the basis of the residual plots, there is some evidence of non-linearity.
Leverage statistics can be computed for any number of predictors using the
hatvalues() function.

hatvalues()

> plot ( hatvalues ( lm . fit ) )
> which . max ( hatvalues ( lm . fit ) )
375

The which.max() function identiﬁes the index of the largest element of a
vector. In this case, it tells us which observation has the largest leverage
statistic.

which.max()

3.6.3 Multiple Linear Regression

In order to ﬁt a multiple linear regression model using least squares, we
again use the lm() function. The syntax lm(y∼x1+x2+x3) is used to ﬁt a
model with three predictors, x1, x2, and x3. The summary() function now
outputs the regression coeﬃcients for all the predictors.
> lm . fit = lm ( medv∼lstat + age , data = Boston )

> summary ( lm . fit )

Call :

lm ( formula = medv ∼ lstat + age , data = Boston )

Residuals :

Min
-15.98

1 Q Median
-1.28

-3.98

3 Q
1.97

Max
23.16

C o e f f i c i e n t s :

Estimate Std . Error t value Pr ( >| t |)

( Intercept )
lstat
age
---
Signif . codes :

33.2228
-1.0321
0.0345

0.7308
0.0482
0.0122

45.46
-21.42
2.83

<2e -16 ***
<2e -16 ***
0.0049 **

0 *** 0.001 ** 0.01 * 0.05 . 0.1

1

Residual standard error : 6.17 on 503 degrees of freedom
Multiple R - squared : 0.551 ,
F - statistic :

309 on 2 and 503 DF ,

Adjusted R - squared : 0.549

p - value : <2e -16

The Boston data set contains 13 variables, and so it would be cumbersome
to have to type all of these in order to perform a regression using all of the
predictors. Instead, we can use the following short-hand:
> lm . fit = lm ( medv∼. , data = Boston )

> summary ( lm . fit )

Call :

lm ( formula = medv ∼ . , data = Boston )

114

3. Linear Regression

Residuals :

Min
-15.594

1 Q
-2.730

Median
-0.518

3 Q
1.777

Max
26.199

C o e f f i c i e n t s :

Estimate Std . Error t value Pr ( >| t |)

( Intercept )
crim
zn
indus
chas
nox
rm
age
dis
rad
tax
ptratio
black
lstat
---
Signif . codes :

3.646 e +01
-1.080 e -01
4.642 e -02
2.056 e -02
2.687 e +00
-1.777 e +01
3.810 e +00
6.922 e -04
-1.476 e +00
3.060 e -01
-1.233 e -02
-9.527 e -01
9.312 e -03
-5.248 e -01

7.144 3.28 e -12 ***

-3.287 0.001087 **

3.382 0.000778 ***
0.334 0.738288
3.118 0.001925 **

5.103 e +00
3.286 e -02
1.373 e -02
6.150 e -02
8.616 e -01
3.820 e +00
4.179 e -01
1.321 e -02
1.995 e -01
6.635 e -02
3.761 e -03
1.308 e -01
2.686 e -03
5.072 e -02 -10.347

-4.651 4.25 e -06 ***
< 2e -16 ***

9.116
0.052 0.958229

-7.398 6.01 e -13 ***
4.613 5.07 e -06 ***

-3.280 0.001112 **
-7.283 1.31 e -12 ***
3.467 0.000573 ***
< 2e -16 ***

0 ‘*** ’ 0.001 ‘** ’ 0.01 ‘* ’ 0.05 ‘. ’ 0.1 ‘ ’ 1

Residual standard error : 4.745 on 492 degrees of freedom
Multiple R - Squared : 0.7406 ,
F - statistic : 108.1 on 13 and 492 DF ,

Adjusted R - squared : 0.7338

p - value : < 2.2 e -16

We can access the individual components of a summary object by name
(type ?summary.lm to see what is available). Hence summary(lm.fit)$r.sq
gives us the R2, and summary(lm.fit)$sigma gives us the RSE. The vif()
function, part of the car package, can be used to compute variance inﬂation
factors. Most VIF’s are low to moderate for this data. The car package is
not part of the base R installation so it must be downloaded the ﬁrst time
you use it via the install.packages option in R.

vif()

> library ( car )
> vif ( lm . fit )

crim
1.79
dis
3.96

zn
2.30
rad
7.48

indus
3.99

chas
1.07
tax ptratio
1.80

9.01

nox
4.39
black
1.35

rm
1.93
lstat
2.94

age
3.10

What if we would like to perform a regression using all of the variables but
one? For example, in the above regression output, age has a high p-value.
So we may wish to run a regression excluding this predictor. The following
syntax results in a regression using all predictors except age.
> lm . fit1 = lm ( medv∼. - age , data = Boston )

> summary ( lm . fit1 )
...

Alternatively, the update() function can be used.

update()

3.6 Lab: Linear Regression

115

> lm . fit1 = update ( lm . fit , ∼. - age )

3.6.4 Interaction Terms

It is easy to include interaction terms in a linear model using the lm() func-
tion. The syntax lstat:black tells R to include an interaction term between
lstat and black. The syntax lstat*age simultaneously includes lstat, age,
and the interaction term lstat×age as predictors; it is a shorthand for
lstat+age+lstat:age.
> summary ( lm ( medv∼lstat * age , data = Boston ) )

Call :

lm ( formula = medv ∼ lstat * age , data = Boston )

Residuals :

Min
-15.81

1 Q Median
-1.33

-4.04

3 Q
2.08

Max
27.55

C o e f f i c i e n t s :

Estimate Std . Error t value Pr ( >| t |)

( Intercept ) 36.088536
lstat
-1.392117
-0.000721
age
lstat : age
0.004156
---
Signif . codes :

1.469835
0.167456
0.019879
0.001852

24.55
-8.31
-0.04
2.24

< 2e -16 ***
8.8 e -16 ***

0.971
0.025 *

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

Residual standard error : 6.15 on 502 degrees of freedom
Multiple R - squared : 0.556 ,
F - statistic :

Adjusted R - squared : 0.553

209 on 3 and 502 DF ,

p - value : <2e -16

3.6.5 Non-linear Transformations of the Predictors

The lm() function can also accommodate non-linear transformations of the
predictors. For instance, given a predictor X, we can create a predictor X 2
using I(X^2). The function I() is needed since the ^ has a special meaning
in a formula; wrapping as we do allows the standard usage in R, which is
to raise X to the power 2. We now perform a regression of medv onto lstat
and lstat
> lm . fit2 = lm ( medv∼lstat + I ( lstat ^2) )

2.

I()

> summary ( lm . fit2 )

Call :

lm ( formula = medv ∼ lstat + I ( lstat ^2) )

Residuals :

Min
-15.28

1 Q Median
-0.53

-3.83

3 Q
2.31

Max
25.41

116

3. Linear Regression

C o e f f i c i e n t s :

Estimate Std . Error t value Pr ( >| t |)

( Intercept ) 42.86201
lstat
-2.33282
I ( lstat ^2)
0.04355
---
Signif . codes :

0.87208
0.12380
0.00375

49.1
-18.8
11.6

<2e -16 ***
<2e -16 ***
<2e -16 ***

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

Residual standard error : 5.52 on 503 degrees of freedom
Multiple R - squared : 0.641 ,
F - statistic :

Adjusted R - squared : 0.639

449 on 2 and 503 DF ,

p - value : <2e -16

The near-zero p-value associated with the quadratic term suggests that
it leads to an improved model. We use the anova() function to further
quantify the extent to which the quadratic ﬁt is superior to the linear ﬁt.
> lm . fit = lm ( medv∼lstat )

anova()

> anova ( lm . fit , lm . fit2 )
Analysis of Variance Table

Model 1: medv ∼ lstat
Model 2: medv ∼ lstat + I ( lstat ^2)

Res . Df

RSS Df Sum of Sq

F Pr ( > F )

504 19472
503 15347

1
2
---
Signif . codes :

1

4125 135 <2e -16 ***

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

Here Model 1 represents the linear submodel containing only one predictor,
lstat, while Model 2 corresponds to the larger quadratic model that has two
2. The anova() function performs a hypothesis
predictors, lstat and lstat
test comparing the two models. The null hypothesis is that the two models
ﬁt the data equally well, and the alternative hypothesis is that the full
model is superior. Here the F-statistic is 135 and the associated p-value is
virtually zero. This provides very clear evidence that the model containing
2 is far superior to the model that only
the predictors lstat and lstat
contains the predictor lstat. This is not surprising, since earlier we saw
evidence for non-linearity in the relationship between medv and lstat. If we
type

> par ( mfrow = c (2 ,2) )
> plot ( lm . fit2 )

then we see that when the lstat
little discernible pattern in the residuals.

2 term is included in the model, there is

In order to create a cubic ﬁt, we can include a predictor of the form
I(X^3). However, this approach can start to get cumbersome for higher-
order polynomials. A better approach involves using the poly() function
to create the polynomial within lm(). For example, the following command
produces a ﬁfth-order polynomial ﬁt:

poly()

3.6 Lab: Linear Regression

117

> lm . fit5 = lm ( medv∼poly ( lstat ,5) )

> summary ( lm . fit5 )

Call :

lm ( formula = medv ∼ poly ( lstat , 5) )

Residuals :

Min
-13.543

1 Q
-3.104

Median
-0.705

3 Q
2.084

Max
27.115

C o e f f i c i e n t s :

Estimate Std . Error t value Pr ( >| t |)

( Intercept )
22.533
poly ( lstat , 5) 1 -152.460
poly ( lstat , 5) 2
64.227
-27.051
poly ( lstat , 5) 3
25.452
poly ( lstat , 5) 4
poly ( lstat , 5) 5
-19.252
---
Signif . codes :

0.232
5.215
5.215
5.215
5.215
5.215

97.20
-29.24
12.32
-5.19
4.88
-3.69

< 2e -16 ***
< 2e -16 ***
< 2e -16 ***
3.1 e -07 ***
1.4 e -06 ***
0.00025 ***

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

Residual standard error : 5.21 on 500 degrees of freedom
Multiple R - squared : 0.682 ,
F - statistic :

Adjusted R - squared : 0.679

214 on 5 and 500 DF ,

p - value : <2e -16

This suggests that including additional polynomial terms, up to ﬁfth order,
leads to an improvement in the model ﬁt! However, further investigation of
the data reveals that no polynomial terms beyond ﬁfth order have signiﬁ-
cant p-values in a regression ﬁt.

Of course, we are in no way restricted to using polynomial transforma-

tions of the predictors. Here we try a log transformation.
> summary ( lm ( medv∼log ( rm ) , data = Boston ) )

...

3.6.6 Qualitative Predictors

We will now examine the Carseats data, which is part of the ISLR library.
We will attempt to predict Sales (child car seat sales) in 400 locations
based on a number of predictors.

> fix ( Carseats )
> names ( Carseats )

[1] " Sales "
[5] " Population "
[9] " Education "

" CompPrice "
" Price "
" Urban "

" Income "
" ShelveLoc "
" US "

" Advertisi n g "
" Age "

The Carseats data includes qualitative predictors such as Shelveloc, an in-
dicator of the quality of the shelving location—that is, the space within
a store in which the car seat is displayed—at each location. The pre-
dictor Shelveloc takes on three possible values, Bad, Medium, and Good.

118

3. Linear Regression

Given a qualitative variable such as Shelveloc, R generates dummy variables
automatically. Below we ﬁt a multiple regression model that includes some
interaction terms.
> lm . fit = lm ( Sales∼.+ Income : Advertisi ng + Price : Age , data = Carseats )

> summary ( lm . fit )

Call :

lm ( formula = Sales ∼ . + Income : Advertisin g + Price : Age , data =

Carseats )

Residuals :

Min

-2.921 -0.750

1 Q Median
0.018

3 Q
0.675

Max
3.341

C o e f f i c i e n t s :

( Intercept )
CompPrice
Income
Advertis i ng
Populatio n
Price
S h e l v e L o c G o o d
S h e l v e L o c M e d i u m
Age
Education
UrbanYes
USYes
Income : Advertisi n g
Price : Age
---
Signif . codes :

Estimate Std . Error t value Pr ( >| t |)
6.575565
0.092937
0.010894
0.070246
0.000159
-0.100806
4.848676
1.953262
-0.057947
-0.020852
0.140160
-0.157557
0.000751
0.000107

1.008747
0.004118
0.002604
0.022609
0.000368
0.007440
0.152838
0.125768
0.015951
0.019613
0.112402
0.148923
0.000278
0.000133

2.2 e -10 ***
< 2e -16 ***
3.6 e -05 ***
0.00203 **
0.66533
< 2e -16 ***
< 2e -16 ***
< 2e -16 ***
0.00032 ***
0.28836
0.21317
0.29073
0.00729 **
0.42381

6.52
22.57
4.18
3.11
0.43
-13.55
31.72
15.53
-3.63
-1.06
1.25
-1.06
2.70
0.80

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

Residual standard error : 1.01 on 386 degrees of freedom
Multiple R - squared : 0.876 ,
F - statistic :

210 on 13 and 386 DF ,

Adjusted R - squared : 0.872

p - value : <2e -16

The contrasts() function returns the coding that R uses for the dummy
variables.

contrasts()

> attach ( Carseats )
> contrasts ( ShelveLoc )

Bad
Good
Medium

Good Medium
0
0
1

0
1
0

Use ?contrasts to learn about other contrasts, and how to set them.

R has created a ShelveLocGood dummy variable that takes on a value of
1 if the shelving location is good, and 0 otherwise. It has also created a
ShelveLocMedium dummy variable that equals 1 if the shelving location is
medium, and 0 otherwise. A bad shelving location corresponds to a zero
for each of the two dummy variables. The fact that the coeﬃcient for

3.6 Lab: Linear Regression

119

ShelveLocGood in the regression output is positive indicates that a good
shelving location is associated with high sales (relative to a bad location).
And ShelveLocMedium has a smaller positive coeﬃcient, indicating that a
medium shelving location leads to higher sales than a bad shelving location
but lower sales than a good shelving location.

3.6.7 Writing Functions

As we have seen, R comes with many useful functions, and still more func-
tions are available by way of R libraries. However, we will often be inter-
ested in performing an operation for which no function is available. In this
setting, we may want to write our own function. For instance, below we
provide a simple function that reads in the ISLR and MASS libraries, called
LoadLibraries(). Before we have created the function, R returns an error if
we try to call it.

> L o a d L i b r a r i e s
Error : object ’ LoadLibraries ’ not found
> L o a d L i b r a r i e s ()
Error : could not find function " L o a d L i b r a r i e s "

We now create the function. Note that the + symbols are printed by R and
should not be typed in. The { symbol informs R that multiple commands
are about to be input. Hitting Enter after typing { will cause R to print the
+ symbol. We can then input as many commands as we wish, hitting Enter
after each one. Finally the } symbol informs R that no further commands
will be entered.

> L o a d L i b r a r i e s = function () {
+ library ( ISLR )
+ library ( MASS )
+ print (" The libraries have been loaded .")
+ }

Now if we type in LoadLibraries, R will tell us what is in the function.

> L o a d L i b r a r i e s
function () {
library ( ISLR )
library ( MASS )
print (" The libraries have been loaded .")
}

If we call the function, the libraries are loaded in and the print statement
is output.

> L o a d L i b r a r i e s ()
[1] " The libraries have been loaded ."

120

3. Linear Regression

3.7 Exercises

Conceptual

1. Describe the null hypotheses to which the p-values given in Table 3.4
correspond. Explain what conclusions you can draw based on these
p-values. Your explanation should be phrased in terms of sales, TV,
radio, and newspaper, rather than in terms of the coeﬃcients of the
linear model.

2. Carefully explain the diﬀerences between the KNN classiﬁer and KNN

regression methods.

3. Suppose we have a data set with ﬁve predictors, X1 = GPA, X2 = IQ,
X3 = Gender (1 for Female and 0 for Male), X4 = Interaction between
GPA and IQ, and X5 = Interaction between GPA and Gender. The
response is starting salary after graduation (in thousands of dollars).
Suppose we use least squares to ﬁt the model, and get ˆβ0 = 50, ˆβ1 =
20, ˆβ2 = 0.07, ˆβ3 = 35, ˆβ4 = 0.01, ˆβ5 = −10.

(a) Which answer is correct, and why?

i. For a ﬁxed value of IQ and GPA, males earn more on average

than females.

ii. For a ﬁxed value of IQ and GPA, females earn more on

average than males.

iii. For a ﬁxed value of IQ and GPA, males earn more on average

than females provided that the GPA is high enough.

iv. For a ﬁxed value of IQ and GPA, females earn more on
average than males provided that the GPA is high enough.

(b) Predict the salary of a female with IQ of 110 and a GPA of 4.0.

(c) True or false: Since the coeﬃcient for the GPA/IQ interaction
term is very small, there is very little evidence of an interaction
eﬀect. Justify your answer.

4. I collect a set of data (n = 100 observations) containing a single
predictor and a quantitative response. I then ﬁt a linear regression
model to the data, as well as a separate cubic regression, i.e. Y =
β0 + β1X + β2X 2 + β3X 3 + .

(a) Suppose that the true relationship between X and Y is linear,
i.e. Y = β0 + β1X + . Consider the training residual sum of
squares (RSS) for the linear regression, and also the training
RSS for the cubic regression. Would we expect one to be lower
than the other, would we expect them to be the same, or is there
not enough information to tell? Justify your answer.

3.7 Exercises

121

(b) Answer (a) using test rather than training RSS.

(c) Suppose that the true relationship between X and Y is not linear,
but we don’t know how far it is from linear. Consider the training
RSS for the linear regression, and also the training RSS for the
cubic regression. Would we expect one to be lower than the
other, would we expect them to be the same, or is there not
enough information to tell? Justify your answer.

(d) Answer (c) using test rather than training RSS.

5. Consider the ﬁtted values that result from performing linear regres-
sion without an intercept. In this setting, the ith ﬁtted value takes
the form

where

ˆyi = xi ˆβ,
(cid:31)

 

n(cid:17)

xiyi

/

i(cid:2)=1

(cid:31)

n(cid:17)

i=1

 

x2
i(cid:2)

.

ˆβ =

(3.38)

Show that we can write

n(cid:17)

i(cid:2)=1

ˆyi =

ai(cid:2)yi(cid:2) .

What is ai(cid:2) ?

Note: We interpret this result by saying that the ﬁtted values from
linear regression are linear combinations of the response values.

6. Using (3.4), argue that in the case of simple linear regression, the

least squares line always passes through the point (¯x, ¯y).

7. It is claimed in the text that in the case of simple linear regression
of Y onto X, the R2 statistic (3.17)
is equal to the square of the
correlation between X and Y (3.18). Prove that this is the case. For
simplicity, you may assume that ¯x = ¯y = 0.

Applied

8. This question involves the use of simple linear regression on the Auto

data set.

(a) Use the lm() function to perform a simple linear regression with
mpg as the response and horsepower as the predictor. Use the
summary() function to print the results. Comment on the output.
For example:

122

3. Linear Regression

i. Is there a relationship between the predictor and the re-

sponse?

ii. How strong is the relationship between the predictor and

the response?

iii. Is the relationship between the predictor and the response

positive or negative?

iv. What is the predicted mpg associated with a horsepower of
98? What are the associated 95 % conﬁdence and prediction
intervals?

(b) Plot the response and the predictor. Use the abline() function

to display the least squares regression line.

(c) Use the plot() function to produce diagnostic plots of the least
squares regression ﬁt. Comment on any problems you see with
the ﬁt.

9. This question involves the use of multiple linear regression on the

Auto data set.

(a) Produce a scatterplot matrix which includes all of the variables

in the data set.

(b) Compute the matrix of correlations between the variables using
the function cor(). You will need to exclude the name variable,
which is qualitative.

cor()

(c) Use the lm() function to perform a multiple linear regression
with mpg as the response and all other variables except name as
the predictors. Use the summary() function to print the results.
Comment on the output. For instance:

i. Is there a relationship between the predictors and the re-

sponse?

ii. Which predictors appear to have a statistically signiﬁcant

relationship to the response?

iii. What does the coeﬃcient for the year variable suggest?

(d) Use the plot() function to produce diagnostic plots of the linear
regression ﬁt. Comment on any problems you see with the ﬁt.
Do the residual plots suggest any unusually large outliers? Does
the leverage plot identify any observations with unusually high
leverage?

(e) Use the * and : symbols to ﬁt linear regression models with
interaction eﬀects. Do any interactions appear to be statistically
signiﬁcant?
√
X, X 2. Comment on your ﬁndings.

(f) Try a few diﬀerent transformations of the variables, such as

log(X),

10. This question should be answered using the Carseats data set.

3.7 Exercises

123

(a) Fit a multiple regression model to predict Sales using Price,

Urban, and US.

(b) Provide an interpretation of each coeﬃcient in the model. Be

careful—some of the variables in the model are qualitative!

(c) Write out the model in equation form, being careful to handle

the qualitative variables properly.

(d) For which of the predictors can you reject the null hypothesis

H0 : βj = 0?

(e) On the basis of your response to the previous question, ﬁt a
smaller model that only uses the predictors for which there is
evidence of association with the outcome.

(f) How well do the models in (a) and (e) ﬁt the data?
(g) Using the model from (e), obtain 95 % conﬁdence intervals for

the coeﬃcient(s).

(h) Is there evidence of outliers or high leverage observations in the

model from (e)?

11. In this problem we will investigate the t-statistic for the null hypoth-
esis H0 : β = 0 in simple linear regression without an intercept. To
begin, we generate a predictor x and a response y as follows.

> set . seed (1)
> x = rnorm (100)
> y =2* x + rnorm (100)

(a) Perform a simple linear regression of y onto x, without an in-
tercept. Report the coeﬃcient estimate ˆβ, the standard error of
this coeﬃcient estimate, and the t-statistic and p-value associ-
ated with the null hypothesis H0 : β = 0. Comment on these
results. (You can perform regression without an intercept using
the command lm(y∼x+0).)

(b) Now perform a simple linear regression of x onto y without an
intercept, and report the coeﬃcient estimate, its standard error,
and the corresponding t-statistic and p-values associated with
the null hypothesis H0 : β = 0. Comment on these results.

(c) What is the relationship between the results obtained in (a) and

(b)?

(d) For the regression of Y onto X without an intercept, the t-
statistic for H0 : β = 0 takes the form ˆβ/SE( ˆβ), where ˆβ is
given by (3.38), and where

!(cid:10)
(n − 1)

n

SE( ˆβ) =

i=1(yi − xi ˆβ)2
n
i(cid:2)=1 x2
i(cid:2)

(cid:10)

.

124

3. Linear Regression

(These formulas are slightly diﬀerent from those given in Sec-
tions 3.1.1 and 3.1.2, since here we are performing regression
without an intercept.) Show algebraically, and conﬁrm numeri-
cally in R, that the t-statistic can be written as

√
n − 1)
(cid:10)
(
n
n
i(cid:2)=1 y2
i=1 x2
i )(

(cid:10)
n
(cid:10)
i=1 xiyi
i(cid:2) ) − (
n
i(cid:2)=1 xi(cid:2) yi(cid:2) )2

(cid:22)
(cid:10)
(

.

(e) Using the results from (d), argue that the t-statistic for the re-
gression of y onto x is the same as the t-statistic for the regression
of x onto y.

(f) In R, show that when regression is performed with an intercept,
the t-statistic for H0 : β1 = 0 is the same for the regression of y
onto x as it is for the regression of x onto y.

12. This problem involves simple linear regression without an intercept.

(a) Recall that the coeﬃcient estimate ˆβ for the linear regression of
Y onto X without an intercept is given by (3.38). Under what
circumstance is the coeﬃcient estimate for the regression of X
onto Y the same as the coeﬃcient estimate for the regression of
Y onto X?

(b) Generate an example in R with n = 100 observations in which
the coeﬃcient estimate for the regression of X onto Y is diﬀerent
from the coeﬃcient estimate for the regression of Y onto X.

(c) Generate an example in R with n = 100 observations in which
the coeﬃcient estimate for the regression of X onto Y is the
same as the coeﬃcient estimate for the regression of Y onto X.

13. In this exercise you will create some simulated data and will ﬁt simple
linear regression models to it. Make sure to use set.seed(1) prior to
starting part (a) to ensure consistent results.

(a) Using the rnorm() function, create a vector, x, containing 100
observations drawn from a N (0, 1) distribution. This represents
a feature, X.

(b) Using the rnorm() function, create a vector, eps, containing 100
observations drawn from a N (0, 0.25) distribution i.e. a normal
distribution with mean zero and variance 0.25.

(c) Using x and eps, generate a vector y according to the model

Y = −1 + 0.5X + .

(3.39)

What is the length of the vector y? What are the values of β0
and β1 in this linear model?

3.7 Exercises

125

(d) Create a scatterplot displaying the relationship between x and

y. Comment on what you observe.

(e) Fit a least squares linear model to predict y using x. Comment
on the model obtained. How do ˆβ0 and ˆβ1 compare to β0 and
β1?

(f) Display the least squares line on the scatterplot obtained in (d).
Draw the population regression line on the plot, in a diﬀerent
color. Use the legend() command to create an appropriate leg-
end.

(g) Now ﬁt a polynomial regression model that predicts y using x
and x2. Is there evidence that the quadratic term improves the
model ﬁt? Explain your answer.

(h) Repeat (a)–(f) after modifying the data generation process in
such a way that there is less noise in the data. The model (3.39)
should remain the same. You can do this by decreasing the vari-
ance of the normal distribution used to generate the error term
 in (b). Describe your results.

(i) Repeat (a)–(f) after modifying the data generation process in
such a way that there is more noise in the data. The model
(3.39) should remain the same. You can do this by increasing
the variance of the normal distribution used to generate the
error term  in (b). Describe your results.

(j) What are the conﬁdence intervals for β0 and β1 based on the
original data set, the noisier data set, and the less noisy data
set? Comment on your results.

14. This problem focuses on the collinearity problem.

(a) Perform the following commands in R:

> set . seed (1)
> x1 = runif (100)
> x2 =0.5* x1 + rnorm (100) /10
> y =2+2* x1 +0.3* x2 + rnorm (100)

The last line corresponds to creating a linear model in which y is
a function of x1 and x2. Write out the form of the linear model.
What are the regression coeﬃcients?

(b) What is the correlation between x1 and x2? Create a scatterplot

displaying the relationship between the variables.

(c) Using this data, ﬁt a least squares regression to predict y using
x1 and x2. Describe the results obtained. What are ˆβ0, ˆβ1, and
ˆβ2? How do these relate to the true β0, β1, and β2? Can you
reject the null hypothesis H0 : β1 = 0? How about the null
hypothesis H0 : β2 = 0?

126

3. Linear Regression

(d) Now ﬁt a least squares regression to predict y using only x1.
Comment on your results. Can you reject the null hypothesis
H0 : β1 = 0?

(e) Now ﬁt a least squares regression to predict y using only x2.
Comment on your results. Can you reject the null hypothesis
H0 : β1 = 0?

(f) Do the results obtained in (c)–(e) contradict each other? Explain

your answer.

(g) Now suppose we obtain one additional observation, which was

unfortunately mismeasured.

> x1 = c ( x1 , 0.1)
> x2 = c ( x2 , 0.8)
> y = c (y ,6)

Re-ﬁt the linear models from (c) to (e) using this new data. What
eﬀect does this new observation have on the each of the models?
In each model, is this observation an outlier? A high-leverage
point? Both? Explain your answers.

15. This problem involves the Boston data set, which we saw in the lab
for this chapter. We will now try to predict per capita crime rate
using the other variables in this data set. In other words, per capita
crime rate is the response, and the other variables are the predictors.

(a) For each predictor, ﬁt a simple linear regression model to predict
the response. Describe your results. In which of the models is
there a statistically signiﬁcant association between the predictor
and the response? Create some plots to back up your assertions.

(b) Fit a multiple regression model to predict the response using
all of the predictors. Describe your results. For which predictors
can we reject the null hypothesis H0 : βj = 0?

(c) How do your results from (a) compare to your results from (b)?
Create a plot displaying the univariate regression coeﬃcients
from (a) on the x-axis, and the multiple regression coeﬃcients
from (b) on the y-axis. That is, each predictor is displayed as a
single point in the plot. Its coeﬃcient in a simple linear regres-
sion model is shown on the x-axis, and its coeﬃcient estimate
in the multiple linear regression model is shown on the y-axis.

(d) Is there evidence of non-linear association between any of the
predictors and the response? To answer this question, for each
predictor X, ﬁt a model of the form

Y = β0 + β1X + β2X 2 + β3X 3 + .

4
Classiﬁcation

The linear regression model discussed in Chapter 3 assumes that the re-
sponse variable Y is quantitative. But in many situations, the response
variable is instead qualitative. For example, eye color is qualitative, taking
on values blue, brown, or green. Often qualitative variables are referred
to as categorical ; we will use these terms interchangeably. In this chapter,
we study approaches for predicting qualitative responses, a process that
is known as classiﬁcation. Predicting a qualitative response for an obser-
vation can be referred to as classifying that observation, since it involves
assigning the observation to a category, or class. On the other hand, often
the methods used for classiﬁcation ﬁrst predict the probability of each of
the categories of a qualitative variable, as the basis for making the classi-
ﬁcation. In this sense they also behave like regression methods.

There are many possible classiﬁcation techniques, or classiﬁers, that one
might use to predict a qualitative response. We touched on some of these
in Sections 2.1.5 and 2.2.3. In this chapter we discuss three of the most
widely-used classiﬁers: logistic regression, linear discriminant analysis, and
K-nearest neighbors. We discuss more computer-intensive methods in later
chapters, such as generalized additive models (Chapter 7), trees, random
forests, and boosting (Chapter 8), and support vector machines (Chap-
ter 9).

qualitative

classiﬁcation

classiﬁer

logistic
regression

linear
discriminant
analysis

K-nearest
neighbors

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 4,
© Springer Science+Business Media New York 2013

127

128

4. Classiﬁcation

4.1 An Overview of Classiﬁcation

Classiﬁcation problems occur often, perhaps even more so than regression
problems. Some examples include:

1. A person arrives at the emergency room with a set of symptoms
that could possibly be attributed to one of three medical conditions.
Which of the three conditions does the individual have?

2. An online banking service must be able to determine whether or not
a transaction being performed on the site is fraudulent, on the basis
of the user’s IP address, past transaction history, and so forth.

3. On the basis of DNA sequence data for a number of patients with
and without a given disease, a biologist would like to ﬁgure out which
DNA mutations are deleterious (disease-causing) and which are not.

Just as in the regression setting, in the classiﬁcation setting we have a
set of training observations (x1, y1), . . . , (xn, yn) that we can use to build
a classiﬁer. We want our classiﬁer to perform well not only on the training
data, but also on test observations that were not used to train the classiﬁer.
In this chapter, we will illustrate the concept of classiﬁcation using the
simulated Default data set. We are interested in predicting whether an
individual will default on his or her credit card payment, on the basis of
annual income and monthly credit card balance. The data set is displayed
in Figure 4.1. We have plotted annual income and monthly credit card
balance for a subset of 10, 000 individuals. The left-hand panel of Figure 4.1
displays individuals who defaulted in a given month in orange, and those
who did not in blue. (The overall default rate is about 3 %, so we have
plotted only a fraction of the individuals who did not default.) It appears
that individuals who defaulted tended to have higher credit card balances
than those who did not. In the right-hand panel of Figure 4.1, two pairs
of boxplots are shown. The ﬁrst shows the distribution of balance split by
the binary default variable; the second is a similar plot for income. In this
chapter, we learn how to build a model to predict default (Y ) for any
given value of balance (X1) and income (X2). Since Y is not quantitative,
the simple linear regression model of Chapter 3 is not appropriate.

It is worth noting that Figure 4.1 displays a very pronounced relation-
ship between the predictor balance and the response default. In most real
applications, the relationship between the predictor and the response will
not be nearly so strong. However, for the sake of illustrating the classiﬁca-
tion procedures discussed in this chapter, we use an example in which the
relationship between the predictor and the response is somewhat exagger-
ated.

e
m
o
c
n
I

0
0
0
0
6

0
0
0
0
4

0
0
0
0
2

0

4.2 Why Not Linear Regression?

129

e
c
n
a
a
B

l

0
0
5
2

0
0
0
2

0
0
5
1

0
0
0
1

0
0
5

0

e
m
o
c
n
I

0
0
0
0
6

0
0
0
0
4

0
0
0
0
2

0

0

500

1000

1500
Balance

2000

2500

Yes
No
Default

Yes
No
Default

FIGURE 4.1. The Default data set. Left: The annual incomes and monthly
credit card balances of a number of individuals. The individuals who defaulted on
their credit card payments are shown in orange, and those who did not are shown
in blue. Center: Boxplots of balance as a function of default status. Right:
Boxplots of income as a function of default status.

4.2 Why Not Linear Regression?

We have stated that linear regression is not appropriate in the case of a
qualitative response. Why not?

Suppose that we are trying to predict the medical condition of a patient
in the emergency room on the basis of her symptoms. In this simpliﬁed
example, there are three possible diagnoses: stroke, drug overdose, and
epileptic seizure. We could consider encoding these values as a quantita-
tive response variable, Y , as follows:

⎧⎪⎨
⎪⎩

Y =

1 if stroke;
2 if drug overdose;
3 if epileptic seizure.

Using this coding, least squares could be used to ﬁt a linear regression model
to predict Y on the basis of a set of predictors X1, . . . , Xp. Unfortunately,
this coding implies an ordering on the outcomes, putting drug overdose in
between stroke and epileptic seizure, and insisting that the diﬀerence
between stroke and drug overdose is the same as the diﬀerence between
drug overdose and epileptic seizure. In practice there is no particular
reason that this needs to be the case. For instance, one could choose an
equally reasonable coding,

⎧⎪⎨
⎪⎩

Y =

1 if epileptic seizure;
2 if stroke;
3 if drug overdose.

130

4. Classiﬁcation

which would imply a totally diﬀerent relationship among the three condi-
tions. Each of these codings would produce fundamentally diﬀerent linear
models that would ultimately lead to diﬀerent sets of predictions on test
observations.

If the response variable’s values did take on a natural ordering, such as
mild, moderate, and severe, and we felt the gap between mild and moderate
was similar to the gap between moderate and severe, then a 1, 2, 3 coding
would be reasonable. Unfortunately, in general there is no natural way to
convert a qualitative response variable with more than two levels into a
quantitative response that is ready for linear regression.

For a binary (two level) qualitative response, the situation is better. For
instance, perhaps there are only two possibilities for the patient’s med-
ical condition: stroke and drug overdose. We could then potentially use
the dummy variable approach from Section 3.3.1 to code the response as
follows:

(cid:30)

binary

Y =

0 if stroke;
1 if drug overdose.

We could then ﬁt a linear regression to this binary response, and predict
drug overdose if ˆY > 0.5 and stroke otherwise. In the binary case it is not
hard to show that even if we ﬂip the above coding, linear regression will
produce the same ﬁnal predictions.

For a binary response with a 0/1 coding as above, regression by least
squares does make sense; it can be shown that the X ˆβ obtained using linear
regression is in fact an estimate of Pr(drug overdose|X) in this special
case. However, if we use linear regression, some of our estimates might be
outside the [0, 1] interval (see Figure 4.2), making them hard to interpret
as probabilities! Nevertheless, the predictions provide an ordering and can
be interpreted as crude probability estimates. Curiously, it turns out that
the classiﬁcations that we get if we use linear regression to predict a binary
response will be the same as for the linear discriminant analysis (LDA)
procedure we discuss in Section 4.4.

However, the dummy variable approach cannot be easily extended to
accommodate qualitative responses with more than two levels. For these
reasons, it is preferable to use a classiﬁcation method that is truly suited
for qualitative response values, such as the ones presented next.

4.3 Logistic Regression

Consider again the Default data set, where the response default falls into
one of two categories, Yes or No. Rather than modeling this response Y
directly, logistic regression models the probability that Y belongs to a par-
ticular category.

t
l

f

u
a
e
D

 
f

o
 
y
t
i
l
i

b
a
b
o
r
P

0
.
1

8
.
0

6
.
0

4
.
0

2
.
0

0
.
0

|

|

|

|
|
|

|
|
|

|

||
|
|
|
|
|
|

|
|
|
|

|
|
|
|

|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|

|
|
|

|
|
|
|
|

|

|
|

|

|
|

|

|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|| | |
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
||
|
|
|
|||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
| |
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| | |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|||
|
|
||
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|||
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
| |
|
| |
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
| ||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
||
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
||
|
|
| |
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
|
|
||
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
| |
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
|
|
||
|
|
|
| | |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
||
|
|||
|
| |
|
|
|
| |
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
||
| |
| |
|||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
| |
||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
| |
| |
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
| |
|
||
| |
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
| |
|
| |
||
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|| |
| |
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| | |
|
|
|
|
|
|
|
|
||
|
|
||
|
||
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
| ||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
||
||
|
||
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| ||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
| |
|
|
|
|
|
|
|
||
|
|
| |
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|| ||
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
||
|
|
||
|
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| | |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
||
|
||
|
|
||
|
|
|
|
|
||
|
|
|
|
|||
|
||
| |
|
|
|
|
|
|
|||
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|||
||
|
| |
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
| |
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| | |
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|

|
|

|
|
|
|

|
|
|
|
|

|

|

|

|

|
|

t
l

f

u
a
e
D

 
f

o

 
y
t
i
l
i

b
a
b
o
r
P

0
.
1

8
.
0

6
.
0

4
.
0

2
.
0

0
.
0

4.3 Logistic Regression

131

|

|

|

|
|
|

|
|
|

|

||
|
|
|
|
|
|

|
|
|
|

|
|
|
|

|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|

|
|
|

|
|
|
|
|

|

|
|

|

|
|

|

|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|| | |
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
||
|
|
|
|||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
| |
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| | |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|||
|
|
||
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|||
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
| |
|
| |
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
| ||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
||
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
||
|
|
| |
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
|
|
||
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
| |
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
|
|
||
|
|
|
| | |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
||
|
|||
|
| |
|
|
|
| |
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
||
| |
| |
|||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
| |
||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
| |
| |
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
| |
|
||
| |
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
| |
|
| |
||
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|| |
| |
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| | |
|
|
|
|
|
|
|
|
||
|
|
||
|
||
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
| ||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
||
||
||
|
||
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| ||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
| |
|
|
||
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
| |
|
|
|
|
|
|
|
||
|
|
| |
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|| ||
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
||
|
|
||
|
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| | |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
||
|
||
|
|
||
|
|
|
|
|
||
|
|
|
|
|||
|
||
| |
|
|
|
|
|
|
|||
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|||
||
|
| |
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
| |
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| | |
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|

|
|

|
|
|
|

|
|
|
|
|

|

|

|

|

|
|

0

500

1000

1500

2000

2500

0

500

1000

1500

2000

2500

Balance

Balance

FIGURE 4.2. Classiﬁcation using the Default data. Left: Estimated probabil-
ity of default using linear regression. Some estimated probabilities are negative!
The orange ticks indicate the 0/1 values coded for default(No or Yes). Right:
Predicted probabilities of default using logistic regression. All probabilities lie
between 0 and 1.

For the Default data, logistic regression models the probability of default.

For example, the probability of default given balance can be written as

Pr(default = Yes|balance).

The values

of Pr(default = Yes|balance), which we

abbreviate
p(balance), will range between 0 and 1. Then for any given value of balance,
a prediction can be made for default. For example, one might predict
default = Yes for any individual for whom p(balance) > 0.5. Alterna-
tively, if a company wishes to be conservative in predicting individuals who
are at risk for default, then they may choose to use a lower threshold, such
as p(balance) > 0.1.

4.3.1 The Logistic Model
How should we model the relationship between p(X) = Pr(Y = 1|X) and
X? (For convenience we are using the generic 0/1 coding for the response).
In Section 4.2 we talked of using a linear regression model to represent
these probabilities:

p(X) = β0 + β1X.

(4.1)

If we use this approach to predict default=Yes using balance, then we
obtain the model shown in the left-hand panel of Figure 4.2. Here we see
the problem with this approach: for balances close to zero we predict a
negative probability of default; if we were to predict for very large balances,
we would get values bigger than 1. These predictions are not sensible, since
of course the true probability of default, regardless of credit card balance,
must fall between 0 and 1. This problem is not unique to the credit default
data. Any time a straight line is ﬁt to a binary response that is coded as

132

4. Classiﬁcation

0 or 1, in principle we can always predict p(X) < 0 for some values of X
and p(X) > 1 for others (unless the range of X is limited).

To avoid this problem, we must model p(X) using a function that gives
outputs between 0 and 1 for all values of X. Many functions meet this
description. In logistic regression, we use the logistic function,

p(X) =

eβ0+β1X

1 + eβ0+β1X .

(4.2)

To ﬁt the model (4.2), we use a method called maximum likelihood, which
we discuss in the next section. The right-hand panel of Figure 4.2 illustrates
the ﬁt of the logistic regression model to the Default data. Notice that for
low balances we now predict the probability of default as close to, but never
below, zero. Likewise, for high balances we predict a default probability
close to, but never above, one. The logistic function will always produce
an S-shaped curve of this form, and so regardless of the value of X, we
will obtain a sensible prediction. We also see that the logistic model is
better able to capture the range of probabilities than is the linear regression
model in the left-hand plot. The average ﬁtted probability in both cases is
0.0333 (averaged over the training data), which is the same as the overall
proportion of defaulters in the data set.

After a bit of manipulation of (4.2), we ﬁnd that

p(X)
1 − p(X)

= eβ0+β1X .

(4.3)
The quantity p(X)/[1− p(X)] is called the odds, and can take on any value
between 0 and ∞. Values of the odds close to 0 and ∞ indicate very low
and very high probabilities of default, respectively. For example, on average
1 in 5 people with an odds of 1/4 will default, since p(X) = 0.2 implies an
0.2
1−0.2 = 1/4. Likewise on average nine out of every ten people with
odds of
0.9
1−0.9 = 9.
an odds of 9 will default, since p(X) = 0.9 implies an odds of
Odds are traditionally used instead of probabilities in horse-racing, since
they relate more naturally to the correct betting strategy.

logistic
function

maximum
likelihood

odds

By taking the logarithm of both sides of (4.3), we arrive at

(cid:11)

(cid:12)

log

p(X)
1 − p(X)

= β0 + β1X.

(4.4)

The left-hand side is called the log-odds or logit. We see that the logistic
regression model (4.2) has a logit that is linear in X.

Recall from Chapter 3 that in a linear regression model, β1 gives the
average change in Y associated with a one-unit increase in X. In contrast,
in a logistic regression model, increasing X by one unit changes the log odds
by β1 (4.4), or equivalently it multiplies the odds by eβ1 (4.3). However,
because the relationship between p(X) and X in (4.2) is not a straight line,

log-odds

logit

4.3 Logistic Regression

133

β1 does not correspond to the change in p(X) associated with a one-unit
increase in X. The amount that p(X) changes due to a one-unit change in
X will depend on the current value of X. But regardless of the value of X,
if β1 is positive then increasing X will be associated with increasing p(X),
and if β1 is negative then increasing X will be associated with decreasing
p(X). The fact that there is not a straight-line relationship between p(X)
and X, and the fact that the rate of change in p(X) per unit change in X
depends on the current value of X, can also be seen by inspection of the
right-hand panel of Figure 4.2.

4.3.2 Estimating the Regression Coeﬃcients

The coeﬃcients β0 and β1 in (4.2) are unknown, and must be estimated
based on the available training data. In Chapter 3, we used the least squares
approach to estimate the unknown linear regression coeﬃcients. Although
we could use (non-linear) least squares to ﬁt the model (4.4), the more
general method of maximum likelihood is preferred, since it has better sta-
tistical properties. The basic intuition behind using maximum likelihood
to ﬁt a logistic regression model is as follows: we seek estimates for β0 and
β1 such that the predicted probability ˆp(xi) of default for each individual,
using (4.2), corresponds as closely as possible to the individual’s observed
default status. In other words, we try to ﬁnd ˆβ0 and ˆβ1 such that plugging
these estimates into the model for p(X), given in (4.2), yields a number
close to one for all individuals who defaulted, and a number close to zero
for all individuals who did not. This intuition can be formalized using a
mathematical equation called a likelihood function:

&

&

(cid:6)(β0, β1) =

p(xi)

i:yi=1

i(cid:2):yi(cid:2) =0

(1 − p(xi(cid:2) )).

likelihood
function

(4.5)

The estimates ˆβ0 and ˆβ1 are chosen to maximize this likelihood function.
Maximum likelihood is a very general approach that is used to ﬁt many
of the non-linear models that we examine throughout this book. In the
linear regression setting, the least squares approach is in fact a special case
of maximum likelihood. The mathematical details of maximum likelihood
are beyond the scope of this book. However, in general, logistic regression
and other models can be easily ﬁt using a statistical software package such
as R, and so we do not need to concern ourselves with the details of the
maximum likelihood ﬁtting procedure.

Table 4.1 shows the coeﬃcient estimates and related information that
result from ﬁtting a logistic regression model on the Default data in order
to predict the probability of default=Yes using balance. We see that ˆβ1 =
0.0055; this indicates that an increase in balance is associated with an
increase in the probability of default. To be precise, a one-unit increase in
balance is associated with an increase in the log odds of default by 0.0055
units.

134

4. Classiﬁcation

Intercept
balance

Coeﬃcient
−10.6513
0.0055

Std. error Z-statistic

0.3612
0.0002

P-value
−29.5 <0.0001
24.9 <0.0001

TABLE 4.1. For the Default data, estimated coeﬃcients of the logistic regres-
sion model that predicts the probability of default using balance. A one-unit
increase in balance is associated with an increase in the log odds of default by
0.0055 units.

Many aspects of the logistic regression output shown in Table 4.1 are
similar to the linear regression output of Chapter 3. For example, we can
measure the accuracy of the coeﬃcient estimates by computing their stan-
dard errors. The z-statistic in Table 4.1 plays the same role as the t-statistic
in the linear regression output, for example in Table 3.1 on page 68. For
instance, the z-statistic associated with β1 is equal to ˆβ1/SE( ˆβ1), and so a
large (absolute) value of the z-statistic indicates evidence against the null
hypothesis H0 : β1 = 0. This null hypothesis implies that p(X) = eβ0
1+eβ0 —
in other words, that the probability of default does not depend on balance.
Since the p-value associated with balance in Table 4.1 is tiny, we can reject
H0. In other words, we conclude that there is indeed an association between
balance and probability of default. The estimated intercept in Table 4.1
is typically not of interest; its main purpose is to adjust the average ﬁtted
probabilities to the proportion of ones in the data.

4.3.3 Making Predictions

Once the coeﬃcients have been estimated, it is a simple matter to compute
the probability of default for any given credit card balance. For example,
using the coeﬃcient estimates given in Table 4.1, we predict that the default
probability for an individual with a balance of $1, 000 is

ˆp(X) =

e ˆβ0+ ˆβ1X

1 + e ˆβ0+ ˆβ1X

=

−10.6513+0.0055×1,000

e

1 + e−10.6513+0.0055×1,000 = 0.00576,

which is below 1 %. In contrast, the predicted probability of default for an
individual with a balance of $2, 000 is much higher, and equals 0.586 or
58.6 %.

One can use qualitative predictors with the logistic regression model
using the dummy variable approach from Section 3.3.1. As an example,
the Default data set contains the qualitative variable student. To ﬁt the
model we simply create a dummy variable that takes on a value of 1 for
students and 0 for non-students. The logistic regression model that results
from predicting probability of default from student status can be seen in
Table 4.2. The coeﬃcient associated with the dummy variable is positive,

4.3 Logistic Regression

135

Intercept
student[Yes]

Coeﬃcient
−3.5041
0.4049

Std. error Z-statistic

0.0707
0.1150

P-value
−49.55 <0.0001
0.0004

3.52

TABLE 4.2. For the Default data, estimated coeﬃcients of the logistic regres-
sion model that predicts the probability of default using student status. Student
status is encoded as a dummy variable, with a value of 1 for a student and a value
of 0 for a non-student, and represented by the variable student[Yes] in the table.

and the associated p-value is statistically signiﬁcant. This indicates that
students tend to have higher default probabilities than non-students:

(cid:23)Pr(default=Yes|student=Yes) =
(cid:23)Pr(default=Yes|student=No) =

e

e

−3.5041+0.4049×1

1 + e−3.5041+0.4049×1 = 0.0431,

−3.5041+0.4049×0

1 + e−3.5041+0.4049×0 = 0.0292.

4.3.4 Multiple Logistic Regression

We now consider the problem of predicting a binary response using multiple
predictors. By analogy with the extension from simple to multiple linear
regression in Chapter 3, we can generalize (4.4) as follows:

(cid:11)

(cid:12)

log

p(X)
1 − p(X)

= β0 + β1X1 + ··· + βpXp,

(4.6)

where X = (X1, . . . , Xp) are p predictors. Equation 4.6 can be rewritten as

p(X) =

eβ0+β1X1+···+βpXp
1 + eβ0+β1X1+···+βpXp

.

(4.7)

Just as in Section 4.3.2, we use the maximum likelihood method to estimate
β0, β1, . . . , βp.

Table 4.3 shows the coeﬃcient estimates for a logistic regression model
that uses balance, income (in thousands of dollars), and student status to
predict probability of default. There is a surprising result here. The p-
values associated with balance and the dummy variable for student status
are very small, indicating that each of these variables is associated with
the probability of default. However, the coeﬃcient for the dummy variable
is negative, indicating that students are less likely to default than non-
students. In contrast, the coeﬃcient for the dummy variable is positive in
Table 4.2. How is it possible for student status to be associated with an
increase in probability of default in Table 4.2 and a decrease in probability
of default in Table 4.3? The left-hand panel of Figure 4.3 provides a graph-
ical illustration of this apparent paradox. The orange and blue solid lines
show the average default rates for students and non-students, respectively,

136

4. Classiﬁcation

Intercept
balance
income
student[Yes]

Coeﬃcient
−10.8690
0.0057
0.0030
−0.6468

Std. error Z-statistic

0.4923
0.0002
0.0082
0.2362

P-value
−22.08 <0.0001
24.74 <0.0001
0.7115
0.37
−2.74
0.0062

TABLE 4.3. For the Default data, estimated coeﬃcients of the logistic regres-
sion model that predicts the probability of default using balance, income, and
student status. Student status is encoded as a dummy variable student[Yes],
with a value of 1 for a student and a value of 0 for a non-student. In ﬁtting this
model, income was measured in thousands of dollars.

as a function of credit card balance. The negative coeﬃcient for student in
the multiple logistic regression indicates that for a ﬁxed value of balance
and income, a student is less likely to default than a non-student. Indeed,
we observe from the left-hand panel of Figure 4.3 that the student default
rate is at or below that of the non-student default rate for every value of
balance. But the horizontal broken lines near the base of the plot, which
show the default rates for students and non-students averaged over all val-
ues of balance and income, suggest the opposite eﬀect: the overall student
default rate is higher than the non-student default rate. Consequently, there
is a positive coeﬃcient for student in the single variable logistic regression
output shown in Table 4.2.

The right-hand panel of Figure 4.3 provides an explanation for this dis-
crepancy. The variables student and balance are correlated. Students tend
to hold higher levels of debt, which is in turn associated with higher prob-
ability of default. In other words, students are more likely to have large
credit card balances, which, as we know from the left-hand panel of Fig-
ure 4.3, tend to be associated with high default rates. Thus, even though
an individual student with a given credit card balance will tend to have a
lower probability of default than a non-student with the same credit card
balance, the fact that students on the whole tend to have higher credit card
balances means that overall, students tend to default at a higher rate than
non-students. This is an important distinction for a credit card company
that is trying to determine to whom they should oﬀer credit. A student is
riskier than a non-student if no information about the student’s credit card
balance is available. However, that student is less risky than a non-student
with the same credit card balance!

This simple example illustrates the dangers and subtleties associated
with performing regressions involving only a single predictor when other
predictors may also be relevant. As in the linear regression setting, the
results obtained using one predictor may be quite diﬀerent from those ob-
tained using multiple predictors, especially when there is correlation among
the predictors. In general, the phenomenon seen in Figure 4.3 is known as
confounding.

confounding

e

t

a
R

 
t
l

f

u
a
e
D

8
0

.

6
0

.

4

.

0

2
0

.

0
0

.

4.3 Logistic Regression

137

0
0
5
2

0
0
0
2

0
0
5
1

0
0
0
1

0
0
5

0

l

e
c
n
a
a
B
d
r
a
C

 

 
t
i

d
e
r
C

500

1000

1500

2000

Credit Card Balance

No

Yes

Student Status

FIGURE 4.3. Confounding in the Default data. Left: Default rates are shown
for students (orange) and non-students (blue). The solid lines display default rate
as a function of balance, while the horizontal broken lines display the overall
default rates. Right: Boxplots of balance for students (orange) and non-students
(blue) are shown.

By substituting estimates for the regression coeﬃcients from Table 4.3
into (4.7), we can make predictions. For example, a student with a credit
card balance of $1, 500 and an income of $40, 000 has an estimated proba-
bility of default of

−10.869+0.00574×1,500+0.003×40−0.6468×1

ˆp(X) =

1 + e−10.869+0.00574×1,500+0.003×40−0.6468×1 = 0.058.

(4.8)

e

e

A non-student with the same balance and income has an estimated prob-
ability of default of

−10.869+0.00574×1,500+0.003×40−0.6468×0

ˆp(X) =

1 + e−10.869+0.00574×1,500+0.003×40−0.6468×0 = 0.105.

(4.9)

(Here we multiply the income coeﬃcient estimate from Table 4.3 by 40,
rather than by 40,000, because in that table the model was ﬁt with income
measured in units of $1, 000.)

4.3.5 Logistic Regression for >2 Response Classes

We sometimes wish to classify a response variable that has more than two
classes. For example, in Section 4.2 we had three categories of medical con-
dition in the emergency room: stroke, drug overdose, epileptic seizure.
In this setting, we wish to model both Pr(Y = stroke|X) and Pr(Y =
drug overdose|X), with the remaining Pr(Y = epileptic seizure|X) =
1 − Pr(Y = stroke|X) − Pr(Y = drug overdose|X). The two-class logis-
tic regression models discussed in the previous sections have multiple-class
extensions, but in practice they tend not to be used all that often. One of
the reasons is that the method we discuss in the next section, discriminant

138

4. Classiﬁcation

analysis, is popular for multiple-class classiﬁcation. So we do not go into
the details of multiple-class logistic regression here, but simply note that
such an approach is possible, and that software for it is available in R.

4.4 Linear Discriminant Analysis
Logistic regression involves directly modeling Pr(Y = k|X = x) using the
logistic function, given by (4.7) for the case of two response classes. In
statistical jargon, we model the conditional distribution of the response Y ,
given the predictor(s) X. We now consider an alternative and less direct
approach to estimating these probabilities. In this alternative approach,
we model the distribution of the predictors X separately in each of the
response classes (i.e. given Y ), and then use Bayes’ theorem to ﬂip these
around into estimates for Pr(Y = k|X = x). When these distributions are
assumed to be normal,
it turns out that the model is very similar in form
to logistic regression.

Why do we need another method, when we have logistic regression?

There are several reasons:

• When the classes are well-separated, the parameter estimates for the
logistic regression model are surprisingly unstable. Linear discrimi-
nant analysis does not suﬀer from this problem.

• If n is small and the distribution of the predictors X is approximately
normal in each of the classes, the linear discriminant model is again
more stable than the logistic regression model.

• As mentioned in Section 4.3.5, linear discriminant analysis is popular

when we have more than two response classes.

4.4.1 Using Bayes’ Theorem for Classiﬁcation

Suppose that we wish to classify an observation into one of K classes, where
K ≥ 2. In other words, the qualitative response variable Y can take on K
possible distinct and unordered values. Let πk represent the overall or prior
probability that a randomly chosen observation comes from the kth class;
this is the probability that a given observation is associated with the kth

category of the response variable Y . Let fk( ) ≡ Pr(X = x|Y = k) denote

x

1

prior

the density function of X for an observation that comes from the kth class.
In other words, fk(x) is relatively large if there is a high probability that
an observation in the kth class has X ≈ x, and fk(x) is small if it is very

density
function

1Technically this definition is only correct if

X

is continuous then
region dx around x.

fk(x)dx would correspond to the probability of

is a discrete random variabl.e. If

X
fa ling in in a small

X l

unlikely that an observation in the kth class has X ≈ x. Then Bayes’
theorem states that

4.4 Linear Discriminant Analysis

139

Pr(Y = k|X = x) =

(cid:10)

πkfk(x)
K
l=1 πlfl(x)

.

(4.10)

In accordance with our earlier notation, we will use the abbreviation pk(X)
= Pr(Y = k|X). This suggests that instead of directly computing pk(X)
as in Section 4.3.1, we can simply plug in estimates of πk and fk(X) into
(4.10). In general, estimating πk is easy if we have a random sample of
Y s from the population: we simply compute the fraction of the training
observations that belong to the kth class. However, estimating fk(X) tends
to be more challenging, unless we assume some simple forms for these
densities. We refer to pk(x) as the posterior probability that an observation
X = x belongs to the kth class. That is, it is the probability that the
observation belongs to the kth class, given the predictor value for that
observation.

We know from Chapter 2 that the Bayes classiﬁer, which classiﬁes an
observation to the class for which pk(X) is largest, has the lowest possible
error rate out of all classiﬁers. (This is of course only true if the terms
in (4.10) are all correctly speciﬁed.) Therefore, if we can ﬁnd a way to
estimate fk(X), then we can develop a classiﬁer that approximates the
Bayes classiﬁer. Such an approach is the topic of the following sections.

4.4.2 Linear Discriminant Analysis for p = 1

For now, assume that p = 1—that is, we have only one predictor. We
would like to obtain an estimate for fk(x) that we can plug into (4.10) in
order to estimate pk(x). We will then classify an observation to the class
for which pk(x) is greatest. In order to estimate fk(x), we will ﬁrst make
some assumptions about its form.

Suppose we assume that fk(x) is normal or Gaussian.

In the one-

(cid:12)
dimensional setting, the normal density takes the form

fk(x) =

1√
2πσk

exp

(cid:11)
− 1
2σ2
k

(x − μk)2

,

(4.11)

Bayes’
theorem

posterior

normal
Gaussian

where μk and σ2
k are the mean and variance parameters for the kth class.
For now, let us further assume that σ2
K: that is, there is a shared
variance term across all K classes, which for simplicity we can denote by
σ2. Plugging (4.11) into (4.10), we ﬁnd that

1 = . . . = σ2
(cid:9)
(cid:8)− 1
2σ2 (x − μk)2
(cid:8)− 1
2σ2 (x − μl)2

exp

pk(x) =

(cid:10)

1√

πk
K
l=1 πl

2πσ
1√

exp

2πσ

(cid:9) .

(4.12)

(Note that in (4.12), πk denotes the prior probability that an observation
belongs to the kth class, not to be confused with π ≈ 3.14159, the math-
ematical constant.) The Bayes classiﬁer involves assigning an observation

140

4. Classiﬁcation

5

4

3

2

1

0

−4

−2

0

2

4

−3

−2

−1

0

1

2

3

4

FIGURE 4.4. Left: Two one-dimensional normal density functions are shown.
The dashed vertical line represents the Bayes decision boundary. Right: 20 obser-
vations were drawn from each of the two classes, and are shown as histograms.
The Bayes decision boundary is again shown as a dashed vertical line. The solid
vertical line represents the LDA decision boundary estimated from the training
data.

X = x to the class for which (4.12) is largest. Taking the log of (4.12)
and rearranging the terms, it is not hard to show that this is equivalent to
assigning the observation to the class for which

δk(x) = x · μk
σ2

− μ2

k

2σ2 + log(πk)

(4.13)

is largest. For instance, if K = 2 and π1 = π2, then the Bayes classiﬁer
assigns an observation to class 1 if 2x (μ1 − μ2) > μ2
2, and to class
2 otherwise. In this case, the Bayes decision boundary corresponds to the
point where

− μ2

1

− μ2
μ2
2(μ1 − μ2)
1

2

x =

=

μ1 + μ2

2

.

(4.14)

1 = σ2

An example is shown in the left-hand panel of Figure 4.4. The two normal
density functions that are displayed, f1(x) and f2(x), represent two distinct
classes. The mean and variance parameters for the two density functions
are μ1 = −1.25, μ2 = 1.25, and σ2
2 = 1. The two densities overlap,
and so given that X = x, there is some uncertainty about the class to which
the observation belongs. If we assume that an observation is equally likely
to come from either class—that is, π1 = π2 = 0.5—then by inspection of
(4.14), we see that the Bayes classiﬁer assigns the observation to class 1
if x < 0 and class 2 otherwise. Note that in this case, we can compute
the Bayes classiﬁer because we know that X is drawn from a Gaussian
distribution within each class, and we know all of the parameters involved.
In a real-life situation, we are not able to calculate the Bayes classiﬁer.

In practice, even if we are quite certain of our assumption that X is drawn
from a Gaussian distribution within each class, we still have to estimate
the parameters μ1, . . . , μK, π1, . . . , πK, and σ2. The linear discriminant

4.4 Linear Discriminant Analysis

141

analysis (LDA) method approximates the Bayes classiﬁer by plugging esti-
mates for πk, μk, and σ2 into (4.13). In particular, the following estimates
are used:

linear
discriminant
analysis

ˆμk =

1
nk

(cid:17)

i:yi=k

xi
K(cid:17)

ˆσ2 =

1

n − K

k=1

i:yi=k

(cid:17)

(xi − ˆμk)2

(4.15)

where n is the total number of training observations, and nk is the number
of training observations in the kth class. The estimate for μk is simply the
average of all the training observations from the kth class, while ˆσ2 can
be seen as a weighted average of the sample variances for each of the K
classes. Sometimes we have knowledge of the class membership probabili-
ties π1, . . . , πK, which can be used directly. In the absence of any additional
information, LDA estimates πk using the proportion of the training obser-
vations that belong to the kth class. In other words,

ˆπk = nk/n.

(4.16)

The LDA classiﬁer plugs the estimates given in (4.15) and (4.16) into (4.13),
and assigns an observation X = x to the class for which

ˆδk(x) = x · ˆμk
ˆσ2

− ˆμ2

k

2ˆσ2 + log(ˆπk)

(4.17)

discriminant
function

is largest. The word linear in the classiﬁer’s name stems from the fact
that the discriminant functions ˆδk(x) in (4.17) are linear functions of x (as
opposed to a more complex function of x).

The right-hand panel of Figure 4.4 displays a histogram of a random
sample of 20 observations from each class. To implement LDA, we began
by estimating πk, μk, and σ2 using (4.15) and (4.16). We then computed the
decision boundary, shown as a black solid line, that results from assigning
an observation to the class for which (4.17) is largest. All points to the left
of this line will be assigned to the green class, while points to the right of
this line are assigned to the purple class. In this case, since n1 = n2 = 20,
we have ˆπ1 = ˆπ2. As a result, the decision boundary corresponds to the
midpoint between the sample means for the two classes, (ˆμ1 + ˆμ2)/2. The
ﬁgure indicates that the LDA decision boundary is slightly to the left of
the optimal Bayes decision boundary, which instead equals (μ1 + μ2)/2 =
0. How well does the LDA classiﬁer perform on this data? Since this is
simulated data, we can generate a large number of test observations in order
to compute the Bayes error rate and the LDA test error rate. These are
10.6 % and 11.1 %, respectively. In other words, the LDA classiﬁer’s error
rate is only 0.5 % above the smallest possible error rate! This indicates that
LDA is performing pretty well on this data set.

142

4. Classiﬁcation

x2

x2

x1

x1

FIGURE 4.5. Two multivariate Gaussian density functions are shown, with
p = 2. Left: The two predictors are uncorrelated. Right: The two variables have
a correlation of 0.7.

To reiterate, the LDA classiﬁer results from assuming that the observa-
tions within each class come from a normal distribution with a class-speciﬁc
mean vector and a common variance σ2, and plugging estimates for these
parameters into the Bayes classiﬁer. In Section 4.4.4, we will consider a less
stringent set of assumptions, by allowing the observations in the kth class
to have a class-speciﬁc variance, σ2
k.

multivariate
Gaussian

4.4.3 Linear Discriminant Analysis for p >1

We now extend the LDA classiﬁer to the case of multiple predictors. To
do this, we will assume that X = (X1, X2, . . . , Xp) is drawn from a multi-
variate Gaussian (or multivariate normal) distribution, with a class-speciﬁc
mean vector and a common covariance matrix. We begin with a brief review
of such a distribution.

The multivariate Gaussian distribution assumes that each individual pre-
dictor follows a one-dimensional normal distribution, as in (4.11), with some
correlation between each pair of predictors. Two examples of multivariate
Gaussian distributions with p = 2 are shown in Figure 4.5. The height of
the surface at any particular point represents the probability that both X1
and X2 fall in a small region around that point. In either panel, if the sur-
face is cut along the X1 axis or along the X2 axis, the resulting cross-section
will have the shape of a one-dimensional normal distribution. The left-hand
panel of Figure 4.5 illustrates an example in which Var(X1) = Var(X2) and
Cor(X1, X2) = 0; this surface has a characteristic bell shape. However, the
bell shape will be distorted if the predictors are correlated or have unequal
variances, as is illustrated in the right-hand panel of Figure 4.5. In this
situation, the base of the bell will have an elliptical, rather than circular,

4.4 Linear Discriminant Analysis

143

2

X

4

2

0

2
−

4
−

2

X

4

2

0

2
−

4
−

−4

−2

0

2

4

−4

−2

0

2

4

X1

X1

FIGURE 4.6. An example with three classes. The observations from each class
are drawn from a multivariate Gaussian distribution with p = 2, with a class-spe-
ciﬁc mean vector and a common covariance matrix. Left: Ellipses that contain
95 % of the probability for each of the three classes are shown. The dashed lines
are the Bayes decision boundaries. Right: 20 observations were generated from
each class, and the corresponding LDA decision boundaries are indicated using
solid black lines. The Bayes decision boundaries are once again shown as dashed
lines.

shape. To indicate that a p-dimensional random variable X has a multi-
variate Gaussian distribution, we write X ∼ N (μ, Σ). Here E(X) = μ is
the mean of X (a vector with p components), and Cov(X) = Σ is the
p × p covariance matrix of X. Formally, the multivariate Gaussian density
is deﬁned as

f (x) =

1

(2π)p/2|Σ|1/2 exp

(cid:11)
− 1
2

(x − μ)T Σ

(cid:12)
−1(x − μ)

.

(4.18)

In the case of p > 1 predictors, the LDA classiﬁer assumes that the
observations in the kth class are drawn from a multivariate Gaussian dis-
tribution N (μk, Σ), where μk is a class-speciﬁc mean vector, and Σ is a
covariance matrix that is common to all K classes. Plugging the density
function for the kth class, fk(X = x), into (4.10) and performing a little
bit of algebra reveals that the Bayes classiﬁer assigns an observation X = x
to the class for which

δk(x) = xT Σ

−1μk − 1

2

−1μk + log πk

μT

k Σ

(4.19)

is largest. This is the vector/matrix version of (4.13).

An example is shown in the left-hand panel of Figure 4.6. Three equally-
sized Gaussian classes are shown with class-speciﬁc mean vectors and a
common covariance matrix. The three ellipses represent regions that con-
tain 95 % of the probability for each of the three classes. The dashed lines

144

4. Classiﬁcation

are the Bayes decision boundaries. In other words, they represent the set
of values x for which δk(x) = δ(cid:5)(x); i.e.

xT Σ

−1μk − 1

2

−1μk = xT Σ

μT

k Σ

−1μl − 1

−1μl

μT

l Σ

(4.20)

2

for k (cid:4)= l. (The log πk term from (4.19) has disappeared because each of
the three classes has the same number of training observations; i.e. πk is
the same for each class.) Note that there are three lines representing the
Bayes decision boundaries because there are three pairs of classes among
the three classes. That is, one Bayes decision boundary separates class 1
from class 2, one separates class 1 from class 3, and one separates class 2
from class 3. These three Bayes decision boundaries divide the predictor
space into three regions. The Bayes classiﬁer will classify an observation
according to the region in which it is located.

Once again, we need to estimate the unknown parameters μ1, . . . , μK,
π1, . . . , πK , and Σ; the formulas are similar to those used in the one-
dimensional case, given in (4.15). To assign a new observation X = x,
LDA plugs these estimates into (4.19) and classiﬁes to the class for which
ˆδk(x) is largest. Note that in (4.19) δk(x) is a linear function of x; that is,
the LDA decision rule depends on x only through a linear combination of
its elements. Once again, this is the reason for the word linear in LDA.

In the right-hand panel of Figure 4.6, 20 observations drawn from each of
the three classes are displayed, and the resulting LDA decision boundaries
are shown as solid black lines. Overall, the LDA decision boundaries are
pretty close to the Bayes decision boundaries, shown again as dashed lines.
The test error rates for the Bayes and LDA classiﬁers are 0.0746 and 0.0770,
respectively. This indicates that LDA is performing well on this data.

We can perform LDA on the Default data in order to predict whether
or not an individual will default on the basis of credit card balance and
student status. The LDA model ﬁt to the 10, 000 training samples results
in a training error rate of 2.75 %. This sounds like a low error rate, but two
caveats must be noted.

• First of all, training error rates will usually be lower than test error
rates, which are the real quantity of interest. In other words, we
might expect this classiﬁer to perform worse if we use it to predict
whether or not a new set of individuals will default. The reason is
that we speciﬁcally adjust the parameters of our model to do well on
the training data. The higher the ratio of parameters p to number
of samples n, the more we expect this overﬁtting to play a role. For
these data we don’t expect this to be a problem, since p = 2 and
n = 10, 000.

• Second, since only 3.33 % of the individuals in the training sample
defaulted, a simple but useless classiﬁer that always predicts that

overﬁtting

4.4 Linear Discriminant Analysis

145

Predicted

default status

No
Yes
Total

9, 644

9, 667

True default status
Total
No
9, 896
104

23

Yes
252
81
333

10, 000

TABLE 4.4. A confusion matrix compares the LDA predictions to the true de-
fault statuses for the 10, 000 training observations in the Default data set. Ele-
ments on the diagonal of the matrix represent individuals whose default statuses
were correctly predicted, while oﬀ-diagonal elements represent individuals that
were misclassiﬁed. LDA made incorrect predictions for 23 individuals who did
not default and for 252 individuals who did default.

each individual will not default, regardless of his or her credit card
balance and student status, will result in an error rate of 3.33 %. In
other words, the trivial null classiﬁer will achieve an error rate that
is only a bit higher than the LDA training set error rate.

null

In practice, a binary classiﬁer such as this one can make two types of
errors: it can incorrectly assign an individual who defaults to the no default
category, or it can incorrectly assign an individual who does not default to
the default category. It is often of interest to determine which of these two
types of errors are being made. A confusion matrix, shown for the Default
data in Table 4.4, is a convenient way to display this information. The
table reveals that LDA predicted that a total of 104 people would default.
Of these people, 81 actually defaulted and 23 did not. Hence only 23 out
of 9, 667 of the individuals who did not default were incorrectly labeled.
This looks like a pretty low error rate! However, of the 333 individuals who
defaulted, 252 (or 75.7 %) were missed by LDA. So while the overall error
rate is low, the error rate among individuals who defaulted is very high.
From the perspective of a credit card company that is trying to identify
high-risk individuals, an error rate of 252/333 = 75.7 % among individuals
who default may well be unacceptable.

Class-speciﬁc performance is also important in medicine and biology,
where the terms sensitivity and speciﬁcity characterize the performance of
a classiﬁer or screening test. In this case the sensitivity is the percentage of
true defaulters that are identiﬁed, a low 24.3 % in this case. The speciﬁcity
is the percentage of non-defaulters that are correctly identiﬁed, here (1 −
23/9, 667) × 100 = 99.8 %.

Why does LDA do such a poor job of classifying the customers who de-
fault? In other words, why does it have such a low sensitivity? As we have
seen, LDA is trying to approximate the Bayes classiﬁer, which has the low-
est total error rate out of all classiﬁers (if the Gaussian model is correct).
That is, the Bayes classiﬁer will yield the smallest possible total number
of misclassiﬁed observations, irrespective of which class the errors come
from. That is, some misclassiﬁcations will result from incorrectly assigning

confusion
matrix

sensitivity

speciﬁcity

146

4. Classiﬁcation

Predicted

default status

No
Yes
Total

True default status
Total
No
9, 570
430

Yes
138
195
333

9, 432
235
9, 667

10, 000

TABLE 4.5. A confusion matrix compares the LDA predictions to the true de-
fault statuses for the 10, 000 training observations in the Default data set, using
a modiﬁed threshold value that predicts default for any individuals whose posterior
default probability exceeds 20 %.

a customer who does not default to the default class, and others will re-
sult from incorrectly assigning a customer who defaults to the non-default
class. In contrast, a credit card company might particularly wish to avoid
incorrectly classifying an individual who will default, whereas incorrectly
classifying an individual who will not default, though still to be avoided,
is less problematic. We will now see that it is possible to modify LDA in
order to develop a classiﬁer that better meets the credit card company’s
needs.

The Bayes classiﬁer works by assigning an observation to the class for
which the posterior probability pk(X) is greatest. In the two-class case, this
amounts to assigning an observation to the default class if

Pr(default = Yes|X = x) > 0.5.

(4.21)

Thus, the Bayes classiﬁer, and by extension LDA, uses a threshold of 50 %
for the posterior probability of default in order to assign an observation
to the default class. However, if we are concerned about incorrectly pre-
dicting the default status for individuals who default, then we can consider
lowering this threshold. For instance, we might label any customer with a
posterior probability of default above 20 % to the default class. In other
words, instead of assigning an observation to the default class if (4.21)
holds, we could instead assign an observation to this class if

Pr(default = Yes|X = x) > 0.2.

(4.22)

The error rates that result from taking this approach are shown in Table 4.5.
Now LDA predicts that 430 individuals will default. Of the 333 individuals
who default, LDA correctly predicts all but 138, or 41.4 %. This is a vast
improvement over the error rate of 75.7 % that resulted from using the
threshold of 50 %. However, this improvement comes at a cost: now 235
individuals who do not default are incorrectly classiﬁed. As a result, the
overall error rate has increased slightly to 3.73 %. But a credit card company
may consider this slight increase in the total error rate to be a small price to
pay for more accurate identiﬁcation of individuals who do indeed default.
Figure 4.7 illustrates the trade-oﬀ that results from modifying the thresh-
old value for the posterior probability of default. Various error rates are

4.4 Linear Discriminant Analysis

147

6

.

0

4

.

0

2

.

0

0

.

0

t

e
a
R

 
r
o
r
r

E

0.0

0.1

0.2

0.3

0.4

0.5

Threshold

FIGURE 4.7. For the Default data set, error rates are shown as a function of
the threshold value for the posterior probability that is used to perform the assign-
ment. The black solid line displays the overall error rate. The blue dashed line
represents the fraction of defaulting customers that are incorrectly classiﬁed, and
the orange dotted line indicates the fraction of errors among the non-defaulting
customers.

shown as a function of the threshold value. Using a threshold of 0.5, as in
(4.21), minimizes the overall error rate, shown as a black solid line. This
is to be expected, since the Bayes classiﬁer uses a threshold of 0.5 and is
known to have the lowest overall error rate. But when a threshold of 0.5 is
used, the error rate among the individuals who default is quite high (blue
dashed line). As the threshold is reduced, the error rate among individuals
who default decreases steadily, but the error rate among the individuals
who do not default increases. How can we decide which threshold value is
best? Such a decision must be based on domain knowledge, such as detailed
information about the costs associated with default.

The ROC curve is a popular graphic for simultaneously displaying the
two types of errors for all possible thresholds. The name “ROC” is his-
toric, and comes from communications theory. It is an acronym for receiver
operating characteristics. Figure 4.8 displays the ROC curve for the LDA
classiﬁer on the training data. The overall performance of a classiﬁer, sum-
marized over all possible thresholds, is given by the area under the (ROC)
curve (AUC). An ideal ROC curve will hug the top left corner, so the larger
the AUC the better the classiﬁer. For this data the AUC is 0.95, which is
close to the maximum of one so would be considered very good. We expect
a classiﬁer that performs no better than chance to have an AUC of 0.5
(when evaluated on an independent test set not used in model training).
ROC curves are useful for comparing diﬀerent classiﬁers, since they take
into account all possible thresholds. It turns out that the ROC curve for the
logistic regression model of Section 4.3.4 ﬁt to these data is virtually indis-
tinguishable from this one for the LDA model, so we do not display it here.
As we have seen above, varying the classiﬁer threshold changes its true
positive and false positive rate. These are also called the sensitivity and one

ROC curve

area under
the (ROC)
curve

sensitivity

148

4. Classiﬁcation

ROC Curve

t

e
a
r
 

e
v
i
t
i
s
o
p

 

e
u
r
T

0

.

1

8

.

0

6

.

0

4

.

0

2

.

0

0
0

.

0.0

0.2

0.4

0.6

0.8

1.0

False positive rate

FIGURE 4.8. A ROC curve for the LDA classiﬁer on the Default data. It
traces out two types of error as we vary the threshold value for the posterior
probability of default. The actual thresholds are not shown. The true positive rate
is the sensitivity: the fraction of defaulters that are correctly identiﬁed, using
a given threshold value. The false positive rate is 1-speciﬁcity: the fraction of
non-defaulters that we classify incorrectly as defaulters, using that same threshold
value. The ideal ROC curve hugs the top left corner, indicating a high true positive
rate and a low false positive rate. The dotted line represents the “no information”
classiﬁer; this is what we would expect if student status and credit card balance
are not associated with probability of default.

+ or Non-null
True
False Pos. (FP)
class + or Non-null False Neg. (FN) True Pos. (TP)

− or Null

True Neg. (TN)

Total

N
P

Predicted class

− or Null

Total

N

∗

∗
P

TABLE 4.6. Possible results when applying a classiﬁer or diagnostic test to a
population.

minus the speciﬁcity of our classiﬁer. Since there is an almost bewildering
array of terms used in this context, we now give a summary. Table 4.6
shows the possible results when applying a classiﬁer (or diagnostic test)
to a population. To make the connection with the epidemiology literature,
we think of “+” as the “disease” that we are trying to detect, and “−” as
the “non-disease” state. To make the connection to the classical hypothesis
testing literature, we think of “−” as the null hypothesis and “+” as the
alternative (non-null) hypothesis. In the context of the Default data, “+”
indicates an individual who defaults, and “−” indicates one who does not.

speciﬁcity

4.4 Linear Discriminant Analysis

149

Name
False Pos. rate
True Pos. rate
Pos. Pred. value
Neg. Pred. value

Deﬁnition

Synonyms
FP/N Type I error, 1−Speciﬁcity
TP/P 1−Type II error, power, sensitivity, recall
∗
TP/P
∗
TN/N

Precision, 1−false discovery proportion

TABLE 4.7. Important measures for classiﬁcation and diagnostic testing,
derived from quantities in Table 4.6.

Table 4.7 lists many of the popular performance measures that are used in
this context. The denominators for the false positive and true positive rates
are the actual population counts in each class. In contrast, the denominators
for the positive predictive value and the negative predictive value are the
total predicted counts for each class.

4.4.4 Quadratic Discriminant Analysis

As we have discussed, LDA assumes that the observations within each
class are drawn from a multivariate Gaussian distribution with a class-
speciﬁc mean vector and a covariance matrix that is common to all K
classes. Quadratic discriminant analysis
(QDA) provides an alternative
approach. Like LDA, the QDA classiﬁer results from assuming that the
observations from each class are drawn from a Gaussian distribution, and
plugging estimates for the parameters into Bayes’ theorem in order to per-
form prediction. However, unlike LDA, QDA assumes that each class has
its own covariance matrix. That is, it assumes that an observation from the

kth class is of the form X ∼ N (μk, Σk), where Σk is a covariance matrix

for the kth class. Under this assumption, the Bayes classiﬁer assigns an
observation X = x to the class for which

quadratic
discriminant
analysis

δk(x) = − 1
2
= − 1
2

(x − μk)T Σ

xT Σ

−1
k x + xT Σ

k μk − 1
−1

2

log |Σk| + log πk

(4.23)

log |Σk| + log πk

k (x − μk) − 1
−1
2
k μk − 1
−1
μT

k Σ

2

is largest. So the QDA classiﬁer involves plugging estimates for Σk, μk,
and πk into (4.23), and then assigning an observation X = x to the class
for which this quantity is largest. Unlike in (4.19), the quantity x appears
as a quadratic function in (4.23). This is where QDA gets its name.

Why does it matter whether or not we assume that the K classes share a
common covariance matrix? In other words, why would one prefer LDA to
QDA, or vice-versa? The answer lies in the bias-variance trade-oﬀ. When
there are p predictors, then estimating a covariance matrix requires esti-
mating p(p+1)/2 parameters. QDA estimates a separate covariance matrix
for each class, for a total of Kp(p+1)/2 parameters. With 50 predictors this

150

4. Classiﬁcation

2

X

2

1

0

1
−

2
−

3
−

4
−

2

X

2

1

0

1
−

2
−

3
−

4
−

−4

−2

0
X1

2

4

−4

−2

2

4

0
X1

FIGURE 4.9. Left: The Bayes (purple dashed), LDA (black dotted), and QDA
(green solid) decision boundaries for a two-class problem with Σ1 = Σ2. The
shading indicates the QDA decision rule. Since the Bayes decision boundary is
linear, it is more accurately approximated by LDA than by QDA. Right: Details
are as given in the left-hand panel, except that Σ1 (cid:3)= Σ2. Since the Bayes decision
boundary is non-linear, it is more accurately approximated by QDA than by LDA.

is some multiple of 1,275, which is a lot of parameters. By instead assum-
ing that the K classes share a common covariance matrix, the LDA model
becomes linear in x, which means there are Kp linear coeﬃcients to esti-
mate. Consequently, LDA is a much less ﬂexible classiﬁer than QDA, and
so has substantially lower variance. This can potentially lead to improved
prediction performance. But there is a trade-oﬀ: if LDA’s assumption that
the K classes share a common covariance matrix is badly oﬀ, then LDA
can suﬀer from high bias. Roughly speaking, LDA tends to be a better bet
than QDA if there are relatively few training observations and so reducing
variance is crucial. In contrast, QDA is recommended if the training set is
very large, so that the variance of the classiﬁer is not a major concern, or if
the assumption of a common covariance matrix for the K classes is clearly
untenable.

Figure 4.9 illustrates the performances of LDA and QDA in two scenarios.
In the left-hand panel, the two Gaussian classes have a common correla-
tion of 0.7 between X1 and X2. As a result, the Bayes decision boundary
is linear and is accurately approximated by the LDA decision boundary.
The QDA decision boundary is inferior, because it suﬀers from higher vari-
ance without a corresponding decrease in bias. In contrast, the right-hand
panel displays a situation in which the orange class has a correlation of 0.7
between the variables and the blue class has a correlation of −0.7. Now
the Bayes decision boundary is quadratic, and so QDA more accurately
approximates this boundary than does LDA.

4.5 A Comparison of Classiﬁcation Methods

151

4.5 A Comparison of Classiﬁcation Methods

In this chapter, we have considered three diﬀerent classiﬁcation approaches:
logistic regression, LDA, and QDA. In Chapter 2, we also discussed the
K-nearest neighbors (KNN) method. We now consider the types of
scenarios in which one approach might dominate the others.

Though their motivations diﬀer, the logistic regression and LDA methods
are closely connected. Consider the two-class setting with p = 1 predictor,

and let p1(x) and p2(x) = 1−p1(x) be the probabilities that the observation

X = x belongs to class 1 and class 2, respectively. In the LDA framework,
we can see from (4.12) to (4.13) (and a bit of simple algebra) that the log
odds is given by

(cid:11)

(cid:12)

log

p1(x)
1 − p1(x)

(cid:11)

(cid:12)

p1(x)
p2(x)

= log

= c0 + c1x,

(4.24)

where c0 and c1 are functions of μ1, μ2, and σ2. From (4.4), we know that
in logistic regression,

(cid:11)

(cid:12)

log

p1
1 − p1

= β0 + β1x.

(4.25)

Both (4.24) and (4.25) are linear functions of x. Hence, both logistic re-
gression and LDA produce linear decision boundaries. The only diﬀerence
between the two approaches lies in the fact that β0 and β1 are estimated
using maximum likelihood, whereas c0 and c1 are computed using the esti-
mated mean and variance from a normal distribution. This same connection
between LDA and logistic regression also holds for multidimensional data
with p > 1.

Since logistic regression and LDA diﬀer only in their ﬁtting procedures,
one might expect the two approaches to give similar results. This is often,
but not always, the case. LDA assumes that the observations are drawn
from a Gaussian distribution with a common covariance matrix in each
class, and so can provide some improvements over logistic regression when
this assumption approximately holds. Conversely, logistic regression can
outperform LDA if these Gaussian assumptions are not met.

Recall from Chapter 2 that KNN takes a completely diﬀerent approach
from the classiﬁers seen in this chapter. In order to make a prediction for
an observation X = x, the K training observations that are closest to x are
identiﬁed. Then X is assigned to the class to which the plurality of these
observations belong. Hence KNN is a completely non-parametric approach:
no assumptions are made about the shape of the decision boundary. There-
fore, we can expect this approach to dominate LDA and logistic regression
when the decision boundary is highly non-linear. On the other hand, KNN
does not tell us which predictors are important; we don’t get a table of
coeﬃcients as in Table 4.3.

152

4. Classiﬁcation

SCENARIO 1

SCENARIO 2

SCENARIO 3

5
4
0

.

0
4

.

0

5
3

.

0

0
3

.

0

5
2
.
0

0
3
0

.

5
2

.

0

0
2

.

0

5
1
.
0

5
4
0

.

0
4

.

0

5
3

.

0

0
3
0

.

5
2

.

0

0
2
.
0

KNN−1 KNN−CV

LDA

Logistic

QDA

KNN−1 KNN−CV

LDA

Logistic

QDA

KNN−1 KNN−CV

LDA

Logistic

QDA

FIGURE 4.10. Boxplots of the test error rates for each of the linear scenarios
described in the main text.

SCENARIO 4

SCENARIO 5

SCENARIO 6

0
4

.

0

5
3

.

0

0
3

.

0

0
4

.

0

5
3

.

0

0
3

.

0

5
2

.

0

0
2

.

0

2
3

.

0

0
3

.

0

8
2

.

0

6
2

.

0

4
2

.

0

2
2

.

0

0
2

.

0

8
1

.

0

KNN−1 KNN−CV

LDA

Logistic

QDA

KNN−1 KNN−CV

LDA

Logistic

QDA

KNN−1 KNN−CV

LDA

Logistic

QDA

FIGURE 4.11. Boxplots of the test error rates for each of the non-linear sce-
narios described in the main text.

Finally, QDA serves as a compromise between the non-parametric KNN
method and the linear LDA and logistic regression approaches. Since QDA
assumes a quadratic decision boundary, it can accurately model a wider
range of problems than can the linear methods. Though not as ﬂexible
as KNN, QDA can perform better in the presence of a limited number of
training observations because it does make some assumptions about the
form of the decision boundary.

To illustrate the performances of these four classiﬁcation approaches,
we generated data from six diﬀerent scenarios. In three of the scenarios,
the Bayes decision boundary is linear, and in the remaining scenarios it
is non-linear. For each scenario, we produced 100 random training data
sets. On each of these training sets, we ﬁt each method to the data and
computed the resulting test error rate on a large test set. Results for the
linear scenarios are shown in Figure 4.10, and the results for the non-linear
scenarios are in Figure 4.11. The KNN method requires selection of K, the
number of neighbors. We performed KNN with two values of K: K = 1,

4.5 A Comparison of Classiﬁcation Methods

153

and a value of K that was chosen automatically using an approach called
cross-validation, which we discuss further in Chapter 5.

In each of the six scenarios, there were p = 2 predictors. The scenarios

were as follows:

Scenario 1: There were 20 training observations in each of two classes.
The observations within each class were uncorrelated random normal
variables with a diﬀerent mean in each class. The left-hand panel
of Figure 4.10 shows that LDA performed well in this setting, as
one would expect since this is the model assumed by LDA. KNN
performed poorly because it paid a price in terms of variance that
was not oﬀset by a reduction in bias. QDA also performed worse
than LDA, since it ﬁt a more ﬂexible classiﬁer than necessary. Since
logistic regression assumes a linear decision boundary, its results were
only slightly inferior to those of LDA.

Scenario 2: Details are as in Scenario 1, except that within each
class, the two predictors had a correlation of −0.5. The center panel
of Figure 4.10 indicates little change in the relative performances of
the methods as compared to the previous scenario.

Scenario 3: We generated X1 and X2 from the t-distribution, with
50 observations per class. The t-distribution has a similar shape to
the normal distribution, but it has a tendency to yield more extreme
points—that is, more points that are far from the mean. In this set-
ting, the decision boundary was still linear, and so ﬁt into the logistic
regression framework. The set-up violated the assumptions of LDA,
since the observations were not drawn from a normal distribution.
The right-hand panel of Figure 4.10 shows that logistic regression
outperformed LDA, though both methods were superior to the other
approaches. In particular, the QDA results deteriorated considerably
as a consequence of non-normality.

Scenario 4: The data were generated from a normal distribution,
with a correlation of 0.5 between the predictors in the ﬁrst class,
and correlation of −0.5 between the predictors in the second class.
This setup corresponded to the QDA assumption, and resulted in
quadratic decision boundaries. The left-hand panel of Figure 4.11
shows that QDA outperformed all of the other approaches.

Scenario 5: Within each class, the observations were generated from
a normal distribution with uncorrelated predictors. However, the re-
sponses were sampled from the logistic function using X 2
2 , and
X1 × X2 as predictors. Consequently, there is a quadratic decision

1 , X 2

boundary. The center panel of Figure 4.11 indicates that QDA once
again performed best, followed closely by KNN-CV. The linear meth-
ods had poor performance.

t-
distribution

154

4. Classiﬁcation

Scenario 6: Details are as in the previous scenario, but the responses
were sampled from a more complicated non-linear function. As a re-
sult, even the quadratic decision boundaries of QDA could not ade-
quately model the data. The right-hand panel of Figure 4.11 shows
that QDA gave slightly better results than the linear methods, while
the much more ﬂexible KNN-CV method gave the best results. But
KNN with K = 1 gave the worst results out of all methods. This
highlights the fact that even when the data exhibits a complex non-
linear relationship, a non-parametric method such as KNN can still
give poor results if the level of smoothness is not chosen correctly.

These six examples illustrate that no one method will dominate the oth-
ers in every situation. When the true decision boundaries are linear, then
the LDA and logistic regression approaches will tend to perform well. When
the boundaries are moderately non-linear, QDA may give better results.
Finally, for much more complicated decision boundaries, a non-parametric
approach such as KNN can be superior. But the level of smoothness for a
non-parametric approach must be chosen carefully. In the next chapter we
examine a number of approaches for choosing the correct level of smooth-
ness and, in general, for selecting the best overall method.

Finally, recall from Chapter 3 that in the regression setting we can accom-
modate a non-linear relationship between the predictors and the response
by performing regression using transformations of the predictors. A similar
approach could be taken in the classiﬁcation setting. For instance, we could
create a more ﬂexible version of logistic regression by including X 2, X 3,
and even X 4 as predictors. This may or may not improve logistic regres-
sion’s performance, depending on whether the increase in variance due to
the added ﬂexibility is oﬀset by a suﬃciently large reduction in bias. We
could do the same for LDA. If we added all possible quadratic terms and
cross-products to LDA, the form of the model would be the same as the
QDA model, although the parameter estimates would be diﬀerent. This
device allows us to move somewhere between an LDA and a QDA model.

4.6 Lab: Logistic Regression, LDA, QDA, and

KNN

4.6.1 The Stock Market Data

We will begin by examining some numerical and graphical summaries of
the Smarket data, which is part of the ISLR library. This data set consists of
percentage returns for the S&P 500 stock index over 1, 250 days, from the
beginning of 2001 until the end of 2005. For each date, we have recorded
the percentage returns for each of the ﬁve previous trading days, Lag1
through Lag5. We have also recorded Volume (the number of shares traded

4.6 Lab: Logistic Regression, LDA, QDA, and KNN

155

on the previous day, in billions), Today (the percentage return on the date
in question) and Direction (whether the market was Up or Down on this
date).

> library ( ISLR )
> names ( Smarket )
[1] " Year "
[6] " Lag5 "
> dim ( Smarket )
[1] 1250
> summary ( Smarket )

9

" Lag1 "
" Volume "

" Lag2 "
" Today "

" Lag3 "
" Direction "

" Lag4 "

Year

Lag1

Lag2

Min .
:2001
1 st Qu .:2002
Median :2003
Mean
:2003
3 rd Qu .:2004
Max .
:2005

Lag3

: -4.92200
Min .
1 st Qu .: -0.64000
Median : 0.03850
Mean
: 0.00172
3 rd Qu .: 0.59675
Max .
: 5.73300

Min .
: -4.92200
1 st Qu .: -0.63950
Median : 0.03900
Mean
: 0.00383
3 rd Qu .: 0.59675
Max .
: 5.73300

Min .
: -4.92200
1 st Qu .: -0.63950
Median : 0.03900
Mean
: 0.00392
3 rd Qu .: 0.59675
Max .
: 5.73300

Lag4

Lag5

: -4.92200
Min .
1 st Qu .: -0.64000
Median : 0.03850
Mean
: 0.00164
3 rd Qu .: 0.59675
Max .
: 5.73300

: -4.92200
Min .
1 st Qu .: -0.64000
Median : 0.03850
Mean
: 0.00561
3 rd Qu .: 0.59700
Max .
: 5.73300

Volume

Today

Min .
:0.356
1 st Qu .:1.257
Median :1.423
Mean
:1.478
3 rd Qu .:1.642
Max .
:3.152

Min .
: -4.92200
1 st Qu .: -0.63950
Median : 0.03850
Mean
: 0.00314
3 rd Qu .: 0.59675
Max .
: 5.73300

> pairs ( Smarket )

Direction
Down :602
Up
:648

The cor() function produces a matrix that contains all of the pairwise
correlations among the predictors in a data set. The ﬁrst command below
gives an error message because the Direction variable is qualitative.

> cor ( Smarket )
Error in cor ( Smarket ) : ’x ’ must be numeric
> cor ( Smarket [ , -9])

Lag2
0.03060

Lag3
0.03319

Year
Lag1
Lag2
Lag3
Lag4
Lag5
Volume 0.5390
Today

Year
1.0000
0.0297
0.0306 -0.02629
0.0332 -0.01080 -0.02590
0.0357 -0.00299 -0.01085 -0.02405
0.0298 -0.00567 -0.00356 -0.01881 -0.02708

Lag5
Lag1
0.02970
0.02979
1.00000 -0.02629 -0.01080 -0.00299 -0.00567
1.00000 -0.02590 -0.01085 -0.00356
1.00000 -0.02405 -0.01881
1.00000 -0.02708
1.00000
0.04091 -0.04338 -0.04182 -0.04841 -0.02200
0.0301 -0.02616 -0.01025 -0.00245 -0.00690 -0.03486

Lag4
0.03569

Year

Volume
0.5390

Today
0.03010

156

4. Classiﬁcation

Lag1
Lag2
Lag3
Lag4
Lag5
Volume
Today

0.0409 -0.02616
-0.0434 -0.01025
-0.0418 -0.00245
-0.0484 -0.00690
-0.0220 -0.03486
0.01459
1.00000

1.0000
0.0146

As one would expect, the correlations between the lag variables and to-
day’s returns are close to zero. In other words, there appears to be little
correlation between today’s returns and previous days’ returns. The only
substantial correlation is between Year and Volume. By plotting the data we
see that Volume is increasing over time. In other words, the average number
of shares traded daily increased from 2001 to 2005.

> attach ( Smarket )
> plot ( Volume )

4.6.2 Logistic Regression

Next, we will ﬁt a logistic regression model in order to predict Direction
using Lag1 through Lag5 and Volume. The glm() function ﬁts generalized
linear models, a class of models that includes logistic regression. The syntax
of the glm() function is similar to that of lm(), except that we must pass in
the argument family=binomial in order to tell R to run a logistic regression
rather than some other type of generalized linear model.
> glm . fit s = glm ( Direction∼Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume ,

glm()

generalized
linear model

data = Smarket , family = binomial )

> summary ( glm . fit s )

Call :

glm ( formula = Direction ∼ Lag1 + Lag2 + Lag3 + Lag4 + Lag5

+ Volume , family = binomial , data = Smarket )

Deviance Residuals :

Min
-1.45

1 Q
-1.20

Median
1.07

3 Q
1.15

Max
1.33

C o e f f i c i e n t s :

( Intercept ) -0.12600
Lag1
-0.07307
-0.04230
Lag2
0.01109
Lag3
0.00936
Lag4
0.01031
Lag5
Volume
0.13544

-0.52
-1.46
-0.84
0.22
0.19
0.21
0.86

Estimate Std . Error z value Pr ( >| z |)
0.60
0.15
0.40
0.82
0.85
0.83
0.39

0.24074
0.05017
0.05009
0.04994
0.04997
0.04951
0.15836

4.6 Lab: Logistic Regression, LDA, QDA, and KNN

157

( Dispersion parameter for binomial family taken to be 1)

Null deviance : 1731.2
Residual deviance : 1727.6
AIC : 1742

on 1249
on 1243

degrees of freedom
degrees of freedom

Number of Fisher Scoring iteration s : 3

The smallest p-value here is associated with Lag1. The negative coeﬃcient
for this predictor suggests that if the market had a positive return yesterday,
then it is less likely to go up today. However, at a value of 0.15, the p-value
is still relatively large, and so there is no clear evidence of a real association
between Lag1 and Direction.

We use the coef() function in order to access just the coeﬃcients for this
ﬁtted model. We can also use the summary() function to access particular
aspects of the ﬁtted model, such as the p-values for the coeﬃcients.

> coef ( glm . fit s )
( Intercept )
-0.12600
Lag5
0.01031

Lag1
-0.07307
Volume
0.13544

> summary ( glm . fit s ) $coef

Lag2
-0.04230

Lag3
0.01109

Lag4
0.00936

Estimate Std . Error z value Pr ( >| z |)
0.601
0.145
0.398
0.824
0.851
0.835
0.392

0.2407
0.0502
0.0501
0.0499
0.0500
0.0495
0.1584

-0.523
-1.457
-0.845
0.222
0.187
0.208
0.855

( Intercept ) -0.12600
-0.07307
Lag1
-0.04230
Lag2
0.01109
Lag3
0.00936
Lag4
Lag5
0.01031
Volume
0.13544
> summary ( glm . fit s ) $coef [ ,4]
( Intercept )
0.601
Lag5
0.835

Lag1
0.145
Volume
0.392

Lag2
0.398

Lag3
0.824

Lag4
0.851

The predict() function can be used to predict the probability that the
market will go up, given values of the predictors. The type="response"
option tells R to output probabilities of the form P (Y = 1|X), as opposed
to other information such as the logit. If no data set is supplied to the
predict() function, then the probabilities are computed for the training
data that was used to ﬁt the logistic regression model. Here we have printed
only the ﬁrst ten probabilities. We know that these values correspond to
the probability of the market going up, rather than down, because the
contrasts() function indicates that R has created a dummy variable with
a 1 for Up.

> glm . probs = predict ( glm . fit s , type =" response ")
> glm . probs [1:10]
3

10
0.507 0.481 0.481 0.515 0.511 0.507 0.493 0.509 0.518 0.489

1

8

9

2

4

5

6

7

158

4. Classiﬁcation

> contrasts ( Direction )

Up
0
1

Down
Up

In order to make a prediction as to whether the market will go up or
down on a particular day, we must convert these predicted probabilities
into class labels, Up or Down. The following two commands create a vector
of class predictions based on whether the predicted probability of a market
increase is greater than or less than 0.5.

> glm . pred = rep (" Down " ,1250)
> glm . pred [ glm . probs >.5]=" Up "

The ﬁrst command creates a vector of 1,250 Down elements. The second line
transforms to Up all of the elements for which the predicted probability of a
market increase exceeds 0.5. Given these predictions, the table() function
can be used to produce a confusion matrix in order to determine how many
observations were correctly or incorrectly classiﬁed.

table()

> table ( glm . pred , Direction )

glm . pred Down

Direction
Up
145 141
457 507

Down
Up

> (507+145) /1250
[1] 0.5216
> mean ( glm . pred == Direction )
[1] 0.5216

The diagonal elements of the confusion matrix indicate correct predictions,
while the oﬀ-diagonals represent incorrect predictions. Hence our model
correctly predicted that the market would go up on 507 days and that
it would go down on 145 days, for a total of 507 + 145 = 652 correct
predictions. The mean() function can be used to compute the fraction of
days for which the prediction was correct. In this case, logistic regression
correctly predicted the movement of the market 52.2 % of the time.

At ﬁrst glance, it appears that the logistic regression model is working
a little better than random guessing. However, this result is misleading
because we trained and tested the model on the same set of 1, 250 observa-
tions. In other words, 100 − 52.2 = 47.8 % is the training error rate. As we
have seen previously, the training error rate is often overly optimistic—it
tends to underestimate the test error rate. In order to better assess the ac-
curacy of the logistic regression model in this setting, we can ﬁt the model
using part of the data, and then examine how well it predicts the held out
data. This will yield a more realistic error rate, in the sense that in prac-
tice we will be interested in our model’s performance not on the data that
we used to ﬁt the model, but rather on days in the future for which the
market’s movements are unknown.

4.6 Lab: Logistic Regression, LDA, QDA, and KNN

159

To implement this strategy, we will ﬁrst create a vector corresponding
to the observations from 2001 through 2004. We will then use this vector
to create a held out data set of observations from 2005.

> train =( Year <2005)
> Smarket .2005= Smarket [! train ,]
> dim ( Smarket .2005)
[1] 252
> Direction .2005= Direction [! train ]

9

The object train is a vector of 1, 250 elements, corresponding to the ob-
servations in our data set. The elements of the vector that correspond to
observations that occurred before 2005 are set to TRUE, whereas those that
correspond to observations in 2005 are set to FALSE. The object train is
a Boolean vector, since its elements are TRUE and FALSE. Boolean vectors
can be used to obtain a subset of the rows or columns of a matrix. For
instance, the command Smarket[train,] would pick out a submatrix of the
stock market data set, corresponding only to the dates before 2005, since
those are the ones for which the elements of train are TRUE. The ! symbol
can be used to reverse all of the elements of a Boolean vector. That is,
!train is a vector similar to train, except that the elements that are TRUE
in train get swapped to FALSE in !train, and the elements that are FALSE
in train get swapped to TRUE in !train. Therefore, Smarket[!train,] yields
a submatrix of the stock market data containing only the observations for
which train is FALSE—that is, the observations with dates in 2005. The
output above indicates that there are 252 such observations.

We now ﬁt a logistic regression model using only the subset of the obser-
vations that correspond to dates before 2005, using the subset argument.
We then obtain predicted probabilities of the stock market going up for
each of the days in our test set—that is, for the days in 2005.
> glm . fit s = glm ( Direction∼Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume ,

data = Smarket , family = binomial , subset = train )

> glm . probs = predict ( glm . fit s , Smarket .2005 , type =" response ")

Notice that we have trained and tested our model on two completely sep-
arate data sets: training was performed using only the dates before 2005,
and testing was performed using only the dates in 2005. Finally, we com-
pute the predictions for 2005 and compare them to the actual movements
of the market over that time period.

boolean

> glm . pred = rep (" Down " ,252)
> glm . pred [ glm . probs >.5]=" Up "
> table ( glm . pred , Direction .2005)

Direction .2005

glm . pred Down Up
77 97
34 44

Down
Up

> mean ( glm . pred == Direction .2005)

160

4. Classiﬁcation

[1] 0.48
> mean ( glm . pred != Direction .2005)
[1] 0.52

The != notation means not equal to, and so the last command computes
the test set error rate. The results are rather disappointing: the test error
rate is 52 %, which is worse than random guessing! Of course this result
is not all that surprising, given that one would not generally expect to be
able to use previous days’ returns to predict future market performance.
(After all, if it were possible to do so, then the authors of this book would
be out striking it rich rather than writing a statistics textbook.)

We recall that the logistic regression model had very underwhelming p-
values associated with all of the predictors, and that the smallest p-value,
though not very small, corresponded to Lag1. Perhaps by removing the
variables that appear not to be helpful in predicting Direction, we can
obtain a more eﬀective model. After all, using predictors that have no
relationship with the response tends to cause a deterioration in the test
error rate (since such predictors cause an increase in variance without a
corresponding decrease in bias), and so removing such predictors may in
turn yield an improvement. Below we have reﬁt the logistic regression using
just Lag1 and Lag2, which seemed to have the highest predictive power in
the original logistic regression model.
> glm . fit s = glm ( Direction∼Lag1 + Lag2 , data = Smarket , family = binomial ,

subset = train )

> glm . probs = predict ( glm . fit s , Smarket .2005 , type =" response ")
> glm . pred = rep (" Down " ,252)
> glm . pred [ glm . probs >.5]=" Up "
> table ( glm . pred , Direction .2005)

Direction .2005

Up
glm . pred Down
35
35
76 106

Down
Up

> mean ( glm . pred == Direction .2005)
[1] 0.56
> 1 0 6 / ( 1 0 6 + 7 6 )
[1] 0.582

Now the results appear to be a little better: 56% of the daily movements
have been correctly predicted. It is worth noting that in this case, a much
simpler strategy of predicting that the market will increase every day will
also be correct 56% of the time! Hence, in terms of overall error rate, the
logistic regression method is no better than the na¨ıve approach. However,
the confusion matrix shows that on days when logistic regression predicts
an increase in the market, it has a 58% accuracy rate. This suggests a
possible trading strategy of buying on days when the model predicts an in-
creasing market, and avoiding trades on days when a decrease is predicted.
Of course one would need to investigate more carefully whether this small
improvement was real or just due to random chance.

4.6 Lab: Logistic Regression, LDA, QDA, and KNN

161

Suppose that we want to predict the returns associated with particular
values of Lag1 and Lag2. In particular, we want to predict Direction on a
day when Lag1 and Lag2 equal 1.2 and 1.1, respectively, and on a day when
they equal 1.5 and −0.8. We do this using the predict() function.

> predict ( glm . fit s , newdata = data . frame ( Lag1 = c (1.2 ,1.5) ,

Lag2 = c (1.1 , -0.8) ) , type =" response ")

1

2

0.4791

0.4961

4.6.3 Linear Discriminant Analysis

Now we will perform LDA on the Smarket data. In R, we ﬁt an LDA model
using the lda() function, which is part of the MASS library. Notice that the
syntax for the lda() function is identical to that of lm(), and to that of
glm() except for the absence of the family option. We ﬁt the model using
only the observations before 2005.

lda()

> library ( MASS )

> lda . fit = lda ( Direction∼Lag1 + Lag2 , data = Smarket , subset = train )

> lda . fit
Call :

lda ( Direction ∼ Lag1 + Lag2 , data = Smarket , subset = train )

Prior p r o b a b i l i t i e s of groups :

Down

Up
0.492 0.508

Group means :
Lag1
0.0428

Lag2
0.0339
-0.0395 -0.0313

Down
Up

C o e f f i c i e n t s of linear d i s c r i m i n a n t s :

LD1
Lag1 -0.642
Lag2 -0.514
> plot ( lda . fit )

The LDA output indicates that ˆπ1 = 0.492 and ˆπ2 = 0.508; in other words,
49.2 % of the training observations correspond to days during which the
market went down. It also provides the group means; these are the average
of each predictor within each class, and are used by LDA as estimates
of μk. These suggest that there is a tendency for the previous 2 days’
returns to be negative on days when the market increases, and a tendency
for the previous days’ returns to be positive on days when the market
declines. The coeﬃcients of linear discriminants output provides the linear
combination of Lag1 and Lag2 that are used to form the LDA decision rule.
In other words, these are the multipliers of the elements of X = x in
(4.19). If −0.642× Lag1− 0.514× Lag2 is large, then the LDA classiﬁer will

162

4. Classiﬁcation

predict a market increase, and if it is small, then the LDA classiﬁer will
predict a market decline. The plot() function produces plots of the linear
discriminants, obtained by computing −0.642 × Lag1 − 0.514 × Lag2 for
each of the training observations.

The predict() function returns a list with three elements. The ﬁrst ele-
ment, class, contains LDA’s predictions about the movement of the market.
The second element, posterior, is a matrix whose kth column contains the
posterior probability that the corresponding observation belongs to the kth
class, computed from (4.10). Finally, x contains the linear discriminants,
described earlier.

> lda . pred = predict ( lda . fit , Smarket .2005)
> names ( lda . pred )
[1] " class "

" posterior " " x "

As we observed in Section 4.5, the LDA and logistic regression predictions
are almost identical.

> lda . class = lda . pred$class
> table ( lda . class , Direction .2005)

Direction .2005

Up
lda . pred Down
35
35
76 106

Down
Up

> mean ( lda . class == Direction .2005)
[1] 0.56

Applying a 50 % threshold to the posterior probabilities allows us to recre-
ate the predictions contained in lda.pred$class.

> sum ( lda . p r e d $ p o s t e r i o r [ ,1] >=.5)
[1] 70
> sum ( lda . p r e d $ p o s t e r i o r [ ,1] <.5)
[1] 182

Notice that the posterior probability output by the model corresponds to
the probability that the market will decrease:

> lda . p r e d $ p o s t e r i o r [1:20 ,1]
> lda . class [1:20]

If we wanted to use a posterior probability threshold other than 50 % in
order to make predictions, then we could easily do so. For instance, suppose
that we wish to predict a market decrease only if we are very certain that the
market will indeed decrease on that day—say, if the posterior probability
is at least 90 %.

> sum ( lda . p r e d $ p o s t e r i o r [ ,1] >.9)
[1] 0

No days in 2005 meet that threshold! In fact, the greatest posterior prob-
ability of decrease in all of 2005 was 52.02 %.

4.6 Lab: Logistic Regression, LDA, QDA, and KNN

163

4.6.4 Quadratic Discriminant Analysis

We will now ﬁt a QDA model to the Smarket data. QDA is implemented
in R using the qda() function, which is also part of the MASS library. The
syntax is identical to that of lda().
> qda . fit = qda ( Direction∼Lag1 + Lag2 , data = Smarket , subset = train )

qda()

> qda . fit
Call :

qda ( Direction ∼ Lag1 + Lag2 , data = Smarket , subset = train )

Prior p r o b a b i l i t i e s of groups :

Down

Up
0.492 0.508

Group means :
Lag1
0.0428

Lag2
0.0339
-0.0395 -0.0313

Down
Up

The output contains the group means. But it does not contain the coef-
ﬁcients of the linear discriminants, because the QDA classiﬁer involves a
quadratic, rather than a linear, function of the predictors. The predict()
function works in exactly the same fashion as for LDA.

> qda . class = predict ( qda . fit , Smarket .2005) $class
> table ( qda . class , Direction .2005)

Direction .2005

qda . class Down

Up

Down
Up

30
20
81 121

> mean ( qda . class == Direction .2005)
[1] 0.599

Interestingly, the QDA predictions are accurate almost 60 % of the time,
even though the 2005 data was not used to ﬁt the model. This level of accu-
racy is quite impressive for stock market data, which is known to be quite
hard to model accurately. This suggests that the quadratic form assumed
by QDA may capture the true relationship more accurately than the linear
forms assumed by LDA and logistic regression. However, we recommend
evaluating this method’s performance on a larger test set before betting
that this approach will consistently beat the market!

4.6.5 K-Nearest Neighbors

We will now perform KNN using the knn() function, which is part of the
class library. This function works rather diﬀerently from the other model-
ﬁtting functions that we have encountered thus far. Rather than a two-step
approach in which we ﬁrst ﬁt the model and then we use the model to make
predictions, knn() forms predictions using a single command. The function
requires four inputs.

knn()

164

4. Classiﬁcation

1. A matrix containing the predictors associated with the training data,

labeled train.X below.

2. A matrix containing the predictors associated with the data for which

we wish to make predictions, labeled test.X below.

3. A vector containing the class labels for the training observations,

labeled train.Direction below.

4. A value for K, the number of nearest neighbors to be used by the

classiﬁer.

We use the cbind() function, short for column bind, to bind the Lag1 and
Lag2 variables together into two matrices, one for the training set and the
other for the test set.

cbind()

> library ( class )
> train . X = cbind ( Lag1 , Lag2 ) [ train ,]
> test . X = cbind ( Lag1 , Lag2 ) [! train ,]
> train . Direction = Direction [ train ]

Now the knn() function can be used to predict the market’s movement for
the dates in 2005. We set a random seed before we apply knn() because
if several observations are tied as nearest neighbors, then R will randomly
break the tie. Therefore, a seed must be set in order to ensure reproducibil-
ity of results.

> set . seed (1)
> knn . pred = knn ( train .X , test .X , train . Direction , k =1)
> table ( knn . pred , Direction .2005)

Direction .2005

knn . pred Down Up
43 58
68 83

Down
Up

> (83+43) /252
[1] 0.5

The results using K = 1 are not very good, since only 50 % of the observa-
tions are correctly predicted. Of course, it may be that K = 1 results in an
overly ﬂexible ﬁt to the data. Below, we repeat the analysis using K = 3.

> knn . pred = knn ( train .X , test .X , train . Direction , k =3)
> table ( knn . pred , Direction .2005)

Direction .2005

knn . pred Down Up
48 54
63 87

Down
Up

> mean ( knn . pred == Direction .2005)
[1] 0.536

The results have improved slightly. But increasing K further turns out
to provide no further improvements. It appears that for this data, QDA
provides the best results of the methods that we have examined so far.

4.6 Lab: Logistic Regression, LDA, QDA, and KNN

165

4.6.6 An Application to Caravan Insurance Data

Finally, we will apply the KNN approach to the Caravan data set, which is
part of the ISLR library. This data set includes 85 predictors that measure
demographic characteristics for 5,822 individuals. The response variable is
Purchase, which indicates whether or not a given individual purchases a
caravan insurance policy. In this data set, only 6 % of people purchased
caravan insurance.

> dim ( Caravan )
[1] 5822
> attach ( Caravan )
> summary ( Purchase )

86

Yes
348

No
5474
> 348/5822
[1] 0.0598

Because the KNN classiﬁer predicts the class of a given test observation by
identifying the observations that are nearest to it, the scale of the variables
matters. Any variables that are on a large scale will have a much larger
eﬀect on the distance between the observations, and hence on the KNN
classiﬁer, than variables that are on a small scale. For instance, imagine a
data set that contains two variables, salary and age (measured in dollars
and years, respectively). As far as KNN is concerned, a diﬀerence of $1,000
in salary is enormous compared to a diﬀerence of 50 years in age. Conse-
quently, salary will drive the KNN classiﬁcation results, and age will have
almost no eﬀect. This is contrary to our intuition that a salary diﬀerence
of $1, 000 is quite small compared to an age diﬀerence of 50 years. Further-
more, the importance of scale to the KNN classiﬁer leads to another issue:
if we measured salary in Japanese yen, or if we measured age in minutes,
then we’d get quite diﬀerent classiﬁcation results from what we get if these
two variables are measured in dollars and years.

A good way to handle this problem is to standardize the data so that all
variables are given a mean of zero and a standard deviation of one. Then
all variables will be on a comparable scale. The scale() function does just
this. In standardizing the data, we exclude column 86, because that is the
qualitative Purchase variable.

standardize

scale()

> s t a n d a r d i z e d . X = scale ( Caravan [ , -86])
> var ( Caravan [ ,1])
[1] 165
> var ( Caravan [ ,2])
[1] 0.165
> var ( s t a n d a r d i z e d . X [ ,1])
[1] 1
> var ( s t a n d a r d i z e d . X [ ,2])
[1] 1

Now every column of standardized.X has a standard deviation of one and
a mean of zero.

166

4. Classiﬁcation

We now split the observations into a test set, containing the ﬁrst 1,000
observations, and a training set, containing the remaining observations.
We ﬁt a KNN model on the training data using K = 1, and evaluate its
performance on the test data.

> test =1:1000
> train . X = s t a n d a r d i z e d . X [ - test ,]
> test . X = s t a n d a r d i z e d . X [ test ,]
> train . Y = Purchase [ - test ]
> test . Y = Purchase [ test ]
> set . seed (1)
> knn . pred = knn ( train .X , test .X , train .Y , k =1)
> mean ( test . Y != knn . pred )
[1] 0.118
> mean ( test . Y !=" No ")
[1] 0.059

The vector test is numeric, with values from 1 through 1, 000. Typing
standardized.X[test,] yields the submatrix of the data containing the ob-
servations whose indices range from 1 to 1, 000, whereas typing
standardized.X[-test,] yields the submatrix containing the observations
whose indices do not range from 1 to 1, 000. The KNN error rate on the
1,000 test observations is just under 12 %. At ﬁrst glance, this may ap-
pear to be fairly good. However, since only 6 % of customers purchased
insurance, we could get the error rate down to 6 % by always predicting No
regardless of the values of the predictors!

Suppose that there is some non-trivial cost to trying to sell insurance
to a given individual. For instance, perhaps a salesperson must visit each
potential customer. If the company tries to sell insurance to a random
selection of customers, then the success rate will be only 6 %, which may
be far too low given the costs involved. Instead, the company would like
to try to sell insurance only to customers who are likely to buy it. So the
overall error rate is not of interest. Instead, the fraction of individuals that
are correctly predicted to buy insurance is of interest.

It turns out that KNN with K = 1 does far better than random guessing
among the customers that are predicted to buy insurance. Among 77 such
customers, 9, or 11.7 %, actually do purchase insurance. This is double the
rate that one would obtain from random guessing.

> table ( knn . pred , test . Y )

knn . pred

No
Yes

test . Y

No Yes
50
9

873
68

> 9/(68+9)
[1] 0.117

Using K = 3, the success rate increases to 19 %, and with K = 5 the rate is
26.7 %. This is over four times the rate that results from random guessing.
It appears that KNN is ﬁnding some real patterns in a diﬃcult data set!

4.6 Lab: Logistic Regression, LDA, QDA, and KNN

167

> knn . pred = knn ( train .X , test .X , train .Y , k =3)
> table ( knn . pred , test . Y )

knn . pred

No
Yes

test . Y

No Yes
54
5

920
21

> 5/26
[1] 0.192
> knn . pred = knn ( train .X , test .X , train .Y , k =5)
> table ( knn . pred , test . Y )

knn . pred

No
Yes

test . Y

No Yes
55
4

930
11

> 4/15
[1] 0.267

As a comparison, we can also ﬁt a logistic regression model to the data.
If we use 0.5 as the predicted probability cut-oﬀ for the classiﬁer, then
we have a problem: only seven of the test observations are predicted to
purchase insurance. Even worse, we are wrong about all of these! However,
we are not required to use a cut-oﬀ of 0.5. If we instead predict a purchase
any time the predicted probability of purchase exceeds 0.25, we get much
better results: we predict that 33 people will purchase insurance, and we
are correct for about 33 % of these people. This is over ﬁve times better
than random guessing!
> glm . fit s = glm ( Purchase∼. , data = Caravan , family = binomial ,

subset = - test )

: fitted p r o b a b i l i t i e s numerical l y 0 or 1 occurred

, Caravan [ test ,] , type =" response ")

Warning message :
g lm . fit s
> glm . probs = predict (
> glm . pred = rep (" No " ,1000)
> glm . pred [ glm . probs >.5]=" Yes "
> table ( glm . pred , test . Y )

g lm . fit s

glm . pred

No
Yes

test . Y

No Yes
59
0

934
7

> glm . pred = rep (" No " ,1000)
> glm . pred [ glm . probs >.25]=" Yes "
> table ( glm . pred , test . Y )

test . Y

No Yes
48
11

glm . pred

No
Yes

919
22
> 11/(22+11 )
[1] 0.333

168

4. Classiﬁcation

4.7 Exercises

Conceptual

1. Using a little bit of algebra, prove that (4.2) is equivalent to (4.3). In
other words, the logistic function representation and logit represen-
tation for the logistic regression model are equivalent.

2. It was stated in the text that classifying an observation to the class
for which (4.12) is largest is equivalent to classifying an observation
to the class for which (4.13) is largest. Prove that this is the case. In
other words, under the assumption that the observations in the kth
class are drawn from a N (μk, σ2) distribution, the Bayes’ classiﬁer
assigns an observation to the class for which the discriminant function
is maximized.

3. This problem relates to the QDA model, in which the observations
within each class are drawn from a normal distribution with a class-
speciﬁc mean vector and a class speciﬁc covariance matrix. We con-
sider the simple case where p = 1; i.e. there is only one feature.

tribution, X ∼ N (μk, σ2

Suppose that we have K classes, and that if an observation belongs
to the kth class then X comes from a one-dimensional normal dis-
k). Recall that the density function for the
one-dimensional normal distribution is given in (4.11). Prove that in
this case, the Bayes’ classiﬁer is not linear. Argue that it is in fact
quadratic.

Hint: For this problem, you should follow the arguments laid out in
Section 4.4.2, but without making the assumption that σ2
1 = . . . = σ2
K .

4. When the number of features p is large, there tends to be a deteri-
oration in the performance of KNN and other local approaches that
perform prediction using only observations that are near the test ob-
servation for which a prediction must be made. This phenomenon is
known as the curse of dimensionality, and it ties into the fact that
non-parametric approaches often perform poorly when p is large. We
will now investigate this curse.

curse of di-
mensionality

(a) Suppose that we have a set of observations, each with measure-
ments on p = 1 feature, X. We assume that X is uniformly
(evenly) distributed on [0, 1]. Associated with each observation
is a response value. Suppose that we wish to predict a test obser-
vation’s response using only observations that are within 10 % of
the range of X closest to that test observation. For instance, in
order to predict the response for a test observation with X = 0.6,

4.7 Exercises

169

we will use observations in the range [0.55, 0.65]. On average,
what fraction of the available observations will we use to make
the prediction?

(b) Now suppose that we have a set of observations, each with
measurements on p = 2 features, X1 and X2. We assume that
(X1, X2) are uniformly distributed on [0, 1] × [0, 1]. We wish to

predict a test observation’s response using only observations that
are within 10 % of the range of X1 and within 10 % of the range
of X2 closest to that test observation. For instance, in order to
predict the response for a test observation with X1 = 0.6 and
X2 = 0.35, we will use observations in the range [0.55, 0.65] for
X1 and in the range [0.3, 0.4] for X2. On average, what fraction
of the available observations will we use to make the prediction?

(c) Now suppose that we have a set of observations on p = 100 fea-
tures. Again the observations are uniformly distributed on each
feature, and again each feature ranges in value from 0 to 1. We
wish to predict a test observation’s response using observations
within the 10 % of each feature’s range that is closest to that test
observation. What fraction of the available observations will we
use to make the prediction?

(d) Using your answers to parts (a)–(c), argue that a drawback of
KNN when p is large is that there are very few training obser-
vations “near” any given test observation.

(e) Now suppose that we wish to make a prediction for a test obser-
vation by creating a p-dimensional hypercube centered around
the test observation that contains, on average, 10 % of the train-
ing observations. For p = 1, 2, and 100, what is the length of
each side of the hypercube? Comment on your answer.

Note: A hypercube is a generalization of a cube to an arbitrary
number of dimensions. When p = 1, a hypercube is simply a line
segment, when p = 2 it is a square, and when p = 100 it is a
100-dimensional cube.

5. We now examine the diﬀerences between LDA and QDA.

(a) If the Bayes decision boundary is linear, do we expect LDA or

QDA to perform better on the training set? On the test set?

(b) If the Bayes decision boundary is non-linear, do we expect LDA
or QDA to perform better on the training set? On the test set?

(c) In general, as the sample size n increases, do we expect the test
prediction accuracy of QDA relative to LDA to improve, decline,
or be unchanged? Why?

170

4. Classiﬁcation

(d) True or False: Even if the Bayes decision boundary for a given
problem is linear, we will probably achieve a superior test er-
ror rate using QDA rather than LDA because QDA is ﬂexible
enough to model a linear decision boundary. Justify your answer.

6. Suppose we collect data for a group of students in a statistics class
with variables X1 = hours studied, X2 = undergrad GPA, and Y =
receive an A. We ﬁt a logistic regression and produce estimated
coeﬃcient, ˆβ0 = −6, ˆβ1 = 0.05, ˆβ2 = 1.

(a) Estimate the probability that a student who studies for 40 h and

has an undergrad GPA of 3.5 gets an A in the class.

(b) How many hours would the student in part (a) need to study to

have a 50 % chance of getting an A in the class?

7. Suppose that we wish to predict whether a given stock will issue a
dividend this year (“Yes” or “No”) based on X, last year’s percent
proﬁt. We examine a large number of companies and discover that the
mean value of X for companies that issued a dividend was ¯X = 10,
while the mean for those that didn’t was ¯X = 0. In addition, the
variance of X for these two sets of companies was ˆσ2 = 36. Finally,
80 % of companies issued dividends. Assuming that X follows a nor-
mal distribution, predict the probability that a company will issue
a dividend this year given that its percentage proﬁt was X = 4 last
year.

Hint: Recall that the density function for a normal random variable
is f (x) = 1√

. You will need to use Bayes’ theorem.

−(x−μ)2/2σ2

2πσ2 e

8. Suppose that we take a data set, divide it into equally-sized training
and test sets, and then try out two diﬀerent classiﬁcation procedures.
First we use logistic regression and get an error rate of 20 % on the
training data and 30 % on the test data. Next we use 1-nearest neigh-
bors (i.e. K = 1) and get an average error rate (averaged over both
test and training data sets) of 18 %. Based on these results, which
method should we prefer to use for classiﬁcation of new observations?
Why?

9. This problem has to do with odds.

(a) On average, what fraction of people with an odds of 0.37 of

defaulting on their credit card payment will in fact default?

(b) Suppose that an individual has a 16 % chance of defaulting on
her credit card payment. What are the odds that she will de-
fault?

4.7 Exercises

171

Applied

10. This question should be answered using the Weekly data set, which
is part of the ISLR package. This data is similar in nature to the
Smarket data from this chapter’s lab, except that it contains 1, 089
weekly returns for 21 years, from the beginning of 1990 to the end of
2010.

(a) Produce some numerical and graphical summaries of the Weekly

data. Do there appear to be any patterns?

(b) Use the full data set to perform a logistic regression with
Direction as the response and the ﬁve lag variables plus Volume
as predictors. Use the summary function to print the results. Do
any of the predictors appear to be statistically signiﬁcant? If so,
which ones?

(c) Compute the confusion matrix and overall fraction of correct
predictions. Explain what the confusion matrix is telling you
about the types of mistakes made by logistic regression.

(d) Now ﬁt the logistic regression model using a training data period
from 1990 to 2008, with Lag2 as the only predictor. Compute the
confusion matrix and the overall fraction of correct predictions
for the held out data (that is, the data from 2009 and 2010).

(e) Repeat (d) using LDA.

(f) Repeat (d) using QDA.

(g) Repeat (d) using KNN with K = 1.

(h) Which of these methods appears to provide the best results on

this data?

(i) Experiment with diﬀerent combinations of predictors, includ-
ing possible transformations and interactions, for each of the
methods. Report the variables, method, and associated confu-
sion matrix that appears to provide the best results on the held
out data. Note that you should also experiment with values for
K in the KNN classiﬁer.

11. In this problem, you will develop a model to predict whether a given

car gets high or low gas mileage based on the Auto data set.

(a) Create a binary variable, mpg01, that contains a 1 if mpg contains
a value above its median, and a 0 if mpg contains a value below
its median. You can compute the median using the median()
function. Note you may ﬁnd it helpful to use the data.frame()
function to create a single data set containing both mpg01 and
the other Auto variables.

172

4. Classiﬁcation

(b) Explore the data graphically in order to investigate the associ-
ation between mpg01 and the other features. Which of the other
features seem most likely to be useful in predicting mpg01? Scat-
terplots and boxplots may be useful tools to answer this ques-
tion. Describe your ﬁndings.

(c) Split the data into a training set and a test set.

(d) Perform LDA on the training data in order to predict mpg01
using the variables that seemed most associated with mpg01 in
(b). What is the test error of the model obtained?

(e) Perform QDA on the training data in order to predict mpg01
using the variables that seemed most associated with mpg01 in
(b). What is the test error of the model obtained?

(f) Perform logistic regression on the training data in order to pre-
dict mpg01 using the variables that seemed most associated with
mpg01 in (b). What is the test error of the model obtained?

(g) Perform KNN on the training data, with several values of K, in
order to predict mpg01. Use only the variables that seemed most
associated with mpg01 in (b). What test errors do you obtain?
Which value of K seems to perform the best on this data set?

12. This problem involves writing functions.

(a) Write a function, Power(), that prints out the result of raising 2
to the 3rd power. In other words, your function should compute
23 and print out the results.
Hint: Recall that x^a raises x to the power a. Use the print()
function to output the result.

(b) Create a new function, Power2(), that allows you to pass any
two numbers, x and a, and prints out the value of x^a. You can
do this by beginning your function with the line

> Power2 = function (x , a ) {

You should be able to call your function by entering, for instance,

> Power2 (3 ,8)

on the command line. This should output the value of 38, namely,
6, 561.

(c) Using the Power2() function that you just wrote, compute 103,

817, and 1313.

(d) Now create a new function, Power3(), that actually returns the
result x^a as an R object, rather than simply printing it to the
screen. That is, if you store the value x^a in an object called
result within your function, then you can simply return() this
result, using the following line:

return()

4.7 Exercises

173

return ( result )

The line above should be the last line in your function, before
the } symbol.

(e) Now using the Power3() function, create a plot of f (x) = x2.
The x-axis should display a range of integers from 1 to 10, and
the y-axis should display x2. Label the axes appropriately, and
use an appropriate title for the ﬁgure. Consider displaying either
the x-axis, the y-axis, or both on the log-scale. You can do this
by using log=‘‘x’’, log=‘‘y’’, or log=‘‘xy’’ as arguments to
the plot() function.

(f) Create a function, PlotPower(), that allows you to create a plot
of x against x^a for a ﬁxed a and for a range of values of x. For
instance, if you call

> PlotPower (1:10 ,3)

then a plot should be created with an x-axis taking on values
1, 2, . . . , 10, and a y-axis taking on values 13, 23, . . . , 103.

13. Using the Boston data set, ﬁt classiﬁcation models in order to predict
whether a given suburb has a crime rate above or below the median.
Explore logistic regression, LDA, and KNN models using various sub-
sets of the predictors. Describe your ﬁndings.

5
Resampling Methods

Resampling methods are an indispensable tool in modern statistics. They
involve repeatedly drawing samples from a training set and reﬁtting a model
of interest on each sample in order to obtain additional information about
the ﬁtted model. For example, in order to estimate the variability of a linear
regression ﬁt, we can repeatedly draw diﬀerent samples from the training
data, ﬁt a linear regression to each new sample, and then examine the
extent to which the resulting ﬁts diﬀer. Such an approach may allow us to
obtain information that would not be available from ﬁtting the model only
once using the original training sample.

Resampling approaches can be computationally expensive, because they
involve ﬁtting the same statistical method multiple times using diﬀerent
subsets of the training data. However, due to recent advances in computing
power, the computational requirements of resampling methods generally
are not prohibitive. In this chapter, we discuss two of the most commonly
used resampling methods, cross-validation and the bootstrap. Both methods
are important tools in the practical application of many statistical learning
procedures. For example, cross-validation can be used to estimate the test
error associated with a given statistical learning method in order to evaluate
its performance, or to select the appropriate level of ﬂexibility. The process
of evaluating a model’s performance is known as model assessment, whereas
the process of selecting the proper level of ﬂexibility for a model is known as
model selection. The bootstrap is used in several contexts, most commonly
to provide a measure of accuracy of a parameter estimate or of a given
statistical learning method.

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 5,
© Springer Science+Business Media New York 2013

175

model
assessment

model
selection

176

5. Resampling Methods

5.1 Cross-Validation

In Chapter 2 we discuss the distinction between the test error rate and the
training error rate. The test error is the average error that results from using
a statistical learning method to predict the response on a new observation—
that is, a measurement that was not used in training the method. Given
a data set, the use of a particular statistical learning method is warranted
if it results in a low test error. The test error can be easily calculated if a
designated test set is available. Unfortunately, this is usually not the case.
In contrast, the training error can be easily calculated by applying the
statistical learning method to the observations used in its training. But as
we saw in Chapter 2, the training error rate often is quite diﬀerent from the
test error rate, and in particular the former can dramatically underestimate
the latter.

In the absence of a very large designated test set that can be used to
directly estimate the test error rate, a number of techniques can be used
to estimate this quantity using the available training data. Some methods
make a mathematical adjustment to the training error rate in order to
estimate the test error rate. Such approaches are discussed in Chapter 6.
In this section, we instead consider a class of methods that estimate the
test error rate by holding out a subset of the training observations from the
ﬁtting process, and then applying the statistical learning method to those
held out observations.

In Sections 5.1.1–5.1.4, for simplicity we assume that we are interested
in performing regression with a quantitative response. In Section 5.1.5 we
consider the case of classiﬁcation with a qualitative response. As we will
see, the key concepts remain the same regardless of whether the response
is quantitative or qualitative.

5.1.1 The Validation Set Approach

Suppose that we would like to estimate the test error associated with ﬁt-
ting a particular statistical learning method on a set of observations. The
validation set approach, displayed in Figure 5.1, is a very simple strategy
for this task. It involves randomly dividing the available set of observa-
tions into two parts, a training set and a validation set or hold-out set. The
model is ﬁt on the training set, and the ﬁtted model is used to predict the
responses for the observations in the validation set. The resulting validation
set error rate—typically assessed using MSE in the case of a quantitative
response—provides an estimate of the test error rate.

We illustrate the validation set approach on the Auto data set. Recall from
Chapter 3 that there appears to be a non-linear relationship between mpg
and horsepower, and that a model that predicts mpg using horsepower and
2 gives better results than a model that uses only a linear term.
horsepower
It is natural to wonder whether a cubic or higher-order ﬁt might provide

validation
set approach

validation
set
hold-out set

1 2 3

7  22  13

5.1 Cross-Validation

177

n

91

FIGURE 5.1. A schematic display of the validation set approach. A set of n
observations are randomly split into a training set (shown in blue, containing
observations 7, 22, and 13, among others) and a validation set (shown in beige,
and containing observation 91, among others). The statistical learning method is
ﬁt on the training set, and its performance is evaluated on the validation set.

even better results. We answer this question in Chapter 3 by looking at
the p-values associated with a cubic term and higher-order polynomial
terms in a linear regression. But we could also answer this question using
the validation method. We randomly split the 392 observations into two
sets, a training set containing 196 of the data points, and a validation set
containing the remaining 196 observations. The validation set error rates
that result from ﬁtting various regression models on the training sample
and evaluating their performance on the validation sample, using MSE
as a measure of validation set error, are shown in the left-hand panel of
Figure 5.2. The validation set MSE for the quadratic ﬁt is considerably
smaller than for the linear ﬁt. However, the validation set MSE for the cubic
ﬁt is actually slightly larger than for the quadratic ﬁt. This implies that
including a cubic term in the regression does not lead to better prediction
than simply using a quadratic term.

Recall that in order to create the left-hand panel of Figure 5.2, we ran-
domly divided the data set into two parts, a training set and a validation
set. If we repeat the process of randomly splitting the sample set into two
parts, we will get a somewhat diﬀerent estimate for the test MSE. As an
illustration, the right-hand panel of Figure 5.2 displays ten diﬀerent vali-
dation set MSE curves from the Auto data set, produced using ten diﬀerent
random splits of the observations into training and validation sets. All ten
curves indicate that the model with a quadratic term has a dramatically
smaller validation set MSE than the model with only a linear term. Fur-
thermore, all ten curves indicate that there is not much beneﬁt in including
cubic or higher-order polynomial terms in the model. But it is worth noting
that each of the ten curves results in a diﬀerent test MSE estimate for each
of the ten regression models considered. And there is no consensus among
the curves as to which model results in the smallest validation set MSE.
Based on the variability among these curves, all that we can conclude with
any conﬁdence is that the linear ﬁt is not adequate for this data.

The validation set approach is conceptually simple and is easy to imple-

ment. But it has two potential drawbacks:

178

5. Resampling Methods

r
o
r
r

E
 
d
e
r
a
u
q
S
 
n
a
e
M

8
2

6
2

4
2

2
2

0
2

8
1

6
1

r
o
r
r

E
 
d
e
r
a
u
q
S
 
n
a
e
M

8
2

6
2

4
2

2
2

0
2

8
1

6
1

2

4

6

8

10

2

4

6

8

10

Degree of Polynomial

Degree of Polynomial

FIGURE 5.2. The validation set approach was used on the Auto data set in
order to estimate the test error that results from predicting mpg using polynomial
functions of horsepower. Left: Validation error estimates for a single split into
training and validation data sets. Right: The validation method was repeated ten
times, each time using a diﬀerent random split of the observations into a training
set and a validation set. This illustrates the variability in the estimated test MSE
that results from this approach.

1. As is shown in the right-hand panel of Figure 5.2, the validation esti-
mate of the test error rate can be highly variable, depending on pre-
cisely which observations are included in the training set and which
observations are included in the validation set.

2. In the validation approach, only a subset of the observations—those
that are included in the training set rather than in the validation
set—are used to ﬁt the model. Since statistical methods tend to per-
form worse when trained on fewer observations, this suggests that the
validation set error rate may tend to overestimate the test error rate
for the model ﬁt on the entire data set.

In the coming subsections, we will present cross-validation, a reﬁnement of
the validation set approach that addresses these two issues.

5.1.2 Leave-One-Out Cross-Validation

Leave-one-out cross-validation (LOOCV) is closely related to the validation
set approach of Section 5.1.1, but it attempts to address that method’s
drawbacks.

Like the validation set approach, LOOCV involves splitting the set of
observations into two parts. However, instead of creating two subsets of
comparable size, a single observation (x1, y1) is used for the validation
set, and the remaining observations {(x2, y2), . . . , (xn, yn)} make up the
training set. The statistical learning method is ﬁt on the n − 1 training
observations, and a prediction ˆy1 is made for the excluded observation,
using its value x1. Since (x1, y1) was not used in the ﬁtting process, MSE1 =

leave-one-
out
cross-
validation

5.1 Cross-Validation

179

1  2  3

1  2  3

1  2  3

1  2  3

1  2  3

·
·
·

n

n

n

n

n

FIGURE 5.3. A schematic display of LOOCV. A set of n data points is repeat-
edly split into a training set (shown in blue) containing all but one observation,
and a validation set that contains only that observation (shown in beige). The test
error is then estimated by averaging the n resulting MSE’s. The ﬁrst training set
contains all but observation 1, the second training set contains all but observation
2, and so forth.

(y1 − ˆy1)2 provides an approximately unbiased estimate for the test error.
But even though MSE1 is unbiased for the test error, it is a poor estimate
because it is highly variable, since it is based upon a single observation
(x1, y1).
We can repeat the procedure by selecting (x2, y2) for the validation
data, training the statistical learning procedure on the n − 1 observations
{(x1, y1), (x3, y3), . . . , (xn, yn)}, and computing MSE2 = (y2−ˆy2)2. Repeat-
ing this approach n times produces n squared errors, MSE1, . . . , MSEn.
The LOOCV estimate for the test MSE is the average of these n test error
estimates:

CV(n) =

n(cid:17)

i=1

1
n

MSEi.

(5.1)

A schematic of the LOOCV approach is illustrated in Figure 5.3.

LOOCV has a couple of major advantages over the validation set ap-
proach. First, it has far less bias. In LOOCV, we repeatedly ﬁt the sta-
tistical learning method using training sets that contain n − 1 observa-
tions, almost as many as are in the entire data set. This is in contrast to
the validation set approach, in which the training set is typically around
half the size of the original data set. Consequently, the LOOCV approach
tends not to overestimate the test error rate as much as the validation
set approach does. Second, in contrast to the validation approach which
will yield diﬀerent results when applied repeatedly due to randomness in
the training/validation set splits, performing LOOCV multiple times will

180

5. Resampling Methods

LOOCV

10−fold CV

r
o
r
r

E
 
d
e
r
a
u
q
S
 
n
a
e
M

8
2

6
2

4
2

2
2

0
2

8
1

6
1

r
o
r
r

E
 
d
e
r
a
u
q
S
 
n
a
e
M

8
2

6
2

4
2

2
2

0
2

8
1

6
1

2

4

6

8

10

2

4

6

8

10

Degree of Polynomial

Degree of Polynomial

FIGURE 5.4. Cross-validation was used on the Auto data set in order to es-
timate the test error that results from predicting mpg using polynomial functions
of horsepower. Left: The LOOCV error curve. Right: 10-fold CV was run nine
separate times, each with a diﬀerent random split of the data into ten parts. The
ﬁgure shows the nine slightly diﬀerent CV error curves.

always yield the same results: there is no randomness in the training/vali-
dation set splits.

We used LOOCV on the Auto data set in order to obtain an estimate
of the test set MSE that results from ﬁtting a linear regression model to
predict mpg using polynomial functions of horsepower. The results are shown
in the left-hand panel of Figure 5.4.

LOOCV has the potential to be expensive to implement, since the model
has to be ﬁt n times. This can be very time consuming if n is large, and if
each individual model is slow to ﬁt. With least squares linear or polynomial
regression, an amazing shortcut makes the cost of LOOCV the same as that
of a single model ﬁt! The following formula holds:

(cid:11)

n(cid:17)

i=1

(cid:12)2

,

yi − ˆyi
1 − hi

1
n

CV(n) =

(5.2)

where ˆyi is the ith ﬁtted value from the original least squares ﬁt, and hi is
the leverage deﬁned in (3.37) on page 98. This is like the ordinary MSE,
except the ith residual is divided by 1 − hi. The leverage lies between 1/n

and 1, and reﬂects the amount that an observation inﬂuences its own ﬁt.
Hence the residuals for high-leverage points are inﬂated in this formula by
exactly the right amount for this equality to hold.

LOOCV is a very general method, and can be used with any kind of
predictive modeling. For example we could use it with logistic regression
or linear discriminant analysis, or any of the methods discussed in later

1 2 3

11 76 5

11 76 5

11 76 5

11 76 5

11 76 5

5.1 Cross-Validation

181

n

47

47

47

47

47

FIGURE 5.5. A schematic display of 5-fold CV. A set of n observations is
randomly split into ﬁve non-overlapping groups. Each of these ﬁfths acts as a
validation set (shown in beige), and the remainder as a training set (shown in
blue). The test error is estimated by averaging the ﬁve resulting MSE estimates.

chapters. The magic formula (5.2) does not hold in general, in which case
the model has to be reﬁt n times.

5.1.3 k-Fold Cross-Validation

An alternative to LOOCV is k-fold CV. This approach involves randomly
dividing the set of observations into k groups, or folds, of approximately
equal size. The ﬁrst fold is treated as a validation set, and the method

is ﬁt on the remaining k − 1 folds. The mean squared error, MSE1, is

k-fold CV

then computed on the observations in the held-out fold. This procedure is
repeated k times; each time, a diﬀerent group of observations is treated
as a validation set. This process results in k estimates of the test error,
MSE1, MSE2, . . . , MSEk. The k-fold CV estimate is computed by averaging
these values,

k(cid:17)

CV(k) =

1
k

MSEi.

i=1

(5.3)

Figure 5.5 illustrates the k-fold CV approach.

It is not hard to see that LOOCV is a special case of k-fold CV in which k
is set to equal n. In practice, one typically performs k-fold CV using k = 5
or k = 10. What is the advantage of using k = 5 or k = 10 rather than
k = n? The most obvious advantage is computational. LOOCV requires
ﬁtting the statistical learning method n times. This has the potential to be
computationally expensive (except for linear models ﬁt by least squares,
in which case formula (5.2) can be used). But cross-validation is a very
general approach that can be applied to almost any statistical learning
method. Some statistical learning methods have computationally intensive
ﬁtting procedures, and so performing LOOCV may pose computational
problems, especially if n is extremely large. In contrast, performing 10-fold

182

5. Resampling Methods

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
.
3

5
.
2

0
.
2

5
.
1

0
.
1

5
.
0

0

.

0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
.
3

5
.
2

0
.
2

5
.
1

0
.
1

5
.
0

0

.

0

0
2

5
1

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
1

5

0

2

5

10

20

2

5

10

20

2

5

10

20

Flexibility

Flexibility

Flexibility

FIGURE 5.6. True and estimated test MSE for the simulated data sets in Fig-
ures 2.9 ( left), 2.10 ( center), and 2.11 ( right). The true test MSE is shown in
blue, the LOOCV estimate is shown as a black dashed line, and the 10-fold CV
estimate is shown in orange. The crosses indicate the minimum of each of the
MSE curves.

CV requires ﬁtting the learning procedure only ten times, which may be
much more feasible. As we see in Section 5.1.4, there also can be other
non-computational advantages to performing 5-fold or 10-fold CV, which
involve the bias-variance trade-oﬀ.

The right-hand panel of Figure 5.4 displays nine diﬀerent 10-fold CV
estimates for the Auto data set, each resulting from a diﬀerent random
split of the observations into ten folds. As we can see from the ﬁgure, there
is some variability in the CV estimates as a result of the variability in how
the observations are divided into ten folds. But this variability is typically
much lower than the variability in the test error estimates that results from
the validation set approach (right-hand panel of Figure 5.2).

When we examine real data, we do not know the true test MSE, and
so it is diﬃcult to determine the accuracy of the cross-validation estimate.
However, if we examine simulated data, then we can compute the true
test MSE, and can thereby evaluate the accuracy of our cross-validation
results. In Figure 5.6, we plot the cross-validation estimates and true test
error rates that result from applying smoothing splines to the simulated
data sets illustrated in Figures 2.9–2.11 of Chapter 2. The true test MSE
is displayed in blue. The black dashed and orange solid lines respectively
show the estimated LOOCV and 10-fold CV estimates. In all three plots,
the two cross-validation estimates are very similar. In the right-hand panel
of Figure 5.6, the true test MSE and the cross-validation curves are almost
identical. In the center panel of Figure 5.6, the two sets of curves are similar
at the lower degrees of ﬂexibility, while the CV curves overestimate the test
set MSE for higher degrees of ﬂexibility. In the left-hand panel of Figure 5.6,
the CV curves have the correct general shape, but they underestimate the
true test MSE.

5.1 Cross-Validation

183

When we perform cross-validation, our goal might be to determine how
well a given statistical learning procedure can be expected to perform on
independent data; in this case, the actual estimate of the test MSE is
of interest. But at other times we are interested only in the location of
the minimum point in the estimated test MSE curve. This is because we
might be performing cross-validation on a number of statistical learning
methods, or on a single method using diﬀerent levels of ﬂexibility, in order
to identify the method that results in the lowest test error. For this purpose,
the location of the minimum point in the estimated test MSE curve is
important, but the actual value of the estimated test MSE is not. We ﬁnd
in Figure 5.6 that despite the fact that they sometimes underestimate the
true test MSE, all of the CV curves come close to identifying the correct
level of ﬂexibility—that is, the ﬂexibility level corresponding to the smallest
test MSE.

5.1.4 Bias-Variance Trade-Oﬀ for k-Fold Cross-Validation

We mentioned in Section 5.1.3 that k-fold CV with k < n has a compu-
tational advantage to LOOCV. But putting computational issues aside,
a less obvious but potentially more important advantage of k-fold CV is
that it often gives more accurate estimates of the test error rate than does
LOOCV. This has to do with a bias-variance trade-oﬀ.

It was mentioned in Section 5.1.1 that the validation set approach can
lead to overestimates of the test error rate, since in this approach the
training set used to ﬁt the statistical learning method contains only half
the observations of the entire data set. Using this logic, it is not hard to
see that LOOCV will give approximately unbiased estimates of the test
error, since each training set contains n − 1 observations, which is almost
as many as the number of observations in the full data set. And performing
k-fold CV for, say, k = 5 or k = 10 will lead to an intermediate level of
bias, since each training set contains (k − 1)n/k observations—fewer than
in the LOOCV approach, but substantially more than in the validation set
approach. Therefore, from the perspective of bias reduction, it is clear that
LOOCV is to be preferred to k-fold CV.

However, we know that bias is not the only source for concern in an esti-
mating procedure; we must also consider the procedure’s variance. It turns
out that LOOCV has higher variance than does k-fold CV with k < n. Why
is this the case? When we perform LOOCV, we are in eﬀect averaging the
outputs of n ﬁtted models, each of which is trained on an almost identical
set of observations; therefore, these outputs are highly (positively) corre-
lated with each other. In contrast, when we perform k-fold CV with k < n,
we are averaging the outputs of k ﬁtted models that are somewhat less
correlated with each other, since the overlap between the training sets in
each model is smaller. Since the mean of many highly correlated quantities

184

5. Resampling Methods

has higher variance than does the mean of many quantities that are not
as highly correlated, the test error estimate resulting from LOOCV tends
to have higher variance than does the test error estimate resulting from
k-fold CV.

To summarize, there is a bias-variance trade-oﬀ associated with the
choice of k in k-fold cross-validation. Typically, given these considerations,
one performs k-fold cross-validation using k = 5 or k = 10, as these values
have been shown empirically to yield test error rate estimates that suﬀer
neither from excessively high bias nor from very high variance.

5.1.5 Cross-Validation on Classiﬁcation Problems

In this chapter so far, we have illustrated the use of cross-validation in the
regression setting where the outcome Y is quantitative, and so have used
MSE to quantify test error. But cross-validation can also be a very useful
approach in the classiﬁcation setting when Y is qualitative. In this setting,
cross-validation works just as described earlier in this chapter, except that
rather than using MSE to quantify test error, we instead use the number
of misclassiﬁed observations. For instance, in the classiﬁcation setting, the
LOOCV error rate takes the form

n(cid:17)

CV(n) =

1
n

Erri,

i=1

(5.4)

where Erri = I(yi (cid:4)= ˆyi). The k-fold CV error rate and validation set error

rates are deﬁned analogously.

As an example, we ﬁt various logistic regression models on the two-
dimensional classiﬁcation data displayed in Figure 2.13. In the top-left
panel of Figure 5.7, the black solid line shows the estimated decision bound-
ary resulting from ﬁtting a standard logistic regression model to this data
set. Since this is simulated data, we can compute the true test error rate,
which takes a value of 0.201 and so is substantially larger than the Bayes
error rate of 0.133. Clearly logistic regression does not have enough ﬂexi-
bility to model the Bayes decision boundary in this setting. We can easily
extend logistic regression to obtain a non-linear decision boundary by using
polynomial functions of the predictors, as we did in the regression setting in
Section 3.3.2. For example, we can ﬁt a quadratic logistic regression model,
given by

(cid:11)

(cid:12)

log

p
1 − p

= β0 + β1X1 + β2X 2

1 + β3X2 + β4X 2
2 .

(5.5)

The top-right panel of Figure 5.7 displays the resulting decision boundary,
which is now curved. However, the test error rate has improved only slightly,
to 0.197. A much larger improvement is apparent in the bottom-left panel

Degree=1

Degree=2

5.1 Cross-Validation

185

o

o

o
o

o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o
o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o
o
o
o

o

o

o

o

Degree=3

o
o

o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o
o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o
o
o
o

o

o

o

o

o

o

o
o
o

o

o

o
o

o

o
o
o

o

o

o
o

o

o

o

o

o

o
o

o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o
o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o
o
o
o

o

o

o

o

Degree=4

o
o

o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o

o
o

o

o
o
o
o
o
o
oo
o
o
o
o
o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
oo
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o

o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o
o

o
o
o
o

o

o

o

o

o
o
o

o

o

o
o

o

o
o
o

o

o

o
o

o

o

o

o

o

FIGURE 5.7. Logistic regression ﬁts on the two-dimensional classiﬁcation data
displayed in Figure 2.13. The Bayes decision boundary is represented using a
purple dashed line. Estimated decision boundaries from linear, quadratic, cubic
and quartic (degrees 1–4) logistic regressions are displayed in black. The test error
rates for the four logistic regression ﬁts are respectively 0.201, 0.197, 0.160, and
0.162, while the Bayes error rate is 0.133.

of Figure 5.7, in which we have ﬁt a logistic regression model involving
cubic polynomials of the predictors. Now the test error rate has decreased
to 0.160. Going to a quartic polynomial (bottom-right) slightly increases
the test error.

In practice, for real data, the Bayes decision boundary and the test er-
ror rates are unknown. So how might we decide between the four logistic
regression models displayed in Figure 5.7? We can use cross-validation in
order to make this decision. The left-hand panel of Figure 5.8 displays in

186

5. Resampling Methods

e

t

a
R

 
r
o
r
r

E

0
2

.

0

8
1

.

0

6
1
0

.

4
1

.

0

2
1
0

.

e

t

a
R

 
r
o
r
r

E

0
2

.

0

8
1

.

0

6
1
0

.

4
1

.

0

2
1
0

.

2

4

6

8

10

0.01

0.02

0.05

0.10

0.20

0.50

1.00

Order of Polynomials Used

1/K

FIGURE 5.8. Test error (brown), training error (blue), and 10-fold CV error
(black) on the two-dimensional classiﬁcation data displayed in Figure 5.7. Left:
Logistic regression using polynomial functions of the predictors. The order of
the polynomials used is displayed on the x-axis. Right: The KNN classiﬁer with
diﬀerent values of K, the number of neighbors used in the KNN classiﬁer.

black the 10-fold CV error rates that result from ﬁtting ten logistic regres-
sion models to the data, using polynomial functions of the predictors up
to tenth order. The true test errors are shown in brown, and the training
errors are shown in blue. As we have seen previously, the training error
tends to decrease as the ﬂexibility of the ﬁt increases. (The ﬁgure indicates
that though the training error rate doesn’t quite decrease monotonically,
it tends to decrease on the whole as the model complexity increases.) In
contrast, the test error displays a characteristic U-shape. The 10-fold CV
error rate provides a pretty good approximation to the test error rate.
While it somewhat underestimates the error rate, it reaches a minimum
when fourth-order polynomials are used, which is very close to the min-
imum of the test curve, which occurs when third-order polynomials are
used. In fact, using fourth-order polynomials would likely lead to good test
set performance, as the true test error rate is approximately the same for
third, fourth, ﬁfth, and sixth-order polynomials.

The right-hand panel of Figure 5.8 displays the same three curves us-
ing the KNN approach for classiﬁcation, as a function of the value of K
(which in this context indicates the number of neighbors used in the KNN
classiﬁer, rather than the number of CV folds used). Again the training
error rate declines as the method becomes more ﬂexible, and so we see that
the training error rate cannot be used to select the optimal value for K.
Though the cross-validation error curve slightly underestimates the test
error rate, it takes on a minimum very close to the best value for K.

5.2 The Bootstrap

187

5.2 The Bootstrap

bootstrap

The bootstrap is a widely applicable and extremely powerful statistical tool
that can be used to quantify the uncertainty associated with a given esti-
mator or statistical learning method. As a simple example, the bootstrap
can be used to estimate the standard errors of the coeﬃcients from a linear
regression ﬁt. In the speciﬁc case of linear regression, this is not particularly
useful, since we saw in Chapter 3 that standard statistical software such as
R outputs such standard errors automatically. However, the power of the
bootstrap lies in the fact that it can be easily applied to a wide range of
statistical learning methods, including some for which a measure of vari-
ability is otherwise diﬃcult to obtain and is not automatically output by
statistical software.

In this section we illustrate the bootstrap on a toy example in which we
wish to determine the best investment allocation under a simple model.
In Section 5.3 we explore the use of the bootstrap to assess the variability
associated with the regression coeﬃcients in a linear model ﬁt.

Suppose that we wish to invest a ﬁxed sum of money in two ﬁnancial
assets that yield returns of X and Y , respectively, where X and Y are
random quantities. We will invest a fraction α of our money in X, and will
invest the remaining 1 − α in Y . Since there is variability associated with
the returns on these two assets, we wish to choose α to minimize the total
risk, or variance, of our investment. In other words, we want to minimize
Var(αX + (1 − α)Y ). One can show that the value that minimizes the risk
is given by

− σXY

σ2
Y

− 2σXY

,

(5.6)

α =

σ2
X + σ2
Y

where σ2

X = Var(X), σ2

Y = Var(Y ), and σXY = Cov(X, Y ).

In reality, the quantities σ2

X , σ2
Y , and σXY are unknown. We can compute
estimates for these quantities, ˆσ2
X , ˆσ2
Y , and ˆσXY , using a data set that
contains past measurements for X and Y . We can then estimate the value
of α that minimizes the variance of our investment using

− ˆσXY

ˆσ2
Y

− 2ˆσXY

ˆσ2
X + ˆσ2
Y

ˆα =

.

(5.7)

Figure 5.9 illustrates this approach for estimating α on a simulated data
set. In each panel, we simulated 100 pairs of returns for the investments
X and Y . We used these returns to estimate σ2
Y , and σXY , which we
then substituted into (5.7) in order to obtain estimates for α. The value of
ˆα resulting from each simulated data set ranges from 0.532 to 0.657.

X , σ2

It is natural to wish to quantify the accuracy of our estimate of α. To
estimate the standard deviation of ˆα, we repeated the process of simu-
lating 100 paired observations of X and Y , and estimating α using (5.7),

188

5. Resampling Methods

2

1

Y

0

1
−

2
−

2

1

Y

0

1
−

2
−

3
−

2

1

Y

0

1
−

2
−

−2

−1

0
X

1

2

−2

−1

1

2

0
X

2

1

Y

0

1
−

2
−

3
−

−3

−2

−1

0

1

2

−2

−1

0

1

2

3

X

X

FIGURE 5.9. Each panel displays 100 simulated returns for investments
X and Y . From left to right and top to bottom, the resulting estimates for α
are 0.576, 0.532, 0.657, and 0.651.

1,000 times. We thereby obtained 1,000 estimates for α, which we can call
ˆα1, ˆα2, . . . , ˆα1,000. The left-hand panel of Figure 5.10 displays a histogram
of the resulting estimates. For these simulations the parameters were set to
σ2
X = 1, σ2
Y = 1.25, and σXY = 0.5, and so we know that the true value of
α is 0.6. We indicated this value using a solid vertical line on the histogram.
The mean over all 1,000 estimates for α is

1,000(cid:17)

1

1, 000

r=1

¯α =

ˆαr = 0.5996,

very close to α = 0.6, and the standard deviation of the estimates is

(cid:27)(cid:28)(cid:28)(cid:29) 1
1, 000 − 1

1,000(cid:17)

r=1

( ˆαr − ¯α)2 = 0.083.

This gives us a very good idea of the accuracy of ˆα: SE(ˆα) ≈ 0.083. So
roughly speaking, for a random sample from the population, we would
expect ˆα to diﬀer from α by approximately 0.08, on average.

In practice, however, the procedure for estimating SE(ˆα) outlined above
cannot be applied, because for real data we cannot generate new samples
from the original population. However, the bootstrap approach allows us
to use a computer to emulate the process of obtaining new sample sets,

5.2 The Bootstrap

189

0
0
2

0
5
1

0
0
1

0
5

0

0
0
2

0
5
1

0
0
1

0
5

0

α

9

.

0

8

.

0

7

.

0

6

.

0

5

.

0

4

.

0

3

.

0

0.4

0.5

0.6

0.7

0.8

0.9

0.3

0.4

0.5

α

0.6
α

0.7

0.8

0.9

True

Bootstrap

FIGURE 5.10. Left: A histogram of the estimates of α obtained by generating
1,000 simulated data sets from the true population. Center: A histogram of the
estimates of α obtained from 1,000 bootstrap samples from a single data set.
Right: The estimates of α displayed in the left and center panels are shown as
boxplots. In each panel, the pink line indicates the true value of α.

so that we can estimate the variability of ˆα without generating additional
samples. Rather than repeatedly obtaining independent data sets from the
population, we instead obtain distinct data sets by repeatedly sampling
observations from the original data set.

This approach is illustrated in Figure 5.11 on a simple data set, which
we call Z, that contains only n = 3 observations. We randomly select n
observations from the data set in order to produce a bootstrap data set,
∗1. The sampling is performed with replacement, which means that the
Z
same observation can occur more than once in the bootstrap data set. In
∗1 contains the third observation twice, the ﬁrst observation
this example, Z
once, and no instances of the second observation. Note that if an observation
∗1, then both its X and Y values are included. We can use
is contained in Z
∗1. This
∗1 to produce a new bootstrap estimate for α, which we call ˆα
Z
procedure is repeated B times for some large value of B, in order to produce
∗B, and B corresponding α
B diﬀerent bootstrap data sets, Z
∗B. We can compute the standard error of these
estimates, ˆα
bootstrap estimates using the formula
(cid:31)
B(cid:17)

∗2, . . . , Z

∗1, Z

∗1, ˆα

∗2, . . . , ˆα

 2

SEB(ˆα) =

.

(5.8)

(cid:27)(cid:28)(cid:28)(cid:29) 1
B − 1

ˆα∗r − 1
B

B(cid:17)

r(cid:2)=1

ˆα∗r(cid:2)

r=1

This serves as an estimate of the standard error of ˆα estimated from the
original data set.

The bootstrap approach is illustrated in the center panel of Figure 5.10,
which displays a histogram of 1,000 bootstrap estimates of α, each com-
puted using a distinct bootstrap data set. This panel was constructed on
the basis of a single data set, and hence could be created using real data.

replacement

190

5. Resampling Methods

Obs

X

1
2
3

4.3
2.1
5.3

Y

2.4
1.1
2.8

Original Data (Z)

Z*1

Z*2

···
···
·
··
···

Z*B

Obs

X

3
1
3

5.3
4.3
5.3

Obs

X

2
3
1

Obs

2
2
1

2.1
5.3
4.3
···
···
···
X

2.1
2.1
4.3

Y

2.8
2.4
2.8

Y

1.1
2.8
2.4

Y

1.1
1.1
2.4

a*1
ˆ

a*2
ˆ

a*B
ˆ

···
···
···
···
···

FIGURE 5.11. A graphical illustration of the bootstrap approach on a small
sample containing n = 3 observations. Each bootstrap data set contains n obser-
vations, sampled with replacement from the original data set. Each bootstrap data
set is used to obtain an estimate of α.

Note that the histogram looks very similar to the left-hand panel which dis-
plays the idealized histogram of the estimates of α obtained by generating
1,000 simulated data sets from the true population. In particular the boot-
strap estimate SE(ˆα) from (5.8) is 0.087, very close to the estimate of 0.083
obtained using 1,000 simulated data sets. The right-hand panel displays the
information in the center and left panels in a diﬀerent way, via boxplots of
the estimates for α obtained by generating 1,000 simulated data sets from
the true population and using the bootstrap approach. Again, the boxplots
are quite similar to each other, indicating that the bootstrap approach can
be used to eﬀectively estimate the variability associated with ˆα.

5.3 Lab: Cross-Validation and the Bootstrap

In this lab, we explore the resampling techniques covered in this chapter.
Some of the commands in this lab may take a while to run on your com-
puter.

5.3 Lab: Cross-Validation and the Bootstrap

191

5.3.1 The Validation Set Approach

We explore the use of the validation set approach in order to estimate the
test error rates that result from ﬁtting various linear models on the Auto
data set.

Before we begin, we use the set.seed() function in order to set a seed for
R’s random number generator, so that the reader of this book will obtain
precisely the same results as those shown below. It is generally a good idea
to set a random seed when performing an analysis such as cross-validation
that contains an element of randomness, so that the results obtained can
be reproduced precisely at a later time.

We begin by using the sample() function to split the set of observations
into two halves, by selecting a random subset of 196 observations out of
the original 392 observations. We refer to these observations as the training
set.

seed

sample()

> library ( ISLR )
> set . seed (1)
> train = sample (392 ,196)

(Here we use a shortcut in the sample command; see ?sample for details.)
We then use the subset option in lm() to ﬁt a linear regression using only
the observations corresponding to the training set.
> lm . fit = lm ( mpg∼horsepower , data = Auto , subset = train )
We now use the predict() function to estimate the response for all 392
observations, and we use the mean() function to calculate the MSE of the
196 observations in the validation set. Note that the -train index below
selects only the observations that are not in the training set.

> attach ( Auto )
> mean (( mpg - predict ( lm . fit , Auto ) ) [ - train ]^2)
[1] 26.14

Therefore, the estimated test MSE for the linear regression ﬁt is 26.14. We
can use the poly() function to estimate the test error for the quadratic
and cubic regressions.
> lm . fit2 = lm ( mpg∼poly ( horsepower ,2) , data = Auto , subset = train )

> mean (( mpg - predict ( lm . fit2 , Auto ) ) [ - train ]^2)
[1] 19.82

> lm . fit3 = lm ( mpg∼poly ( horsepower ,3) , data = Auto , subset = train )

> mean (( mpg - predict ( lm . fit3 , Auto ) ) [ - train ]^2)
[1] 19.78

These error rates are 19.82 and 19.78, respectively. If we choose a diﬀerent
training set instead, then we will obtain somewhat diﬀerent errors on the
validation set.

> set . seed (2)
> train = sample (392 ,196)

> lm . fit = lm ( mpg∼horsepower , subset = train )

192

5. Resampling Methods

> mean (( mpg - predict ( lm . fit , Auto ) ) [ - train ]^2)
[1] 23.30

> lm . fit2 = lm ( mpg∼poly ( horsepower ,2) , data = Auto , subset = train )

> mean (( mpg - predict ( lm . fit2 , Auto ) ) [ - train ]^2)
[1] 18.90

> lm . fit3 = lm ( mpg∼poly ( horsepower ,3) , data = Auto , subset = train )

> mean (( mpg - predict ( lm . fit3 , Auto ) ) [ - train ]^2)
[1] 19.26

Using this split of the observations into a training set and a validation
set, we ﬁnd that the validation set error rates for the models with linear,
quadratic, and cubic terms are 23.30, 18.90, and 19.26, respectively.

These results are consistent with our previous ﬁndings: a model that
predicts mpg using a quadratic function of horsepower performs better than
a model that involves only a linear function of horsepower, and there is
little evidence in favor of a model that uses a cubic function of horsepower.

5.3.2 Leave-One-Out Cross-Validation

The LOOCV estimate can be automatically computed for any generalized
linear model using the glm() and cv.glm() functions. In the lab for Chap-
ter 4, we used the glm() function to perform logistic regression by passing
in the family="binomial" argument. But if we use glm() to ﬁt a model
without passing in the family argument, then it performs linear regression,
just like the lm() function. So for instance,
> glm . fit = glm ( mpg∼horsepower , data = Auto )

cv.glm()

> coef ( glm . fit )
( Intercept )
39.936

horsepower
-0.158

and
> lm . fit = lm ( mpg∼horsepower , data = Auto )

> coef ( lm . fit )
( Intercept )
39.936

horsepower
-0.158

yield identical linear regression models. In this lab, we will perform linear
regression using the glm() function rather than the lm() function because
the former can be used together with cv .glm(). The cv .glm() function is
part of the boot library.

> library ( boot )

> glm . fit = glm ( mpg∼horsepower , data = Auto )

> cv . err = cv . glm ( Auto , glm . fit )
> cv . err$delta

1

1
24.23 24.23

The cv.glm() function produces a list with several components. The two
numbers in the delta vector contain the cross-validation results. In this

5.3 Lab: Cross-Validation and the Bootstrap

193

case the numbers are identical (up to two decimal places) and correspond
to the LOOCV statistic given in (5.1). Below, we discuss a situation in
which the two numbers diﬀer. Our cross-validation estimate for the test
error is approximately 24.23.

We can repeat this procedure for increasingly complex polynomial ﬁts.
To automate the process, we use the for() function to initiate a for loop
which iteratively ﬁts polynomial regressions for polynomials of order i = 1
to i = 5, computes the associated cross-validation error, and stores it in
the ith element of the vector cv.error. We begin by initializing the vector.
This command will likely take a couple of minutes to run.

for()
for loop

> cv . error = rep (0 ,5)
> for ( i in 1:5) {

+ glm . fit = glm ( mpg∼poly ( horsepower , i ) , data = Auto )

+ cv . error [ i ]= cv . glm ( Auto , glm . fit ) $delta [1]
+ }
> cv . error
[1] 24.23 19.25 19.33 19.42 19.03

As in Figure 5.4, we see a sharp drop in the estimated test MSE between
the linear and quadratic ﬁts, but then no clear improvement from using
higher-order polynomials.

5.3.3 k-Fold Cross-Validation

The cv.glm() function can also be used to implement k-fold CV. Below we
use k = 10, a common choice for k, on the Auto data set. We once again set
a random seed and initialize a vector in which we will store the CV errors
corresponding to the polynomial ﬁts of orders one to ten.

> set . seed (17)
> cv . error .10= rep (0 ,10)
> for ( i in 1:10) {

+ glm . fit = glm ( mpg∼poly ( horsepower , i ) , data = Auto )

+ cv . error .10[ i ]= cv . glm ( Auto , glm . fit , K =10) $delta [1]
+ }
> cv . error .10
[1] 24.21 19.19 19.31 19.34 18.88 19.02 18.90 19.71 18.95 19.50

Notice that the computation time is much shorter than that of LOOCV.
(In principle, the computation time for LOOCV for a least squares linear
model should be faster than for k-fold CV, due to the availability of the
formula (5.2) for LOOCV; however, unfortunately the cv.glm() function
does not make use of this formula.) We still see little evidence that using
cubic or higher-order polynomial terms leads to lower test error than simply
using a quadratic ﬁt.

We saw in Section 5.3.2 that the two numbers associated with delta are
essentially the same when LOOCV is performed. When we instead perform
k-fold CV, then the two numbers associated with delta diﬀer slightly. The

194

5. Resampling Methods

ﬁrst is the standard k-fold CV estimate, as in (5.3). The second is a bias-
corrected version. On this data set, the two estimates are very similar to
each other.

5.3.4 The Bootstrap

We illustrate the use of the bootstrap in the simple example of Section 5.2,
as well as on an example involving estimating the accuracy of the linear
regression model on the Auto data set.

Estimating the Accuracy of a Statistic of Interest

One of the great advantages of the bootstrap approach is that it can be
applied in almost all situations. No complicated mathematical calculations
are required. Performing a bootstrap analysis in R entails only two steps.
First, we must create a function that computes the statistic of interest.
Second, we use the boot() function, which is part of the boot library, to
perform the bootstrap by repeatedly sampling observations from the data
set with replacement.

The Portfolio data set in the ISLR package is described in Section 5.2.
To illustrate the use of the bootstrap on this data, we must ﬁrst create
a function, alpha.fn(), which takes as input the (X, Y ) data as well as
a vector indicating which observations should be used to estimate α. The
function then outputs the estimate for α based on the selected observations.

> alpha . fn = function ( data , index ) {
+ X = data$X [ index ]
+ Y = data$Y [ index ]
+ return (( var ( Y ) - cov (X , Y ) ) /( var ( X ) + var ( Y ) -2* cov (X , Y ) ) )
+ }

This function returns, or outputs, an estimate for α based on applying
(5.7) to the observations indexed by the argument index. For instance, the
following command tells R to estimate α using all 100 observations.

> alpha . fn ( Portfolio ,1:100)
[1] 0.576

The next command uses the sample() function to randomly select 100 ob-
servations from the range 1 to 100, with replacement. This is equivalent
to constructing a new bootstrap data set and recomputing ˆα based on the
new data set.

> set . seed (1)
> alpha . fn ( Portfolio , sample (100 ,100 , replace = T ) )
[1] 0.596

We can implement a bootstrap analysis by performing this command many
times, recording all of the corresponding estimates for α, and computing

boot()

5.3 Lab: Cross-Validation and the Bootstrap

195

the resulting standard deviation. However, the boot() function automates
this approach. Below we produce R = 1, 000 bootstrap estimates for α.

boot()

> boot ( Portfolio , alpha . fn , R =1000)

ORDINARY N O N P A R A M E T R I C BOOTSTRAP

Call :
boot ( data = Portfolio , statistic = alpha . fn , R = 1000)

Bootstrap Statistics :

original
0.5758

t1 *

bias

-7.315 e -05

std . error
0.0886

The ﬁnal output shows that using the original data, ˆα = 0.5758, and that
the bootstrap estimate for SE(ˆα) is 0.0886.

Estimating the Accuracy of a Linear Regression Model

The bootstrap approach can be used to assess the variability of the coef-
ﬁcient estimates and predictions from a statistical learning method. Here
we use the bootstrap approach in order to assess the variability of the
estimates for β0 and β1, the intercept and slope terms for the linear regres-
sion model that uses horsepower to predict mpg in the Auto data set. We
will compare the estimates obtained using the bootstrap to those obtained
using the formulas for SE( ˆβ0) and SE( ˆβ1) described in Section 3.1.2.

We ﬁrst create a simple function, boot.fn(), which takes in the Auto data
set as well as a set of indices for the observations, and returns the intercept
and slope estimates for the linear regression model. We then apply this
function to the full set of 392 observations in order to compute the esti-
mates of β0 and β1 on the entire data set using the usual linear regression
coeﬃcient estimate formulas from Chapter 3. Note that we do not need the
{ and } at the beginning and end of the function because it is only one line
long.

> boot . fn = function ( data , index )

+ return ( coef ( lm ( mpg∼horsepower , data = data , subset = index ) ) )

> boot . fn ( Auto ,1:392)
( Intercept ) horsepower

39.936

-0.158

The boot.fn() function can also be used in order to create bootstrap esti-
mates for the intercept and slope terms by randomly sampling from among
the observations with replacement. Here we give two examples.

> set . seed (1)
> boot . fn ( Auto , sample (392 ,392 , replace = T ) )
( Intercept ) horsepower

38.739

-0.148

> boot . fn ( Auto , sample (392 ,392 , replace = T ) )
( Intercept ) horsepower

40.038

-0.160

196

5. Resampling Methods

Next, we use the boot() function to compute the standard errors of 1,000
bootstrap estimates for the intercept and slope terms.

> boot ( Auto , boot . fn ,1000)

ORDINARY N O N P A R A M E T R I C BOOTSTRAP

Call :
boot ( data = Auto , statistic = boot . fn , R = 1000)

Bootstrap Statistics :

original

t1 * 39.936
t2 * -0.158

bias
0.0297
-0.0003

std . error
0.8600
0.0074

This indicates that the bootstrap estimate for SE( ˆβ0) is 0.86, and that
the bootstrap estimate for SE( ˆβ1) is 0.0074. As discussed in Section 3.1.2,
standard formulas can be used to compute the standard errors for the
regression coeﬃcients in a linear model. These can be obtained using the
summary() function.
> summary ( lm ( mpg∼horsepower , data = Auto ) ) $coef

Estimate Std . Error t value

( Intercept )
horsepowe r

39.936
-0.158

0.71750
0.00645

Pr ( >| t |)
55.7 1.22 e -187
7.03 e -81

-24.5

The standard error estimates for ˆβ0 and ˆβ1 obtained using the formulas
from Section 3.1.2 are 0.717 for the intercept and 0.0064 for the slope.
Interestingly, these are somewhat diﬀerent from the estimates obtained
using the bootstrap. Does this indicate a problem with the bootstrap? In
fact, it suggests the opposite. Recall that the standard formulas given in
Equation 3.8 on page 66 rely on certain assumptions. For example, they
depend on the unknown parameter σ2, the noise variance. We then estimate
σ2 using the RSS. Now although the formula for the standard errors do not
rely on the linear model being correct, the estimate for σ2 does. We see in
Figure 3.8 on page 91 that there is a non-linear relationship in the data, and
so the residuals from a linear ﬁt will be inﬂated, and so will ˆσ2. Secondly,
the standard formulas assume (somewhat unrealistically) that the xi are
ﬁxed, and all the variability comes from the variation in the errors i. The
bootstrap approach does not rely on any of these assumptions, and so it is
likely giving a more accurate estimate of the standard errors of ˆβ0 and ˆβ1
than is the summary() function.

Below we compute the bootstrap standard error estimates and the stan-
dard linear regression estimates that result from ﬁtting the quadratic model
to the data. Since this model provides a good ﬁt to the data (Figure 3.8),
there is now a better correspondence between the bootstrap estimates and
the standard estimates of SE( ˆβ0), SE( ˆβ1) and SE( ˆβ2).

5.4 Exercises

197

> boot . fn = function ( data , index )

+ c o e f f i c i e n t s ( lm ( mpg∼horsepowe r + I ( horsepower ^2) , data = data ,

subset = index ) )

> set . seed (1)
> boot ( Auto , boot . fn ,1000)

ORDINARY N O N P A R A M E T R I C BOOTSTRAP

Call :
boot ( data = Auto , statistic = boot . fn , R = 1000)

Bootstrap Statistics :

original
56.900

t1 *
t2 * -0.466
0.001
t3 *

bias

std . error

6.098 e -03 2.0945
-1.777 e -04 0.0334
1.324 e -06 0.0001

> summary ( lm ( mpg∼horsepowe r + I ( horsepower ^2) , data = Auto ) ) $coef

( Intercept )
horsepowe r
I ( horsepowe r ^2)

Estimate Std . Error t value Pr ( >| t |)
32 1.7 e -109
2.3 e -40
2.2 e -21

56.9001
-0.4662
0.0012

1.80043
0.03112
0.00012

-15
10

5.4 Exercises

Conceptual

1. Using basic statistical properties of the variance, as well as single-
variable calculus, derive (5.6). In other words, prove that α given by
(5.6) does indeed minimize Var(αX + (1 − α)Y ).

2. We will now derive the probability that a given observation is part
of a bootstrap sample. Suppose that we obtain a bootstrap sample
from a set of n observations.

(a) What is the probability that the ﬁrst bootstrap observation is
not the jth observation from the original sample? Justify your
answer.

(b) What is the probability that the second bootstrap observation

(c) Argue that the probability that the jth observation is not in the

is not the jth observation from the original sample?
bootstrap sample is (1 − 1/n)n.

(d) When n = 5, what is the probability that the jth observation is

in the bootstrap sample?

(e) When n = 100, what is the probability that the jth observation

is in the bootstrap sample?

198

5. Resampling Methods

(f) When n = 10, 000, what is the probability that the jth observa-

tion is in the bootstrap sample?

(g) Create a plot that displays, for each integer value of n from 1
to 100, 000, the probability that the jth observation is in the
bootstrap sample. Comment on what you observe.

(h) We will now investigate numerically the probability that a boot-
strap sample of size n = 100 contains the jth observation. Here
j = 4. We repeatedly create bootstrap samples, and each time
we record whether or not the fourth observation is contained in
the bootstrap sample.

> store = rep ( NA , 10000)
> for ( i in 1:10000) {

store [ i ]= sum ( sample (1:100 , rep = TRUE ) ==4) >0

}
> mean ( store )

Comment on the results obtained.

3. We now review k-fold cross-validation.

(a) Explain how k-fold cross-validation is implemented.

(b) What are the advantages and disadvantages of k-fold cross-

validation relative to:

i. The validation set approach?
ii. LOOCV?

4. Suppose that we use some statistical learning method to make a pre-
diction for the response Y for a particular value of the predictor X.
Carefully describe how we might estimate the standard deviation of
our prediction.

Applied

5. In Chapter 4, we used logistic regression to predict the probability of
default using income and balance on the Default data set. We will
now estimate the test error of this logistic regression model using the
validation set approach. Do not forget to set a random seed before
beginning your analysis.

(a) Fit a logistic regression model that uses income and balance to

predict default.

(b) Using the validation set approach, estimate the test error of this
model. In order to do this, you must perform the following steps:

i. Split the sample set into a training set and a validation set.

5.4 Exercises

199

ii. Fit a multiple logistic regression model using only the train-

ing observations.

iii. Obtain a prediction of default status for each individual in
the validation set by computing the posterior probability of
default for that individual, and classifying the individual to
the default category if the posterior probability is greater
than 0.5.

iv. Compute the validation set error, which is the fraction of
the observations in the validation set that are misclassiﬁed.
(c) Repeat the process in (b) three times, using three diﬀerent splits
of the observations into a training set and a validation set. Com-
ment on the results obtained.

(d) Now consider a logistic regression model that predicts the prob-
ability of default using income, balance, and a dummy variable
for student. Estimate the test error for this model using the val-
idation set approach. Comment on whether or not including a
dummy variable for student leads to a reduction in the test error
rate.

6. We continue to consider the use of a logistic regression model to
predict the probability of default using income and balance on the
Default data set. In particular, we will now compute estimates for
the standard errors of the income and balance logistic regression co-
eﬃcients in two diﬀerent ways: (1) using the bootstrap, and (2) using
the standard formula for computing the standard errors in the glm()
function. Do not forget to set a random seed before beginning your
analysis.

(a) Using the summary() and glm() functions, determine the esti-
mated standard errors for the coeﬃcients associated with income
and balance in a multiple logistic regression model that uses
both predictors.

(b) Write a function, boot.fn(), that takes as input the Default data
set as well as an index of the observations, and that outputs
the coeﬃcient estimates for income and balance in the multiple
logistic regression model.

(c) Use the boot() function together with your boot.fn() function to
estimate the standard errors of the logistic regression coeﬃcients
for income and balance.

(d) Comment on the estimated standard errors obtained using the

glm() function and using your bootstrap function.

7. In Sections 5.3.2 and 5.3.3, we saw that the cv.glm() function can be
used in order to compute the LOOCV test error estimate. Alterna-
tively, one could compute those quantities using just the glm() and

200

5. Resampling Methods

predict.glm() functions, and a for loop. You will now take this ap-
proach in order to compute the LOOCV error for a simple logistic
regression model on the Weekly data set. Recall that in the context
of classiﬁcation problems, the LOOCV error is given in (5.4).

(a) Fit a logistic regression model that predicts Direction using Lag1

and Lag2.

(b) Fit a logistic regression model that predicts Direction using Lag1

and Lag2 using all but the ﬁrst observation.

(c) Use the model from (b) to predict the direction of the ﬁrst obser-
vation. You can do this by predicting that the ﬁrst observation
will go up if P (Direction="Up"|Lag1, Lag2) > 0.5. Was this ob-
servation correctly classiﬁed?

(d) Write a for loop from i = 1 to i = n, where n is the number of
observations in the data set, that performs each of the following
steps:

i. Fit a logistic regression model using all but the ith obser-

vation to predict Direction using Lag1 and Lag2.

ii. Compute the posterior probability of the market moving up

for the ith observation.

iii. Use the posterior probability for the ith observation in order

to predict whether or not the market moves up.

iv. Determine whether or not an error was made in predicting
the direction for the ith observation. If an error was made,
then indicate this as a 1, and otherwise indicate it as a 0.

(e) Take the average of the n numbers obtained in (d)iv in order to
obtain the LOOCV estimate for the test error. Comment on the
results.

8. We will now perform cross-validation on a simulated data set.

(a) Generate a simulated data set as follows:

> set . seed (1)
> x = rnorm (100)
> y =x -2* x ^2+ rnorm (100)

In this data set, what is n and what is p? Write out the model
used to generate the data in equation form.

(b) Create a scatterplot of X against Y . Comment on what you ﬁnd.

(c) Set a random seed, and then compute the LOOCV errors that
result from ﬁtting the following four models using least squares:

5.4 Exercises

201

i. Y = β0 + β1X + 
ii. Y = β0 + β1X + β2X 2 + 
iii. Y = β0 + β1X + β2X 2 + β3X 3 + 
iv. Y = β0 + β1X + β2X 2 + β3X 3 + β4X 4 + .
Note you may ﬁnd it helpful to use the data.frame() function
to create a single data set containing both X and Y .

(d) Repeat (c) using another random seed, and report your results.

Are your results the same as what you got in (c)? Why?

(e) Which of the models in (c) had the smallest LOOCV error? Is

this what you expected? Explain your answer.

(f) Comment on the statistical signiﬁcance of the coeﬃcient esti-
mates that results from ﬁtting each of the models in (c) using
least squares. Do these results agree with the conclusions drawn
based on the cross-validation results?

9. We will now consider the Boston housing data set, from the MASS

library.

(a) Based on this data set, provide an estimate for the population

mean of medv. Call this estimate ˆμ.

(b) Provide an estimate of the standard error of ˆμ. Interpret this

result.
Hint: We can compute the standard error of the sample mean by
dividing the sample standard deviation by the square root of the
number of observations.

(c) Now estimate the standard error of ˆμ using the bootstrap. How

does this compare to your answer from (b)?

(d) Based on your bootstrap estimate from (c), provide a 95 % con-
ﬁdence interval for the mean of medv. Compare it to the results
obtained using t.test(Boston$medv).
Hint: You can approximate a 95 % conﬁdence interval using the
formula [ˆμ − 2SE(ˆμ), ˆμ + 2SE(ˆμ)].

(e) Based on this data set, provide an estimate, ˆμmed, for the median

value of medv in the population.

(f) We now would like to estimate the standard error of ˆμmed. Unfor-
tunately, there is no simple formula for computing the standard
error of the median. Instead, estimate the standard error of the
median using the bootstrap. Comment on your ﬁndings.

(g) Based on this data set, provide an estimate for the tenth per-
centile of medv in Boston suburbs. Call this quantity ˆμ0.1. (You
can use the quantile() function.)

(h) Use the bootstrap to estimate the standard error of ˆμ0.1. Com-

ment on your ﬁndings.

6
Linear Model Selection
and Regularization

In the regression setting, the standard linear model

Y = β0 + β1X1 + ··· + βpXp + 

(6.1)

is commonly used to describe the relationship between a response Y and
a set of variables X1, X2, . . . , Xp. We have seen in Chapter 3 that one
typically ﬁts this model using least squares.

In the chapters that follow, we consider some approaches for extending
the linear model framework. In Chapter 7 we generalize (6.1) in order to
accommodate non-linear, but still additive, relationships, while in Chap-
ter 8 we consider even more general non-linear models. However, the linear
model has distinct advantages in terms of inference and, on real-world prob-
lems, is often surprisingly competitive in relation to non-linear methods.
Hence, before moving to the non-linear world, we discuss in this chapter
some ways in which the simple linear model can be improved, by replacing
plain least squares ﬁtting with some alternative ﬁtting procedures.

Why might we want to use another ﬁtting procedure instead of least
squares? As we will see, alternative ﬁtting procedures can yield better pre-
diction accuracy and model interpretability.

• Prediction Accuracy: Provided that the true relationship between the
response and the predictors is approximately linear, the least squares
estimates will have low bias. If n (cid:10) p—that is, if n, the number of
observations, is much larger than p, the number of variables—then the
least squares estimates tend to also have low variance, and hence will
perform well on test observations. However, if n is not much larger

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 6,
© Springer Science+Business Media New York 2013

203

204

6. Linear Model Selection and Regularization

than p, then there can be a lot of variability in the least squares ﬁt,
resulting in overﬁtting and consequently poor predictions on future
observations not used in model training. And if p > n, then there
is no longer a unique least squares coeﬃcient estimate: the variance
is inﬁnite so the method cannot be used at all. By constraining or
shrinking the estimated coeﬃcients, we can often substantially reduce
the variance at the cost of a negligible increase in bias. This can
lead to substantial improvements in the accuracy with which we can
predict the response for observations not used in model training.

• Model Interpretability: It is often the case that some or many of the
variables used in a multiple regression model are in fact not associ-
ated with the response. Including such irrelevant variables leads to
unnecessary complexity in the resulting model. By removing these
variables—that is, by setting the corresponding coeﬃcient estimates
to zero—we can obtain a model that is more easily interpreted. Now
least squares is extremely unlikely to yield any coeﬃcient estimates
that are exactly zero. In this chapter, we see some approaches for au-
tomatically performing feature selection or variable selection—that is,
for excluding irrelevant variables from a multiple regression model.

There are many alternatives, both classical and modern, to using least
squares to ﬁt (6.1). In this chapter, we discuss three important classes of
methods.

• Subset Selection. This approach involves identifying a subset of the p
predictors that we believe to be related to the response. We then ﬁt
a model using least squares on the reduced set of variables.

• Shrinkage. This approach involves ﬁtting a model involving all p pre-
dictors. However, the estimated coeﬃcients are shrunken towards zero
relative to the least squares estimates. This shrinkage (also known as
regularization) has the eﬀect of reducing variance. Depending on what
type of shrinkage is performed, some of the coeﬃcients may be esti-
mated to be exactly zero. Hence, shrinkage methods can also perform
variable selection.

• Dimension Reduction. This approach involves projecting the p predic-
tors into a M -dimensional subspace, where M < p. This is achieved
by computing M diﬀerent linear combinations, or projections, of the
variables. Then these M projections are used as predictors to ﬁt a
linear regression model by least squares.

In the following sections we describe each of these approaches in greater de-
tail, along with their advantages and disadvantages. Although this chapter
describes extensions and modiﬁcations to the linear model for regression
seen in Chapter 3, the same concepts apply to other methods, such as the
classiﬁcation models seen in Chapter 4.

feature
selection
variable
selection

6.1 Subset Selection

205

6.1 Subset Selection

In this section we consider some methods for selecting subsets of predictors.
These include best subset and stepwise model selection procedures.

6.1.1 Best Subset Selection

To perform best subset selection, we ﬁt a separate least squares regression
for each possible combination of the p predictors. That is, we ﬁt all p models
= p(p− 1)/2 models that contain
that contain exactly one predictor, all
exactly two predictors, and so forth. We then look at all of the resulting
models, with the goal of identifying the one that is best.

(cid:8)

(cid:9)

p
2

The problem of selecting the best model from among the 2p possibilities
considered by best subset selection is not trivial. This is usually broken up
into two stages, as described in Algorithm 6.1.

Algorithm 6.1 Best subset selection

1. Let M0 denote the null model , which contains no predictors. This

model simply predicts the sample mean for each observation.

best subset
selection

2. For k = 1, 2, . . . p:

(cid:8)

(cid:9)

p
k

(cid:8)

(cid:9)

(a) Fit all

models that contain exactly k predictors.

(b) Pick the best among these

models, and call it Mk. Here best
is deﬁned as having the smallest RSS, or equivalently largest R2.
3. Select a single best model from among M0, . . . ,Mp using cross-

p
k

validated prediction error, Cp (AIC), BIC, or adjusted R2.

In Algorithm 6.1, Step 2 identiﬁes the best model (on the training data)
for each subset size, in order to reduce the problem from one of 2p possible
models to one of p + 1 possible models. In Figure 6.1, these models form
the lower frontier depicted in red.

Now in order to select a single best model, we must simply choose among
these p + 1 options. This task must be performed with care, because the
RSS of these p + 1 models decreases monotonically, and the R2 increases
monotonically, as the number of features included in the models increases.
Therefore, if we use these statistics to select the best model, then we will
always end up with a model involving all of the variables. The problem is
that a low RSS or a high R2 indicates a model with a low training error,
whereas we wish to choose a model that has a low test error. (As shown
in Chapter 2 in Figures 2.9–2.11, training error tends to be quite a bit
smaller than test error, and a low training error by no means guarantees
a low test error.) Therefore, in Step 3, we use cross-validated prediction

206

6. Linear Model Selection and Regularization

s
e
r
a
u
q
S

 
f

 

o
m
u
S

 
l

i

a
u
d
s
e
R

7
0
+
e
8

7
0
+
e
6

7
0
+
e
4

7
0
+
e
2

2
R

0

.

1

8

.

0

6

.

0

4

.

0

2

.
0

0

.

0

2

4

6

8

10

2

4

6

8

10

Number of Predictors

Number of Predictors

FIGURE 6.1. For each possible model containing a subset of the ten predictors
in the Credit data set, the RSS and R2 are displayed. The red frontier tracks the
best model for a given number of predictors, according to RSS and R2. Though
the data set contains only ten predictors, the x-axis ranges from 1 to 11, since one
of the variables is categorical and takes on three values, leading to the creation of
two dummy variables.

error, Cp, BIC, or adjusted R2 in order to select among M0,M1, . . . ,Mp.

These approaches are discussed in Section 6.1.3.

An application of best subset selection is shown in Figure 6.1. Each
plotted point corresponds to a least squares regression model ﬁt using a
diﬀerent subset of the 11 predictors in the Credit data set, discussed in
Chapter 3. Here the variable ethnicity is a three-level qualitative variable,
and so is represented by two dummy variables, which are selected separately
in this case. We have plotted the RSS and R2 statistics for each model, as
a function of the number of variables. The red curves connect the best
models for each model size, according to RSS or R2. The ﬁgure shows that,
as expected, these quantities improve as the number of variables increases;
however, from the three-variable model on, there is little improvement in
RSS and R2 as a result of including additional predictors.

Although we have presented best subset selection here for least squares
regression, the same ideas apply to other types of models, such as logistic
regression. In the case of logistic regression, instead of ordering models by
RSS in Step 2 of Algorithm 6.1, we instead use the deviance, a measure
that plays the role of RSS for a broader class of models. The deviance is
negative two times the maximized log-likelihood; the smaller the deviance,
the better the ﬁt.

While best subset selection is a simple and conceptually appealing ap-
proach, it suﬀers from computational limitations. The number of possible
models that must be considered grows rapidly as p increases. In general,
there are 2p models that involve subsets of p predictors. So if p = 10,
then there are approximately 1,000 possible models to be considered, and if

deviance

6.1 Subset Selection

207

p = 20, then there are over one million possibilities! Consequently, best sub-
set selection becomes computationally infeasible for values of p greater than
around 40, even with extremely fast modern computers. There are compu-
tational shortcuts—so called branch-and-bound techniques—for eliminat-
ing some choices, but these have their limitations as p gets large. They also
only work for least squares linear regression. We present computationally
eﬃcient alternatives to best subset selection next.

6.1.2 Stepwise Selection

For computational reasons, best subset selection cannot be applied with
very large p. Best subset selection may also suﬀer from statistical problems
when p is large. The larger the search space, the higher the chance of ﬁnding
models that look good on the training data, even though they might not
have any predictive power on future data. Thus an enormous search space
can lead to overﬁtting and high variance of the coeﬃcient estimates.

For both of these reasons, stepwise methods, which explore a far more
restricted set of models, are attractive alternatives to best subset selection.

Forward Stepwise Selection

Forward stepwise selection is a computationally eﬃcient alternative to best
subset selection. While the best subset selection procedure considers all
2p possible models containing subsets of the p predictors, forward step-
wise considers a much smaller set of models. Forward stepwise selection
begins with a model containing no predictors, and then adds predictors
to the model, one-at-a-time, until all of the predictors are in the model.
In particular, at each step the variable that gives the greatest additional
improvement to the ﬁt is added to the model. More formally, the forward
stepwise selection procedure is given in Algorithm 6.2.

forward
stepwise
selection

Algorithm 6.2 Forward stepwise selection

1. Let M0 denote the null model, which contains no predictors.
2. For k = 0, . . . , p − 1:

(a) Consider all p − k models that augment the predictors in Mk
(b) Choose the best among these p − k models, and call it Mk+1.

with one additional predictor.

Here best is deﬁned as having smallest RSS or highest R2.

3. Select a single best model from among M0, . . . ,Mp using cross-

validated prediction error, Cp (AIC), BIC, or adjusted R2.

208

6. Linear Model Selection and Regularization

Unlike best subset selection, which involved ﬁtting 2p models, forward
stepwise selection involves ﬁtting one null model, along with p − k models
in the kth iteration, for k = 0, . . . , p − 1. This amounts to a total of 1 +
(cid:10)
k=0(p− k) = 1 + p(p + 1)/2 models. This is a substantial diﬀerence: when
p−1
p = 20, best subset selection requires ﬁtting 1,048,576 models, whereas
forward stepwise selection requires ﬁtting only 211 models.1
among those p− k that augment Mk with one additional predictor. We can

In Step 2(b) of Algorithm 6.2, we must identify the best model from

do this by simply choosing the model with the lowest RSS or the highest
R2. However, in Step 3, we must identify the best model among a set of
models with diﬀerent numbers of variables. This is more challenging, and
is discussed in Section 6.1.3.

Forward stepwise selection’s computational advantage over best subset
selection is clear. Though forward stepwise tends to do well in practice,
it is not guaranteed to ﬁnd the best possible model out of all 2p mod-
els containing subsets of the p predictors. For instance, suppose that in a
given data set with p = 3 predictors, the best possible one-variable model
contains X1, and the best possible two-variable model instead contains X2
and X3. Then forward stepwise selection will fail to select the best possible
two-variable model, because M1 will contain X1, so M2 must also contain
X1 together with one additional variable.

Table 6.1, which shows the ﬁrst four selected models for best subset
and forward stepwise selection on the Credit data set, illustrates this phe-
nomenon. Both best subset selection and forward stepwise selection choose
rating for the best one-variable model and then include income and student
for the two- and three-variable models. However, best subset selection re-
places rating by cards in the four-variable model, while forward stepwise
selection must maintain rating in its four-variable model. In this example,
Figure 6.1 indicates that there is not much diﬀerence between the three-
and four-variable models in terms of RSS, so either of the four-variable
models will likely be adequate.

Forward stepwise selection can be applied even in the high-dimensional
setting where n < p; however, in this case, it is possible to construct sub-
models M0, . . . ,Mn−1 only, since each submodel is ﬁt using least squares,
which will not yield a unique solution if p ≥ n.

Backward Stepwise Selection

Like forward stepwise selection, backward stepwise selection provides an
eﬃcient alternative to best subset selection. However, unlike forward

backward
stepwise
selection

1Though forward stepwise selection considers p(p + 1)/2 + 1 models, it performs a
guided search over model space, and so the eﬀective model space considered contains
substantially more than p(p + 1)/2 + 1 models.

6.1 Subset Selection

209

# Variables Best subset
One
Two
Three
Four

rating
rating, income
rating, income, student
cards, income,
student, limit

Forward stepwise
rating
rating, income
rating, income, student
rating, income,
student, limit

TABLE 6.1. The ﬁrst four selected models for best subset selection and forward
stepwise selection on the Credit data set. The ﬁrst three models are identical but
the fourth models diﬀer.

stepwise selection, it begins with the full least squares model containing
all p predictors, and then iteratively removes the least useful predictor,
one-at-a-time. Details are given in Algorithm 6.3.

Algorithm 6.3 Backward stepwise selection

1. Let Mp denote the full model, which contains all p predictors.
2. For k = p, p − 1, . . . , 1:

(a) Consider all k models that contain all but one of the predictors

in Mk, for a total of k − 1 predictors.

(b) Choose the best among these k models, and call it Mk−1. Here

best is deﬁned as having smallest RSS or highest R2.

3. Select a single best model from among M0, . . . ,Mp using cross-

validated prediction error, Cp (AIC), BIC, or adjusted R2.

Like forward stepwise selection, the backward selection approach searches
through only 1 + p(p + 1)/2 models, and so can be applied in settings where
p is too large to apply best subset selection.2 Also like forward stepwise
selection, backward stepwise selection is not guaranteed to yield the best
model containing a subset of the p predictors.

Backward selection requires that the number of samples n is larger than
the number of variables p (so that the full model can be ﬁt). In contrast,
forward stepwise can be used even when n < p, and so is the only viable
subset method when p is very large.

2Like forward stepwise selection, backward stepwise selection performs a guided
search over model space, and so eﬀectively considers substantially more than 1+p(p+1)/2
models.

210

6. Linear Model Selection and Regularization

Hybrid Approaches

The best subset, forward stepwise, and backward stepwise selection ap-
proaches generally give similar but not identical models. As another al-
ternative, hybrid versions of forward and backward stepwise selection are
available, in which variables are added to the model sequentially, in analogy
to forward selection. However, after adding each new variable, the method
may also remove any variables that no longer provide an improvement in
the model ﬁt. Such an approach attempts to more closely mimic best sub-
set selection while retaining the computational advantages of forward and
backward stepwise selection.

6.1.3 Choosing the Optimal Model

Best subset selection, forward selection, and backward selection result in
the creation of a set of models, each of which contains a subset of the p pre-
dictors. In order to implement these methods, we need a way to determine
which of these models is best. As we discussed in Section 6.1.1, the model
containing all of the predictors will always have the smallest RSS and the
largest R2, since these quantities are related to the training error. Instead,
we wish to choose a model with a low test error. As is evident here, and as
we show in Chapter 2, the training error can be a poor estimate of the test
error. Therefore, RSS and R2 are not suitable for selecting the best model
among a collection of models with diﬀerent numbers of predictors.

In order to select the best model with respect to test error, we need to

estimate this test error. There are two common approaches:

1. We can indirectly estimate test error by making an adjustment to the

training error to account for the bias due to overﬁtting.

2. We can directly estimate the test error, using either a validation set
approach or a cross-validation approach, as discussed in Chapter 5.

We consider both of these approaches below.

Cp, AIC, BIC, and Adjusted R2

We show in Chapter 2 that the training set MSE is generally an under-
estimate of the test MSE. (Recall that MSE = RSS/n.) This is because
when we ﬁt a model to the training data using least squares, we speciﬁ-
cally estimate the regression coeﬃcients such that the training RSS (but
not the test RSS) is as small as possible. In particular, the training error
will decrease as more variables are included in the model, but the test error
may not. Therefore, training set RSS and training set R2 cannot be used
to select from among a set of models with diﬀerent numbers of variables.
However, a number of techniques for adjusting the training error for the
model size are available. These approaches can be used to select among a set

6.1 Subset Selection

211

p
C

0
0
0
0
3

0
0
0
5
2

0
0
0
0
2

0
0
0
5
1

0
0
0
0
1

C
B

I

0
0
0
0
3

0
0
0
5
2

0
0
0
0
2

0
0
0
5
1

0
0
0
0
1

6
9

.

0

4
9
0

.

2
9

.

0

0
9

.

0

8
8

.

0

6
8

.

0

2
R
 
d
e
t
s
u
d
A

j

2

4

6

8

10

2

4

6

8

10

2

4

6

8

10

Number of Predictors

Number of Predictors

Number of Predictors

FIGURE 6.2. Cp, BIC, and adjusted R2 are shown for the best models of each
size for the Credit data set (the lower frontier in Figure 6.1). Cp and BIC are
estimates of test MSE. In the middle plot we see that the BIC estimate of test
error shows an increase after four variables are selected. The other two plots are
rather ﬂat after four variables are included.

of models with diﬀerent numbers of variables. We now consider four such
approaches: Cp, Akaike information criterion (AIC), Bayesian information
criterion (BIC), and adjusted R2. Figure 6.2 displays Cp, BIC, and adjusted
R2 for the best model of each size produced by best subset selection on the
Credit data set.

For a ﬁtted least squares model containing d predictors, the Cp estimate

of test MSE is computed using the equation

(cid:8)
RSS + 2dˆσ2

(cid:9)
,

(6.2)

Cp =

1
n

ˆσ2

where ˆσ2 is an estimate of the variance of the error  associated with each
response measurement in (6.1).3
Typically
is estimated using the full
Essentially, the Cp statistic adds a penalty
model containing all predictors.
of 2dˆσ2 to the training RSS in order to adjust for the fact that the training
error tends to underestimate the test error. Clearly, the penalty increases as
the number of predictors in the model increases; this is intended to adjust
for the corresponding decrease in training RSS. Though it is beyond the
scope of this book, one can show that if ˆσ2 is an unbiased estimate of σ2 in
(6.2), then Cp is an unbiased estimate of test MSE. As a consequence, the
Cp statistic tends to take on a small value for models with a low test error,
so when determining which of a set of models is best, we choose the model
with the lowest Cp value. In Figure 6.2, Cp selects the six-variable model
containing the predictors income, limit, rating, cards, age and student.

3Mallow’s Cp is sometimes deﬁned as C

the deﬁnition given above in the sense that Cp = 1
smallest Cp also has smallest C

(cid:3)
p.

p = RSS/ˆσ2 + 2d − n. This is equivalent to
(cid:3)
(cid:3)
p + n), and so the model with

n ˆσ2(C

Cp

Akaike
information
criterion
Bayesian
information
criterion
adjusted R2

212

6. Linear Model Selection and Regularization

The AIC criterion is deﬁned for a large class of models ﬁt by maximum
likelihood. In the case of the model (6.1) with Gaussian errors, maximum
likelihood and least squares are the same thing. In this case AIC is given by

(cid:8)
RSS + 2dˆσ2

(cid:9)

,

AIC =

1
nˆσ2

where, for simplicity, we have omitted an additive constant. Hence for least
squares models, Cp and AIC are proportional to each other, and so only
Cp is displayed in Figure 6.2.

BIC is derived from a Bayesian point of view, but ends up looking similar
to Cp (and AIC) as well. For the least squares model with d predictors, the
BIC is, up to irrelevant constants, given by

(cid:8)
RSS + log(n)dˆσ2

(cid:9)

BIC =

1
nˆσ2

.

(6.3)

Like Cp, the BIC will tend to take on a small value for a model with a
low test error, and so generally we select the model that has the lowest
BIC value. Notice that BIC replaces the 2dˆσ2 used by Cp with a log(n)dˆσ2
term, where n is the number of observations. Since log n > 2 for any n > 7,
the BIC statistic generally places a heavier penalty on models with many
variables, and hence results in the selection of smaller models than Cp.
In Figure 6.2, we see that this is indeed the case for the Credit data set;
BIC chooses a model that contains only the four predictors income, limit,
cards, and student. In this case the curves are very ﬂat and so there does
not appear to be much diﬀerence in accuracy between the four-variable and
six-variable models.

The adjusted R2 statistic is another popular approach for selecting among
a set of models that contain diﬀerent numbers of variables. Recall from
Chapter 3 that the usual R2 is deﬁned as 1 − RSS/TSS, where TSS =
(cid:10)
(yi − y)2 is the total sum of squares for the response. Since RSS always
decreases as more variables are added to the model, the R2 always increases
as more variables are added. For a least squares model with d variables,
the adjusted R2 statistic is calculated as

Adjusted R2 = 1 − RSS/(n − d − 1)
TSS/(n − 1)

.

(6.4)

Unlike Cp, AIC, and BIC, for which a small value indicates a model with
a low test error, a large value of adjusted R2 indicates a model with a
small test error. Maximizing the adjusted R2 is equivalent to minimizing
RSS
n−d−1 . While RSS always decreases as the number of variables in the model
increases, RSS
n−d−1 may increase or decrease, due to the presence of d in the
denominator.

The intuition behind the adjusted R2 is that once all of the correct
variables have been included in the model, adding additional noise variables

6.1 Subset Selection

213

will lead to only a very small decrease in RSS. Since adding noise variables
leads to an increase in d, such variables will lead to an increase in RSS
n−d−1 ,
and consequently a decrease in the adjusted R2. Therefore, in theory, the
model with the largest adjusted R2 will have only correct variables and
no noise variables. Unlike the R2 statistic, the adjusted R2 statistic pays
a price for the inclusion of unnecessary variables in the model. Figure 6.2
displays the adjusted R2 for the Credit data set. Using this statistic results
in the selection of a model that contains seven variables, adding gender to
the model selected by Cp and AIC.

Cp, AIC, and BIC all have rigorous theoretical justiﬁcations that are
beyond the scope of this book. These justiﬁcations rely on asymptotic ar-
guments (scenarios where the sample size n is very large). Despite its pop-
ularity, and even though it is quite intuitive, the adjusted R2 is not as well
motivated in statistical theory as AIC, BIC, and Cp. All of these measures
are simple to use and compute. Here we have presented the formulas for
AIC, BIC, and Cp in the case of a linear model ﬁt using least squares;
however, these quantities can also be deﬁned for more general types of
models.

Validation and Cross-Validation

As an alternative to the approaches just discussed, we can directly esti-
mate the test error using the validation set and cross-validation methods
discussed in Chapter 5. We can compute the validation set error or the
cross-validation error for each model under consideration, and then select
the model for which the resulting estimated test error is smallest. This pro-
cedure has an advantage relative to AIC, BIC, Cp, and adjusted R2, in that
it provides a direct estimate of the test error, and makes fewer assumptions
about the true underlying model. It can also be used in a wider range of
model selection tasks, even in cases where it is hard to pinpoint the model
degrees of freedom (e.g. the number of predictors in the model) or hard to
estimate the error variance σ2.

In the past, performing cross-validation was computationally prohibitive
for many problems with large p and/or large n, and so AIC, BIC, Cp,
and adjusted R2 were more attractive approaches for choosing among a
set of models. However, nowadays with fast computers, the computations
required to perform cross-validation are hardly ever an issue. Thus, cross-
validation is a very attractive approach for selecting from among a number
of models under consideration.

Figure 6.3 displays, as a function of d, the BIC, validation set errors, and
cross-validation errors on the Credit data, for the best d-variable model.
The validation errors were calculated by randomly selecting three-quarters
of the observations as the training set, and the remainder as the valida-
tion set. The cross-validation errors were computed using k = 10 folds.
In this case, the validation and cross-validation methods both result in a

214

6. Linear Model Selection and Regularization

C
B

I

 
f

o

 
t

 

o
o
R
e
r
a
u
q
S

0
2
2

0
0
2

0
8
1

0
6
1

0
4
1

0
2
1

0
0
1

r
o
r
r

E

 
t

e
S
n
o

 

i
t

a
d

i
l

a
V

0
2
2

0
0
2

0
8
1

0
6
1

0
4
1

0
2
1

0
0
1

4

2
10
Number of Predictors

6

8

r
o
r
r

 

E
n
o

i
t

a
d

i
l

a
V
−
s
s
o
r
C

0
2
2

0
0
2

0
8
1

0
6
1

0
4
1

0
2
1

0
0
1

4

2
10
Number of Predictors

6

8

4

2
10
Number of Predictors

6

8

FIGURE 6.3. For the Credit data set, three quantities are displayed for the
best model containing d predictors, for d ranging from 1 to 11. The overall best
model, based on each of these quantities, is shown as a blue cross. Left: Square
root of BIC. Center: Validation set errors. Right: Cross-validation errors.

six-variable model. However, all three approaches suggest that the four-,
ﬁve-, and six-variable models are roughly equivalent in terms of their test
errors.

In fact, the estimated test error curves displayed in the center and right-
hand panels of Figure 6.3 are quite ﬂat. While a three-variable model clearly
has lower estimated test error than a two-variable model, the estimated test
errors of the 3- to 11-variable models are quite similar. Furthermore, if we
repeated the validation set approach using a diﬀerent split of the data into
a training set and a validation set, or if we repeated cross-validation using
a diﬀerent set of cross-validation folds, then the precise model with the
lowest estimated test error would surely change. In this setting, we can
select a model using the one-standard-error rule. We ﬁrst calculate the one-
standard error of the estimated test MSE for each model size, and then
select the smallest model for which the estimated test error is within one
standard error of the lowest point on the curve. The rationale here is that
if a set of models appear to be more or less equally good, then we might
as well choose the simplest model—that is, the model with the smallest
number of predictors. In this case, applying the one-standard-error rule
to the validation set or cross-validation approach leads to selection of the
three-variable model.

standard-
error
rule

6.2 Shrinkage Methods

The subset selection methods described in Section 6.1 involve using least
squares to ﬁt a linear model that contains a subset of the predictors. As an
alternative, we can ﬁt a model containing all p predictors using a technique
that constrains or regularizes the coeﬃcient estimates, or equivalently, that
shrinks the coeﬃcient estimates towards zero. It may not be immediately

6.2 Shrinkage Methods

215

obvious why such a constraint should improve the ﬁt, but it turns out that
shrinking the coeﬃcient estimates can signiﬁcantly reduce their variance.
The two best-known techniques for shrinking the regression coeﬃcients
towards zero are ridge regression and the lasso.

6.2.1 Ridge Regression

Recall from Chapter 3 that the least squares ﬁtting procedure estimates
β0, β1, . . . , βp using the values that minimize

RSS =

n(cid:17)

i=1

⎛
⎝yi − β0 − p(cid:17)

j=1

⎞
⎠2

βjxij

.

Ridge regression is very similar to least squares, except that the coeﬃcients
are estimated by minimizing a slightly diﬀerent quantity. In particular, the
ridge regression coeﬃcient estimates ˆβR are the values that minimize

⎛
⎝yi − β0 − p(cid:17)

n(cid:17)

i=1

βjxij

j=1

⎞
⎠2

p(cid:17)

j=1

+ λ

β2
j = RSS + λ

p(cid:17)

j=1

β2
j ,

(6.5)

(cid:10)

j β2

where λ ≥ 0 is a tuning parameter, to be determined separately. Equa-
tion 6.5 trades oﬀ two diﬀerent criteria. As with least squares, ridge regres-
sion seeks coeﬃcient estimates that ﬁt the data well, by making the RSS
small. However, the second term, λ
j , called a shrinkage penalty, is
small when β1, . . . , βp are close to zero, and so it has the eﬀect of shrinking
the estimates of βj towards zero. The tuning parameter λ serves to control
the relative impact of these two terms on the regression coeﬃcient esti-
mates. When λ = 0, the penalty term has no eﬀect, and ridge regression
will produce the least squares estimates. However, as λ → ∞, the impact of
the shrinkage penalty grows, and the ridge regression coeﬃcient estimates
will approach zero. Unlike least squares, which generates only one set of co-
eﬃcient estimates, ridge regression will produce a diﬀerent set of coeﬃcient
estimates, ˆβR
λ , for each value of λ. Selecting a good value for λ is critical;
we defer this discussion to Section 6.2.3, where we use cross-validation.

Note that in (6.5), the shrinkage penalty is applied to β1, . . . , βp, but
not to the intercept β0. We want to shrink the estimated association of
each variable with the response; however, we do not want to shrink the
intercept, which is simply a measure of the mean value of the response
when xi1 = xi2 = . . . = xip = 0. If we assume that the variables—that is,
the columns of the data matrix X—have been centered to have mean zero
before ridge regression is performed, then the estimated intercept will take
the form ˆβ0 = ¯y =

(cid:10)

n
i=1 yi/n.

ridge
regression

tuning
parameter

shrinkage
penalty

216

6. Linear Model Selection and Regularization

i

s
t
n
e
c
i
f
f
e
o
C
 
d
e
z
d
r
a
d
n
a
t
S

i

Income
Limit
Rating
Student

0
0
4

0
0
3

0
0
2

0
0
1

0

0
0
1
−

0
0
3
−

i

s
t
n
e
c
i
f
f
e
o
C
 
d
e
z
d
r
a
d
n
a
t
S

i

0
0
4

0
0
3

0
0
2

0
0
1

0

0
0
1
−

0
0
3
−

1e−02

1e+00

1e+02
λ

1e+04

0.0

0.2

0.6

0.4
λ 2/ ˆβ 2
ˆβR

0.8

1.0

FIGURE 6.4. The standardized ridge regression coeﬃcients are displayed for
the Credit data set, as a function of λ and (cid:4) ˆβR

λ (cid:4)2/(cid:4) ˆβ(cid:4)2.

An Application to the Credit Data

In Figure 6.4, the ridge regression coeﬃcient estimates for the Credit data
set are displayed. In the left-hand panel, each curve corresponds to the
ridge regression coeﬃcient estimate for one of the ten variables, plotted
as a function of λ. For example, the black solid line represents the ridge
regression estimate for the income coeﬃcient, as λ is varied. At the extreme
left-hand side of the plot, λ is essentially zero, and so the corresponding
ridge coeﬃcient estimates are the same as the usual least squares esti-
mates. But as λ increases, the ridge coeﬃcient estimates shrink towards
zero. When λ is extremely large, then all of the ridge coeﬃcient estimates
are basically zero; this corresponds to the null model that contains no pre-
dictors. In this plot, the income, limit, rating, and student variables are
displayed in distinct colors, since these variables tend to have by far the
largest coeﬃcient estimates. While the ridge coeﬃcient estimates tend to
decrease in aggregate as λ increases, individual coeﬃcients, such as rating
and income, may occasionally increase as λ increases.

λ

λ

The right-hand panel of Figure 6.4 displays the same ridge coeﬃcient
estimates as the left-hand panel, but instead of displaying λ on the x-axis,
(cid:12)2/(cid:12) ˆβ(cid:12)2, where ˆβ denotes the vector of least squares
we now display (cid:12) ˆβR
coeﬃcient estimates. The notation (cid:12)β(cid:12)2 denotes the (cid:6)2 norm (pronounced
“ell 2”) of a vector, and is deﬁned as (cid:12)β(cid:12)2 =
2. It measures
the distance of β from zero. As λ increases, the (cid:6)2 norm of ˆβR
decrease, and so will (cid:12) ˆβR
λ = 0, in which case the ridge regression coeﬃcient estimate is the same
as the least squares estimate, and so their (cid:6)2 norms are the same) to 0
(when λ = ∞, in which case the ridge regression coeﬃcient estimate is a
vector of zeros, with (cid:6)2 norm equal to zero). Therefore, we can think of the
x-axis in the right-hand panel of Figure 6.4 as the amount that the ridge

λ will always
(cid:12)2/(cid:12) ˆβ(cid:12)2. The latter quantity ranges from 1 (when

’(cid:10)

p
j=1 βj

(cid:5)2 norm

6.2 Shrinkage Methods

217

regression coeﬃcient estimates have been shrunken towards zero; a small
value indicates that they have been shrunken very close to zero.

The standard least squares coeﬃcient estimates discussed in Chapter 3
are scale equivariant: multiplying Xj by a constant c simply leads to a
scaling of the least squares coeﬃcient estimates by a factor of 1/c. In other
words, regardless of how the jth predictor is scaled, Xj ˆβj will remain the
same. In contrast, the ridge regression coeﬃcient estimates can change sub-
stantially when multiplying a given predictor by a constant. For instance,
consider the income variable, which is measured in dollars. One could rea-
sonably have measured income in thousands of dollars, which would result
in a reduction in the observed values of income by a factor of 1,000. Now due
to the sum of squared coeﬃcients term in the ridge regression formulation
(6.5), such a change in scale will not simply cause the ridge regression co-
eﬃcient estimate for income to change by a factor of 1,000. In other words,
Xj ˆβR
j,λ will depend not only on the value of λ, but also on the scaling of the
jth predictor. In fact, the value of Xj ˆβR
j,λ may even depend on the scaling
of the other predictors! Therefore, it is best to apply ridge regression after
standardizing the predictors, using the formula

scale
equivariant

˜xij =

’

(cid:10)

1
n

xij

n

i=1(xij − xj)2

,

(6.6)

so that they are all on the same scale. In (6.6), the denominator is the
estimated standard deviation of the jth predictor. Consequently, all of the
standardized predictors will have a standard deviation of one. As a re-
sult the ﬁnal ﬁt will not depend on the scale on which the predictors are
measured. In Figure 6.4, the y-axis displays the standardized ridge regres-
sion coeﬃcient estimates—that is, the coeﬃcient estimates that result from
performing ridge regression using standardized predictors.

Why Does Ridge Regression Improve Over Least Squares?

Ridge regression’s advantage over least squares is rooted in the bias-variance
trade-oﬀ. As λ increases, the ﬂexibility of the ridge regression ﬁt decreases,
leading to decreased variance but increased bias. This is illustrated in the
left-hand panel of Figure 6.5, using a simulated data set containing p = 45
predictors and n = 50 observations. The green curve in the left-hand panel
of Figure 6.5 displays the variance of the ridge regression predictions as a
function of λ. At the least squares coeﬃcient estimates, which correspond
to ridge regression with λ = 0, the variance is high but there is no bias. But
as λ increases, the shrinkage of the ridge coeﬃcient estimates leads to a
substantial reduction in the variance of the predictions, at the expense of a
slight increase in bias. Recall that the test mean squared error (MSE), plot-
ted in purple, is a function of the variance plus the squared bias. For values

218

6. Linear Model Selection and Regularization

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
6

0
5

0
4

0
3

0
2

0
1

0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
6

0
5

0
4

0
3

0
2

0
1

0

1e−01

1e+01
λ

1e+03

0.0

0.2

0.6

0.4
λ 2/ ˆβ 2
ˆβR

0.8

1.0

FIGURE 6.5. Squared bias (black), variance (green), and test mean squared
error (purple) for the ridge regression predictions on a simulated data set, as a
λ (cid:4)2/(cid:4) ˆβ(cid:4)2. The horizontal dashed lines indicate the minimum
function of λ and (cid:4) ˆβR
possible MSE. The purple crosses indicate the ridge regression models for which
the MSE is smallest.

of λ up to about 10, the variance decreases rapidly, with very little increase
in bias, plotted in black. Consequently, the MSE drops considerably as λ
increases from 0 to 10. Beyond this point, the decrease in variance due to
increasing λ slows, and the shrinkage on the coeﬃcients causes them to be
signiﬁcantly underestimated, resulting in a large increase in the bias. The
minimum MSE is achieved at approximately λ = 30. Interestingly, because
of its high variance, the MSE associated with the least squares ﬁt, when
λ = 0, is almost as high as that of the null model for which all coeﬃcient
estimates are zero, when λ = ∞. However, for an intermediate value of λ,
the MSE is considerably lower.

The right-hand panel of Figure 6.5 displays the same curves as the left-
hand panel, this time plotted against the (cid:6)2 norm of the ridge regression
coeﬃcient estimates divided by the (cid:6)2 norm of the least squares estimates.
Now as we move from left to right, the ﬁts become more ﬂexible, and so
the bias decreases and the variance increases.

In general, in situations where the relationship between the response
and the predictors is close to linear, the least squares estimates will have
low bias but may have high variance. This means that a small change in
the training data can cause a large change in the least squares coeﬃcient
estimates. In particular, when the number of variables p is almost as large
as the number of observations n, as in the example in Figure 6.5, the
least squares estimates will be extremely variable. And if p > n, then the
least squares estimates do not even have a unique solution, whereas ridge
regression can still perform well by trading oﬀ a small increase in bias for a
large decrease in variance. Hence, ridge regression works best in situations
where the least squares estimates have high variance.

Ridge regression also has substantial computational advantages over best
subset selection, which requires searching through 2p models. As we

6.2 Shrinkage Methods

219

discussed previously, even for moderate values of p, such a search can
be computationally infeasible. In contrast, for any ﬁxed value of λ, ridge
regression only ﬁts a single model, and the model-ﬁtting procedure can
be performed quite quickly. In fact, one can show that the computations
required to solve (6.5), simultaneously for all values of λ, are almost iden-
tical to those for ﬁtting a model using least squares.

6.2.2 The Lasso

(cid:10)

Ridge regression does have one obvious disadvantage. Unlike best subset,
forward stepwise, and backward stepwise selection, which will generally
select models that involve just a subset of the variables, ridge regression
β2
will include all p predictors in the ﬁnal model. The penalty λ
j in (6.5)
will shrink all of the coeﬃcients towards zero, but it will not set any of them
exactly to zero (unless λ = ∞). This may not be a problem for prediction
accuracy, but it can create a challenge in model interpretation in settings in
which the number of variables p is quite large. For example, in the Credit
data set, it appears that the most important variables are income, limit,
rating, and student. So we might wish to build a model including just
these predictors. However, ridge regression will always generate a model
involving all ten predictors. Increasing the value of λ will tend to reduce
the magnitudes of the coeﬃcients, but will not result in exclusion of any of
the variables.

The lasso is a relatively recent alternative to ridge regression that over-
λ , minimize the quantity

comes this disadvantage. The lasso coeﬃcients, ˆβL

lasso

βjxij

+ λ

|βj| = RSS + λ

|βj|.

(6.7)

p(cid:17)

n(cid:17)

⎛
⎝yi − β0 − p(cid:17)

⎞
⎠2

p(cid:17)

i=1

j=1

j=1

j=1

Comparing (6.7) to (6.5), we see that the lasso and ridge regression have
similar formulations. The only diﬀerence is that the β2
j term in the ridge
regression penalty (6.5) has been replaced by |βj| in the lasso penalty (6.7).
In statistical parlance, the lasso uses an (cid:6)1 (pronounced “ell 1”) penalty
instead of an (cid:6)2 penalty. The (cid:6)1 norm of a coeﬃcient vector β is given by
(cid:12)β(cid:12)1 =

(cid:10)|βj|.

As with ridge regression, the lasso shrinks the coeﬃcient estimates
towards zero. However, in the case of the lasso, the (cid:6)1 penalty has the eﬀect
of forcing some of the coeﬃcient estimates to be exactly equal to zero when
the tuning parameter λ is suﬃciently large. Hence, much like best subset se-
lection, the lasso performs variable selection. As a result, models generated
from the lasso are generally much easier to interpret than those produced
by ridge regression. We say that the lasso yields sparse models—that is, sparse
models that involve only a subset of the variables. As in ridge regression,
selecting a good value of λ for the lasso is critical; we defer this discussion
to Section 6.2.3, where we use cross-validation.

220

6. Linear Model Selection and Regularization

i

s
t
n
e
c
i
f
f
e
o
C
 
d
e
z
d
r
a
d
n
a
t
S

i

0
0
4

0
0
3

0
0
2

0
0
1

0

0
0
2
−

i

s
t
n
e
c
i
f
f
e
o
C
 
d
e
z
d
r
a
d
n
a
t
S

i

0
0
4

0
0
3

0
0
2

0
0
1

0

0
0
1
−

0
0
3
−

Income
Limit
Rating
Student

20

50

100 200

500
λ

2000

5000

0.0

0.2

0.6

0.4
ˆβL
λ 1/ ˆβ 1

0.8

1.0

FIGURE 6.6. The standardized lasso coeﬃcients on the Credit data set are
shown as a function of λ and (cid:4) ˆβL

λ (cid:4)1/(cid:4) ˆβ(cid:4)1.

As an example, consider the coeﬃcient plots in Figure 6.6, which are gen-
erated from applying the lasso to the Credit data set. When λ = 0, then
the lasso simply gives the least squares ﬁt, and when λ becomes suﬃciently
large, the lasso gives the null model in which all coeﬃcient estimates equal
zero. However, in between these two extremes, the ridge regression and
lasso models are quite diﬀerent from each other. Moving from left to right
in the right-hand panel of Figure 6.6, we observe that at ﬁrst the lasso re-
sults in a model that contains only the rating predictor. Then student and
limit enter the model almost simultaneously, shortly followed by income.
Eventually, the remaining variables enter the model. Hence, depending on
the value of λ, the lasso can produce a model involving any number of vari-
ables. In contrast, ridge regression will always include all of the variables in
the model, although the magnitude of the coeﬃcient estimates will depend
on λ.

Another Formulation for Ridge Regression and the Lasso

One can show that the lasso and ridge regression coeﬃcient estimates solve
the problems

⎧⎪⎨
⎪⎩

n(cid:17)

i=1

⎛
⎝yi − β0 − p(cid:17)

⎞
⎠

2

⎫⎪⎬
⎪⎭ subject to

βjxij

j=1

minimize

β

and

minimize

β

⎧⎪⎨
⎪⎩

n(cid:17)

i=1

⎛
⎝yi − β0 − p(cid:17)

j=1

⎞
⎠2

⎫⎪⎬
⎪⎭ subject to

βjxij

p(cid:17)

j=1

|βj| ≤ s

(6.8)

p(cid:17)

j=1

≤ s,

β2
j

(6.9)

6.2 Shrinkage Methods

221

respectively. In other words, for every value of λ, there is some s such that
the Equations (6.7) and (6.8) will give the same lasso coeﬃcient estimates.
Similarly, for every value of λ there is a corresponding s such that Equa-
tions (6.5) and (6.9) will give the same ridge regression coeﬃcient estimates.
When p = 2, then (6.8) indicates that the lasso coeﬃcient estimates have
the smallest RSS out of all points that lie within the diamond deﬁned by

|β1| + |β2| ≤ s. Similarly, the ridge regression estimates have the smallest
RSS out of all points that lie within the circle deﬁned by β2
(cid:10)

We can think of (6.8) as follows. When we perform the lasso we are trying
to ﬁnd the set of coeﬃcient estimates that lead to the smallest RSS, subject
to the constraint that there is a budget s for how large
When s is extremely large, then this budget is not very restrictive, and so
the coeﬃcient estimates can be large. In fact, if s is large enough that the
least squares solution falls within the budget, then (6.8) will simply yield
the least squares solution. In contrast, if s is small, then
small in order to avoid violating the budget. Similarly, (6.9) indicates that
when we perform ridge regression, we seek a set of coeﬃcient estimates
(cid:10)
such that the RSS is as small as possible, subject to the requirement that

|βj| must be

|βj| can be.

p
j=1 β2
The formulations (6.8) and (6.9) reveal a close connection between the

j not exceed the budget s.

1 + β2
2

≤ s.

(cid:10)

p
j=1

p
j=1

lasso, ridge regression, and best subset selection. Consider the problem

⎞
⎠2

⎫⎪⎬
⎪⎭ subject to

p(cid:17)

j=1

I(βj (cid:4)= 0) ≤ s.

⎧⎪⎨
⎪⎩

n(cid:17)

i=1

⎛
⎝yi − β0 − p(cid:17)

βjxij

j=1

minimize

β

Here I(βj (cid:4)= 0) is an indicator variable: it takes on a value of 1 if βj (cid:4)= 0, and

(6.10)

equals zero otherwise. Then (6.10) amounts to ﬁnding a set of coeﬃcient es-
timates such that RSS is as small as possible, subject to the constraint that
no more than s coeﬃcients can be nonzero. The problem (6.10) is equivalent
to best subset selection. Unfortunately, solving (6.10) is computationally
infeasible when p is large, since it requires considering all
models con-
taining s predictors. Therefore, we can interpret ridge regression and the
lasso as computationally feasible alternatives to best subset selection that
replace the intractable form of the budget in (6.10) with forms that are
much easier to solve. Of course, the lasso is much more closely related to
best subset selection, since only the lasso performs feature selection for s
suﬃciently small in (6.8).

(cid:8)

(cid:9)

p
s

The Variable Selection Property of the Lasso

Why is it that the lasso, unlike ridge regression, results in coeﬃcient
estimates that are exactly equal to zero? The formulations (6.8) and (6.9)
can be used to shed light on the issue. Figure 6.7 illustrates the situation.
The least squares solution is marked as ˆβ, while the blue diamond and

222

6. Linear Model Selection and Regularization

β2

^
β

β2

β^

β1

β1

FIGURE 6.7. Contours of the error and constraint functions for the lasso
(left) and ridge regression (right). The solid blue areas are the constraint re-
gions, |β1| + |β2| ≤ s and β2
2 ≤ s, while the red ellipses are the contours of
the RSS.

1 + β2

circle represent the lasso and ridge regression constraints in (6.8) and (6.9),
respectively. If s is suﬃciently large, then the constraint regions will con-
tain ˆβ, and so the ridge regression and lasso estimates will be the same as
the least squares estimates. (Such a large value of s corresponds to λ = 0
in (6.5) and (6.7).) However, in Figure 6.7 the least squares estimates lie
outside of the diamond and the circle, and so the least squares estimates
are not the same as the lasso and ridge regression estimates.

The ellipses that are centered around ˆβ represent regions of constant
RSS. In other words, all of the points on a given ellipse share a common
value of the RSS. As the ellipses expand away from the least squares co-
eﬃcient estimates, the RSS increases. Equations (6.8) and (6.9) indicate
that the lasso and ridge regression coeﬃcient estimates are given by the
ﬁrst point at which an ellipse contacts the constraint region. Since ridge
regression has a circular constraint with no sharp points, this intersection
will not generally occur on an axis, and so the ridge regression coeﬃcient
estimates will be exclusively non-zero. However, the lasso constraint has
corners at each of the axes, and so the ellipse will often intersect the con-
straint region at an axis. When this occurs, one of the coeﬃcients will equal
zero. In higher dimensions, many of the coeﬃcient estimates may equal zero
simultaneously. In Figure 6.7, the intersection occurs at β1 = 0, and so the
resulting model will only include β2.

In Figure 6.7, we considered the simple case of p = 2. When p = 3,
then the constraint region for ridge regression becomes a sphere, and the
constraint region for the lasso becomes a polyhedron. When p > 3, the

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
6

0
5

0
4

0
3

0
2

0
1

0

6.2 Shrinkage Methods

223

0
6

0
5

0
4

0
3

0
2

0
1

0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0.02

0.10

0.50

2.00

10.00

50.00

0.0

0.2

0.4

0.6

0.8

1.0

λ

R2 on Training Data

FIGURE 6.8. Left: Plots of squared bias (black), variance (green), and test MSE
(purple) for the lasso on a simulated data set. Right: Comparison of squared bias,
variance and test MSE between lasso (solid) and ridge (dotted). Both are plotted
against their R2 on the training data, as a common form of indexing. The crosses
in both plots indicate the lasso model for which the MSE is smallest.

constraint for ridge regression becomes a hypersphere, and the constraint
for the lasso becomes a polytope. However, the key ideas depicted in Fig-
ure 6.7 still hold. In particular, the lasso leads to feature selection when
p > 2 due to the sharp corners of the polyhedron or polytope.

Comparing the Lasso and Ridge Regression

It is clear that the lasso has a major advantage over ridge regression, in
that it produces simpler and more interpretable models that involve only a
subset of the predictors. However, which method leads to better prediction
accuracy? Figure 6.8 displays the variance, squared bias, and test MSE of
the lasso applied to the same simulated data as in Figure 6.5. Clearly the
lasso leads to qualitatively similar behavior to ridge regression, in that as λ
increases, the variance decreases and the bias increases. In the right-hand
panel of Figure 6.8, the dotted lines represent the ridge regression ﬁts.
Here we plot both against their R2 on the training data. This is another
useful way to index models, and can be used to compare models with
diﬀerent types of regularization, as is the case here. In this example, the
lasso and ridge regression result in almost identical biases. However, the
variance of ridge regression is slightly lower than the variance of the lasso.
Consequently, the minimum MSE of ridge regression is slightly smaller than
that of the lasso.

However, the data in Figure 6.8 were generated in such a way that all 45
predictors were related to the response—that is, none of the true coeﬃcients
β1, . . . , β45 equaled zero. The lasso implicitly assumes that a number of the
coeﬃcients truly equal zero. Consequently, it is not surprising that ridge
regression outperforms the lasso in terms of prediction error in this setting.
Figure 6.9 illustrates a similar situation, except that now the response is a

224

6. Linear Model Selection and Regularization

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
0
1

0
8

0
6

0
4

0
2

0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
0
1

0
8

0
6

0
4

0
2

0

0.02

0.10

0.50

2.00

10.00

50.00

0.4

0.5

0.6

0.7

0.8

0.9

1.0

λ

R2 on Training Data

FIGURE 6.9. Left: Plots of squared bias (black), variance (green), and test MSE
(purple) for the lasso. The simulated data is similar to that in Figure 6.8, except
that now only two predictors are related to the response. Right: Comparison of
squared bias, variance and test MSE between lasso (solid) and ridge (dotted). Both
are plotted against their R2 on the training data, as a common form of indexing.
The crosses in both plots indicate the lasso model for which the MSE is smallest.

function of only 2 out of 45 predictors. Now the lasso tends to outperform
ridge regression in terms of bias, variance, and MSE.

These two examples illustrate that neither ridge regression nor the lasso
will universally dominate the other. In general, one might expect the lasso
to perform better in a setting where a relatively small number of predictors
have substantial coeﬃcients, and the remaining predictors have coeﬃcients
that are very small or that equal zero. Ridge regression will perform better
when the response is a function of many predictors, all with coeﬃcients of
roughly equal size. However, the number of predictors that is related to the
response is never known a priori for real data sets. A technique such as
cross-validation can be used in order to determine which approach is better
on a particular data set.

As with ridge regression, when the least squares estimates have exces-
sively high variance, the lasso solution can yield a reduction in variance
at the expense of a small increase in bias, and consequently can gener-
ate more accurate predictions. Unlike ridge regression, the lasso performs
variable selection, and hence results in models that are easier to interpret.
There are very eﬃcient algorithms for ﬁtting both ridge and lasso models;
in both cases the entire coeﬃcient paths can be computed with about the
same amount of work as a single least squares ﬁt. We will explore this
further in the lab at the end of this chapter.

A Simple Special Case for Ridge Regression and the Lasso

In order to obtain a better intuition about the behavior of ridge regression
and the lasso, consider a simple special case with n = p, and X a diag-
onal matrix with 1’s on the diagonal and 0’s in all oﬀ-diagonal elements.
To simplify the problem further, assume also that we are performing regres-

6.2 Shrinkage Methods

225

sion without an intercept. With these assumptions, the usual least squares
problem simpliﬁes to ﬁnding β1, . . . , βp that minimize

p(cid:17)

(yj − βj)2.

(6.11)

In this case, the least squares solution is given by

j=1

ˆβj = yj.

And in this setting, ridge regression amounts to ﬁnding β1, . . . , βp such that

(yj − βj)2 + λ

j=1

j=1

β2
j

(6.12)

p(cid:17)

p(cid:17)

p(cid:17)

p(cid:17)

is minimized, and the lasso amounts to ﬁnding the coeﬃcients such that

(yj − βj)2 + λ

|βj|

(6.13)

j=1

j=1

is minimized. One can show that in this setting, the ridge regression esti-
mates take the form

ˆβR
j = yj/(1 + λ),

and the lasso estimates take the form

⎧⎪⎨
⎪⎩

ˆβL
j =

yj − λ/2
yj + λ/2
0

if yj > λ/2;
if yj < −λ/2;
if |yj| ≤ λ/2.

(6.14)

(6.15)

Figure 6.10 displays the situation. We can see that ridge regression and
the lasso perform two very diﬀerent types of shrinkage. In ridge regression,
each least squares coeﬃcient estimate is shrunken by the same proportion.
In contrast, the lasso shrinks each least squares coeﬃcient towards zero by
a constant amount, λ/2; the least squares coeﬃcients that are less than
λ/2 in absolute value are shrunken entirely to zero. The type of shrink-
age performed by the lasso in this simple setting (6.15) is known as soft-
thresholding. The fact that some lasso coeﬃcients are shrunken entirely to
zero explains why the lasso performs feature selection.

In the case of a more general data matrix X, the story is a little more
complicated than what is depicted in Figure 6.10, but the main ideas still
hold approximately: ridge regression more or less shrinks every dimension
of the data by the same proportion, whereas the lasso more or less shrinks
all coeﬃcients toward zero by a similar amount, and suﬃciently small co-
eﬃcients are shrunken all the way to zero.

soft-
thresholding

226

6. Linear Model Selection and Regularization

e
t
a
m

i
t
s
E

i

 
t
n
e
c
i
f
f
e
o
C

5
.
1

5
.
0

5
.
0
−

5
.
1
−

Ridge
Least Squares

e
t
a
m

i
t
s
E

i

 
t
n
e
c
i
f
f
e
o
C

Lasso
Least Squares

5
.
1

5
.
0

5
.
0
−

5
.
1
−

−1.5

−0.5 0.0

0.5

1.0

1.5

−1.5

−0.5 0.0

0.5

1.0

1.5

yj

yj

FIGURE 6.10. The ridge regression and lasso coeﬃcient estimates for a simple
setting with n = p and X a diagonal matrix with 1’s on the diagonal. Left: The
ridge regression coeﬃcient estimates are shrunken proportionally towards zero,
relative to the least squares estimates. Right: The lasso coeﬃcient estimates are
soft-thresholded towards zero.

Bayesian Interpretation for Ridge Regression and the Lasso

We now show that one can view ridge regression and the lasso through
a Bayesian lens. A Bayesian viewpoint for regression assumes that the
coeﬃcient vector β has some prior distribution, say p(β), where β =

(β0, β1, . . . , βp)T . The likelihood of the data can be written as f (Y |X, β),
where X = (X1, . . . , Xp). Multiplying the prior distribution by the likeli-
hood gives us (up to a proportionality constant) the posterior distribution,
which takes the form

posterior
distribution

p(β|X, Y ) ∝ f (Y |X, β)p(β|X) = f (Y |X, β)p(β),

where the proportionality above follows from Bayes’ theorem, and the
equality above follows from the assumption that X is ﬁxed.

We assume the usual linear model,

Y = β0 + X1β1 + . . . + Xpβp + ,

and suppose that the errors are independent and drawn from a normal dis-
p
tribution. Furthermore, assume that p(β) =
j=1 g(βj), for some density
function g. It turns out that ridge regression and the lasso follow naturally
from two special cases of g:

+

• If g is a Gaussian distribution with mean zero and standard deviation
a function of λ, then it follows that the posterior mode for β—that
is, the most likely value for β, given the data—is given by the ridge
regression solution. (In fact, the ridge regression solution is also the
posterior mean.)

posterior
mode

6.2 Shrinkage Methods

227

)

j

β
(

7
0

.

6

.

0

5

.

0

4

.

0

3

.

0

2
0

.

1

.

0

0

.
0

)

j

β
(

7
0

.

6

.

0

5

.

0

4

.

0

3

.

0

2
0

.

1

.

0

0

.
0

−3

−2

−1

0
βj

1

2

3

−3

−2

−1

1

2

3

0
βj

FIGURE 6.11. Left: Ridge regression is the posterior mode for β under a Gaus-
sian prior. Right: The lasso is the posterior mode for β under a double-exponential
prior.

• If g is a double-exponential (Laplace) distribution with mean zero
and scale parameter a function of λ, then it follows that the posterior
mode for β is the lasso solution. (However, the lasso solution is not
the posterior mean, and in fact, the posterior mean does not yield a
sparse coeﬃcient vector.)

The Gaussian and double-exponential priors are displayed in Figure 6.11.
Therefore, from a Bayesian viewpoint, ridge regression and the lasso follow
directly from assuming the usual linear model with normal errors, together
with a simple prior distribution for β. Notice that the lasso prior is steeply
peaked at zero, while the Gaussian is ﬂatter and fatter at zero. Hence, the
lasso expects a priori that many of the coeﬃcients are (exactly) zero, while
ridge assumes the coeﬃcients are randomly distributed about zero.

6.2.3 Selecting the Tuning Parameter

Just as the subset selection approaches considered in Section 6.1 require
a method to determine which of the models under consideration is best,
implementing ridge regression and the lasso requires a method for selecting
a value for the tuning parameter λ in (6.5) and (6.7), or equivalently, the
value of the constraint s in (6.9) and (6.8). Cross-validation provides a sim-
ple way to tackle this problem. We choose a grid of λ values, and compute
the cross-validation error for each value of λ, as described in Chapter 5. We
then select the tuning parameter value for which the cross-validation error
is smallest. Finally, the model is re-ﬁt using all of the available observations
and the selected value of the tuning parameter.

Figure 6.12 displays the choice of λ that results from performing leave-
one-out cross-validation on the ridge regression ﬁts from the Credit data
set. The dashed vertical lines indicate the selected value of λ. In this case
the value is relatively small, indicating that the optimal ﬁt only involves a

228

6. Linear Model Selection and Regularization

r
o
r
r

 

E
n
o

i
t

a
d

i
l

a
V
−
s
s
o
r
C

6
.
5
2

4
.
5
2

2
.
5
2

0
.
5
2

s
t

i

n
e
c
i
f
f

 

i

e
o
C
d
e
z
d
r
a
d
n
a
S

t

0
0
3

0
0
1

0

0
0
1
−

0
0
3
−

5e−03

5e−02

5e−01

5e+00

5e−03

5e−02

5e−01

5e+00

λ

λ

FIGURE 6.12. Left: Cross-validation errors that result from applying ridge
regression to the Credit data set with various value of λ. Right: The coeﬃcient
estimates as a function of λ. The vertical dashed lines indicate the value of λ
selected by cross-validation.

small amount of shrinkage relative to the least squares solution. In addition,
the dip is not very pronounced, so there is rather a wide range of values
that would give very similar error. In a case like this we might simply use
the least squares solution.

Figure 6.13 provides an illustration of ten-fold cross-validation applied to
the lasso ﬁts on the sparse simulated data from Figure 6.9. The left-hand
panel of Figure 6.13 displays the cross-validation error, while the right-hand
panel displays the coeﬃcient estimates. The vertical dashed lines indicate
the point at which the cross-validation error is smallest. The two colored
lines in the right-hand panel of Figure 6.13 represent the two predictors
that are related to the response, while the grey lines represent the unre-
lated predictors; these are often referred to as signal and noise variables,
respectively. Not only has the lasso correctly given much larger coeﬃ-
cient estimates to the two signal predictors, but also the minimum cross-
validation error corresponds to a set of coeﬃcient estimates for which only
the signal variables are non-zero. Hence cross-validation together with the
lasso has correctly identiﬁed the two signal variables in the model, even
though this is a challenging setting, with p = 45 variables and only n = 50
observations. In contrast, the least squares solution—displayed on the far
right of the right-hand panel of Figure 6.13—assigns a large coeﬃcient
estimate to only one of the two signal variables.

signal

6.3 Dimension Reduction Methods

The methods that we have discussed so far in this chapter have controlled
variance in two diﬀerent ways, either by using a subset of the original vari-
ables, or by shrinking their coeﬃcients toward zero. All of these methods

6.3 Dimension Reduction Methods

229

r
o
r
r

 

E
n
o

i
t

a
d

i
l

a
V
−
s
s
o
r
C

0
0
4
1

0
0
0
1

0
0
6

0
0
2

0

0.0

0.2

s
t

i

n
e
c
i
f
f

i

 

e
o
C
d
e
z
d
r
a
d
n
a
S

t

5
1

0
1

5

0

5
−

0.8

1.0

0.0

0.2

0.4

0.6

ˆβL
λ 1/ ˆβ 1

0.6

0.4

ˆβL
λ 1/ ˆβ 1

0.8

1.0

dimension
reduction
linear
combination

FIGURE 6.13. Left: Ten-fold cross-validation MSE for the lasso, applied to
the sparse simulated data set from Figure 6.9. Right: The corresponding lasso
coeﬃcient estimates are displayed. The vertical dashed lines indicate the lasso ﬁt
for which the cross-validation error is smallest.

are deﬁned using the original predictors, X1, X2, . . . , Xp. We now explore
a class of approaches that transform the predictors and then ﬁt a least
squares model using the transformed variables. We will refer to these tech-
niques as dimension reduction methods.

Let Z1, Z2, . . . , ZM represent M < p linear combinations of our original

p predictors. That is,

p(cid:17)

Zm =

φjmXj

j=1

(6.16)

for some constants φ1m, φ2m . . . , φpm, m = 1, . . . , M . We can then ﬁt the
linear regression model

M(cid:17)

yi = θ0 +

θmzim + i,

i = 1, . . . , n,

(6.17)

m=1

using least squares. Note that in (6.17), the regression coeﬃcients are given
by θ0, θ1, . . . , θM . If the constants φ1m, φ2m, . . . , φpm are chosen wisely, then
such dimension reduction approaches can often outperform least squares
regression. In other words, ﬁtting (6.17) using least squares can lead to
better results than ﬁtting (6.1) using least squares.

The term dimension reduction comes from the fact that this approach
reduces the problem of estimating the p + 1 coeﬃcients β0, β1, . . . , βp to the
simpler problem of estimating the M + 1 coeﬃcients θ0, θ1, . . . , θM , where
M < p. In other words, the dimension of the problem has been reduced
from p + 1 to M + 1.

Notice that from (6.16),

M(cid:17)

M(cid:17)

p(cid:17)

p(cid:17)

M(cid:17)

p(cid:17)

θmzim =

θm

φjmxij =

θmφjmxij =

βjxij ,

m=1

m=1

j=1

j=1

m=1

j=1

230

6. Linear Model Selection and Regularization

i

g
n
d
n
e
p
S
 
d
A

5
3

0
3

5
2

0
2

5
1

0
1

5

0

10

20

30

40

50

60

70

Population

FIGURE 6.14. The population size (pop) and ad spending (ad) for 100 diﬀerent
cities are shown as purple circles. The green solid line indicates the ﬁrst principal
component, and the blue dashed line indicates the second principal component.

where

M(cid:17)

βj =

θmφjm.

m=1

(6.18)

Hence (6.17) can be thought of as a special case of the original linear
regression model given by (6.1). Dimension reduction serves to constrain
the estimated βj coeﬃcients, since now they must take the form (6.18).
This constraint on the form of the coeﬃcients has the potential to bias the
coeﬃcient estimates. However, in situations where p is large relative to n,
selecting a value of M (cid:15) p can signiﬁcantly reduce the variance of the ﬁtted
coeﬃcients. If M = p, and all the Zm are linearly independent, then (6.18)
poses no constraints. In this case, no dimension reduction occurs, and so
ﬁtting (6.17) is equivalent to performing least squares on the original p
predictors.

All dimension reduction methods work in two steps. First, the trans-
formed predictors Z1, Z2, . . . , ZM are obtained. Second, the model is ﬁt
using these M predictors. However, the choice of Z1, Z2, . . . , ZM , or equiv-
alently, the selection of the φjm’s, can be achieved in diﬀerent ways. In this
chapter, we will consider two approaches for this task: principal components
and partial least squares.

6.3.1 Principal Components Regression

Principal components analysis (PCA) is a popular approach for deriving
a low-dimensional set of features from a large set of variables. PCA is
discussed in greater detail as a tool for unsupervised learning in Chapter 10.
Here we describe its use as a dimension reduction technique for regression.

principal
components
analysis

6.3 Dimension Reduction Methods

231

An Overview of Principal Components Analysis
PCA is a technique for reducing the dimension of a n × p data matrix X.
The ﬁrst principal component direction of the data is that along which the
observations vary the most. For instance, consider Figure 6.14, which shows
population size (pop) in tens of thousands of people, and ad spending for a
particular company (ad) in thousands of dollars, for 100 cities. The green
solid line represents the ﬁrst principal component direction of the data. We
can see by eye that this is the direction along which there is the greatest
variability in the data. That is, if we projected the 100 observations onto
this line (as shown in the left-hand panel of Figure 6.15), then the resulting
projected observations would have the largest possible variance; projecting
the observations onto any other line would yield projected observations
with lower variance. Projecting a point onto a line simply involves ﬁnding
the location on the line which is closest to the point.

The ﬁrst principal component is displayed graphically in Figure 6.14, but

how can it be summarized mathematically? It is given by the formula

Z1 = 0.839 × (pop − pop) + 0.544 × (ad − ad).

(6.19)

Here φ11 = 0.839 and φ21 = 0.544 are the principal component loadings,
which deﬁne the direction referred to above. In (6.19), pop indicates the
mean of all pop values in this data set, and ad indicates the mean of all ad-
vertising spending. The idea is that out of every possible linear combination
of pop and ad such that φ2
21 = 1, this particular linear combination
yields the highest variance: i.e. this is the linear combination for which
Var(φ11 × (pop − pop) + φ21 × (ad − ad)) is maximized. It is necessary to
consider only linear combinations of the form φ2
21 = 1, since otherwise
we could increase φ11 and φ21 arbitrarily in order to blow up the variance.
In (6.19), the two loadings are both positive and have similar size, and so
Z1 is almost an average of the two variables.

11 + φ2

11 +φ2

Since n = 100, pop and ad are vectors of length 100, and so is Z1 in

(6.19). For instance,

zi1 = 0.839 × (popi − pop) + 0.544 × (adi − ad).

(6.20)

The values of z11, . . . , zn1 are known as the principal component scores, and
can be seen in the right-hand panel of Figure 6.15.

There is also another interpretation for PCA: the ﬁrst principal compo-
nent vector deﬁnes the line that is as close as possible to the data. For
instance, in Figure 6.14, the ﬁrst principal component line minimizes the
sum of the squared perpendicular distances between each point and the
line. These distances are plotted as dashed line segments in the left-hand
panel of Figure 6.15, in which the crosses represent the projection of each
point onto the ﬁrst principal component line. The ﬁrst principal component
has been chosen so that the projected observations are as close as possible
to the original observations.

232

6. Linear Model Selection and Regularization

i

g
n
d
n
e
p
S
d
A

 

0
3

5
2

0
2

5
1

0
1

5

t

n
e
n
o
p
m
o
C

 
l

i

a
p
c
n
i
r

 

P
d
n
2

0
1

5

0

5
−

0
1
−

20

30

40

50

−20

−10

0

10

20

Population

1st Principal Component

FIGURE 6.15. A subset of the advertising data. The mean pop and ad budgets
are indicated with a blue circle. Left: The ﬁrst principal component direction is
shown in green. It is the dimension along which the data vary the most, and it also
deﬁnes the line that is closest to all n of the observations. The distances from each
observation to the principal component are represented using the black dashed line
segments. The blue dot represents (pop, ad). Right: The left-hand panel has been
rotated so that the ﬁrst principal component direction coincides with the x-axis.

In the right-hand panel of Figure 6.15, the left-hand panel has been
rotated so that the ﬁrst principal component direction coincides with the
x-axis. It is possible to show that the ﬁrst principal component score for
the ith observation, given in (6.20), is the distance in the x-direction of the
ith cross from zero. So for example, the point in the bottom-left corner of
the left-hand panel of Figure 6.15 has a large negative principal component

score, zi1 = −26.1, while the point in the top-right corner has a large
positive score, zi1 = 18.7. These scores can be computed directly using
(6.20).

We can think of the values of the principal component Z1 as single-
number summaries of the joint pop and ad budgets for each location. In
this example, if zi1 = 0.839 × (popi − pop) + 0.544 × (adi − ad) < 0,

then this indicates a city with below-average population size and below-
average ad spending. A positive score suggests the opposite. How well can a
single number represent both pop and ad? In this case, Figure 6.14 indicates
that pop and ad have approximately a linear relationship, and so we might
expect that a single-number summary will work well. Figure 6.16 displays
zi1 versus both pop and ad. The plots show a strong relationship between
the ﬁrst principal component and the two features. In other words, the ﬁrst
principal component appears to capture most of the information contained
in the pop and ad predictors.

4

So far we have concentrated on the ﬁrst principal component. In gen-
eral, one can construct up to p distinct principal components. The second
principal component Z2 is a linear combination of the variables that is un-
correlated with Z1, and has largest variance subject to this constraint. The
second principal component direction is illustrated as a dashed blue line in
Figure 6.14. It turns out that the zero correlation condition of Z1 with Z2

4The principal components were calculated after first standardizing both pop and ad,
a common approach. Hence, the x-axes on Figures 6.15 and 6.16 are not on the same scale.

6.3 Dimension Reduction Methods

233

0
6

0
5

0
4

0
3

0
2

n
o

i
t

l

a
u
p
o
P

i

g
n
d
n
e
p
S
d
A

 

0
3

5
2

0
2

5
1

0
1

5

−3

−2

−1

0

1

2

3

−3

−2

−1

0

1

2

3

1st Principal Component

1st Principal Component

FIGURE 6.16. Plots of the ﬁrst principal component scores zi1 versus pop and
ad. The relationships are strong.

is equivalent to the condition that the direction must be perpendicular, or
orthogonal, to the ﬁrst principal component direction. The second principal
component is given by the formula

Z2 = 0.544 × (pop − pop) − 0.839 × (ad − ad).

perpendicular

orthogonal

Since the advertising data has two predictors, the ﬁrst two principal com-
ponents contain all of the information that is in pop and ad. However, by
construction, the ﬁrst component will contain the most information. Con-
sider, for example, the much larger variability of zi1 (the x-axis) versus
zi2 (the y-axis) in the right-hand panel of Figure 6.15. The fact that the
second principal component scores are much closer to zero indicates that
this component captures far less information. As another illustration, Fig-
ure 6.17 displays zi2 versus pop and ad. There is little relationship between
the second principal component and these two predictors, again suggesting
that in this case, one only needs the ﬁrst principal component in order to
accurately represent the pop and ad budgets.

With two-dimensional data, such as in our advertising example, we can
construct at most two principal components. However, if we had other
predictors, such as population age, income level, education, and so forth,
then additional components could be constructed. They would successively
maximize variance, subject to the constraint of being uncorrelated with the
preceding components.

The Principal Components Regression Approach

the predictors

The principal components regression (PCR) approach involves constructing
the ﬁrst M principal components, Z1, . . . , ZM , and then using these compo-
nents as
is ﬁt
using least squares. The key idea is that often a small number of prin-
cipal components suﬃce to explain most of the variability in the data, as
well as the relationship with the response. In other words, we assume that
the directions in which X1, . . . , Xp show the most variation are the direc-
tions that are associated with Y . While this assumption is not guaranteed

regression model

in a linear

that

principal
components
regression

234

6. Linear Model Selection and Regularization

0
6

0
5

0
4

0
3

0
2

n
o

i
t

l

a
u
p
o
P

i

g
n
d
n
e
p
S
d
A

 

0
3

5
2

0
2

5
1

0
1

5

−1.0

−0.5

0.0

0.5

1.0

−1.0

−0.5

0.0

0.5

1.0

2nd Principal Component

2nd Principal Component

FIGURE 6.17. Plots of the second principal component scores zi2 versus pop
and ad. The relationships are weak.

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
7

0
6

0
5

0
4

0
3

0
2

0
1

0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

Squared Bias
Test MSE
Variance

0
5
1

0
0
1

0
5

0

0

10

20

30

40

0

10

20

30

40

Number of Components

Number of Components

FIGURE 6.18. PCR was applied to two simulated data sets. Left: Simulated
data from Figure 6.8. Right: Simulated data from Figure 6.9.

to be true, it often turns out to be a reasonable enough approximation to
give good results.

If the assumption underlying PCR holds, then ﬁtting a least squares
model to Z1, . . . , ZM will lead to better results than ﬁtting a least squares
model to X1, . . . , Xp, since most or all of the information in the data that
relates to the response is contained in Z1, . . . , ZM , and by estimating only
M (cid:15) p coeﬃcients we can mitigate overﬁtting. In the advertising data, the
ﬁrst principal component explains most of the variance in both pop and ad,
so a principal component regression that uses this single variable to predict
some response of interest, such as sales, will likely perform quite well.

Figure 6.18 displays the PCR ﬁts on the simulated data sets from
Figures 6.8 and 6.9. Recall that both data sets were generated using n = 50
observations and p = 45 predictors. However, while the response in the ﬁrst
data set was a function of all the predictors, the response in the second data
set was generated using only two of the predictors. The curves are plotted
as a function of M , the number of principal components used as predic-
tors in the regression model. As more principal components are used in

6.3 Dimension Reduction Methods

235

PCR

Ridge Regression and Lasso

Squared Bias
Test MSE
Variance

0
7

0
6

0
5

0
4

0
3

0
2

0
1

0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
7

0
6

0
5

0
4

0
3

0
2

0
1

0

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0

10

20

30

40

0.0

0.2

0.4

0.6

0.8

1.0

Number of Components

Shrinkage Factor

FIGURE 6.19. PCR, ridge regression, and the lasso were applied to a simulated
data set in which the ﬁrst ﬁve principal components of X contain all the informa-
tion about the response Y . In each panel, the irreducible error Var() is shown as
a horizontal dashed line. Left: Results for PCR. Right: Results for lasso (solid)
and ridge regression (dotted). The x-axis displays the shrinkage factor of the co-
eﬃcient estimates, deﬁned as the (cid:7)2 norm of the shrunken coeﬃcient estimates
divided by the (cid:7)2 norm of the least squares estimate.

the regression model, the bias decreases, but the variance increases. This
results in a typical U-shape for the mean squared error. When M = p = 45,
then PCR amounts simply to a least squares ﬁt using all of the original
predictors. The ﬁgure indicates that performing PCR with an appropriate
choice of M can result in a substantial improvement over least squares, es-
pecially in the left-hand panel. However, by examining the ridge regression
and lasso results in Figures 6.5, 6.8, and 6.9, we see that PCR does not
perform as well as the two shrinkage methods in this example.

The relatively worse performance of PCR in Figure 6.18 is a consequence
of the fact that the data were generated in such a way that many princi-
pal components are required in order to adequately model the response.
In contrast, PCR will tend to do well in cases when the ﬁrst few principal
components are suﬃcient to capture most of the variation in the predictors
as well as the relationship with the response. The left-hand panel of Fig-
ure 6.19 illustrates the results from another simulated data set designed to
be more favorable to PCR. Here the response was generated in such a way
that it depends exclusively on the ﬁrst ﬁve principal components. Now the
bias drops to zero rapidly as M , the number of principal components used
in PCR, increases. The mean squared error displays a clear minimum at
M = 5. The right-hand panel of Figure 6.19 displays the results on these
data using ridge regression and the lasso. All three methods oﬀer a signif-
icant improvement over least squares. However, PCR and ridge regression
slightly outperform the lasso.

We note that even though PCR provides a simple way to perform
regression using M < p predictors, it is not a feature selection method.
This is because each of the M principal components used in the regression

236

6. Linear Model Selection and Regularization

s
t

i

n
e
c
i
f
f

 

i

e
o
C
d
e
z
d
r
a
d
n
a
S

t

Income
Limit
Rating
Student

0
0
4

0
0
3

0
0
2

0
0
1

0

0
0
1
−

0
0
3
−

E
S
M
n
o

 

i
t

a
d

i
l

a
V
−
s
s
o
r
C

0
0
0
0
8

0
0
0
0
6

0
0
0
0
4

0
0
0
0
2

2

4

6

8

10

2

4

6

8

10

Number of Components

Number of Components

FIGURE 6.20. Left: PCR standardized coeﬃcient estimates on the Credit data
set for diﬀerent values of M . Right: The ten-fold cross validation MSE obtained
using PCR, as a function of M .

is a linear combination of all p of the original features. For instance, in
(6.19), Z1 was a linear combination of both pop and ad. Therefore, while
PCR often performs quite well in many practical settings, it does not result
in the development of a model that relies upon a small set of the original
features. In this sense, PCR is more closely related to ridge regression than
to the lasso. In fact, one can show that PCR and ridge regression are very
closely related. One can even think of ridge regression as a continuous ver-
5
sion of PCR!

In PCR, the number of principal components, M , is typically chosen by
cross-validation. The results of applying PCR to the Credit data set are
shown in Figure 6.20; the right-hand panel displays the cross-validation
errors obtained, as a function of M . On these data, the lowest cross-
validation error occurs when there are M = 10 components; this corre-
sponds to almost no dimension reduction at all, since PCR with M = 11
is equivalent to simply performing least squares.

When performing PCR, we generally recommend standardizing each
predictor, using (6.6), prior to generating the principal components. This
standardization ensures that all variables are on the same scale. In the
absence of standardization, the high-variance variables will tend to play a
larger role in the principal components obtained, and the scale on which
the variables are measured will ultimately have an eﬀect on the ﬁnal PCR
model. However, if the variables are all measured in the same units (say,
kilograms, or inches), then one might choose not to standardize them.

5

More details can be found in Section 3.5 of Elements of Statistical Learning by

Hastie, Tibshirani, and Friedman.

6.3 Dimension Reduction Methods

237

i

g
n
d
n
e
p
S
 
d
A

0
3

5
2

0
2

5
1

0
1

5

20

30

40

50

60

Population

FIGURE 6.21. For the advertising data, the ﬁrst PLS direction (solid line) and
ﬁrst PCR direction (dotted line) are shown.

6.3.2 Partial Least Squares

The PCR approach that we just described involves identifying linear combi-
nations, or directions, that best represent the predictors X1, . . . , Xp. These
directions are identiﬁed in an unsupervised way, since the response Y is not
used to help determine the principal component directions. That is, the
response does not supervise the identiﬁcation of the principal components.
Consequently, PCR suﬀers from a drawback: there is no guarantee that the
directions that best explain the predictors will also be the best directions
to use for predicting the response. Unsupervised methods are discussed
further in Chapter 10.

We now present partial least squares (PLS), a supervised alternative to
PCR. Like PCR, PLS is a dimension reduction method, which ﬁrst identiﬁes
a new set of features Z1, . . . , ZM that are linear combinations of the original
features, and then ﬁts a linear model via least squares using these M new
features. But unlike PCR, PLS identiﬁes these new features in a supervised
way—that is, it makes use of the response Y in order to identify new
features that not only approximate the old features well, but also that are
related to the response. Roughly speaking, the PLS approach attempts to
ﬁnd directions that help explain both the response and the predictors.

We now describe how the ﬁrst PLS direction is computed. After stan-
dardizing the p predictors, PLS computes the ﬁrst direction Z1 by setting
each φj1 in (6.16) equal to the coeﬃcient from the simple linear regression
of Y onto Xj. One can show that this coeﬃcient is proportional to the cor-
p
relation between Y and Xj. Hence, in computing Z1 =
j=1 φj1Xj, PLS
places the highest weight on the variables that are most strongly related
to the response.

(cid:10)

partial least
squares

Figure 6.21 displays an example of PLS on

set with Sales in
each of 100 regions as the response, and two predictors; Population Size
and Advertising Spending. The solid green line indicates the ﬁrst PLS
direction, while the dotted line shows the ﬁrst principal component direction.
ad dimension per unit
PLS has chosen a direction that has less change in the

6

a synthetic

data

6This dataset is distinct from the Advertising data discussed in Chapter 3.

238

6. Linear Model Selection and Regularization

pop is
ad. The PLS direction
not fit the predictors as closely as does PCA, but it does a better job

change in the pop dimension, relative to PCA. This suggests that
more highly correlated with the response than is
does
explaining the response.

To identify the second PLS direction we ﬁrst adjust each of the variables
for Z1, by regressing each variable on Z1 and taking residuals. These resid-
uals can be interpreted as the remaining information that has not been
explained by the ﬁrst PLS direction. We then compute Z2 using this or-
thogonalized data in exactly the same fashion as Z1 was computed based
on the original data. This iterative approach can be repeated M times to
identify multiple PLS components Z1, . . . , ZM . Finally, at the end of this
procedure, we use least squares to ﬁt a linear model to predict Y using
Z1, . . . , ZM in exactly the same fashion as for PCR.

As with PCR, the number M of partial least squares directions used in
PLS is a tuning parameter that is typically chosen by cross-validation. We
generally standardize the predictors and response before performing PLS.
PLS is popular in the ﬁeld of chemometrics, where many variables arise
from digitized spectrometry signals. In practice it often performs no better
than ridge regression or PCR. While the supervised dimension reduction
of PLS can reduce bias, it also has the potential to increase variance, so
that the overall beneﬁt of PLS relative to PCR is a wash.

6.4 Considerations in High Dimensions

6.4.1 High-Dimensional Data

Most traditional statistical techniques for regression and classiﬁcation are
intended for the low-dimensional setting in which n, the number of ob-
servations, is much greater than p, the number of features. This is due in
part to the fact that throughout most of the ﬁeld’s history, the bulk of sci-
entiﬁc problems requiring the use of statistics have been low-dimensional.
For instance, consider the task of developing a model to predict a patient’s
blood pressure on the basis of his or her age, gender, and body mass index
(BMI). There are three predictors, or four if an intercept is included in
the model, and perhaps several thousand patients for whom blood pressure
and age, gender, and BMI are available. Hence n (cid:10) p, and so the problem
is low-dimensional. (By dimension here we are referring to the size of p.)

In the past 20 years, new technologies have changed the way that data
are collected in ﬁelds as diverse as ﬁnance, marketing, and medicine. It is
now commonplace to collect an almost unlimited number of feature mea-
surements (p very large). While p can be extremely large, the number of
observations n is often limited due to cost, sample availability, or other
considerations. Two examples are as follows:

1. Rather than predicting blood pressure on the basis of just age, gen-
der, and BMI, one might also collect measurements for half a million

low-
dimensional

high-
dimensional

6.4 Considerations in High Dimensions

239

single nucleotide polymorphisms (SNPs; these are individual DNA
mutations that are relatively common in the population) for inclu-
sion in the predictive model. Then n ≈ 200 and p ≈ 500,000.

2. A marketing analyst interested in understanding people’s online shop-
ping patterns could treat as features all of the search terms entered
by users of a search engine. This is sometimes known as the “bag-of-
words” model. The same researcher might have access to the search
histories of only a few hundred or a few thousand search engine users
who have consented to share their information with the researcher.
For a given user, each of the p search terms is scored present (0) or
absent (1), creating a large binary feature vector. Then n ≈ 1,000
and p is much larger.

Data sets containing more features than observations are often referred
to as high-dimensional. Classical approaches such as least squares linear
regression are not appropriate in this setting. Many of the issues that arise
in the analysis of high-dimensional data were discussed earlier in this book,
since they apply also when n > p: these include the role of the bias-variance
trade-oﬀ and the danger of overﬁtting. Though these issues are always rele-
vant, they can become particularly important when the number of features
is very large relative to the number of observations.

We have deﬁned the high-dimensional setting as the case where the num-
ber of features p is larger than the number of observations n. But the con-
siderations that we will now discuss certainly also apply if p is slightly
smaller than n, and are best always kept in mind when performing super-
vised learning.

6.4.2 What Goes Wrong in High Dimensions?

In order to illustrate the need for extra care and specialized techniques
for regression and classiﬁcation when p > n, we begin by examining what
can go wrong if we apply a statistical technique not intended for the high-
dimensional setting. For this purpose, we examine least squares regression.
But the same concepts apply to logistic regression, linear discriminant anal-
ysis, and other classical statistical approaches.

When the number of features p is as large as, or larger than, the number
of observations n, least squares as described in Chapter 3 cannot (or rather,
should not ) be performed. The reason is simple: regardless of whether or
not there truly is a relationship between the features and the response,
least squares will yield a set of coeﬃcient estimates that result in a perfect
ﬁt to the data, such that the residuals are zero.

An example is shown in Figure 6.22 with p = 1 feature (plus an intercept)
in two cases: when there are 20 observations, and when there are only
two observations. When there are 20 observations, n > p and the least

240

6. Linear Model Selection and Regularization

0
1

5

0
1

5

Y

0

Y

0

5
−

0
1
−

5
−

0
1
−

−1.5 −1.0 −0.5

0.0

0.5

1.0

−1.5 −1.0 −0.5

0.0

0.5

1.0

X

X

FIGURE 6.22. Left: Least squares regression in the low-dimensional setting.
Right: Least squares regression with n = 2 observations and two parameters to be
estimated (an intercept and a coeﬃcient).

squares regression line does not perfectly ﬁt the data; instead, the regression
line seeks to approximate the 20 observations as well as possible. On the
other hand, when there are only two observations, then regardless of the
values of those observations, the regression line will ﬁt the data exactly.
This is problematic because this perfect ﬁt will almost certainly lead to
overﬁtting of the data. In other words, though it is possible to perfectly ﬁt
the training data in the high-dimensional setting, the resulting linear model
will perform extremely poorly on an independent test set, and therefore
does not constitute a useful model. In fact, we can see that this happened
in Figure 6.22: the least squares line obtained in the right-hand panel will
perform very poorly on a test set comprised of the observations in the left-
hand panel. The problem is simple: when p > n or p ≈ n, a simple least
squares regression line is too ﬂexible and hence overﬁts the data.

Figure 6.23 further illustrates the risk of carelessly applying least squares
when the number of features p is large. Data were simulated with n = 20
observations, and regression was performed with between 1 and 20 features,
each of which was completely unrelated to the response. As shown in the
ﬁgure, the model R2 increases to 1 as the number of features included in the
model increases, and correspondingly the training set MSE decreases to 0
as the number of features increases, even though the features are completely
unrelated to the response. On the other hand, the MSE on an independent
test set becomes extremely large as the number of features included in the
model increases, because including the additional predictors leads to a vast
increase in the variance of the coeﬃcient estimates. Looking at the test
set MSE, it is clear that the best model contains at most a few variables.
However, someone who carelessly examines only the R2 or the training set
MSE might erroneously conclude that the model with the greatest number
of variables is best. This indicates the importance of applying extra care

0
1

.

8
0

.

6
0

.

4
0

.

2
0

.

2
R

6.4 Considerations in High Dimensions

241

8

.

0

6
0

.

4
0

.

2

.

0

0
0

.

E
S
M

 
t
s
e
T

0
0
5

0
5

5

1

 

E
S
M
g
n
n
a
r
T

i

i

5

10

15

Number of Variables

5

10

15

Number of Variables

5

10

15

Number of Variables

FIGURE 6.23. On a simulated example with n = 20 training observations,
features that are completely unrelated to the outcome are added to the model.
Left: The R2 increases to 1 as more features are included. Center: The training
set MSE decreases to 0 as more features are included. Right: The test set MSE
increases as more features are included.

when analyzing data sets with a large number of variables, and of always
evaluating model performance on an independent test set.

In Section 6.1.3, we saw a number of approaches for adjusting the training
set RSS or R2 in order to account for the number of variables used to ﬁt
a least squares model. Unfortunately, the Cp, AIC, and BIC approaches
are not appropriate in the high-dimensional setting, because estimating ˆσ2
is problematic. (For instance, the formula for ˆσ2 from Chapter 3 yields an
estimate ˆσ2 = 0 in this setting.) Similarly, problems arise in the application
of adjusted R2 in the high-dimensional setting, since one can easily obtain
a model with an adjusted R2 value of 1. Clearly, alternative approaches
that are better-suited to the high-dimensional setting are required.

6.4.3 Regression in High Dimensions

It turns out that many of the methods seen in this chapter for ﬁtting
less ﬂexible least squares models, such as forward stepwise selection, ridge
regression, the lasso, and principal components regression, are particularly
useful for performing regression in the high-dimensional setting. Essentially,
these approaches avoid overﬁtting by using a less ﬂexible ﬁtting approach
than least squares.

Figure 6.24 illustrates the performance of the lasso in a simple simulated
example. There are p = 20, 50, or 2,000 features, of which 20 are truly
associated with the outcome. The lasso was performed on n = 100 training
observations, and the mean squared error was evaluated on an independent
test set. As the number of features increases, the test set error increases.
When p = 20, the lowest validation set error was achieved when λ in
(6.7) was small; however, when p was larger then the lowest validation
set error was achieved using a larger value of λ. In each boxplot, rather
than reporting the values of λ used, the degrees of freedom of the resulting

242

6. Linear Model Selection and Regularization

p = 20

p = 50

p = 2000

5

4

3

2

1

0

5

4

3

2

1

0

5

4

3

2

1

0

16

1
21
Degrees of Freedom

28

1
51
Degrees of Freedom

70

1
111
Degrees of Freedom

FIGURE 6.24. The lasso was performed with n = 100 observations and three
values of p, the number of features. Of the p features, 20 were associated with
the response. The boxplots show the test MSEs that result using three diﬀerent
values of the tuning parameter λ in (6.7). For ease of interpretation, rather than
reporting λ, the degrees of freedom are reported; for the lasso this turns out
to be simply the number of estimated non-zero coeﬃcients. When p = 20, the
lowest test MSE was obtained with the smallest amount of regularization. When
p = 50, the lowest test MSE was achieved when there is a substantial amount
of regularization. When p = 2,000 the lasso performed poorly regardless of the
amount of regularization, due to the fact that only 20 of the 2,000 features truly
are associated with the outcome.

lasso solution is displayed; this is simply the number of non-zero coeﬃcient
estimates in the lasso solution, and is a measure of the ﬂexibility of the
lasso ﬁt. Figure 6.24 highlights three important points: (1) regularization
or shrinkage plays a key role in high-dimensional problems, (2) appropriate
tuning parameter selection is crucial for good predictive performance, and
(3) the test error tends to increase as the dimensionality of the problem
(i.e. the number of features or predictors) increases, unless the additional
features are truly associated with the response.

The third point above is in fact a key principle in the analysis of high-
dimensional data, which is known as the curse of dimensionality. One might
think that as the number of features used to ﬁt a model increases, the
quality of the ﬁtted model will increase as well. However, comparing the
left-hand and right-hand panels in Figure 6.24, we see that this is not
necessarily the case: in this example, the test set MSE almost doubles as
p increases from 20 to 2,000. In general, adding additional signal features
that are truly associated with the response will improve the ﬁtted model,
in the sense of leading to a reduction in test set error. However, adding
noise features that are not truly associated with the response will lead
to a deterioration in the ﬁtted model, and consequently an increased test
set error. This is because noise features increase the dimensionality of the

curse of di-
mensionality

6.4 Considerations in High Dimensions

243

problem, exacerbating the risk of overﬁtting (since noise features may be
assigned nonzero coeﬃcients due to chance associations with the response
on the training set) without any potential upside in terms of improved test
set error. Thus, we see that new technologies that allow for the collection
of measurements for thousands or millions of features are a double-edged
sword: they can lead to improved predictive models if these features are in
fact relevant to the problem at hand, but will lead to worse results if the
features are not relevant. Even if they are relevant, the variance incurred
in ﬁtting their coeﬃcients may outweigh the reduction in bias that they
bring.

6.4.4 Interpreting Results in High Dimensions

When we perform the lasso, ridge regression, or other regression proce-
dures in the high-dimensional setting, we must be quite cautious in the way
that we report the results obtained. In Chapter 3, we learned about multi-
collinearity, the concept that the variables in a regression might be corre-
lated with each other. In the high-dimensional setting, the multicollinearity
problem is extreme: any variable in the model can be written as a linear
combination of all of the other variables in the model. Essentially, this
means that we can never know exactly which variables (if any) truly are
predictive of the outcome, and we can never identify the best coeﬃcients
for use in the regression. At most, we can hope to assign large regression
coeﬃcients to variables that are correlated with the variables that truly are
predictive of the outcome.

For instance, suppose that we are trying to predict blood pressure on the
basis of half a million SNPs, and that forward stepwise selection indicates
that 17 of those SNPs lead to a good predictive model on the training data.
It would be incorrect to conclude that these 17 SNPs predict blood pressure
more eﬀectively than the other SNPs not included in the model. There are
likely to be many sets of 17 SNPs that would predict blood pressure just
as well as the selected model. If we were to obtain an independent data set
and perform forward stepwise selection on that data set, we would likely
obtain a model containing a diﬀerent, and perhaps even non-overlapping,
set of SNPs. This does not detract from the value of the model obtained—
for instance, the model might turn out to be very eﬀective in predicting
blood pressure on an independent set of patients, and might be clinically
useful for physicians. But we must be careful not to overstate the results
obtained, and to make it clear that what we have identiﬁed is simply one
of many possible models for predicting blood pressure, and that it must be
further validated on independent data sets.

It is also important to be particularly careful in reporting errors and
measures of model ﬁt in the high-dimensional setting. We have seen that
when p > n, it is easy to obtain a useless model that has zero residu-
als. Therefore, one should never use sum of squared errors, p-values, R2

244

6. Linear Model Selection and Regularization

statistics, or other traditional measures of model ﬁt on the training data as
evidence of a good model ﬁt in the high-dimensional setting. For instance,
as we saw in Figure 6.23, one can easily obtain a model with R2 = 1 when
p > n. Reporting this fact might mislead others into thinking that a sta-
tistically valid and useful model has been obtained, whereas in fact this
provides absolutely no evidence of a compelling model. It is important to
instead report results on an independent test set, or cross-validation errors.
For instance, the MSE or R2 on an independent test set is a valid measure
of model ﬁt, but the MSE on the training set certainly is not.

6.5 Lab 1: Subset Selection Methods

6.5.1 Best Subset Selection

Here we apply the best subset selection approach to the Hitters data. We
wish to predict a baseball player’s Salary on the basis of various statistics
associated with performance in the previous year.

First of all, we note that the Salary variable is missing for some of the
players. The is.na() function can be used to identify the missing observa-
tions. It returns a vector of the same length as the input vector, with a TRUE
for any elements that are missing, and a FALSE for non-missing elements.
The sum() function can then be used to count all of the missing elements.

is.na()

sum()

> library ( ISLR )
> fix ( Hitters )
> names ( Hitters )

" Hits "
" Years "
" CRBI "
" Assists "

[1] " AtBat "
[6] " Walks "
[11] " CRuns "
[16] " PutOuts "
> dim ( Hitters )
[1] 322
> sum ( is . na ( H i t t e r s $ S a l a r y ) )
[1] 59

20

" HmRun "
" CAtBat "
" CWalks "
" Errors "

" Runs "
" CHits "
" League "
" Salary "

" RBI "
" CHmRun "
" Division "
" NewLeague "

Hence we see that Salary is missing for 59 players. The na.omit() function
removes all of the rows that have missing values in any variable.

> Hitters = na . omit ( Hitters )
> dim ( Hitters )
[1] 263
> sum ( is . na ( Hitters ) )
[1] 0

20

The regsubsets() function (part of the leaps library) performs best sub-
set selection by identifying the best model that contains a given number
of predictors, where best is quantiﬁed using RSS. The syntax is the same
as for lm(). The summary() command outputs the best set of variables for
each model size.

regsubsets()

6.5 Lab 1: Subset Selection Methods

245

> library ( leaps )

> regfit . full = regsubset s ( Salary∼. , Hitters )

> summary ( regfit . full )
Subset selection object

Call : regsubsets . formula ( Salary ∼ . , Hitters )

( and intercept )

19 Variables
...
1 subsets of each size up to 8
Selection Algorithm : exhaustive

AtBat Hits HmRun Runs RBI Walks Years CAtBat CHits

( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) "*"
( 1 ) "*"
( 1 ) " "
( 1 ) "*"

" "
"*"
"*"
"*"
"*"
"*"
"*"
"*"

" "
" "
" "
" "
" "
" "
" "
" "

" "
" "
" "
" "
" "
" "
" "
" "

" " " "
" " " "
" " " "
" " " "
" " " "
" " "*"
" " "*"
" " "*"

" "
" "
" "
" "
" "
" "
" "
" "

" "
" "
" "
" "
" "
" "
"*"
" "

" "
" "
" "
" "
" "
" "
"*"
" "

CHmRun CRuns CRBI CWalks LeagueN DivisionW PutOuts

( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) "*"
( 1 ) "*"

" "
" "
" "
" "
" "
" "
" "
"*"

"*"
"*"
"*"
"*"
"*"
"*"
" "
" "

" "
" "
" "
" "
" "
" "
" "
"*"

" "
" "
" "
" "
" "
" "
" "
" "

Assists Errors NewLeagueN

" "
" "
" "
"*"
"*"
"*"
"*"
"*"

" "
" "
"*"
"*"
"*"
"*"
"*"
"*"

( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "
( 1 ) " "

" "
" "
" "
" "
" "
" "
" "
" "

" "
" "
" "
" "
" "
" "
" "
" "

1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8

1
2
3
4
5
6
7
8

An asterisk indicates that a given variable is included in the corresponding
model. For instance, this output indicates that the best two-variable model
contains only Hits and CRBI. By default, regsubsets() only reports results
up to the best eight-variable model. But the nvmax option can be used
in order to return as many variables as are desired. Here we ﬁt up to a
19-variable model.
> regfit . full = regsubset s ( Salary∼. , data = Hitters , nvmax =19)

> reg . summary = summary ( regfit . full )

The summary() function also returns R2, RSS, adjusted R2, Cp, and BIC.

We can examine these to try to select the best overall model.

> names ( reg . summary )
[1] " which "
" rsq "
[7] " outmat " " obj "

" rss "

" adjr2 "

" cp "

" bic "

246

6. Linear Model Selection and Regularization

For instance, we see that the R2 statistic increases from 32 %, when only
one variable is included in the model, to almost 55 %, when all variables
are included. As expected, the R2 statistic increases monotonically as more
variables are included.

> reg . summary$r sq

[1] 0.321 0.425 0.451 0.475 0.491 0.509 0.514 0.529 0.535
[10] 0.540 0.543 0.544 0.544 0.545 0.545 0.546 0.546 0.546
[19] 0.546

Plotting RSS, adjusted R2, Cp, and BIC for all of the models at once will
help us decide which model to select. Note the type="l" option tells R to
connect the plotted points with lines.

> par ( mfrow = c (2 ,2) )
> plot ( reg . summary$rss , xlab =" Number of Variables " , ylab =" RSS " ,

type =" l ")

> plot ( reg . summary$adjr2 , xlab =" Number of Variables " ,

ylab =" Adjusted RSq " , type =" l ")

The points() command works like the plot() command, except that it
puts points on a plot that has already been created, instead of creating a
new plot. The which.max() function can be used to identify the location of
the maximum point of a vector. We will now plot a red dot to indicate the
model with the largest adjusted R2 statistic.

points()

> which . max ( reg . s u m m a r y $ a d j r 2 )
[1] 11
> points (11 , reg . s u m m a r y $ a d j r 2 [11] , col =" red " , cex =2 , pch =20)

In a similar fashion we can plot the Cp and BIC statistics, and indicate the
models with the smallest statistic using which.min().

which.min()

> plot ( reg . summary$cp , xlab =" Number of Variables " , ylab =" Cp " ,

type = ’ l ’)

> which . min ( reg . summary$cp )
[1] 10
> points (10 , reg . summary$cp [10] , col =" red " , cex =2 , pch =20)
> which . min ( reg . summary$b i c )
[1] 6
> plot ( reg . summary$bic , xlab =" Number of Variables " , ylab =" BIC " ,

type = ’ l ’)

> points (6 , reg . summary$b ic [6] , col =" red " , cex =2 , pch =20)

The regsubsets() function has a built-in plot() command which can
be used to display the selected variables for the best model with a given
number of predictors, ranked according to the BIC, Cp, adjusted R2, or
AIC. To ﬁnd out more about this function, type ?plot.regsubsets.

> plot ( regfit . full , scale =" r2 ")
> plot ( regfit . full , scale =" adjr2 ")
> plot ( regfit . full , scale =" Cp ")
> plot ( regfit . full , scale =" bic ")

6.5 Lab 1: Subset Selection Methods

247

The top row of each plot contains a black square for each variable selected
according to the optimal model associated with that statistic. For instance,
we see that several models share a BIC close to −150. However, the model
with the lowest BIC is the six-variable model that contains only AtBat,
Hits, Walks, CRBI, DivisionW, and PutOuts. We can use the coef() function
to see the coeﬃcient estimates associated with this model.

> coef ( regfit . full ,6)
( Intercept )
91.512
DivisionW
-122.952

AtBat
-1.869
PutOuts
0.264

Hits
7.604

Walks
3.698

CRBI
0.643

6.5.2 Forward and Backward Stepwise Selection

We can also use the regsubsets() function to perform forward stepwise
or backward stepwise selection, using the argument method="forward" or
method="backward".
> regfit . fwd = regsubsets ( Salary∼. , data = Hitters , nvmax =19 ,

method =" forward ")
> summary ( regfit . fwd )

> regfit . bwd = regsubsets ( Salary∼. , data = Hitters , nvmax =19 ,

method =" backward ")

> summary ( regfit . bwd )

For instance, we see that using forward stepwise selection, the best one-
variable model contains only CRBI, and the best two-variable model ad-
ditionally includes Hits. For this data, the best one-variable through six-
variable models are each identical for best subset and forward selection.
However, the best seven-variable models identiﬁed by forward stepwise se-
lection, backward stepwise selection, and best subset selection are diﬀerent.

> coef ( regfit . full ,7)
( Intercept )
79.451
CHmRun
1.442

Hits
1.283
DivisionW
-129.987

> coef ( regfit . fwd ,7)
( Intercept )
109.787
CWalks
-0.305

AtBat
-1.959
DivisionW
-127.122

> coef ( regfit . bwd ,7)
( Intercept )
105.649
CWalks
-0.716

AtBat
-1.976
DivisionW
-116.169

Walks
3.227
PutOuts
0.237

Hits
7.450
PutOuts
0.253

Hits
6.757
PutOuts
0.303

CAtBat
-0.375

CHits
1.496

Walks
4.913

CRBI
0.854

Walks
6.056

CRuns
1.129

248

6. Linear Model Selection and Regularization

6.5.3 Choosing Among Models Using the Validation Set

Approach and Cross-Validation

We just saw that it is possible to choose among a set of models of diﬀerent
sizes using Cp, BIC, and adjusted R2. We will now consider how to do this
using the validation set and cross-validation approaches.

In order for these approaches to yield accurate estimates of the test
error, we must use only the training observations to perform all aspects of
model-ﬁtting—including variable selection. Therefore, the determination of
which model of a given size is best must be made using only the training
observations. This point is subtle but important. If the full data set is used
to perform the best subset selection step, the validation set errors and
cross-validation errors that we obtain will not be accurate estimates of the
test error.

In order to use the validation set approach, we begin by splitting the
observations into a training set and a test set. We do this by creating
a random vector, train, of elements equal to TRUE if the corresponding
observation is in the training set, and FALSE otherwise. The vector test has
a TRUE if the observation is in the test set, and a FALSE otherwise. Note the
! in the command to create test causes TRUEs to be switched to FALSEs and
vice versa. We also set a random seed so that the user will obtain the same
training set/test set split.

> set . seed (1)
> train = sample ( c ( TRUE , FALSE ) , nrow ( Hitters ) , rep = TRUE )
> test =(! train )

Now, we apply regsubsets() to the training set in order to perform best
subset selection.
> regfit . best = regsubset s ( Salary∼. , data = Hitters [ train ,] ,

nvmax =19)

Notice that we subset the Hitters data frame directly in the call in or-
der to access only the training subset of the data, using the expression
Hitters[train,]. We now compute the validation set error for the best
model of each model size. We ﬁrst make a model matrix from the test
data.

test . mat = model . matrix ( Salary∼. , data = Hitters [ test ,])

The model.matrix() function is used in many regression packages for build-
ing an “X” matrix from data. Now we run a loop, and for each size i, we
extract the coeﬃcients from regfit.best for the best model of that size,
multiply them into the appropriate columns of the test model matrix to
form the predictions, and compute the test MSE.

model.
matrix()

> val . errors = rep ( NA ,19)
> for ( i in 1:19) {
+

coefi = coef ( regfit . best , id = i )

6.5 Lab 1: Subset Selection Methods

249

pred = test . mat [ , names ( coefi ) ]%*% coefi
val . errors [ i ]= mean (( H i t t e r s $ S a l a r y [ test ] - pred ) ^2)

+
+
}

We ﬁnd that the best model is the one that contains ten variables.

> val . errors

[1] 220968 169157 178518 163426 168418 171271 162377 157909
[9] 154056 148162 151156 151742 152214 157359 158541 158743

[17] 159973 159860 160106
> which . min ( val . errors )
[1] 10
> coef ( regfit . best ,10)
( Intercept )
-80.275
CHits
1.105
PutOuts
0.238

AtBat
-1.468
CHmRun
1.384

Hits
7.163
CWalks
-0.748

Walks
3.643
LeagueN
84.558

CAtBat
-0.186
DivisionW
-53.029

This was a little tedious, partly because there is no predict() method
for regsubsets(). Since we will be using this function again, we can capture
our steps above and write our own predict method.

>
+
+
+
+
+
+

predict . regsubset s = function ( object , newdata , id ,...) {
form = as . formula ( object$ca l l [[2]])
mat = model . matrix ( form , newdata )
coefi = coef ( object , id = id )
xvars = names ( coefi )
mat [ , xvars ]%*% coefi
}

Our function pretty much mimics what we did above. The only complex
part is how we extracted the formula used in the call to regsubsets(). We
demonstrate how we use this function below, when we do cross-validation.
Finally, we perform best subset selection on the full data set, and select
the best ten-variable model. It is important that we make use of the full
data set in order to obtain more accurate coeﬃcient estimates. Note that
we perform best subset selection on the full data set and select the best ten-
variable model, rather than simply using the variables that were obtained
from the training set, because the best ten-variable model on the full data
set may diﬀer from the corresponding model on the training set.
> regfit . best = regsubset s ( Salary∼. , data = Hitters , nvmax =19)

> coef ( regfit . best ,10)
( Intercept )
162.535
CRuns
1.408
Assists
0.283

AtBat
-2.169
CRBI
0.774

Hits
6.918
CWalks
-0.831

Walks
5.773
DivisionW
-112.380

CAtBat
-0.130
PutOuts
0.297

250

6. Linear Model Selection and Regularization

In fact, we see that the best ten-variable model on the full data set has a
diﬀerent set of variables than the best ten-variable model on the training
set.

We now try to choose among the models of diﬀerent sizes using cross-
validation. This approach is somewhat involved, as we must perform best
subset selection within each of the k training sets. Despite this, we see that
with its clever subsetting syntax, R makes this job quite easy. First, we
create a vector that allocates each observation to one of k = 10 folds, and
we create a matrix in which we will store the results.

> k =10
> set . seed (1)
> folds = sample (1: k , nrow ( Hitters ) , replace = TRUE )
> cv . errors = matrix ( NA ,k ,19 , dimnames = list ( NULL , paste (1:19) ) )

Now we write a for loop that performs cross-validation. In the jth fold, the
elements of folds that equal j are in the test set, and the remainder are in
the training set. We make our predictions for each model size (using our
new predict() method), compute the test errors on the appropriate subset,
and store them in the appropriate slot in the matrix cv.errors.

> for ( j in 1: k ) {
+

best . fit = regsubsets ( Salary∼. , data = Hitters [ folds != j ,] ,

nvmax =19)

for ( i in 1:19) {

pred = predict ( best . fit , Hitters [ folds == j ,] , id = i )
cv . errors [j , i ]= mean ( ( H i t t e r s $ S a l a r y [ folds == j ] - pred ) ^2)
}

+
+
+
+
+

}

This has given us a 10×19 matrix, of which the (i, j)th element corresponds
to the test MSE for the ith cross-validation fold for the best j-variable
model. We use the apply() function to average over the columns of this
matrix in order to obtain a vector for which the jth element is the cross-
validation error for the j-variable model.

apply()

> mean . cv . errors = apply ( cv . errors ,2 , mean )
> mean . cv . errors

[1] 160093 140197 153117 151159 146841 138303 144346 130208
[9] 129460 125335 125154 128274 133461 133975 131826 131883

[17] 132751 133096 132805
> par ( mfrow = c (1 ,1) )
> plot ( mean . cv . errors , type = ’b ’)

We see that cross-validation selects an 11-variable model. We now perform
best subset selection on the full data set in order to obtain the 11-variable
model.
> reg . best = regsubset s ( Salary∼. , data = Hitters , nvmax =19)

> coef ( reg . best ,11)
( Intercept )
135.751

AtBat
-2.128

Hits
6.924

Walks
5.620

CAtBat
-0.139

glmnet()

6.6 Lab 2: Ridge Regression and the Lasso

251

CRuns
1.455
PutOuts
0.289

CRBI
0.785
Assists
0.269

CWalks
-0.823

LeagueN
43.112

DivisionW
-111.146

6.6 Lab 2: Ridge Regression and the Lasso

We will use the glmnet package in order to perform ridge regression and
the lasso. The main function in this package is glmnet(), which can be used
to ﬁt ridge regression models, lasso models, and more. This function has
slightly diﬀerent syntax from other model-ﬁtting functions that we have
encountered thus far in this book. In particular, we must pass in an x
matrix as well as a y vector, and we do not use the y ∼ x syntax. We will
now perform ridge regression and the lasso in order to predict Salary on
the Hitters data. Before proceeding ensure that the missing values have
been removed from the data, as described in Section 6.5.
> x = model . matrix ( Salary∼. , Hitters ) [ , -1]

> y = H i t t e r s $ S a l a r y

The model.matrix() function is particularly useful for creating x; not only
does it produce a matrix corresponding to the 19 predictors but it also
automatically transforms any qualitative variables into dummy variables.
The latter property is important because glmnet() can only take numerical,
quantitative inputs.

6.6.1 Ridge Regression

The glmnet() function has an alpha argument that determines what type
of model is ﬁt. If alpha=0 then a ridge regression model is ﬁt, and if alpha=1
then a lasso model is ﬁt. We ﬁrst ﬁt a ridge regression model.

> library ( glmnet )
> grid =10^ seq (10 , -2 , length =100)
> ridge . mod = glmnet (x ,y , alpha =0 , lambda = grid )

By default the glmnet() function performs ridge regression for an automati-
cally selected range of λ values. However, here we have chosen to implement
−2, es-
the function over a grid of values ranging from λ = 1010 to λ = 10
sentially covering the full range of scenarios from the null model containing
only the intercept, to the least squares ﬁt. As we will see, we can also com-
pute model ﬁts for a particular value of λ that is not one of the original
grid values. Note that by default, the glmnet() function standardizes the
variables so that they are on the same scale. To turn oﬀ this default setting,
use the argument standardize=FALSE.
Associated with each value of λ is a vector of ridge regression coeﬃcients,
stored in a matrix that can be accessed by coef(). In this case, it is a 20×100

252

6. Linear Model Selection and Regularization

matrix, with 20 rows (one for each predictor, plus an intercept) and 100
columns (one for each value of λ).

> dim ( coef ( ridge . mod ) )
[1]

20 100

We expect the coeﬃcient estimates to be much smaller, in terms of (cid:6)2 norm,
when a large value of λ is used, as compared to when a small value of λ is
used. These are the coeﬃcients when λ = 11,498, along with their (cid:6)2 norm:

> ridge . mod$lambd a [50]
[1] 11498
> coef ( ridge . mod ) [ ,50]
( Intercept )
407.356
RBI
0.240
CHmRun
0.088
DivisionW
-6.215

AtBat
0.037
Walks
0.290
CRuns
0.023
PutOuts
0.016

Hits
0.138
Years
1.108
CRBI
0.024
Assists
0.003

HmRun
0.525
CAtBat
0.003
CWalks
0.025
Errors
-0.021

Runs
0.231
CHits
0.012
LeagueN
0.085
NewLeague N
0.301

> sqrt ( sum ( coef ( ridge . mod ) [ -1 ,50]^2) )
[1] 6.36

In contrast, here are the coeﬃcients when λ = 705, along with their (cid:6)2
norm. Note the much larger (cid:6)2 norm of the coeﬃcients associated with this
smaller value of λ.

> ridge . mod$lambd a [60]
[1] 705
> coef ( ridge . mod ) [ ,60]
( Intercept )
54.325
RBI
0.847
CHmRun
0.338
DivisionW
-54.659

AtBat
0.112
Walks
1.320
CRuns
0.094
PutOuts
0.119

Hits
0.656
Years
2.596
CRBI
0.098
Assists
0.016

HmRun
1.180
CAtBat
0.011
CWalks
0.072
Errors
-0.704

Runs
0.938
CHits
0.047
LeagueN
13.684
NewLeague N
8.612

> sqrt ( sum ( coef ( ridge . mod ) [ -1 ,60]^2) )
[1] 57.1

We can use the predict() function for a number of purposes. For instance,
we can obtain the ridge regression coeﬃcients for a new value of λ, say 50:

> predict ( ridge . mod , s =50 , type =" c o e f f i c i e n t s ") [1:20 ,]
( Intercept )
48.766
RBI
0.804
CHmRun
0.624
DivisionW
-118.201

Hits
1.969
Years
-6.218
CRBI
0.219
Assists
0.122

AtBat
-0.358
Walks
2.716
CRuns
0.221
PutOuts
0.250

HmRun
-1.278
CAtBat
0.005
CWalks
-0.150
Errors
-3.279

Runs
1.146
CHits
0.106
LeagueN
45.926
NewLeague N
-9.497

6.6 Lab 2: Ridge Regression and the Lasso

253

We now split the samples into a training set and a test set in order
to estimate the test error of ridge regression and the lasso. There are two
common ways to randomly split a data set. The ﬁrst is to produce a random
vector of TRUE, FALSE elements and select the observations corresponding to
TRUE for the training data. The second is to randomly choose a subset of
numbers between 1 and n; these can then be used as the indices for the
training observations. The two approaches work equally well. We used the
former method in Section 6.5.3. Here we demonstrate the latter approach.
We ﬁrst set a random seed so that the results obtained will be repro-

ducible.

> set . seed (1)
> train = sample (1: nrow ( x ) , nrow ( x ) /2)
> test =( - train )
> y . test = y [ test ]

Next we ﬁt a ridge regression model on the training set, and evaluate
its MSE on the test set, using λ = 4. Note the use of the predict()
function again. This time we get predictions for a test set, by replacing
type="coefficients" with the newx argument.

> ridge . mod = glmnet ( x [ train ,] , y [ train ] , alpha =0 , lambda = grid ,

thresh =1 e -12)

> ridge . pred = predict ( ridge . mod , s =4 , newx = x [ test ,])
> mean (( ridge . pred - y . test ) ^2)
[1] 101037

The test MSE is 101037. Note that if we had instead simply ﬁt a model
with just an intercept, we would have predicted each test observation using
the mean of the training observations. In that case, we could compute the
test set MSE like this:

> mean (( mean ( y [ train ]) - y . test ) ^2)
[1] 193253

We could also get the same result by ﬁtting a ridge regression model with
a very large value of λ. Note that 1e10 means 1010.

> ridge . pred = predict ( ridge . mod , s =1 e10 , newx = x [ test ,])
> mean (( ridge . pred - y . test ) ^2)
[1] 193253

So ﬁtting a ridge regression model with λ = 4 leads to a much lower test
MSE than ﬁtting a model with just an intercept. We now check whether
there is any beneﬁt to performing ridge regression with λ = 4 instead of
just performing least squares regression. Recall that least squares is simply
ridge regression with λ = 0.

7

7

In order for glmnet() to yield the exact least squares coeﬃcients when λ = 0,
we use the argument exact=T when calling the predict() function. Otherwise, the
interpolate over the grid of λ values used in ﬁtting the
predict() function will

254

6. Linear Model Selection and Regularization

> ridge . pred = predict ( ridge . mod , s =0 , newx = x [ test ,] , exact = T )
> mean (( ridge . pred - y . test ) ^2)
[1] 114783

> lm ( y∼x , subset = train )

> predict ( ridge . mod , s =0 , exact =T , type =" c o e f f i c i e n t s ") [1:20 ,]

In general, if we want to ﬁt a (unpenalized) least squares model, then
we should use the lm() function, since that function provides more useful
outputs, such as standard errors and p-values for the coeﬃcients.

In general, instead of arbitrarily choosing λ = 4, it would be better to
use cross-validation to choose the tuning parameter λ. We can do this using
the built-in cross-validation function, cv.glmnet(). By default, the function
performs ten-fold cross-validation, though this can be changed using the
argument nfolds. Note that we set a random seed ﬁrst so our results will
be reproducible, since the choice of the cross-validation folds is random.

> set . seed (1)
> cv . out = cv . glmnet ( x [ train ,] , y [ train ] , alpha =0)
> plot ( cv . out )
> bestlam = cv . out$lambda . min
> bestlam
[1] 212

Therefore, we see that the value of λ that results in the smallest cross-
validation error is 212. What is the test MSE associated with this value of
λ?

> ridge . pred = predict ( ridge . mod , s = bestlam , newx = x [ test ,])
> mean (( ridge . pred - y . test ) ^2)
[1] 96016

This represents a further improvement over the test MSE that we got using
λ = 4. Finally, we reﬁt our ridge regression model on the full data set,
using the value of λ chosen by cross-validation, and examine the coeﬃcient
estimates.

cv.glmnet()

> out = glmnet (x ,y , alpha =0)
> predict ( out , type =" c o e f f i c i e n t s " , s = bestlam ) [1:20 ,]
( Intercept )
9.8849
RBI
0.8732
CHmRun
0.4516
DivisionW
-91.6341

Hits
1.0088
Years
0.1307
CRBI
0.1374
Assists
0.0425

AtBat
0.0314
Walks
1.8041
CRuns
0.1290
PutOuts
0.1915

HmRun
0.1393
CAtBat
0.0111
CWalks
0.0291
Errors
-1.8124

Runs
1.1132
CHits
0.0649
LeagueN
27.1823
NewLeague N
7.2121

glmnet() model, yielding approximate results. When we use exact=T, there remains
a slight discrepancy in the third decimal place between the output of glmnet() when
λ = 0 and the output of lm(); this is due to numerical approximation on the part of
glmnet().

6.6 Lab 2: Ridge Regression and the Lasso

255

As expected, none of the coeﬃcients are zero—ridge regression does not
perform variable selection!

6.6.2 The Lasso

We saw that ridge regression with a wise choice of λ can outperform least
squares as well as the null model on the Hitters data set. We now ask
whether the lasso can yield either a more accurate or a more interpretable
model than ridge regression. In order to ﬁt a lasso model, we once again
use the glmnet() function; however, this time we use the argument alpha=1.
Other than that change, we proceed just as we did in ﬁtting a ridge model.

> lasso . mod = glmnet ( x [ train ,] , y [ train ] , alpha =1 , lambda = grid )
> plot ( lasso . mod )

We can see from the coeﬃcient plot that depending on the choice of tuning
parameter, some of the coeﬃcients will be exactly equal to zero. We now
perform cross-validation and compute the associated test error.

> set . seed (1)
> cv . out = cv . glmnet ( x [ train ,] , y [ train ] , alpha =1)
> plot ( cv . out )
> bestlam = cv . out$lambda . min
> lasso . pred = predict ( lasso . mod , s = bestlam , newx = x [ test ,])
> mean (( lasso . pred - y . test ) ^2)
[1] 100743

This is substantially lower than the test set MSE of the null model and of
least squares, and very similar to the test MSE of ridge regression with λ
chosen by cross-validation.

However, the lasso has a substantial advantage over ridge regression in
that the resulting coeﬃcient estimates are sparse. Here we see that 12 of
the 19 coeﬃcient estimates are exactly zero. So the lasso model with λ
chosen by cross-validation contains only seven variables.

> out = glmnet (x ,y , alpha =1 , lambda = grid )
> lasso . coef = predict ( out , type =" c o e f f i c i e n t s " , s = bestlam ) [1:20 ,]
> lasso . coef
( Intercept )
18.539
RBI
0.000
CHmRun
0.000
DivisionW
-103.485

Runs
0.000
CHits
0.000
LeagueN
3.267
NewLeague N
0.000

HmRun
0.000
CAtBat
0.000
CWalks
0.000
Errors
0.000

AtBat
0.000
Walks
2.218
CRuns
0.207
PutOuts
0.220

Hits
1.874
Years
0.000
CRBI
0.413
Assists
0.000

> lasso . coef [ lasso . coef !=0]
( Intercept )
18.539
LeagueN
3.267

Hits
1.874
DivisionW
-103.485

Walks
2.218
PutOuts
0.220

CRuns
0.207

CRBI
0.413

256

6. Linear Model Selection and Regularization

6.7 Lab 3: PCR and PLS Regression

6.7.1 Principal Components Regression

Principal components regression (PCR) can be performed using the pcr()
function, which is part of the pls library. We now apply PCR to the Hitters
data, in order to predict Salary. Again, ensure that the missing values have
been removed from the data, as described in Section 6.5.

pcr()

> library ( pls )
> set . seed (2)

> pcr . fit = pcr ( Salary∼. , data = Hitters , scale = TRUE ,

validation =" CV ")

The syntax for the pcr() function is similar to that for lm(), with a few
additional options. Setting scale=TRUE has the eﬀect of standardizing each
predictor, using (6.6), prior to generating the principal components, so that
the scale on which each variable is measured will not have an eﬀect. Setting
validation="CV" causes pcr() to compute the ten-fold cross-validation error
for each possible value of M , the number of principal components used. The
resulting ﬁt can be examined using summary().

> summary ( pcr . fit )
Data :

X dimension : 263 19

Y dimension : 263 1

Fit method : svdpc
Number of components considered : 19

VALIDATIO N : RMSEP
Cross - validated using 10 random segments .

( Intercept )
452
452

1 comps
348.9
348.7

2 comps
352.2
351.8

3 comps
353.5
352.9

4 comps
352.8
352.1

CV
adjCV
...

TRAINING : % variance explained

1 comps
38.31
40.63

2 comps
60.16
41.58

3 comps
70.84
42.17

4 comps
79.03
43.22

5 comps
84.29
44.90

6 comps
88.63
46.48

X
Salary
...

The CV score is provided for each possible number of components, ranging
from M = 0 onwards. (We have printed the CV output only up to M = 4.)
Note that pcr() reports the root mean squared error ; in order to obtain
the usual MSE, we must square this quantity. For instance, a root mean
squared error of 352.8 corresponds to an MSE of 352.82 = 124,468.

One can also plot the cross-validation scores using the validationplot()
function. Using val.type="MSEP" will cause the cross-validation MSE to be
plotted.

> v a l i d a t i o n p l o t ( pcr . fit , val . type =" MSEP ")

validation
plot()

6.7 Lab 3: PCR and PLS Regression

257

We see that the smallest cross-validation error occurs when M = 16 com-
ponents are used. This is barely fewer than M = 19, which amounts to
simply performing least squares, because when all of the components are
used in PCR no dimension reduction occurs. However, from the plot we
also see that the cross-validation error is roughly the same when only one
component is included in the model. This suggests that a model that uses
just a small number of components might suﬃce.

The summary() function also provides the percentage of variance explained
in the predictors and in the response using diﬀerent numbers of compo-
nents. This concept is discussed in greater detail in Chapter 10. Brieﬂy,
we can think of this as the amount of information about the predictors or
the response that is captured using M principal components. For example,
setting M = 1 only captures 38.31 % of all the variance, or information, in
the predictors. In contrast, using M = 6 increases the value to 88.63 %. If
we were to use all M = p = 19 components, this would increase to 100 %.
We now perform PCR on the training data and evaluate its test set

performance.

> set . seed (1)

> pcr . fit = pcr ( Salary∼. , data = Hitters , subset = train , scale = TRUE ,

validation =" CV ")

> v a l i d a t i o n p l o t ( pcr . fit , val . type =" MSEP ")

Now we ﬁnd that the lowest cross-validation error occurs when M = 7
component are used. We compute the test MSE as follows.

> pcr . pred = predict ( pcr . fit , x [ test ,] , ncomp =7)
> mean (( pcr . pred - y . test ) ^2)
[1] 96556

This test set MSE is competitive with the results obtained using ridge re-
gression and the lasso. However, as a result of the way PCR is implemented,
the ﬁnal model is more diﬃcult to interpret because it does not perform
any kind of variable selection or even directly produce coeﬃcient estimates.
Finally, we ﬁt PCR on the full data set, using M = 7, the number of

components identiﬁed by cross-validation.
> pcr . fit = pcr ( y∼x , scale = TRUE , ncomp =7)

> summary ( pcr . fit )
Data :

X dimension : 263 19
Y dimension : 263 1

Fit method : svdpc
Number of components considered : 7
TRAINING : % variance explained

2 comps
60.16
41.58

3 comps
70.84
42.17

4 comps
79.03
43.22

5 comps
84.29
44.90

6 comps
88.63
46.48

1 comps
38.31
40.63
7 comps
92.26
46.69

X
y

X
y

258

6. Linear Model Selection and Regularization

6.7.2 Partial Least Squares

We implement partial least squares (PLS) using the plsr() function, also
in the pls library. The syntax is just like that of the pcr() function.

plsr()

> set . seed (1)

> pls . fit = plsr ( Salary∼. , data = Hitters , subset = train , scale = TRUE ,

validation =" CV ")

> summary ( pls . fit )
Data :

X dimension : 131 19

Y dimension : 131 1

Fit method : kernelpls
Number of components considered : 19

VALIDATIO N : RMSEP
Cross - validated using 10 random segments .

( Intercept )
464.6
464.6

1 comps
394.2
393.4

2 comps
391.5
390.2

3 comps
393.1
391.1

4 comps
395.0
392.9

CV
adjCV
...

TRAINING : % variance explained

1 comps
38.12
33.58

4 comps
74.49
42.43

5 comps
79.33
44.04

6 comps
84.56
45.59

2 comps
53.46
38.96

3 comps
66.05
41.57

X
Salary
...
> v a l i d a t i o n p l o t ( pls . fit , val . type =" MSEP ")

The lowest cross-validation error occurs when only M = 2 partial least
squares directions are used. We now evaluate the corresponding test set
MSE.

> pls . pred = predict ( pls . fit , x [ test ,] , ncomp =2)
> mean (( pls . pred - y . test ) ^2)
[1] 101417

The test MSE is comparable to, but slightly higher than, the test MSE
obtained using ridge regression, the lasso, and PCR.

Finally, we perform PLS using the full data set, using M = 2, the number

of components identiﬁed by cross-validation.
> pls . fit = plsr ( Salary∼. , data = Hitters , scale = TRUE , ncomp =2)

> summary ( pls . fit )
Data :

X dimension : 263 19

Y dimension : 263 1

Fit method : kernelpls
Number of components considered : 2
TRAINING : % variance explained

X
Salary

1 comps
38.08
43.05

2 comps
51.03
46.40

Notice that the percentage of variance in Salary that the two-component
PLS ﬁt explains, 46.40 %, is almost as much as that explained using the

6.8 Exercises

259

ﬁnal seven-component model PCR ﬁt, 46.69 %. This is because PCR only
attempts to maximize the amount of variance explained in the predictors,
while PLS searches for directions that explain variance in both the predic-
tors and the response.

6.8 Exercises

Conceptual

1. We perform best subset, forward stepwise, and backward stepwise
selection on a single data set. For each approach, we obtain p + 1
models, containing 0, 1, 2, . . . , p predictors. Explain your answers:

(a) Which of the three models with k predictors has the smallest

training RSS?

(b) Which of the three models with k predictors has the smallest

test RSS?

(c) True or False:

i. The predictors in the k-variable model identiﬁed by forward
stepwise are a subset of the predictors in the (k +1)-variable
model identiﬁed by forward stepwise selection.

ii. The predictors in the k-variable model identiﬁed by back-
ward stepwise are a subset of the predictors in the (k + 1)-
variable model identiﬁed by backward stepwise selection.

iii. The predictors in the k-variable model identiﬁed by back-
ward stepwise are a subset of the predictors in the (k + 1)-
variable model identiﬁed by forward stepwise selection.

iv. The predictors in the k-variable model identiﬁed by forward
stepwise are a subset of the predictors in the (k +1)-variable
model identiﬁed by backward stepwise selection.

v. The predictors in the k-variable model identiﬁed by best
subset are a subset of the predictors in the (k + 1)-variable
model identiﬁed by best subset selection.

2. For parts (a) through (c), indicate which of i. through iv. is correct.

Justify your answer.

(a) The lasso, relative to least squares, is:

i. More ﬂexible and hence will give improved prediction ac-
curacy when its increase in bias is less than its decrease in
variance.

ii. More ﬂexible and hence will give improved prediction accu-
racy when its increase in variance is less than its decrease
in bias.

260

6. Linear Model Selection and Regularization

iii. Less ﬂexible and hence will give improved prediction accu-
racy when its increase in bias is less than its decrease in
variance.

iv. Less ﬂexible and hence will give improved prediction accu-
racy when its increase in variance is less than its decrease
in bias.

(b) Repeat (a) for ridge regression relative to least squares.

(c) Repeat (a) for non-linear methods relative to least squares.

3. Suppose we estimate the regression coeﬃcients in a linear regression

model by minimizing

n(cid:17)

i=1

⎛
⎝yi − β0 − p(cid:17)

j=1

⎞
⎠2

βjxij

subject to

p(cid:17)

j=1

|βj| ≤ s

for a particular value of s. For parts (a) through (e), indicate which
of i. through v. is correct. Justify your answer.

(a) As we increase s from 0, the training RSS will:

i. Increase initially, and then eventually start decreasing in an

inverted U shape.

ii. Decrease initially, and then eventually start increasing in a

U shape.

iii. Steadily increase.
iv. Steadily decrease.
v. Remain constant.

(b) Repeat (a) for test RSS.

(c) Repeat (a) for variance.

(d) Repeat (a) for (squared) bias.

(e) Repeat (a) for the irreducible error.

4. Suppose we estimate the regression coeﬃcients in a linear regression

model by minimizing
⎛
⎝yi − β0 − p(cid:17)

n(cid:17)

⎞
⎠2

βjxij

i=1

j=1

p(cid:17)

j=1

β2
j

+ λ

for a particular value of λ. For parts (a) through (e), indicate which
of i. through v. is correct. Justify your answer.

6.8 Exercises

261

(a) As we increase λ from 0, the training RSS will:

i. Increase initially, and then eventually start decreasing in an

inverted U shape.

ii. Decrease initially, and then eventually start increasing in a

U shape.

iii. Steadily increase.
iv. Steadily decrease.
v. Remain constant.

(b) Repeat (a) for test RSS.

(c) Repeat (a) for variance.

(d) Repeat (a) for (squared) bias.

(e) Repeat (a) for the irreducible error.

5. It is well-known that ridge regression tends to give similar coeﬃcient
values to correlated variables, whereas the lasso may give quite dif-
ferent coeﬃcient values to correlated variables. We will now explore
this property in a very simple setting.

Suppose that n = 2, p = 2, x11 = x12, x21 = x22. Furthermore,
suppose that y1 + y2 = 0 and x11 + x21 = 0 and x12 + x22 = 0, so that
the estimate for the intercept in a least squares, ridge regression, or
lasso model is zero: ˆβ0 = 0.

(a) Write out the ridge regression optimization problem in this set-

ting.

(b) Argue that in this setting, the ridge coeﬃcient estimates satisfy

ˆβ1 = ˆβ2.

(c) Write out the lasso optimization problem in this setting.
(d) Argue that in this setting, the lasso coeﬃcients ˆβ1 and ˆβ2 are
not unique—in other words, there are many possible solutions
to the optimization problem in (c). Describe these solutions.

6. We will now explore (6.12) and (6.13) further.

(a) Consider (6.12) with p = 1. For some choice of y1 and λ > 0,
plot (6.12) as a function of β1. Your plot should conﬁrm that
(6.12) is solved by (6.14).

(b) Consider (6.13) with p = 1. For some choice of y1 and λ > 0,
plot (6.13) as a function of β1. Your plot should conﬁrm that
(6.13) is solved by (6.15).

262

6. Linear Model Selection and Regularization

7. We will now derive the Bayesian connection to the lasso and ridge

regression discussed in Section 6.2.2.

(cid:10)

(a) Suppose that yi = β0 +

p
j=1 xij βj +i where 1, . . . , n are inde-
pendent and identically distributed from a N (0, σ2) distribution.
Write out the likelihood for the data.

(b) Assume the following prior for β: β1, . . . , βp are independent
and identically distributed according to a double-exponential
distribution with mean 0 and common scale parameter b: i.e.
p(β) = 1
setting.

2b exp(−|β|/b). Write out the posterior for β in this

(c) Argue that the lasso estimate is the mode for β under this pos-

terior distribution.

(d) Now assume the following prior for β: β1, . . . , βp are independent
and identically distributed according to a normal distribution
with mean zero and variance c. Write out the posterior for β in
this setting.

(e) Argue that the ridge regression estimate is both the mode and

the mean for β under this posterior distribution.

Applied

8. In this exercise, we will generate simulated data, and will then use

this data to perform best subset selection.

(a) Use the rnorm() function to generate a predictor X of length

n = 100, as well as a noise vector  of length n = 100.

(b) Generate a response vector Y of length n = 100 according to

the model

Y = β0 + β1X + β2X 2 + β3X 3 + ,

where β0, β1, β2, and β3 are constants of your choice.

(c) Use the regsubsets() function to perform best subset selection
in order to choose the best model containing the predictors
X, X 2, . . . , X 10. What is the best model obtained according to
Cp, BIC, and adjusted R2? Show some plots to provide evidence
for your answer, and report the coeﬃcients of the best model ob-
tained. Note you will need to use the data.frame() function to
create a single data set containing both X and Y .

6.8 Exercises

263

(d) Repeat (c), using forward stepwise selection and also using back-
wards stepwise selection. How does your answer compare to the
results in (c)?

(e) Now ﬁt a lasso model to the simulated data, again using X, X 2,
. . . , X 10 as predictors. Use cross-validation to select the optimal
value of λ. Create plots of the cross-validation error as a function
of λ. Report the resulting coeﬃcient estimates, and discuss the
results obtained.

(f) Now generate a response vector Y according to the model

Y = β0 + β7X 7 + ,

and perform best subset selection and the lasso. Discuss the
results obtained.

9. In this exercise, we will predict the number of applications received

using the other variables in the College data set.

(a) Split the data set into a training set and a test set.
(b) Fit a linear model using least squares on the training set, and

report the test error obtained.

(c) Fit a ridge regression model on the training set, with λ chosen

by cross-validation. Report the test error obtained.

(d) Fit a lasso model on the training set, with λ chosen by cross-
validation. Report the test error obtained, along with the num-
ber of non-zero coeﬃcient estimates.

(e) Fit a PCR model on the training set, with M chosen by cross-
validation. Report the test error obtained, along with the value
of M selected by cross-validation.

(f) Fit a PLS model on the training set, with M chosen by cross-
validation. Report the test error obtained, along with the value
of M selected by cross-validation.

(g) Comment on the results obtained. How accurately can we pre-
dict the number of college applications received? Is there much
diﬀerence among the test errors resulting from these ﬁve ap-
proaches?

10. We have seen that as the number of features used in a model increases,
the training error will necessarily decrease, but the test error may not.
We will now explore this in a simulated data set.

(a) Generate a data set with p = 20 features, n = 1,000 observa-
tions, and an associated quantitative response vector generated
according to the model

where β has some elements that are exactly equal to zero.

Y = Xβ + ,

264

6. Linear Model Selection and Regularization

(b) Split your data set into a training set containing 100 observations

and a test set containing 900 observations.

(c) Perform best subset selection on the training set, and plot the

training set MSE associated with the best model of each size.

(d) Plot the test set MSE associated with the best model of each

size.

(e) For which model size does the test set MSE take on its minimum
value? Comment on your results. If it takes on its minimum value
for a model containing only an intercept or a model containing
all of the features, then play around with the way that you are
generating the data in (a) until you come up with a scenario in
which the test set MSE is minimized for an intermediate model
size.

(f) How does the model at which the test set MSE is minimized
compare to the true model used to generate the data? Comment
on the coeﬃcient values.

’(cid:10)

(g) Create a plot displaying

j )2 for a range of values
of r, where ˆβr
j is the jth coeﬃcient estimate for the best model
containing r coeﬃcients. Comment on what you observe. How
does this compare to the test MSE plot from (d)?

p

j=1(βj − ˆβr

11. We will now try to predict per capita crime rate in the Boston data

set.

(a) Try out some of the regression methods explored in this chapter,
such as best subset selection, the lasso, ridge regression, and
PCR. Present and discuss results for the approaches that you
consider.

(b) Propose a model (or set of models) that seem to perform well on
this data set, and justify your answer. Make sure that you are
evaluating model performance using validation set error, cross-
validation, or some other reasonable alternative, as opposed to
using training error.

(c) Does your chosen model involve all of the features in the data

set? Why or why not?

7
Moving Beyond Linearity

So far in this book, we have mostly focused on linear models. Linear models
are relatively simple to describe and implement, and have advantages over
other approaches in terms of interpretation and inference. However, stan-
dard linear regression can have signiﬁcant limitations in terms of predic-
tive power. This is because the linearity assumption is almost always an
approximation, and sometimes a poor one. In Chapter 6 we see that we can
improve upon least squares using ridge regression, the lasso, principal com-
ponents regression, and other techniques. In that setting, the improvement
is obtained by reducing the complexity of the linear model, and hence the
variance of the estimates. But we are still using a linear model, which can
only be improved so far! In this chapter we relax the linearity assumption
while still attempting to maintain as much interpretability as possible. We
do this by examining very simple extensions of linear models like polyno-
mial regression and step functions, as well as more sophisticated approaches
such as splines, local regression, and generalized additive models.

• Polynomial regression extends the linear model by adding extra pre-
dictors, obtained by raising each of the original predictors to a power.
For example, a cubic regression uses three variables, X, X 2, and X 3,
as predictors. This approach provides a simple way to provide a non-
linear ﬁt to data.

• Step functions cut the range of a variable into K distinct regions in
order to produce a qualitative variable. This has the eﬀect of ﬁtting
a piecewise constant function.

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 7,
© Springer Science+Business Media New York 2013

265

266

7. Moving Beyond Linearity

• Regression splines are more ﬂexible than polynomials and step
functions, and in fact are an extension of the two. They involve di-
viding the range of X into K distinct regions. Within each region,
a polynomial function is ﬁt to the data. However, these polynomials
are constrained so that they join smoothly at the region boundaries,
or knots. Provided that the interval is divided into enough regions,
this can produce an extremely ﬂexible ﬁt.

• Smoothing splines are similar to regression splines, but arise in a
slightly diﬀerent situation. Smoothing splines result from minimizing
a residual sum of squares criterion subject to a smoothness penalty.
• Local regression is similar to splines, but diﬀers in an important way.
The regions are allowed to overlap, and indeed they do so in a very
smooth way.

• Generalized additive models allow us to extend the methods above to

deal with multiple predictors.

In Sections 7.1–7.6, we present a number of approaches for modeling the
relationship between a response Y and a single predictor X in a ﬂexible
way. In Section 7.7, we show that these approaches can be seamlessly inte-
grated in order to model a response Y as a function of several predictors
X1, . . . , Xp.

7.1 Polynomial Regression

Historically, the standard way to extend linear regression to settings in
which the relationship between the predictors and the response is non-
linear has been to replace the standard linear model

yi = β0 + β1xi + i

with a polynomial function

yi = β0 + β1xi + β2x2

i + β3x3

i + . . . + βdxd

i + i,

(7.1)

where i is the error term. This approach is known as polynomial regression,
and in fact we saw an example of this method in Section 3.3.2. For large
enough degree d, a polynomial regression allows us to produce an extremely
non-linear curve. Notice that the coeﬃcients in (7.1) can be easily estimated
using least squares linear regression because this is just a standard linear
model with predictors xi, x2
i . Generally speaking, it is unusual
to use d greater than 3 or 4 because for large values of d, the polynomial
curve can become overly ﬂexible and can take on some very strange shapes.
This is especially true near the boundary of the X variable.

i , . . . , xd

i , x3

polynomial
regression

7.1 Polynomial Regression

267

Degree−4 Polynomial

)
e
g
A
 
|

 
0
5
2
>
e
g
a
W

(
r
P

0
2

.

0

5
1
0

.

0
1

.
0

5
0
.
0

0
0
.
0

|

|

|
|
|

|

|
|

|
|

|

|
|
|
|
|

|
|
|
|

|
|
|

|
|
|

|

|
|
|
|
|
|
|

|
|

|
|

|
|
|
|
|

|
|

|
|

|
|
|

|

|
|
|
|

|
|
|

|
|

|
|

|
|

|
|

|
|
|

|
|

|
|

|

|
|

|
|

|

|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
||
|
|
| |
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
| |
|
|
|
|
|
|
|
||
|
|
| ||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
| |
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
| |
|
|
|
||
| |
| |
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
| |
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|||
||
|
| |
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
|
|
|
||
|| | |
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
||| |
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
||
||
| |
|
|
||
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
||
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
||
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
||
|
||
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
||
| |
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
|
|
||
|
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
| |
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|||
|
||
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
| |
| |
|
|
||
|
|
|
|
|
| |
|
|||
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| | |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
| |
|
|
|
| |
|
|
||
|
|
| |
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
||
|
|
|
|
|
||
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
||
|
|
|
|
|
| |
|
|
|| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| | |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|| |
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|

|
|
|
|
|
| |
|
|

|
|
|
|
|
|

|
|
|
|
|
|
|
|

|
|
|
|

|
|
|
|
|

|
|
|

|
|

|
|
|

|

|
|
|
|

0
0
3

0
5
2

0
0
2

0
5
1

0
0
1

0
5

e
g
a
W

20

30

40

50

60

70

80

20

30

40

50

60

70

80

Age

Age

FIGURE 7.1. The Wage data. Left: The solid blue curve is a degree-4 polynomial
of wage (in thousands of dollars) as a function of age, ﬁt by least squares. The
dotted curves indicate an estimated 95 % conﬁdence interval. Right: We model the
binary event wage>250 using logistic regression, again with a degree-4 polynomial.
The ﬁtted posterior probability of wage exceeding $250,000 is shown in blue, along
with an estimated 95 % conﬁdence interval.

The left-hand panel in Figure 7.1 is a plot of wage against age for the
Wage data set, which contains income and demographic information for
males who reside in the central Atlantic region of the United States. We
see the results of ﬁtting a degree-4 polynomial using least squares (solid
blue curve). Even though this is a linear regression model like any other,
the individual coeﬃcients are not of particular interest. Instead, we look at
the entire ﬁtted function across a grid of 62 values for age from 18 to 80 in
order to understand the relationship between age and wage.
In Figure 7.1, a pair of dotted curves accompanies the ﬁt; these are (2×)
standard error curves. Let’s see how these arise. Suppose we have computed
the ﬁt at a particular value of age, x0:

ˆf (x0) = ˆβ0 + ˆβ1x0 + ˆβ2x2

0 + ˆβ3x3

0 + ˆβ4x4
0.

(7.2)

What is the variance of the ﬁt, i.e. Var ˆf (x0)? Least squares returns variance
estimates for each of the ﬁtted coeﬃcients ˆβj, as well as the covariances
between pairs of coeﬃcient estimates. We can use these to compute the
estimated variance of ˆf (x0).1 The estimated pointwise standard error of
ˆf (x0) is the square-root of this variance. This computation is repeated

1If ˆC is the 5 × 5 covariance matrix of the ˆβj, and if (cid:5)T

0), then

Var[ ˆf (x0)] = (cid:5)T

0 ˆC(cid:5)0.

0 = (1, x0, x2

0, x3

0, x4

268

7. Moving Beyond Linearity

at each reference point x0, and we plot the ﬁtted curve, as well as twice
the standard error on either side of the ﬁtted curve. We plot twice the
standard error because, for normally distributed error terms, this quantity
corresponds to an approximate 95 % conﬁdence interval.

It seems like the wages in Figure 7.1 are from two distinct populations:
there appears to be a high earners group earning more than $250,000 per
annum, as well as a low earners group. We can treat wage as a binary
variable by splitting it into these two groups. Logistic regression can then
be used to predict this binary response, using polynomial functions of age
as predictors. In other words, we ﬁt the model

Pr(yi > 250|xi) =

exp(β0 + β1xi + β2x2

1 + exp(β0 + β1xi + β2x2

i + . . . + βdxd
i )
i + . . . + βdxd
i )

.

(7.3)

The result is shown in the right-hand panel of Figure 7.1. The gray marks
on the top and bottom of the panel indicate the ages of the high earners
and the low earners. The solid blue curve indicates the ﬁtted probabilities
of being a high earner, as a function of age. The estimated 95 % conﬁdence
interval is shown as well. We see that here the conﬁdence intervals are fairly
wide, especially on the right-hand side. Although the sample size for this
data set is substantial (n = 3,000), there are only 79 high earners, which
results in a high variance in the estimated coeﬃcients and consequently
wide conﬁdence intervals.

7.2 Step Functions

Using polynomial functions of the features as predictors in a linear model
imposes a global structure on the non-linear function of X. We can instead
use step functions in order to avoid imposing such a global structure. Here
we break the range of X into bins, and ﬁt a diﬀerent constant in each bin.
This amounts to converting a continuous variable into an ordered categorical
variable.

In greater detail, we create cutpoints c1, c2, . . . , cK in the range of X,

and then construct K + 1 new variables

step function

ordered
categorical
variable

C0(X)
C1(X)
C2(X)

= I(X < c1),
= I(c1 ≤ X < c2),
= I(c2 ≤ X < c3),
...
= I(cK ≤ X),

CK−1(X) = I(cK−1 ≤ X < cK),
CK(X)

(7.4)

where I(·) is an indicator function that returns a 1 if the condition is true,
and returns a 0 otherwise. For example, I(cK ≤ X) equals 1 if cK ≤ X, and

indicator
function

0
0
3

0
5
2

0
0
2

0
5
1

0
0
1

0
5

e
g
a
W

7.2 Step Functions

269

Piecewise Constant

)
e
g
A
 
|

 
0
5
2
>
e
g
a
W

(
r
P

0
2

.

0

5
1

.

0

0
1

.

0

5
0

.

0

0
0

.

0

|

|

|
|
|

|

|
|

|
|

|

|
|
|
|
|

|
|
|
|

|
|
|

|
|
|

|

|
|
|
|
|
|
|

|
|

|
|

|
|
|
|
|

|
|

|
|

|
|
|

|

|
|
|
|

|
|
|

|
|

|
|

|
|

|
|

|
|
|

|
|

|
|

|

|
|

|
|

|

|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| ||
|
|
||
|
|
|
|
|
||
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
| |
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
||
|
|
|
||
| |
| |
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
| |
| |
|
| |
|
|
|
|
|
|
|||
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|
||
|| | |
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
||| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
| |
|
| |
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
| ||
|
|
|
|
|
|
|
||
||
| |
|
|
||
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|||
|
||
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
| |
| |
|
|
||
|
|
|
|
|
| |
|
|||
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| | |
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
| |
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
| |
| |
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
| |
|
|
|
|
| |
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
| |
|
||
|
|
|
|
|
| |
|
|
|
| |
|
|
||
|
|
|
||
|
|
| |
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
| |
| |
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
| |
|
|
|| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
||
|| |
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|

|
|
|
|
| |
|
|
|

|
|
|
|
|
|

|
|
|
|
|
|
|
|

|
|
|
|

|
|
|
|
|

|
|
|

|
|

|
|
|

|

|
|
|
|

20

30

40

50

60

70

80

20

30

40

50

60

70

80

Age

Age

FIGURE 7.2. The Wage data. Left: The solid curve displays the ﬁtted value from
a least squares regression of wage (in thousands of dollars) using step functions
of age. The dotted curves indicate an estimated 95 % conﬁdence interval. Right:
We model the binary event wage>250 using logistic regression, again using step
functions of age. The ﬁtted posterior probability of wage exceeding $250,000 is
shown, along with an estimated 95 % conﬁdence interval.

equals 0 otherwise. These are sometimes called dummy variables. Notice
that for any value of X, C0(X) + C1(X) + . . . + CK (X) = 1, since X must
be in exactly one of the K + 1 intervals. We then use least squares to ﬁt a
linear model using C1(X), C2(X), . . . , CK (X) as predictors2:

yi = β0 + β1C1(xi) + β2C2(xi) + . . . + βKCK(xi) + i.

(7.5)

For a given value of X, at most one of C1, C2, . . . , CK can be non-zero.
Note that when X < c1, all of the predictors in (7.5) are zero, so β0 can
be interpreted as the mean value of Y for X < c1. By comparison, (7.5)
predicts a response of β0+βj for cj ≤ X < cj+1, so βj represents the average
increase in the response for X in cj ≤ X < cj+1 relative to X < c1.

An example of ﬁtting step functions to the Wage data from Figure 7.1 is
shown in the left-hand panel of Figure 7.2. We also ﬁt the logistic regression
model

2We exclude C0(X) as a predictor in (7.5) because it is redundant with the intercept.
This is similar to the fact that we need only two dummy variables to code a qualitative
variable with three levels, provided that the model will contain an intercept. The decision
to exclude C0(X) instead of some other Ck(X) in (7.5) is arbitrary. Alternatively, we
could include C0(X), C1(X), . . . , CK (X), and exclude the intercept.

270

7. Moving Beyond Linearity

Pr(yi > 250|xi) =

exp(β0 + β1C1(xi) + . . . + βKCK (xi))

1 + exp(β0 + β1C1(xi) + . . . + βKCK(xi))

(7.6)

in order to predict the probability that an individual is a high earner on the
basis of age. The right-hand panel of Figure 7.2 displays the ﬁtted posterior
probabilities obtained using this approach.

Unfortunately, unless there are natural breakpoints in the predictors,
piecewise-constant functions can miss the action. For example, in the left-
hand panel of Figure 7.2, the ﬁrst bin clearly misses the increasing trend
of wage with age. Nevertheless, step function approaches are very popular
in biostatistics and epidemiology, among other disciplines. For example,
5-year age groups are often used to deﬁne the bins.

7.3 Basis Functions

Polynomial and piecewise-constant regression models are in fact special
cases of a basis function approach. The idea is to have at hand a fam-
ily of functions or transformations that can be applied to a variable X:
b1(X), b2(X), . . . , bK(X). Instead of ﬁtting a linear model in X, we ﬁt the
model

basis
function

yi = β0 + β1b1(xi) + β2b2(xi) + β3b3(xi) + . . . + βKbK(xi) + i.

(7.7)

Note that the basis functions b1(·), b2(·), . . . , bK(·) are ﬁxed and known.

(In other words, we choose the functions ahead of time.) For polynomial
regression, the basis functions are bj(xi) = xj
i , and for piecewise constant
functions they are bj(xi) = I(cj ≤ xi < cj+1). We can think of (7.7) as
a standard linear model with predictors b1(xi), b2(xi), . . . , bK(xi). Hence,
we can use least squares to estimate the unknown regression coeﬃcients
in (7.7). Importantly, this means that all of the inference tools for linear
models that are discussed in Chapter 3, such as standard errors for the
coeﬃcient estimates and F-statistics for the model’s overall signiﬁcance,
are available in this setting.

Thus far we have considered the use of polynomial functions and piece-
wise constant functions for our basis functions; however, many alternatives
are possible. For instance, we can use wavelets or Fourier series to construct
basis functions. In the next section, we investigate a very common choice
for a basis function: regression splines.

regression
spline

7.4 Regression Splines

271

7.4 Regression Splines

Now we discuss a ﬂexible class of basis functions that extends upon the
polynomial regression and piecewise constant regression approaches that
we have just seen.

7.4.1 Piecewise Polynomials

Instead of ﬁtting a high-degree polynomial over the entire range of X, piece-
wise polynomial regression involves ﬁtting separate low-degree polynomials
over diﬀerent regions of X. For example, a piecewise cubic polynomial works
by ﬁtting a cubic regression model of the form

piecewise
polynomial
regression

yi = β0 + β1xi + β2x2

i + β3x3

i + i,

(7.8)

where the coeﬃcients β0, β1, β2, and β3 diﬀer in diﬀerent parts of the range
of X. The points where the coeﬃcients change are called knots.

For example, a piecewise cubic with no knots is just a standard cubic
polynomial, as in (7.1) with d = 3. A piecewise cubic polynomial with a
single knot at a point c takes the form

(cid:30)

knot

yi =

β01 + β11xi + β21x2
β02 + β12xi + β22x2

i + β31x3
i + β32x3

i + i
i + i

if xi < c;
if xi ≥ c.

In other words, we ﬁt two diﬀerent polynomial functions to the data, one
on the subset of the observations with xi < c, and one on the subset of
the observations with xi ≥ c. The ﬁrst polynomial function has coeﬃcients
β01, β11, β21, β31, and the second has coeﬃcients β02, β12, β22, β32. Each of
these polynomial functions can be ﬁt using least squares applied to simple
functions of the original predictor.

Using more knots leads to a more ﬂexible piecewise polynomial. In gen-
eral, if we place K diﬀerent knots throughout the range of X, then we
will end up ﬁtting K + 1 diﬀerent cubic polynomials. Note that we do not
need to use a cubic polynomial. For example, we can instead ﬁt piecewise
linear functions. In fact, our piecewise constant functions of Section 7.2 are
piecewise polynomials of degree 0!

The top left panel of Figure 7.3 shows a piecewise cubic polynomial ﬁt to
a subset of the Wage data, with a single knot at age=50. We immediately see
a problem: the function is discontinuous and looks ridiculous! Since each
polynomial has four parameters, we are using a total of eight degrees of
freedom in ﬁtting this piecewise polynomial model.

7.4.2 Constraints and Splines

The top left panel of Figure 7.3 looks wrong because the ﬁtted curve is just
too ﬂexible. To remedy this problem, we can ﬁt a piecewise polynomial

degrees of
freedom

272

7. Moving Beyond Linearity

Piecewise Cubic

Continuous Piecewise Cubic

e
g
a
W

e
g
a
W

0
5
2

0
0
2

0
5
1

0
0
1

0
5

0
5
2

0
0
2

0
5
1

0
0
1

0
5

e
g
a
W

0
5
2

0
0
2

0
5
1

0
0
1

0
5

20

30

40

50

60

70

20

30

40

50

60

70

Age

Cubic Spline

Age

Linear Spline

e
g
a
W

0
5
2

0
0
2

0
5
1

0
0
1

0
5

20

30

40

50

60

70

20

30

40

50

60

70

Age

Age

FIGURE 7.3. Various piecewise polynomials are ﬁt to a subset of the Wage
data, with a knot at age=50. Top Left: The cubic polynomials are unconstrained.
Top Right: The cubic polynomials are constrained to be continuous at age=50.
Bottom Left: The cubic polynomials are constrained to be continuous, and to
have continuous ﬁrst and second derivatives. Bottom Right: A linear spline is
shown, which is constrained to be continuous.

under the constraint that the ﬁtted curve must be continuous. In other
words, there cannot be a jump when age=50. The top right plot in Figure 7.3
shows the resulting ﬁt. This looks better than the top left plot, but the V-
shaped join looks unnatural.

In the lower left plot, we have added two additional constraints: now both
the ﬁrst and second derivatives of the piecewise polynomials are continuous
at age=50. In other words, we are requiring that the piecewise polynomial
be not only continuous when age=50, but also very smooth. Each constraint
that we impose on the piecewise cubic polynomials eﬀectively frees up one
degree of freedom, by reducing the complexity of the resulting piecewise
polynomial ﬁt. So in the top left plot, we are using eight degrees of free-
dom, but in the bottom left plot we imposed three constraints (continuity,
continuity of the ﬁrst derivative, and continuity of the second derivative)
and so are left with ﬁve degrees of freedom. The curve in the bottom left

derivative

7.4 Regression Splines

273

plot is called a cubic spline.3 In general, a cubic spline with K knots uses
a total of 4 + K degrees of freedom.

In Figure 7.3, the lower right plot is a linear spline, which is continuous
at age=50. The general deﬁnition of a degree-d spline is that it is a piecewise
degree-d polynomial, with continuity in derivatives up to degree d − 1 at
each knot. Therefore, a linear spline is obtained by ﬁtting a line in each
region of the predictor space deﬁned by the knots, requiring continuity at
each knot.

In Figure 7.3, there is a single knot at age=50. Of course, we could add

more knots, and impose continuity at each.

cubic spline

linear spline

7.4.3 The Spline Basis Representation

The regression splines that we just saw in the previous section may have
seemed somewhat complex: how can we ﬁt a piecewise degree-d polynomial
under the constraint that it (and possibly its ﬁrst d − 1 derivatives) be
continuous? It turns out that we can use the basis model (7.7) to represent
a regression spline. A cubic spline with K knots can be modeled as

yi = β0 + β1b1(xi) + β2b2(xi) + ··· + βK+3bK+3(xi) + i,

(7.9)

for an appropriate choice of basis functions b1, b2, . . . , bK+3. The model
(7.9) can then be ﬁt using least squares.

truncated
power basis

Just as there were several ways to represent polynomials, there are also
many equivalent ways to represent cubic splines using diﬀerent choices of
basis functions in (7.9). The most direct way to represent a cubic spline
using (7.9) is to start oﬀ with a basis for a cubic polynomial—namely,
x, x2, x3—and then add one truncated power basis function per knot.
A truncated power basis function is deﬁned as
(x − ξ)3

,

h(x, ξ) = (x − ξ)3

+ =

if x > ξ
otherwise,

0

(7.10)

where ξ is the knot. One can show that adding a term of the form β4h(x, ξ)
to the model (7.8) for a cubic polynomial will lead to a discontinuity in
only the third derivative at ξ; the function will remain continuous, with
continuous ﬁrst and second derivatives, at each of the knots.

In other words, in order to ﬁt a cubic spline to a data set with K knots, we
perform least squares regression with an intercept and 3 + K predictors, of
the form X, X 2, X 3, h(X, ξ1), h(X, ξ2), . . . , h(X, ξK), where ξ1, . . . , ξK are
the knots. This amounts to estimating a total of K + 4 regression coeﬃ-
cients; for this reason, ﬁtting a cubic spline with K knots uses K +4 degrees
of freedom.

3Cubic splines are popular because most human eyes cannot detect the discontinuity

at the knots.

Natural Cubic Spline
Cubic Spline

274

7. Moving Beyond Linearity

e
g
a
W

0
5
2

0
0
2

0
5
1

0
0
1

0
5

20

30

40

50

60

70

Age

FIGURE 7.4. A cubic spline and a natural cubic spline, with three knots, ﬁt to
a subset of the Wage data.

Unfortunately, splines can have high variance at the outer range of the
predictors—that is, when X takes on either a very small or very large
value. Figure 7.4 shows a ﬁt to the Wage data with three knots. We see that
the conﬁdence bands in the boundary region appear fairly wild. A natu-
ral spline is a regression spline with additional boundary constraints: the
function is required to be linear at the boundary (in the region where X is
smaller than the smallest knot, or larger than the largest knot). This addi-
tional constraint means that natural splines generally produce more stable
estimates at the boundaries. In Figure 7.4, a natural cubic spline is also
displayed as a red line. Note that the corresponding conﬁdence intervals
are narrower.

natural
spline

7.4.4 Choosing the Number and Locations of the Knots

When we ﬁt a spline, where should we place the knots? The regression
spline is most ﬂexible in regions that contain a lot of knots, because in
those regions the polynomial coeﬃcients can change rapidly. Hence, one
option is to place more knots in places where we feel the function might
vary most rapidly, and to place fewer knots where it seems more stable.
While this option can work well, in practice it is common to place knots in
a uniform fashion. One way to do this is to specify the desired degrees of
freedom, and then have the software automatically place the corresponding
number of knots at uniform quantiles of the data.

Figure 7.5 shows an example on the Wage data. As in Figure 7.4, we
have ﬁt a natural cubic spline with three knots, except this time the knot
locations were chosen automatically as the 25th, 50th, and 75th percentiles

0
0
3

0
5
2

0
0
2

0
5
1

0
0
1

0
5

e
g
a
W

7.4 Regression Splines

275

Natural Cubic Spline

)
e
g
A
 
|

 
0
5
2
>
e
g
a
W

(
r
P

0
2

.

0

5
1

.

0

0
1
0

.

5
0
0

.

0
0

.

0

|

|

|
|
|

|

|
|

|
|

|

|
|
|
|
|

|
|
|
|

|
|
|

|
|
|

|

|
|
|
|
|
|
|

|
|

|
|

|
|
|
|
|

|
|

|
|

|
|
|

|

|
|
|
|

|
|
|

|
|

|
|

|
|

|
|

|
|
|

|
|

|
|

|

|
|

|
|

|

|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
||
|| |
|
|
|
|
| | |
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|| |
|
|
|
| |
|
|
|
||
| |
| |
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| | |
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
| |
| |
|
|
|
|
|
|
|
| ||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
||
|
|
|
|
|
||
|
|
|
|
||
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
||
|
|
|
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
| |
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
| |
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
| |
| |
|
|
|
|
|
|
|
|||
||
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|| | |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
||
|
| ||
|
|
|
|
|
|
|
||
||
| |
|
|
||
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
|
|
||
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
||
|
|
|
|
||
|
|
||
|
|
|
|
|
|
|
|
|
||
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
| |
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|||
|
||
| |
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
| |
|
|
| |
|
|
|
| |
| |
|
|
||
|
|
|
|
|
| |
|
|||
||
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
| |
| |
|
|
|
| |
|
|
|
||
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
| |
|
|
|
|
| |
| |
|
|
||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
||
|
|
|
|
||
|
||
|
|
|
|
| |
|
|
|
| |
|
|
||
|
|
|
||
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| ||
|
|
|
|
| |
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
||
|
|
| |
| |
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
||
|
|
|
|
|
|
|
|
| |
|
|
|| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|
|
||
| |
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
| |
|
|
|
|
|
|
|
| |
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
||
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|

|
|
|
|
|
|
|
|
|
|
|
|

|
|
|
|
|
|
|

|
|
|
|
| |
|
|
|

|
|
|
|
|
|

|
|
|
|
|
|
|
|

|
|
|
|

|
|
|
|
|

|
|
|

|
|

|
|
|

|

|
|
|
|

20

30

40

50

60

70

80

20

30

40

50

60

70

80

Age

Age

FIGURE 7.5. A natural cubic spline function with four degrees of freedom is
ﬁt to the Wage data. Left: A spline is ﬁt to wage (in thousands of dollars) as
a function of age. Right: Logistic regression is used to model the binary event
wage>250 as a function of age. The ﬁtted posterior probability of wage exceeding
$250,000 is shown.

of age. This was speciﬁed by requesting four degrees of freedom. The ar-
gument by which four degrees of freedom leads to three interior knots is
somewhat technical.4

How many knots should we use, or equivalently how many degrees of
freedom should our spline contain? One option is to try out diﬀerent num-
bers of knots and see which produces the best looking curve. A somewhat
more objective approach is to use cross-validation, as discussed in Chap-
ters 5 and 6. With this method, we remove a portion of the data (say 10 %),
ﬁt a spline with a certain number of knots to the remaining data, and then
use the spline to make predictions for the held-out portion. We repeat this
process multiple times until each observation has been left out once, and
then compute the overall cross-validated RSS. This procedure can be re-
peated for diﬀerent numbers of knots K. Then the value of K giving the
smallest RSS is chosen.

4There are actually ﬁve knots, including the two boundary knots. A cubic spline
with ﬁve knots would have nine degrees of freedom. But natural cubic splines have two
additional natural constraints at each boundary to enforce linearity, resulting in 9−4 = 5
degrees of freedom. Since this includes a constant, which is absorbed in the intercept,
we count it as four degrees of freedom.

276

7. Moving Beyond Linearity

0
8
6
1

0
6
6
1

0
4
6
1

0
2
6
1

0
0
6
1

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

0
8
6
1

0
6
6
1

0
4
6
1

0
2
6
1

0
0
6
1

r
o
r
r

 

E
d
e
r
a
u
q
S
n
a
e
M

 

2

4

6

8

10

2

4

6

8

10

Degrees of Freedom of Natural Spline

Degrees of Freedom of Cubic Spline

FIGURE 7.6. Ten-fold cross-validated mean squared errors for selecting the
degrees of freedom when ﬁtting splines to the Wage data. The response is wage
and the predictor age. Left: A natural cubic spline. Right: A cubic spline.

Figure 7.6 shows ten-fold cross-validated mean squared errors for splines
with various degrees of freedom ﬁt to the Wage data. The left-hand panel
corresponds to a natural spline and the right-hand panel to a cubic spline.
The two methods produce almost identical results, with clear evidence that
a one-degree ﬁt (a linear regression) is not adequate. Both curves ﬂatten
out quickly, and it seems that three degrees of freedom for the natural
spline and four degrees of freedom for the cubic spline are quite adequate.
In Section 7.7 we ﬁt additive spline models simultaneously on several
variables at a time. This could potentially require the selection of degrees
of freedom for each variable. In cases like this we typically adopt a more
pragmatic approach and set the degrees of freedom to a ﬁxed number, say
four, for all terms.

7.4.5 Comparison to Polynomial Regression

Regression splines often give superior results to polynomial regression. This
is because unlike polynomials, which must use a high degree (exponent in
the highest monomial term, e.g. X 15) to produce ﬂexible ﬁts, splines intro-
duce ﬂexibility by increasing the number of knots but keeping the degree
ﬁxed. Generally, this approach produces more stable estimates. Splines also
allow us to place more knots, and hence ﬂexibility, over regions where the
function f seems to be changing rapidly, and fewer knots where f appears
more stable. Figure 7.7 compares a natural cubic spline with 15 degrees of
freedom to a degree-15 polynomial on the Wage data set. The extra ﬂexibil-
ity in the polynomial produces undesirable results at the boundaries, while
the natural cubic spline still provides a reasonable ﬁt to the data.

7.5 Smoothing Splines

277

Natural Cubic Spline
Polynomial

0
0
3

0
5
2

0
0
2

0
5
1

0
0
1

0
5

e
g
a
W

20

30

40

50

60

70

80

Age

FIGURE 7.7. On the Wage data set, a natural cubic spline with 15 degrees
of freedom is compared to a degree-15 polynomial. Polynomials can show wild
behavior, especially near the tails.

7.5 Smoothing Splines

7.5.1 An Overview of Smoothing Splines

In the last section we discussed regression splines, which we create by spec-
ifying a set of knots, producing a sequence of basis functions, and then
using least squares to estimate the spline coeﬃcients. We now introduce a
somewhat diﬀerent approach that also produces a spline.

n

(cid:10)

i=1(yi − g(xi))2 to be small. However, there is a problem

In ﬁtting a smooth curve to a set of data, what we really want to do is
ﬁnd some function, say g(x), that ﬁts the observed data well: that is, we
want RSS =
with this approach. If we don’t put any constraints on g(xi), then we can
always make RSS zero simply by choosing g such that it interpolates all
of the yi. Such a function would woefully overﬁt the data—it would be far
too ﬂexible. What we really want is a function g that makes RSS small,
but that is also smooth.

How might we ensure that g is smooth? There are a number of ways to

do this. A natural approach is to ﬁnd the function g that minimizes

n(cid:17)

-

(yi − g(xi))2 + λ

(cid:5)(cid:5)

g

(t)2dt

(7.11)

i=1

where λ is a nonnegative tuning parameter. The function g that minimizes
(7.11) is known as a smoothing spline.

What does (7.11) mean? Equation 7.11 takes the “Loss+Penalty” for-
mulation that we encounter in the context of ridge regression and the lasso
in Chapter 6. The term
ages g to ﬁt the data well, and the term λ

(cid:10)
i=1(yi − g(xi))2 is a loss function that encour-
(t)2dt is a penalty term

.

(cid:5)(cid:5)

g

n

smoothing
spline

loss function

278

7. Moving Beyond Linearity

(cid:5)(cid:5)

(cid:5)

.

.

(cid:5)(cid:5)

g

(t) will be close to constant and

(t) indicates the second
that penalizes the variability in g. The notation g
(cid:5)
derivative of the function g. The ﬁrst derivative g
(t) measures the slope
of a function at t, and the second derivative corresponds to the amount by
which the slope is changing. Hence, broadly speaking, the second derivative
of a function is a measure of its roughness: it is large in absolute value if
g(t) is very wiggly near t, and it is close to zero otherwise. (The second
derivative of a straight line is zero; note that a line is perfectly smooth.)
notation is an integral , which we can think of as a summation over
The
(t)2dt is simply a measure of the total
the range of t. In other words,
.
change in the function g
(t), over its entire range. If g is very smooth, then
(cid:5)
(t)2dt will take on a small value.
g
.
(t) will vary signiﬁcantly and
Conversely, if g is jumpy and variable then g
(t)2dt en-
courages g to be smooth. The larger the value of λ, the smoother g will be.
When λ = 0, then the penalty term in (7.11) has no eﬀect, and so the
function g will be very jumpy and will exactly interpolate the training
observations. When λ → ∞, g will be perfectly smooth—it will just be
a straight line that passes as closely as possible to the training points.
In fact, in this case, g will be the linear least squares line, since the loss
function in (7.11) amounts to minimizing the residual sum of squares. For
an intermediate value of λ, g will approximate the training observations
but will be somewhat smooth. We see that λ controls the bias-variance
trade-oﬀ of the smoothing spline.

(t)2dt will take on a large value. Therefore, in (7.11), λ

(cid:5)(cid:5)

g

(cid:5)(cid:5)

g

(cid:5)

.

(cid:5)(cid:5)

g

The function g(x) that minimizes (7.11) can be shown to have some spe-
cial properties: it is a piecewise cubic polynomial with knots at the unique
values of x1, . . . , xn, and continuous ﬁrst and second derivatives at each
knot. Furthermore, it is linear in the region outside of the extreme knots.
In other words, the function g(x) that minimizes (7.11) is a natural cubic
spline with knots at x1, . . . , xn! However, it is not the same natural cubic
spline that one would get if one applied the basis function approach de-
scribed in Section 7.4.3 with knots at x1, . . . , xn—rather, it is a shrunken
version of such a natural cubic spline, where the value of the tuning pa-
rameter λ in (7.11) controls the level of shrinkage.

7.5.2 Choosing the Smoothing Parameter λ

We have seen that a smoothing spline is simply a natural cubic spline
with knots at every unique value of xi. It might seem that a smoothing
spline will have far too many degrees of freedom, since a knot at each data
point allows a great deal of ﬂexibility. But the tuning parameter λ controls
the roughness of the smoothing spline, and hence the eﬀective degrees of
freedom. It is possible to show that as λ increases from 0 to ∞, the eﬀective
degrees of freedom, which we write dfλ, decrease from n to 2.

In the context of smoothing splines, why do we discuss eﬀective degrees
of freedom instead of degrees of freedom? Usually degrees of freedom refer

eﬀective
degrees of
freedom

7.5 Smoothing Splines

279

to the number of free parameters, such as the number of coeﬃcients ﬁt in a
polynomial or cubic spline. Although a smoothing spline has n parameters
and hence n nominal degrees of freedom, these n parameters are heavily
constrained or shrunk down. Hence dfλ is a measure of the ﬂexibility of the
smoothing spline—the higher it is, the more ﬂexible (and the lower-bias but
higher-variance) the smoothing spline. The deﬁnition of eﬀective degrees of
freedom is somewhat technical. We can write

ˆgλ = Sλy,

(7.12)

where ˆg is the solution to (7.11) for a particular choice of λ—that is, it is a
n-vector containing the ﬁtted values of the smoothing spline at the training
points x1, . . . , xn. Equation 7.12 indicates that the vector of ﬁtted values
when applying a smoothing spline to the data can be written as a n × n
matrix Sλ (for which there is a formula) times the response vector y. Then
the eﬀective degrees of freedom is deﬁned to be

n(cid:17)

dfλ =

i=1

{Sλ}ii,

(7.13)

the sum of the diagonal elements of the matrix Sλ.

In ﬁtting a smoothing spline, we do not need to select the number or
location of the knots—there will be a knot at each training observation,
x1, . . . , xn. Instead, we have another problem: we need to choose the value
of λ. It should come as no surprise that one possible solution to this problem
is cross-validation. In other words, we can ﬁnd the value of λ that makes
the cross-validated RSS as small as possible. It turns out that the leave-
one-out cross-validation error (LOOCV) can be computed very eﬃciently
for smoothing splines, with essentially the same cost as computing a single
ﬁt, using the following formula:

RSScv(λ) =

(yi − ˆg(−i)

λ

(xi))2 =

n(cid:17)

i=1

(cid:20)

n(cid:17)

i=1

yi − ˆgλ(xi)
1 − {Sλ}ii

(cid:21)2

.

λ

The notation ˆg(−i)
(xi) indicates the ﬁtted value for this smoothing spline
evaluated at xi, where the ﬁt uses all of the training observations except
for the ith observation (xi, yi). In contrast, ˆgλ(xi) indicates the smoothing
spline function ﬁt to all of the training observations and evaluated at xi.
This remarkable formula says that we can compute each of these leave-
one-out ﬁts using only ˆgλ, the original ﬁt to all of the data!5 We have
a very similar formula (5.2) on page 180 in Chapter 5 for least squares
linear regression. Using (5.2), we can very quickly perform LOOCV for
the regression splines discussed earlier in this chapter, as well as for least
squares regression using arbitrary basis functions.

5The exact formulas for computing ˆg(xi) and Sλ are very technical; however, eﬃcient

algorithms are available for computing these quantities.

280

7. Moving Beyond Linearity

Smoothing Spline

16 Degrees of Freedom
6.8 Degrees of Freedom (LOOCV)

e
g
a
W

0
0
3

0
0
2

0
0
1

0
5

0

20

30

40

50

Age

60

70

80

FIGURE 7.8. Smoothing spline ﬁts to the Wage data. The red curve results
from specifying 16 eﬀective degrees of freedom. For the blue curve, λ was found
automatically by leave-one-out cross-validation, which resulted in 6.8 eﬀective
degrees of freedom.

Figure 7.8 shows the results from ﬁtting a smoothing spline to the Wage
data. The red curve indicates the ﬁt obtained from pre-specifying that we
would like a smoothing spline with 16 eﬀective degrees of freedom. The blue
curve is the smoothing spline obtained when λ is chosen using LOOCV; in
this case, the value of λ chosen results in 6.8 eﬀective degrees of freedom
(computed using (7.13)). For this data, there is little discernible diﬀerence
between the two smoothing splines, beyond the fact that the one with 16
degrees of freedom seems slightly wigglier. Since there is little diﬀerence
between the two ﬁts, the smoothing spline ﬁt with 6.8 degrees of freedom
is preferable, since in general simpler models are better unless the data
provides evidence in support of a more complex model.

7.6 Local Regression

Local regression is a diﬀerent approach for ﬁtting ﬂexible non-linear func-
tions, which involves computing the ﬁt at a target point x0 using only the
nearby training observations. Figure 7.9 illustrates the idea on some simu-
lated data, with one target point near 0.4, and another near the boundary
at 0.05. In this ﬁgure the blue line represents the function f (x) from which
the data were generated, and the light orange line corresponds to the local
regression estimate ˆf (x). Local regression is described in Algorithm 7.1.

Note that in Step 3 of Algorithm 7.1, the weights Ki0 will diﬀer for each
value of x0. In other words, in order to obtain the local regression ﬁt at a
new point, we need to ﬁt a new weighted least squares regression model by

local
regression

7.6 Local Regression

281

Local Regression

5

.

1

0

.

1

5
0

.

0
0

.

5
.
0
−

0
.
1
−

O
OO
O
OO
O

O
O
O
O
O
O
O

O
O
O
OO
O
O
O
O

O

O
O

O
O
O
OO
O
O
O
O
O
O
O
OO
O
O
OO
OO
O
O
O

O

OO
O
O

O
O
O
O
O
O
OOO
OOO
O
O
O
O
O
O
O
O
O
O

O
O

O
O
O
O
O
O
O
O
OO
OO

O
O

O
O

O
O

O

O
O

O

O
O
OO
O

O
O
O

O

O
O

OO
O

O

O
O
OO
O
O

O

5

.

1

0

.

1

5
0

.

0
0

.

5
.
0
−

0
.
1
−

O
O
OO
OO
O
O
OO
OO
O
O

O
O
O
O
O
O
O
O
O
O
O
O

O
O
O
O
O
O
OO
OO
O
O
O
O
O
O
O
O

O
O

O
O
O
O

O
O
O
O
O
O
OO
OO
O
O
O
O
O
O
O
O
O
O
O
O
O
O
OO
OO
O
O
O
O
OO
OO
OO
OO
O
O
O
O
O
O

O
O

OO
O
O
O

O
O
O
OOO
O
O
O
O
O

O

O
O
O
O
OO

O

O

O

O

O
O

O

O
O
OO
O

O
O
O

O

O
O

OO
O

O

O
O
OO
O
O

O

0.0

0.2

0.4

0.6

0.8

1.0

0.0

0.2

0.4

0.6

0.8

1.0

FIGURE 7.9. Local regression illustrated on some simulated data, where the
blue curve represents f (x) from which the data were generated, and the light
orange curve corresponds to the local regression estimate ˆf (x). The orange colored
points are local to the target point x0, represented by the orange vertical line.
The yellow bell-shape superimposed on the plot indicates weights assigned to each
point, decreasing to zero with distance from the target point. The ﬁt ˆf (x0) at x0 is
obtained by ﬁtting a weighted linear regression (orange line segment), and using
the ﬁtted value at x0 (orange solid dot) as the estimate ˆf (x0).

minimizing (7.14) for a new set of weights. Local regression is sometimes
referred to as a memory-based procedure, because like nearest-neighbors, we
need all the training data each time we wish to compute a prediction. We
will avoid getting into the technical details of local regression here—there
are books written on the topic.

In order to perform local regression, there are a number of choices to be
made, such as how to deﬁne the weighting function K, and whether to ﬁt
a linear, constant, or quadratic regression in Step 3 above. (Equation 7.14
corresponds to a linear regression.) While all of these choices make some
diﬀerence, the most important choice is the span s, deﬁned in Step 1 above.
The span plays a role like that of the tuning parameter λ in smoothing
splines: it controls the ﬂexibility of the non-linear ﬁt. The smaller the value
of s, the more local and wiggly will be our ﬁt; alternatively, a very large
value of s will lead to a global ﬁt to the data using all of the training
observations. We can again use cross-validation to choose s, or we can
specify it directly. Figure 7.10 displays local linear regression ﬁts on the
Wage data, using two values of s: 0.7 and 0.2. As expected, the ﬁt obtained
using s = 0.7 is smoother than that obtained using s = 0.2.

The idea of local regression can be generalized in many diﬀerent ways.
In a setting with multiple features X1, X2, . . . , Xp, one very useful general-
ization involves ﬁtting a multiple linear regression model that is global in
some variables, but local in another, such as time. Such varying coeﬃcient

282

7. Moving Beyond Linearity

Algorithm 7.1 Local Regression At X = x0

1. Gather the fraction s = k/n of training points whose xi are closest

to x0.

2. Assign a weight Ki0 = K(xi, x0) to each point in this neighborhood,
so that the point furthest from x0 has weight zero, and the closest
has the highest weight. All but these k nearest neighbors get weight
zero.

3. Fit a weighted least squares regression of the yi on the xi using the

aforementioned weights, by ﬁnding ˆβ0 and ˆβ1 that minimize

n(cid:17)

Ki0(yi − β0 − β1xi)2.

(7.14)

i=1

4. The ﬁtted value at x0 is given by ˆf (x0) = ˆβ0 + ˆβ1x0.

models are a useful way of adapting a model to the most recently gathered
data. Local regression also generalizes very naturally when we want to ﬁt
models that are local in a pair of variables X1 and X2, rather than one.
We can simply use two-dimensional neighborhoods, and ﬁt bivariate linear
regression models using the observations that are near each target point
in two-dimensional space. Theoretically the same approach can be imple-
mented in higher dimensions, using linear regressions ﬁt to p-dimensional
neighborhoods. However, local regression can perform poorly if p is much
larger than about 3 or 4 because there will generally be very few training
observations close to x0. Nearest-neighbors regression, discussed in Chap-
ter 3, suﬀers from a similar problem in high dimensions.

varying
coeﬃcient
model

7.7 Generalized Additive Models

In Sections 7.1–7.6, we present a number of approaches for ﬂexibly predict-
ing a response Y on the basis of a single predictor X. These approaches can
be seen as extensions of simple linear regression. Here we explore the prob-
lem of ﬂexibly predicting Y on the basis of several predictors, X1, . . . , Xp.
This amounts to an extension of multiple linear regression.

Generalized additive models (GAMs) provide a general framework for
extending a standard linear model by allowing non-linear functions of each
of the variables, while maintaining additivity. Just like linear models, GAMs
can be applied with both quantitative and qualitative responses. We ﬁrst
examine GAMs for a quantitative response in Section 7.7.1, and then for a
qualitative response in Section 7.7.2.

generalized
additive
model
additivity

7.7 Generalized Additive Models

283

Local Linear Regression

Span is 0.2  (16.4 Degrees of Freedom)
Span is 0.7  (5.3 Degrees of Freedom)

e
g
a
W

0
0
3

0
0
2

0
0
1

0
5

0

20

30

40

50

Age

60

70

80

FIGURE 7.10. Local linear ﬁts to the Wage data. The span speciﬁes the fraction
of the data used to compute the ﬁt at each target point.

7.7.1 GAMs for Regression Problems

A natural way to extend the multiple linear regression model

yi = β0 + β1xi1 + β2xi2 + ··· + βpxip + i

in order to allow for non-linear relationships between each feature and the
response is to replace each linear component βjxij with a (smooth) non-
linear function fj(xij ). We would then write the model as

p(cid:17)

yi = β0 +

fj(xij ) + i

j=1

= β0 + f1(xi1) + f2(xi2) + ··· + fp(xip) + i.

(7.15)

This is an example of a GAM. It is called an additive model because we
calculate a separate fj for each Xj, and then add together all of their
contributions.

In Sections 7.1–7.6, we discuss many methods for ﬁtting functions to a
single variable. The beauty of GAMs is that we can use these methods
as building blocks for ﬁtting an additive model. In fact, for most of the
methods that we have seen so far in this chapter, this can be done fairly
trivially. Take, for example, natural splines, and consider the task of ﬁtting
the model

wage = β0 + f1(year) + f2(age) + f3(education) + 

(7.16)

284

7. Moving Beyond Linearity

<HS HS

<Coll

Coll >Coll

)
r
a
e
y
(
1
f

0
3

0
2

0
1

0

0
1
−

0
2
−

0
3
−

)
e
g
a
(
2
f

0
2

0
1

0

0
1
−

0
2
−

0
3
−

0
4
−

0
5
−

)
n
o
i
t
a
c
u
d
e
(
3
f

0
4

0
3

0
2

0
1

0

0
1
−

0
2
−

0
3
−

2003

2005

2007

2009

20

30

40

year

60

70

80

50
age

education

FIGURE 7.11. For the Wage data, plots of the relationship between each feature
and the response, wage, in the ﬁtted model (7.16). Each plot displays the ﬁtted
function and pointwise standard errors. The ﬁrst two functions are natural splines
in year and age, with four and ﬁve degrees of freedom, respectively. The third
function is a step function, ﬁt to the qualitative variable education.

on the Wage data. Here year and age are quantitative variables, and
education is a qualitative variable with ﬁve levels: <HS, HS, <Coll, Coll,
>Coll, referring to the amount of high school or college education that
an individual has completed. We ﬁt the ﬁrst two functions using natural
splines. We ﬁt the third function using a separate constant for each level,
via the usual dummy variable approach of Section 3.3.1.

Figure 7.11 shows the results of ﬁtting the model (7.16) using least
squares. This is easy to do, since as discussed in Section 7.4, natural splines
can be constructed using an appropriately chosen set of basis functions.
Hence the entire model is just a big regression onto spline basis variables
and dummy variables, all packed into one big regression matrix.

Figure 7.11 can be easily interpreted. The left-hand panel indicates that
holding age and education ﬁxed, wage tends to increase slightly with year;
this may be due to inﬂation. The center panel indicates that holding
education and year ﬁxed, wage tends to be highest for intermediate val-
ues of age, and lowest for the very young and very old. The right-hand
panel indicates that holding year and age ﬁxed, wage tends to increase
with education: the more educated a person is, the higher their salary, on
average. All of these ﬁndings are intuitive.

Figure 7.12 shows a similar triple of plots, but this time f1 and f2 are
smoothing splines with four and ﬁve degrees of freedom, respectively. Fit-
ting a GAM with a smoothing spline is not quite as simple as ﬁtting a GAM
with a natural spline, since in the case of smoothing splines, least squares
cannot be used. However, standard software such as the gam() function in R
can be used to ﬁt GAMs using smoothing splines, via an approach known
as backﬁtting. This method ﬁts a model involving multiple predictors by

backﬁtting

7.7 Generalized Additive Models

285

<HS HS

<Coll

Coll >Coll

)
r
a
e
y
(
1
f

0
3

0
2

0
1

0

0
1
−

0
2
−

0
3
−

)
e
g
a
(
2
f

0
2

0
1

0

0
1
−

0
2
−

0
3
−

0
4
−

0
5
−

)
n
o
i
t
a
c
u
d
e
(
3
f

0
4

0
3

0
2

0
1

0

0
1
−

0
2
−

0
3
−

2003

2005

2007

2009

20

30

40

year

60

70

80

50
age

education

FIGURE 7.12. Details are as in Figure 7.11, but now f1 and f2 are smoothing
splines with four and ﬁve degrees of freedom, respectively.

repeatedly updating the ﬁt for each predictor in turn, holding the others
ﬁxed. The beauty of this approach is that each time we update a function,
we simply apply the ﬁtting method for that variable to a partial residual.6
The ﬁtted functions in Figures 7.11 and 7.12 look rather similar. In most
situations, the diﬀerences in the GAMs obtained using smoothing splines
versus natural splines are small.

We do not have to use splines as the building blocks for GAMs: we can
just as well use local regression, polynomial regression, or any combination
of the approaches seen earlier in this chapter in order to create a GAM.
GAMs are investigated in further detail in the lab at the end of this chapter.

Pros and Cons of GAMs

Before we move on, let us summarize the advantages and limitations of a
GAM.

▲ GAMs allow us to ﬁt a non-linear fj to each Xj, so that we can
automatically model non-linear relationships that standard linear re-
gression will miss. This means that we do not need to manually try
out many diﬀerent transformations on each variable individually.

▲ The non-linear ﬁts can potentially make more accurate predictions

for the response Y .

▲ Because the model is additive, we can still examine the eﬀect of
each Xj on Y individually while holding all of the other variables
ﬁxed. Hence if we are interested in inference, GAMs provide a useful
representation.

6A partial residual for X3, for example, has the form ri = yi − f1(xi1) − f2(xi2).
If we know f1 and f2, then we can ﬁt f3 by treating this residual as a response in a
non-linear regression on X3.

286

7. Moving Beyond Linearity

▲ The smoothness of the function fj for the variable Xj can be sum-

marized via degrees of freedom.

◆ The main limitation of GAMs is that the model is restricted to be
additive. With many variables, important interactions can be missed.
However, as with linear regression, we can manually add interaction
terms to the GAM model by including additional predictors of the

form Xj × Xk. In addition we can add low-dimensional interaction
functions of the form fjk(Xj , Xk) into the model; such terms can
be ﬁt using two-dimensional smoothers such as local regression, or
two-dimensional splines (not covered here).

For fully general models, we have to look for even more ﬂexible approaches
such as random forests and boosting, described in Chapter 8. GAMs provide
a useful compromise between linear and fully nonparametric models.

7.7.2 GAMs for Classiﬁcation Problems

GAMs can also be used in situations where Y is qualitative. For simplicity,
here we will assume Y takes on values zero or one, and let p(X) = Pr(Y =
1|X) be the conditional probability (given the predictors) that the response
equals one. Recall the logistic regression model (4.6):

(cid:11)

(cid:12)

log

p(X)
1 − p(X)

(cid:11)

(cid:12)

= β0 + β1X1 + β2X2 + ··· + βpXp.

(7.17)

This logit is the log of the odds of P (Y = 1|X) versus P (Y = 0|X), which
(7.17) represents as a linear function of the predictors. A natural way to
extend (7.17) to allow for non-linear relationships is to use the model

log

p(X)
1 − p(X)

= β0 + f1(X1) + f2(X2) + ··· + fp(Xp).

(7.18)

Equation 7.18 is a logistic regression GAM. It has all the same pros and
cons as discussed in the previous section for quantitative responses.

We ﬁt a GAM to the Wage data in order to predict the probability that
an individual’s income exceeds $250,000 per year. The GAM that we ﬁt
takes the form

= β0 + β1 × year + f2(age) + f3(education),

(7.19)

(cid:11)

(cid:12)

p(X)
1 − p(X)

log

where

p(X) = Pr(wage > 250|year, age, education).

7.8 Lab: Non-linear Modeling

287

<HS HS

<Coll

Coll >Coll

)
r
a
e
y
(
1
f

4

2

0

2
−

4
−

)
e
g
a
(
2
f

2

0

2
−

4
−

6
−

8
−

)
n
o
i
t
a
c
u
d
e
(
3
f

0
0
4

0
0
2

0

0
0
2
−

0
0
4
−

2003

2005

2007

2009

20

30

40

year

60

70

80

50
age

education

FIGURE 7.13. For the Wage data, the logistic regression GAM given in (7.19)
is ﬁt to the binary response I(wage>250). Each plot displays the ﬁtted function
and pointwise standard errors. The ﬁrst function is linear in year, the second
function a smoothing spline with ﬁve degrees of freedom in age, and the third a
step function for education. There are very wide standard errors for the ﬁrst
level <HS of education.

Once again f2 is ﬁt using a smoothing spline with ﬁve degrees of freedom,
and f3 is ﬁt as a step function, by creating dummy variables for each of
the levels of education. The resulting ﬁt is shown in Figure 7.13. The last
panel looks suspicious, with very wide conﬁdence intervals for level <HS. In
fact, there are no ones for that category: no individuals with less than a
high school education make more than $250,000 per year. Hence we reﬁt
the GAM, excluding the individuals with less than a high school education.
The resulting model is shown in Figure 7.14. As in Figures 7.11 and 7.12,
all three panels have the same vertical scale. This allows us to visually
assess the relative contributions of each of the variables. We observe that
age and education have a much larger eﬀect than year on the probability
of being a high earner.

7.8 Lab: Non-linear Modeling

In this lab, we re-analyze the Wage data considered in the examples through-
out this chapter, in order to illustrate the fact that many of the complex
non-linear ﬁtting procedures discussed can be easily implemented in R. We
begin by loading the ISLR library, which contains the data.

> library ( ISLR )
> attach ( Wage )

288

7. Moving Beyond Linearity

HS

<Coll

Coll

>Coll

)
r
a
e
y
(
1
f

4

2

0

2
−

4
−

)
e
g
a
(
2
f

2

0

2
−

4
−

6
−

8
−

)
n
o
i
t
a
c
u
d
e
(
3
f

4

2

0

2
−

4
−

2003

2005

2007

2009

20

30

40

ryea

60

70

80

50
age

education

FIGURE 7.14. The same model is ﬁt as in Figure 7.13, this time excluding the
observations for which education is <HS. Now we see that increased education
tends to be associated with higher salaries.

7.8.1 Polynomial Regression and Step Functions

We now examine how Figure 7.1 was produced. We ﬁrst ﬁt the model using
the following command:
> fit = lm ( wage∼poly ( age ,4) , data = Wage )

> coef ( summary ( fit ) )

111.704
( Intercept )
poly ( age , 4) 1
447.068
poly ( age , 4) 2 -478.316
125.522
poly ( age , 4) 3
poly ( age , 4) 4
-77.911

Estimate Std . Error t value Pr ( >| t |)
<2e -16
<2e -16
<2e -16
0.0017
0.0510

153.28
11.20
-11.98
3.14
-1.95

0.729
39.915
39.915
39.915
39.915

This syntax ﬁts a linear model, using the lm() function, in order to predict
wage using a fourth-degree polynomial in age: poly(age,4). The poly() com-
mand allows us to avoid having to write out a long formula with powers
of age. The function returns a matrix whose columns are a basis of or-
thogonal polynomials, which essentially means that each column is a linear
combination of the variables age, age^2, age^3 and age^4.

However, we can also use poly() to obtain age, age^2, age^3 and age^4
directly, if we prefer. We can do this by using the raw=TRUE argument to
the poly() function. Later we see that this does not aﬀect the model in a
meaningful way—though the choice of basis clearly aﬀects the coeﬃcient
estimates, it does not aﬀect the ﬁtted values obtained.
> fit2 = lm ( wage∼poly ( age ,4 , raw = T ) , data = Wage )

> coef ( summary ( fit2 ) )

orthogonal
polynomial

-1.84 e +02
( Intercept )
poly ( age , 4 , raw = T ) 1
2.12 e +01
poly ( age , 4 , raw = T ) 2 -5.64 e -01

Estimate Std . Error t value Pr ( >| t |)
-3.07 0.002180
3.61 0.000312
-2.74 0.006261

6.00 e +01
5.89 e +00
2.06 e -01

7.8 Lab: Non-linear Modeling

289

poly ( age , 4 , raw = T ) 3
6.81 e -03
poly ( age , 4 , raw = T ) 4 -3.20 e -05

3.07 e -03
1.64 e -05

2.22 0.026398
-1.95 0.051039

There are several other equivalent ways of ﬁtting this model, which show-

case the ﬂexibility of the formula language in R. For example
> fit2a = lm ( wage∼age + I ( age ^2) + I ( age ^3) + I ( age ^4) , data = Wage )

> coef ( fit2a )
( Intercept )
-1.84 e +02

age
2.12 e +01

I ( age ^2)
-5.64 e -01

I ( age ^3)
6.81 e -03

I ( age ^4)
-3.20 e -05

This simply creates the polynomial basis functions on the ﬂy, taking care
to protect terms like age^2 via the wrapper function I() (the ^ symbol has wrapper
a special meaning in formulas).
> fit2b = lm ( wage∼cbind ( age , age ^2 , age ^3 , age ^4) , data = Wage )
This does the same more compactly, using the cbind() function for building
a matrix from a collection of vectors; any function call such as cbind() inside
a formula also serves as a wrapper.

We now create a grid of values for age at which we want predictions, and
then call the generic predict() function, specifying that we want standard
errors as well.

> agelims = range ( age )
> age . grid = seq ( from = agelims [1] , to = agelims [2])
> preds = predict ( fit , newdata = list ( age = age . grid ) , se = TRUE )
> se . bands = cbind ( preds$fit +2* preds$se . fit , preds$fit -2* preds$se .

fit )

Finally, we plot the data and add the ﬁt from the degree-4 polynomial.

> par ( mfrow = c (1 ,2) , mar = c (4.5 ,4.5 ,1 ,1) , oma = c (0 ,0 ,4 ,0) )
> plot ( age , wage , xlim = agelims , cex =.5 , col =" darkgrey ")
> title (" Degree -4 Polynomial " , outer = T )
> lines ( age . grid , preds$fit , lwd =2 , col =" blue ")
> matlines ( age . grid , se . bands , lwd =1 , col =" blue " , lty =3)

Here the mar and oma arguments to par() allow us to control the margins
of the plot, and the title() function creates a ﬁgure title that spans both
subplots.

We mentioned earlier that whether or not an orthogonal set of basis func-
tions is produced in the poly() function will not aﬀect the model obtained
in a meaningful way. What do we mean by this? The ﬁtted values obtained
in either case are identical:

title()

> preds2 = predict ( fit2 , newdata = list ( age = age . grid ) , se = TRUE )
> max ( abs ( preds$fit - preds2$fit ) )
[1] 7.39 e -13

In performing a polynomial regression we must decide on the degree of
the polynomial to use. One way to do this is by using hypothesis tests. We
now ﬁt models ranging from linear to a degree-5 polynomial and seek to
determine the simplest model which is suﬃcient to explain the relationship

290

7. Moving Beyond Linearity

anova()

analysis of
variance

between wage and age. We use the anova() function, which performs an
analysis of variance (ANOVA, using an F-test) in order to test the null

hypothesis that a model M1 is suﬃcient to explain the data against the
alternative hypothesis that a more complex model M2 is required. In order
to use the anova() function, M1 and M2 must be nested models: the
predictors in M1 must be a subset of the predictors in M2. In this case,

we ﬁt ﬁve diﬀerent models and sequentially compare the simpler model to
the more complex model.
> fit .1= lm ( wage∼age , data = Wage )
> fit .2= lm ( wage∼poly ( age ,2) , data = Wage )
> fit .3= lm ( wage∼poly ( age ,3) , data = Wage )
> fit .4= lm ( wage∼poly ( age ,4) , data = Wage )
> fit .5= lm ( wage∼poly ( age ,5) , data = Wage )

> anova ( fit .1 , fit .2 , fit .3 , fit .4 , fit .5)
Analysis of Variance Table

Model 1: wage ∼ age
Model 2: wage ∼ poly ( age , 2)
Model 3: wage ∼ poly ( age , 3)
Model 4: wage ∼ poly ( age , 4)
Model 5: wage ∼ poly ( age , 5)

Res . Df

RSS Df Sum of Sq

F Pr ( > F )

2998 5022216
2997 4793430
2996 4777674
2995 4771604
2994 4770322

1
2
3
4
5
---
Signif . codes :

1
1
1
1

228786 143.59 <2e -16 ***

15756
6070
1283

9.89 0.0017 **
3.81 0.0510 .
0.80 0.3697

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

The p-value comparing the linear Model 1 to the quadratic Model 2 is
−15), indicating that a linear ﬁt is not suﬃcient. Sim-
essentially zero (<10
ilarly the p-value comparing the quadratic Model 2 to the cubic Model 3
is very low (0.0017), so the quadratic ﬁt is also insuﬃcient. The p-value
comparing the cubic and degree-4 polynomials, Model 3 and Model 4, is ap-
proximately 5 % while the degree-5 polynomial Model 5 seems unnecessary
because its p-value is 0.37. Hence, either a cubic or a quartic polynomial
appear to provide a reasonable ﬁt to the data, but lower- or higher-order
models are not justiﬁed.

In this case, instead of using the anova() function, we could have obtained
these p-values more succinctly by exploiting the fact that poly() creates
orthogonal polynomials.

> coef ( summary ( fit .5) )

Estimate Std . Error

( Intercept )
poly ( age , 5) 1
poly ( age , 5) 2
poly ( age , 5) 3

111.70
447.07
-478.32
125.52

t value

Pr ( >| t |)
0.7288 153.2780 0.000 e +00
11.2002 1.491 e -28
39.9161
39.9161 -11.9830 2.368 e -32
39.9161
3.1446 1.679 e -03

7.8 Lab: Non-linear Modeling

291

poly ( age , 5) 4
poly ( age , 5) 5

-77.91
-35.81

39.9161
39.9161

-1.9519 5.105 e -02
-0.8972 3.697 e -01

Notice that the p-values are the same, and in fact the square of the
t-statistics are equal to the F-statistics from the anova() function; for
example:

> ( -11.983) ^2
[1] 143.6

However, the ANOVA method works whether or not we used orthogonal
polynomials; it also works when we have other terms in the model as well.
For example, we can use anova() to compare these three models:
> fit .1= lm ( wage∼education + age , data = Wage )
> fit .2= lm ( wage∼education + poly ( age ,2) , data = Wage )
> fit .3= lm ( wage∼education + poly ( age ,3) , data = Wage )

> anova ( fit .1 , fit .2 , fit .3)

As an alternative to using hypothesis tests and ANOVA, we could choose

the polynomial degree using cross-validation, as discussed in Chapter 5.

Next we consider the task of predicting whether an individual earns more
than $250,000 per year. We proceed much as before, except that ﬁrst we
create the appropriate response vector, and then apply the glm() function
using family="binomial" in order to ﬁt a polynomial logistic regression
model.
> fit = glm ( I ( wage >250)∼poly ( age ,4) , data = Wage , family = binomial )

Note that we again use the wrapper I() to create this binary response
variable on the ﬂy. The expression wage>250 evaluates to a logical variable
containing TRUEs and FALSEs, which glm() coerces to binary by setting the
TRUEs to 1 and the FALSEs to 0.

Once again, we make predictions using the predict() function.

> preds = predict ( fit , newdata = list ( age = age . grid ) , se = T )

However, calculating the conﬁdence intervals is slightly more involved than
in the linear regression case. The default prediction type for a glm() model
is type="link", which is what we use here. This means we get predictions
for the logit: that is, we have ﬁt a model of the form

(cid:11)

log

(cid:12)

Pr(Y = 1|X)
1 − Pr(Y = 1|X)

= Xβ,

and the predictions given are of the form X ˆβ. The standard errors given are
also of this form. In order to obtain conﬁdence intervals for Pr(Y = 1|X),
we use the transformation

Pr(Y = 1|X) =

exp(Xβ)

1 + exp(Xβ)

.

292

7. Moving Beyond Linearity

> pfit = exp ( preds$fit ) /(1+ exp ( preds$fit ) )
> se . bands . logit = cbind ( preds$fit +2* preds$se . fit , preds$fit -2*

preds$se . fit )

> se . bands = exp ( se . bands . logit ) /(1+ exp ( se . bands . logit ) )

Note that we could have directly computed the probabilities by selecting
the type="response" option in the predict() function.

> preds = predict ( fit , newdata = list ( age = age . grid ) , type =" response " ,

se = T )

However, the corresponding conﬁdence intervals would not have been sen-
sible because we would end up with negative probabilities!

Finally, the right-hand plot from Figure 7.1 was made as follows:

> plot ( age , I ( wage >250) , xlim = agelims , type =" n " , ylim = c (0 ,.2) )
> points ( jitter ( age ) , I (( wage >250) /5) , cex =.5 , pch ="|" ,

col =" darkgrey ")

> lines ( age . grid , pfit , lwd =2 , col =" blue ")
> matlines ( age . grid , se . bands , lwd =1 , col =" blue " , lty =3)

We have drawn the age values corresponding to the observations with wage
values above 250 as gray marks on the top of the plot, and those with wage
values below 250 are shown as gray marks on the bottom of the plot. We
used the jitter() function to jitter the age values a bit so that observations
with the same age value do not cover each other up. This is often called a
rug plot.

In order to ﬁt a step function, as discussed in Section 7.2, we use the

cut() function.

jitter()

rug plot

cut()

> table ( cut ( age ,4) )
(17.9 ,33.5]
750

(33.5 ,49]
1399

> fit = lm ( wage∼cut ( age ,4) , data = Wage )

(49 ,64.5] (64.5 ,80.1]
72

779

> coef ( summary ( fit ) )

( Intercept )
cut ( age , 4) (33.5 ,49]
cut ( age , 4) (49 ,64.5]
cut ( age , 4) (64.5 ,80.1]

Estimate Std . Error t value Pr ( >| t |)
63.79 0.00 e +00
13.15 1.98 e -38
11.44 1.04 e -29
1.53 1.26 e -01

94.16
24.05
23.66
7.64

1.48
1.83
2.07
4.99

Here cut() automatically picked the cutpoints at 33.5, 49, and 64.5 years
of age. We could also have speciﬁed our own cutpoints directly using the
breaks option. The function cut() returns an ordered categorical variable;
the lm() function then creates a set of dummy variables for use in the re-
gression. The age<33.5 category is left out, so the intercept coeﬃcient of
$94,160 can be interpreted as the average salary for those under 33.5 years
of age, and the other coeﬃcients can be interpreted as the average addi-
tional salary for those in the other age groups. We can produce predictions
and plots just as we did in the case of the polynomial ﬁt.

7.8 Lab: Non-linear Modeling

293

7.8.2 Splines

In order to ﬁt regression splines in R, we use the splines library. In Section
7.4, we saw that regression splines can be ﬁt by constructing an appropriate
matrix of basis functions. The bs() function generates the entire matrix of
basis functions for splines with the speciﬁed set of knots. By default, cubic
splines are produced. Fitting wage to age using a regression spline is simple:

bs()

> library ( splines )

> fit = lm ( wage∼bs ( age , knots = c (25 ,40 ,60) ) , data = Wage )

> pred = predict ( fit , newdata = list ( age = age . grid ) , se = T )
> plot ( age , wage , col =" gray ")
> lines ( age . grid , pred$fit , lwd =2)
> lines ( age . grid , pred$fit +2* pred$se , lty =" dashed ")
> lines ( age . grid , pred$fit -2* pred$se , lty =" dashed ")

Here we have prespeciﬁed knots at ages 25, 40, and 60. This produces a
spline with six basis functions. (Recall that a cubic spline with three knots
has seven degrees of freedom; these degrees of freedom are used up by an
intercept, plus six basis functions.) We could also use the df option to
produce a spline with knots at uniform quantiles of the data.

> dim ( bs ( age , knots = c (25 ,40 ,60) ) )
[1] 3000
> dim ( bs ( age , df =6) )
[1] 3000
> attr ( bs ( age , df =6) ," knots ")

6

6

25%

75%
33.8 42.0 51.0

50%

In this case R chooses knots at ages 33.8, 42.0, and 51.0, which correspond
to the 25th, 50th, and 75th percentiles of age. The function bs() also has
a degree argument, so we can ﬁt splines of any degree, rather than the
default degree of 3 (which yields a cubic spline).

In order to instead ﬁt a natural spline, we use the ns() function. Here

we ﬁt a natural spline with four degrees of freedom.
> fit2 = lm ( wage∼ns ( age , df =4) , data = Wage )

> pred2 = predict ( fit2 , newdata = list ( age = age . grid ) , se = T )
> lines ( age . grid , pred2$fit , col =" red " , lwd =2)

ns()

As with the bs() function, we could instead specify the knots directly using
the knots option.

In order to ﬁt a smoothing spline, we use the smooth.spline() function.

Figure 7.8 was produced with the following code:

smooth.
spline()

> plot ( age , wage , xlim = agelims , cex =.5 , col =" darkgrey ")
> title (" Smoothing Spline ")
> fit = smooth . spline ( age , wage , df =16)
> fit2 = smooth . spline ( age , wage , cv = TRUE )
> fit2$df
[1] 6.8
> lines ( fit , col =" red " , lwd =2)

294

7. Moving Beyond Linearity

> lines ( fit2 , col =" blue " , lwd =2)
> legend (" topright " , legend = c ("16 DF " ,"6.8 DF ") ,

col = c (" red " ," blue ") , lty =1 , lwd =2 , cex =.8)

Notice that in the ﬁrst call to smooth.spline(), we speciﬁed df=16. The
function then determines which value of λ leads to 16 degrees of freedom. In
the second call to smooth.spline(), we select the smoothness level by cross-
validation; this results in a value of λ that yields 6.8 degrees of freedom.

In order to perform local regression, we use the loess() function.

loess()

> plot ( age , wage , xlim = agelims , cex =.5 , col =" darkgrey ")
> title (" Local Regression ")

> fit = loess ( wage∼age , span =.2 , data = Wage )
> fit2 = loess ( wage∼age , span =.5 , data = Wage )

> lines ( age . grid , predict ( fit , data . frame ( age = age . grid ) ) ,

col =" red " , lwd =2)

> lines ( age . grid , predict ( fit2 , data . frame ( age = age . grid ) ) ,

col =" blue " , lwd =2)

> legend (" topright " , legend = c (" Span =0.2" ," Span =0.5") ,

col = c (" red " ," blue ") , lty =1 , lwd =2 , cex =.8)

Here we have performed local linear regression using spans of 0.2 and 0.5:
that is, each neighborhood consists of 20 % or 50 % of the observations. The
larger the span, the smoother the ﬁt. The locfit library can also be used
for ﬁtting local regression models in R.

7.8.3 GAMs

We now ﬁt a GAM to predict wage using natural spline functions of year
and age, treating education as a qualitative predictor, as in (7.16). Since
this is just a big linear regression model using an appropriate choice of
basis functions, we can simply do this using the lm() function.
> gam1 = lm ( wage∼ns ( year ,4) + ns ( age ,5) + education , data = Wage )

We now ﬁt the model (7.16) using smoothing splines rather than natural
splines. In order to ﬁt more general sorts of GAMs, using smoothing splines
or other components that cannot be expressed in terms of basis functions
and then ﬁt using least squares regression, we will need to use the gam
library in R.

The s() function, which is part of the gam library, is used to indicate that
we would like to use a smoothing spline. We specify that the function of
year should have 4 degrees of freedom, and that the function of age will
have 5 degrees of freedom. Since education is qualitative, we leave it as is,
and it is converted into four dummy variables. We use the gam() function in
order to ﬁt a GAM using these components. All of the terms in (7.16) are
ﬁt simultaneously, taking each other into account to explain the response.

s()

gam()

> library ( gam )

> gam . m3 = gam ( wage∼s ( year ,4) + s ( age ,5) + education , data = Wage )

7.8 Lab: Non-linear Modeling

295

In order to produce Figure 7.12, we simply call the plot() function:

> par ( mfrow = c (1 ,3) )
> plot ( gam . m3 , se = TRUE , col =" blue ")

The generic plot() function recognizes that gam.m3 is an object of class gam,
and invokes the appropriate plot.gam() method. Conveniently, even though
gam1 is not of class gam but rather of class lm, we can still use plot.gam()
on it. Figure 7.11 was produced using the following expression:

plot.gam()

> plot . gam ( gam1 , se = TRUE , col =" red ")

Notice here we had to use plot.gam() rather than the generic plot()
function.

In these plots, the function of year looks rather linear. We can perform a
series of ANOVA tests in order to determine which of these three models is

best: a GAM that excludes year (M1), a GAM that uses a linear function
of year (M2), or a GAM that uses a spline function of year (M3).
> gam . m1 = gam ( wage∼s ( age ,5) + education , data = Wage )
> gam . m2 = gam ( wage∼year + s ( age ,5) + education , data = Wage )

> anova ( gam . m1 , gam . m2 , gam . m3 , test =" F ")
Analysis of Deviance Table

Model 1: wage ∼ s ( age , 5) + education
Model 2: wage ∼ year + s ( age , 5) + education
Model 3: wage ∼ s ( year , 4) + s ( age , 5) + education

Resid . Df Resid . Dev Df Deviance

F

Pr ( > F )

2990
2989
2986

1
2
3
---
Signif . codes :

3711730
3693841
3689770

1
3

17889 14.5 0.00014 ***

4071

1.1 0.34857

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

We ﬁnd that there is compelling evidence that a GAM with a linear func-
tion of year is better than a GAM that does not include year at all
(p-value = 0.00014). However, there is no evidence that a non-linear func-
tion of year is needed (p-value = 0.349). In other words, based on the results

of this ANOVA, M2 is preferred.

The summary() function produces a summary of the gam ﬁt.

> summary ( gam . m3 )

Call : gam ( formula = wage ∼ s ( year , 4) + s ( age , 5) + education ,

data = Wage )

Deviance Residuals :

Min
-119.43

1 Q
-19.70

Median
-3.33

3 Q
14.17

Max
213.48

( Dispersion Parameter for gaussian family taken to be 1236)

Null Deviance : 5222086 on 2999 degrees of freedom
Residual Deviance : 3689770 on 2986 degrees of freedom

296

7. Moving Beyond Linearity

AIC : 29888

Number of Local Scoring Iterations : 2

DF for Terms and F - values for N o n p a r a m e t r i c Effects

Df Npar Df Npar F

Pr ( F )

( Intercept )
s ( year , 4)
s ( age , 5)
education
---
Signif . codes :

1
1
1
4

3
4

1.1

0.35

32.4 <2e -16 ***

0 ’*** ’ 0.001 ’** ’ 0.01 ’* ’ 0.05 ’. ’ 0.1 ’ ’ 1

The p-values for year and age correspond to a null hypothesis of a linear
relationship versus the alternative of a non-linear relationship. The large
p-value for year reinforces our conclusion from the ANOVA test that a lin-
ear function is adequate for this term. However, there is very clear evidence
that a non-linear term is required for age.

We can make predictions from gam objects, just like from lm objects,
using the predict() method for the class gam. Here we make predictions on
the training set.

> preds = predict ( gam . m2 , newdata = Wage )

We can also use local regression ﬁts as building blocks in a GAM, using

the lo() function.
> gam . lo = gam ( wage∼s ( year , df =4) + lo ( age , span =0.7) + education ,

lo()

data = Wage )

> plot . gam ( gam . lo , se = TRUE , col =" green ")

Here we have used local regression for the age term, with a span of 0.7.
We can also use the lo() function to create interactions before calling the
gam() function. For example,
> gam . lo . i = gam ( wage∼lo ( year , age , span =0.5) + education ,

data = Wage )

ﬁts a two-term model, in which the ﬁrst term is an interaction between
year and age, ﬁt by a local regression surface. We can plot the resulting
two-dimensional surface if we ﬁrst install the akima package.

> library ( akima )
> plot ( gam . lo . i )

In order to ﬁt a logistic regression GAM, we once again use the I() func-
tion in constructing the binary response variable, and set family=binomial.
> gam . lr = gam ( I ( wage >250)∼year + s ( age , df =5) + education ,

family = binomial , data = Wage )

> par ( mfrow = c (1 ,3) )
> plot ( gam . lr , se =T , col =" green ")

It is easy to see that there are no high earners in the <HS category:

7.9 Exercises

297

> table ( education , I ( wage >250) )

education

1. < HS Grad
2. HS Grad
3. Some College
4. College Grad
5. Advanced Degree

FALSE TRUE
0
5
7
22
45

268
966
643
663
381

Hence, we ﬁt a logistic regression GAM using all but this category. This
provides more sensible results.
> gam . lr . s = gam ( I ( wage >250)∼year + s ( age , df =5) + education , family =

binomial , data = Wage , subset =( education !="1. < HS Grad ") )

> plot ( gam . lr .s , se =T , col =" green ")

7.9 Exercises

Conceptual

1. It was mentioned in the chapter that a cubic regression spline with
one knot at ξ can be obtained using a basis of the form x, x2, x3,
(x − ξ)3
+ = (x − ξ)3 if x > ξ and equals 0 otherwise.
We will now show that a function of the form

+, where (x − ξ)3

f (x) = β0 + β1x + β2x2 + β3x3 + β4(x − ξ)3

+

is indeed a cubic regression spline, regardless of the values of β0, β1, β2,
β3, β4.

(a) Find a cubic polynomial

f1(x) = a1 + b1x + c1x2 + d1x3

such that f (x) = f1(x) for all x ≤ ξ. Express a1, b1, c1, d1 in
terms of β0, β1, β2, β3, β4.
(b) Find a cubic polynomial

f2(x) = a2 + b2x + c2x2 + d2x3

such that f (x) = f2(x) for all x > ξ. Express a2, b2, c2, d2 in
terms of β0, β1, β2, β3, β4. We have now established that f (x) is
a piecewise polynomial.

(c) Show that f1(ξ) = f2(ξ). That is, f (x) is continuous at ξ.
(d) Show that f
(x) is continuous at ξ.

(cid:5)
2(ξ). That is, f

(cid:5)
1(ξ) = f

(cid:5)

298

7. Moving Beyond Linearity

(e) Show that f

(cid:5)(cid:5)
1 (ξ) = f

(cid:5)(cid:5)
2 (ξ). That is, f

(cid:5)(cid:5)

(x) is continuous at ξ.

Therefore, f (x) is indeed a cubic spline.

Hint: Parts (d) and (e) of this problem require knowledge of single-
variable calculus. As a reminder, given a cubic polynomial

f1(x) = a1 + b1x + c1x2 + d1x3,

the ﬁrst derivative takes the form

(cid:5)
1(x) = b1 + 2c1x + 3d1x2

f

and the second derivative takes the form

(cid:5)(cid:5)
1 (x) = 2c1 + 6d1x.

f

2. Suppose that a curve ˆg is computed to smoothly ﬁt a set of n points

using the following formula:

(cid:31)
n(cid:17)

ˆg = arg min

g

i=1

(yi − g(xi))2 + λ

- (cid:24)

(cid:25)2
g(m)(x)

 

dx

,

where g(m) represents the mth derivative of g (and g(0) = g). Provide
example sketches of ˆg in each of the following scenarios.
(a) λ = ∞, m = 0.
(b) λ = ∞, m = 1.
(c) λ = ∞, m = 2.
(d) λ = ∞, m = 3.
(e) λ = 0, m = 3.

3. Suppose we ﬁt a curve with basis functions b1(X) = X, b2(X) =
(X − 1)2I(X ≥ 1). (Note that I(X ≥ 1) equals 1 for X ≥ 1 and 0
otherwise.) We ﬁt the linear regression model

Y = β0 + β1b1(X) + β2b2(X) + ,

and obtain coeﬃcient estimates ˆβ0 = 1, ˆβ1 = 1, ˆβ2 = −2. Sketch the
estimated curve between X = −2 and X = 2. Note the intercepts,
slopes, and other relevant information.

4. Suppose we ﬁt a curve with basis functions b1(X) = I(0 ≤ X ≤ 2) −
(X − 1)I(1 ≤ X ≤ 2), b2(X) = (X − 3)I(3 ≤ X ≤ 4) + I(4 < X ≤ 5).

We ﬁt the linear regression model

Y = β0 + β1b1(X) + β2b2(X) + ,

and obtain coeﬃcient estimates ˆβ0 = 1, ˆβ1 = 1, ˆβ2 = 3. Sketch the
estimated curve between X = −2 and X = 2. Note the intercepts,
slopes, and other relevant information.

5. Consider two curves, ˆg1 and ˆg2, deﬁned by
(yi − g(xi))2 + λ

ˆg1 = arg min

n(cid:17)

(cid:31)

g

(cid:31)

i=1

n(cid:17)

ˆg2 = arg min

g

i=1

(yi − g(xi))2 + λ

7.9 Exercises

299

- (cid:24)

- (cid:24)

(cid:25)2
g(3)(x)
(cid:25)2
g(4)(x)

 

dx
 

dx

,

,

where g(m) represents the mth derivative of g.
(a) As λ → ∞, will ˆg1 or ˆg2 have the smaller training RSS?
(b) As λ → ∞, will ˆg1 or ˆg2 have the smaller test RSS?
(c) For λ = 0, will ˆg1 or ˆg2 have the smaller training and test RSS?

Applied

6. In this exercise, you will further analyze the Wage data set considered

throughout this chapter.

(a) Perform polynomial regression to predict wage using age. Use
cross-validation to select the optimal degree d for the polyno-
mial. What degree was chosen, and how does this compare to
the results of hypothesis testing using ANOVA? Make a plot of
the resulting polynomial ﬁt to the data.

(b) Fit a step function to predict wage using age, and perform cross-
validation to choose the optimal number of cuts. Make a plot of
the ﬁt obtained.

7. The Wage data set contains a number of other features not explored
in this chapter, such as marital status (maritl), job class (jobclass),
and others. Explore the relationships between some of these other
predictors and wage, and use non-linear ﬁtting techniques in order to
ﬁt ﬂexible models to the data. Create plots of the results obtained,
and write a summary of your ﬁndings.

8. Fit some of the non-linear models investigated in this chapter to the
Auto data set. Is there evidence for non-linear relationships in this
data set? Create some informative plots to justify your answer.

9. This question uses the variables dis (the weighted mean of distances
to ﬁve Boston employment centers) and nox (nitrogen oxides concen-
tration in parts per 10 million) from the Boston data. We will treat
dis as the predictor and nox as the response.

(a) Use the poly() function to ﬁt a cubic polynomial regression to
predict nox using dis. Report the regression output, and plot
the resulting data and polynomial ﬁts.

300

7. Moving Beyond Linearity

(b) Plot the polynomial ﬁts for a range of diﬀerent polynomial
degrees (say, from 1 to 10), and report the associated residual
sum of squares.

(c) Perform cross-validation or another approach to select the opti-

mal degree for the polynomial, and explain your results.

(d) Use the bs() function to ﬁt a regression spline to predict nox
using dis. Report the output for the ﬁt using four degrees of
freedom. How did you choose the knots? Plot the resulting ﬁt.

(e) Now ﬁt a regression spline for a range of degrees of freedom, and
plot the resulting ﬁts and report the resulting RSS. Describe the
results obtained.

(f) Perform cross-validation or another approach in order to select
the best degrees of freedom for a regression spline on this data.
Describe your results.

10. This question relates to the College data set.

(a) Split the data into a training set and a test set. Using out-of-state
tuition as the response and the other variables as the predictors,
perform forward stepwise selection on the training set in order
to identify a satisfactory model that uses just a subset of the
predictors.

(b) Fit a GAM on the training data, using out-of-state tuition as
the response and the features selected in the previous step as
the predictors. Plot the results, and explain your ﬁndings.

(c) Evaluate the model obtained on the test set, and explain the

results obtained.

(d) For which variables, if any, is there evidence of a non-linear

relationship with the response?

11. In Section 7.7, it was mentioned that GAMs are generally ﬁt using
a backﬁtting approach. The idea behind backﬁtting is actually quite
simple. We will now explore backﬁtting in the context of multiple
linear regression.

Suppose that we would like to perform multiple linear regression, but
we do not have software to do so. Instead, we only have software
to perform simple linear regression. Therefore, we take the following
iterative approach: we repeatedly hold all but one coeﬃcient esti-
mate ﬁxed at its current value, and update only that coeﬃcient
estimate using a simple linear regression. The process is continued un-
til convergence—that is, until the coeﬃcient estimates stop changing.

We now try this out on a toy example.

7.9 Exercises

301

(a) Generate a response Y and two predictors X1 and X2, with

n = 100.

(b) Initialize ˆβ1 to take on a value of your choice. It does not matter

what value you choose.

(c) Keeping ˆβ1 ﬁxed, ﬁt the model

Y − ˆβ1X1 = β0 + β2X2 + .

You can do this as follows:

> a =y - beta1 * x1

> beta2 = lm ( a∼x2 ) $coef [2]

(d) Keeping ˆβ2 ﬁxed, ﬁt the model

Y − ˆβ2X2 = β0 + β1X1 + .

You can do this as follows:

> a =y - beta2 * x2

> beta1 = lm ( a∼x1 ) $coef [2]

(e) Write a for loop to repeat (c) and (d) 1,000 times. Report the
estimates of ˆβ0, ˆβ1, and ˆβ2 at each iteration of the for loop.
Create a plot in which each of these values is displayed, with ˆβ0,
ˆβ1, and ˆβ2 each shown in a diﬀerent color.

(f) Compare your answer in (e) to the results of simply performing
multiple linear regression to predict Y using X1 and X2. Use
the abline() function to overlay those multiple linear regression
coeﬃcient estimates on the plot obtained in (e).

(g) On this data set, how many backﬁtting iterations were required
in order to obtain a “good” approximation to the multiple re-
gression coeﬃcient estimates?

12. This problem is a continuation of the previous exercise. In a toy
example with p = 100, show that one can approximate the multiple
linear regression coeﬃcient estimates by repeatedly performing simple
linear regression in a backﬁtting procedure. How many backﬁtting
iterations are required in order to obtain a “good” approximation to
the multiple regression coeﬃcient estimates? Create a plot to justify
your answer.

8
Tree-Based Methods

In this chapter, we describe tree-based methods for regression and
classiﬁcation. These involve stratifying or segmenting the predictor space
into a number of simple regions. In order to make a prediction for a given
observation, we typically use the mean or the mode of the training observa-
tions in the region to which it belongs. Since the set of splitting rules used
to segment the predictor space can be summarized in a tree, these types of
approaches are known as decision tree methods.

Tree-based methods are simple and useful for interpretation. However,
they typically are not competitive with the best supervised learning ap-
proaches, such as those seen in Chapters 6 and 7, in terms of prediction
accuracy. Hence in this chapter we also introduce bagging, random forests,
and boosting. Each of these approaches involves producing multiple trees
which are then combined to yield a single consensus prediction. We will
see that combining a large number of trees can often result in dramatic
improvements in prediction accuracy, at the expense of some loss in inter-
pretation.

decision tree

8.1 The Basics of Decision Trees

Decision trees can be applied to both regression and classiﬁcation problems.
We ﬁrst consider regression problems, and then move on to classiﬁcation.

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 8,
© Springer Science+Business Media New York 2013

303

304

8. Tree-Based Methods

Years < 4.5

|

5.11

Hits < 117.5

6.00

6.74

FIGURE 8.1. For the Hitters data, a regression tree for predicting the log
salary of a baseball player, based on the number of years that he has played in
the major leagues and the number of hits that he made in the previous year. At a
given internal node, the label (of the form Xj < tk) indicates the left-hand branch
emanating from that split, and the right-hand branch corresponds to Xj ≥ tk.
For instance, the split at the top of the tree results in two large branches. The
left-hand branch corresponds to Years<4.5, and the right-hand branch corresponds
to Years>=4.5. The tree has two internal nodes and three terminal nodes, or
leaves. The number in each leaf is the mean of the response for the observations
that fall there.

8.1.1 Regression Trees

In order to motivate regression trees, we begin with a simple example.

regression
tree

Predicting Baseball Players’ Salaries Using Regression Trees

We use the Hitters data set to predict a baseball player’s Salary based on
Years (the number of years that he has played in the major leagues) and
Hits (the number of hits that he made in the previous year). We ﬁrst remove
observations that are missing Salary values, and log-transform Salary so
that its distribution has more of a typical bell-shape. (Recall that Salary
is measured in thousands of dollars.)

Figure 8.1 shows a regression tree ﬁt to this data. It consists of a series
of splitting rules, starting at the top of the tree. The top split assigns
observations having Years<4.5 to the left branch.1 The predicted salary

1Both Years and Hits are integers in these data; the tree() function in R labels

the splits at the midpoint between two adjacent values.

8.1 The Basics of Decision Trees

305

238

117.5

s
t
i

H

R1

R3

R2

1

4.5

Years

1

24

FIGURE 8.2. The three-region partition for the Hitters data set from the
regression tree illustrated in Figure 8.1.

for these players is given by the mean response value for the players in
the data set with Years<4.5. For such players, the mean log salary is 5.107,
and so we make a prediction of e5.107 thousands of dollars, i.e. $165,174, for
these players. Players with Years>=4.5 are assigned to the right branch, and
then that group is further subdivided by Hits. Overall, the tree stratiﬁes
or segments the players into three regions of predictor space: players who
have played for four or fewer years, players who have played for ﬁve or more
years and who made fewer than 118 hits last year, and players who have
played for ﬁve or more years and who made at least 118 hits last year. These

three regions can be written as R1 ={X | Years<4.5}, R2 ={X | Years>=4.5,
Hits<117.5}, and R3 ={X | Years>=4.5, Hits>=117.5}. Figure 8.2 illustrates
the regions as a function of Years and Hits. The predicted salaries for these
three groups are $1,000×e5.107 =$165,174, $1,000×e5.999 =$402,834, and
$1,000×e6.740 =$845,346 respectively.

In keeping with the tree analogy, the regions R1, R2, and R3 are known
as terminal nodes or leaves of the tree. As is the case for Figure 8.1, decision
trees are typically drawn upside down, in the sense that the leaves are at
the bottom of the tree. The points along the tree where the predictor space
is split are referred to as internal nodes.
In Figure 8.1, the two internal
nodes are indicated by the text Years<4.5 and Hits<117.5. We refer to the
segments of the trees that connect the nodes as branches.

We might interpret the regression tree displayed in Figure 8.1 as follows:
Years is the most important factor in determining Salary, and players with
less experience earn lower salaries than more experienced players. Given
that a player is less experienced, the number of hits that he made in the
previous year seems to play little role in his salary. But among players who

terminal
node
leaf

internal node

branch

306

8. Tree-Based Methods

have been in the major leagues for ﬁve or more years, the number of hits
made in the previous year does aﬀect salary, and players who made more
hits last year tend to have higher salaries. The regression tree shown in
Figure 8.1 is likely an over-simpliﬁcation of the true relationship between
Hits, Years, and Salary. However, it has advantages over other types of
regression models (such as those seen in Chapters 3 and 6): it is easier to
interpret, and has a nice graphical representation.

Prediction via Stratiﬁcation of the Feature Space

We now discuss the process of building a regression tree. Roughly speaking,
there are two steps.

1. We divide the predictor space—that is, the set of possible values for
X1, X2, . . . , Xp—into J distinct and non-overlapping regions,
R1, R2, . . . , RJ .

2. For every observation that falls into the region Rj, we make the same
prediction, which is simply the mean of the response values for the
training observations in Rj.

For instance, suppose that in Step 1 we obtain two regions, R1 and R2,
and that the response mean of the training observations in the ﬁrst region
is 10, while the response mean of the training observations in the second

region is 20. Then for a given observation X = x, if x ∈ R1 we will predict
a value of 10, and if x ∈ R2 we will predict a value of 20.

We now elaborate on Step 1 above. How do we construct the regions
R1, . . . , RJ ? In theory, the regions could have any shape. However, we
choose to divide the predictor space into high-dimensional rectangles, or
boxes, for simplicity and for ease of interpretation of the resulting predic-
tive model. The goal is to ﬁnd boxes R1, . . . , RJ that minimize the RSS,
given by

(yi − ˆyRj )2,

(8.1)

J(cid:17)

(cid:17)

i∈Rj

j=1

where ˆyRj is the mean response for the training observations within the
jth box. Unfortunately, it is computationally infeasible to consider every
possible partition of the feature space into J boxes. For this reason, we take
a top-down, greedy approach that is known as recursive binary splitting. The
approach is top-down because it begins at the top of the tree (at which point
all observations belong to a single region) and then successively splits the
predictor space; each split is indicated via two new branches further down
on the tree. It is greedy because at each step of the tree-building process,
the best split is made at that particular step, rather than looking ahead
and picking a split that will lead to a better tree in some future step.

recursive
binary
splitting

8.1 The Basics of Decision Trees

307

In order to perform recursive binary splitting, we ﬁrst select the pre-
dictor Xj and the cutpoint s such that splitting the predictor space into
the regions {X|Xj < s} and {X|Xj ≥ s} leads to the greatest possible
reduction in RSS. (The notation {X|Xj < s} means the region of predictor
space in which Xj takes on a value less than s.) That is, we consider all
predictors X1, . . . , Xp, and all possible values of the cutpoint s for each of
the predictors, and then choose the predictor and cutpoint such that the
resulting tree has the lowest RSS. In greater detail, for any j and s, we
deﬁne the pair of half-planes

R1(j, s) = {X|Xj < s} and R2(j, s) = {X|Xj ≥ s},

and we seek the value of j and s that minimize the equation

(cid:17)

(cid:17)

(yi − ˆyR1)2 +

(yi − ˆyR2)2,

i: xi∈R1(j,s)

i: xi∈R2(j,s)

(8.2)

(8.3)

where ˆyR1 is the mean response for the training observations in R1(j, s),
and ˆyR2 is the mean response for the training observations in R2(j, s).
Finding the values of j and s that minimize (8.3) can be done quite quickly,
especially when the number of features p is not too large.

Next, we repeat the process, looking for the best predictor and best
cutpoint in order to split the data further so as to minimize the RSS within
each of the resulting regions. However, this time, instead of splitting the
entire predictor space, we split one of the two previously identiﬁed regions.
We now have three regions. Again, we look to split one of these three regions
further, so as to minimize the RSS. The process continues until a stopping
criterion is reached; for instance, we may continue until no region contains
more than ﬁve observations.

Once the regions R1, . . . , RJ have been created, we predict the response
for a given test observation using the mean of the training observations in
the region to which that test observation belongs.

A ﬁve-region example of this approach is shown in Figure 8.3.

Tree Pruning

The process described above may produce good predictions on the training
set, but is likely to overﬁt the data, leading to poor test set performance.
This is because the resulting tree might be too complex. A smaller tree
with fewer splits (that is, fewer regions R1, . . . , RJ ) might lead to lower
variance and better interpretation at the cost of a little bias. One possible
alternative to the process described above is to build the tree only so long
as the decrease in the RSS due to each split exceeds some (high) threshold.
This strategy will result in smaller trees, but is too short-sighted since a
seemingly worthless split early on in the tree might be followed by a very
good split—that is, a split that leads to a large reduction in RSS later on.

308

8. Tree-Based Methods

2

X

X1

X1 ≤ t1
|

t4

R5

R4

2

X

t2

R2

R1

R3

t1

t3

X1

X2 ≤ t2

X1 ≤ t3

Y

X2 ≤ t4

R1

R2

R3

R4

R5

X

2

X1

FIGURE 8.3. Top Left: A partition of two-dimensional feature space that could
not result from recursive binary splitting. Top Right: The output of recursive
binary splitting on a two-dimensional example. Bottom Left: A tree corresponding
to the partition in the top right panel. Bottom Right: A perspective plot of the
prediction surface corresponding to that tree.

Therefore, a better strategy is to grow a very large tree T0, and then

prune it back in order to obtain a subtree. How do we determine the best prune
way to prune the tree? Intuitively, our goal is to select a subtree that
subtree
leads to the lowest test error rate. Given a subtree, we can estimate its
test error using cross-validation or the validation set approach. However,
estimating the cross-validation error for every possible subtree would be too
cumbersome, since there is an extremely large number of possible subtrees.
Instead, we need a way to select a small set of subtrees for consideration.
Cost complexity pruning—also known as weakest link pruning—gives us
a way to do just this. Rather than considering every possible subtree, we
consider a sequence of trees indexed by a nonnegative tuning parameter α.

cost
complexity
pruning

weakest link
pruning

8.1 The Basics of Decision Trees

309

Algorithm 8.1 Building a Regression Tree

1. Use recursive binary splitting to grow a large tree on the training
data, stopping only when each terminal node has fewer than some
minimum number of observations.

2. Apply cost complexity pruning to the large tree in order to obtain a

sequence of best subtrees, as a function of α.

3. Use K-fold cross-validation to choose α. That is, divide the training

observations into K folds. For each k = 1, . . . , K:

(a) Repeat Steps 1 and 2 on all but the kth fold of the training data.

(b) Evaluate the mean squared prediction error on the data in the
left-out kth fold, as a function of α.

Average the results for each value of α, and pick α to minimize the
average error.

4. Return the subtree from Step 2 that corresponds to the chosen value

of α.

For each value of α there corresponds a subtree T ⊂ T0 such that

|T|(cid:17)

(cid:17)

m=1

i: xi∈Rm

(yi − ˆyRm)2 + α|T|

(8.4)

is as small as possible. Here |T| indicates the number of terminal nodes
of the tree T , Rm is the rectangle (i.e. the subset of predictor space) cor-
responding to the mth terminal node, and ˆyRm is the predicted response
associated with Rm—that is, the mean of the training observations in Rm.
The tuning parameter α controls a trade-oﬀ between the subtree’s com-
plexity and its ﬁt to the training data. When α = 0, then the subtree T
will simply equal T0, because then (8.4) just measures the training error.
However, as α increases, there is a price to pay for having a tree with
many terminal nodes, and so the quantity (8.4) will tend to be minimized
for a smaller subtree. Equation 8.4 is reminiscent of the lasso (6.7) from
Chapter 6, in which a similar formulation was used in order to control the
complexity of a linear model.

It turns out that as we increase α from zero in (8.4), branches get pruned
from the tree in a nested and predictable fashion, so obtaining the whole
sequence of subtrees as a function of α is easy. We can select a value of
α using a validation set or using cross-validation. We then return to the
full data set and obtain the subtree corresponding to α. This process is
summarized in Algorithm 8.1.

310

8. Tree-Based Methods

Years < 4.5

|

RBI < 60.5

Hits < 117.5

Putouts < 82

Years < 3.5

5.487

Years < 3.5

4.622

5.183

5.394

6.189

Walks < 43.5

Walks < 52.5

Runs < 47.5

6.015

5.571

6.407

6.549

RBI < 80.5

Years < 6.5

6.459

7.007

7.289

FIGURE 8.4. Regression tree analysis for the Hitters data. The unpruned tree
that results from top-down greedy splitting on the training data is shown.

Figures 8.4 and 8.5 display the results of ﬁtting and pruning a regression
tree on the Hitters data, using nine of the features. First, we randomly
divided the data set in half, yielding 132 observations in the training set
and 131 observations in the test set. We then built a large regression tree
on the training data and varied α in (8.4) in order to create subtrees with
diﬀerent numbers of terminal nodes. Finally, we performed six-fold cross-
validation in order to estimate the cross-validated MSE of the trees as
a function of α. (We chose to perform six-fold cross-validation because
132 is an exact multiple of six.) The unpruned regression tree is shown
in Figure 8.4. The green curve in Figure 8.5 shows the CV error as a
function of the number of leaves,2 while the orange curve indicates the
test error. Also shown are standard error bars around the estimated errors.
For reference, the training error curve is shown in black. The CV error
is a reasonable approximation of the test error: the CV error takes on its

2Although CV error is computed as a function of α, it is convenient to display the
result as a function of |T|, the number of leaves; this is based on the relationship between
α and |T| in the original tree grown to all the training data.

8.1 The Basics of Decision Trees

311

Training
Cross−Validation
Test

r
o
r
r

E
 
d
e
r
a
u
q
S
 
n
a
e
M

0
.
1

8
.
0

6
.
0

4
.
0

2

.

0

0

.

0

2

4

6

8

10

Tree Size

FIGURE 8.5. Regression tree analysis for the Hitters data. The training,
cross-validation, and test MSE are shown as a function of the number of termi-
nal nodes in the pruned tree. Standard error bands are displayed. The minimum
cross-validation error occurs at a tree size of three.

minimum for a three-node tree, while the test error also dips down at the
three-node tree (though it takes on its lowest value at the ten-node tree).
The pruned tree containing three terminal nodes is shown in Figure 8.1.

8.1.2 Classiﬁcation Trees

A classiﬁcation tree is very similar to a regression tree, except that it is
used to predict a qualitative response rather than a quantitative one. Re-
call that for a regression tree, the predicted response for an observation is
given by the mean response of the training observations that belong to the
same terminal node. In contrast, for a classiﬁcation tree, we predict that
each observation belongs to the most commonly occurring class of training
observations in the region to which it belongs. In interpreting the results of
a classiﬁcation tree, we are often interested not only in the class prediction
corresponding to a particular terminal node region, but also in the class
proportions among the training observations that fall into that region.

The task of growing a classiﬁcation tree is quite similar to the task of
growing a regression tree. Just as in the regression setting, we use recursive
binary splitting to grow a classiﬁcation tree. However, in the classiﬁcation
setting, RSS cannot be used as a criterion for making the binary splits.
A natural alternative to RSS is the classiﬁcation error rate. Since we plan
to assign an observation in a given region to the most commonly occurring
class of training observations in that region, the classiﬁcation error rate is
simply the fraction of the training observations in that region that do not
belong to the most common class:

classiﬁcation
tree

classiﬁcation
error rate

312

8. Tree-Based Methods

E = 1 − max

k

(ˆpmk).

(8.5)

Here ˆpmk represents the proportion of training observations in the mth
region that are from the kth class. However, it turns out that classiﬁcation
error is not suﬃciently sensitive for tree-growing, and in practice two other
measures are preferable.

The Gini index is deﬁned by

K(cid:17)

k=1

G =

ˆpmk(1 − ˆpmk),

Gini index

(8.6)

entropy

a measure of total variance across the K classes. It is not hard to see
that the Gini index takes on a small value if all of the ˆpmk’s are close to
zero or one. For this reason the Gini index is referred to as a measure of
node purity—a small value indicates that a node contains predominantly
observations from a single class.

An alternative to the Gini index is entropy, given by

D = − K(cid:17)

ˆpmk log ˆpmk.

(8.7)

k=1

Since 0 ≤ ˆpmk ≤ 1, it follows that 0 ≤ −ˆpmk log ˆpmk. One can show that
the entropy will take on a value near zero if the ˆpmk’s are all near
zero or near one. Therefore, like the Gini index, the entropy will take
on a small value if the mth node is pure. In fact, it turns out that the Gini
index and the entropy are quite similar numerically.

When building a classiﬁcation tree, either the Gini index or the
entropy are typically used to evaluate the quality of a particular split,
since these two approaches are more sensitive to node purity than is the
classiﬁcation error rate. Any of these three approaches might be used when
pruning the tree, but the classiﬁcation error rate is preferable if prediction
accuracy of the ﬁnal pruned tree is the goal.

Figure 8.6 shows an example on the Heart data set. These data con-
tain a binary outcome HD for 303 patients who presented with chest pain.
An outcome value of Yes indicates the presence of heart disease based on
an angiographic test, while No means no heart disease. There are 13 predic-
tors including Age, Sex, Chol (a cholesterol measurement), and other heart
and lung function measurements. Cross-validation results in a tree with six
terminal nodes.

In our discussion thus far, we have assumed that the predictor vari-
ables take on continuous values. However, decision trees can be constructed
even in the presence of qualitative predictor variables. For instance, in the
Heart data, some of the predictors, such as Sex, Thal (Thallium stress test),
and ChestPain, are qualitative. Therefore, a split on one of these variables
amounts to assigning some of the qualitative values to one branch and

8.1 The Basics of Decision Trees

313

Thal:a

|

Ca < 0.5

Ca < 0.5

MaxHR < 161.5

ChestPain:bc

Age < 52

Thal:b

RestECG < 1

Slope < 1.5

Oldpeak < 1.1

Yes

No

No

ChestPain:a

Yes

Yes

Yes

No

Yes

MaxHR < 156

MaxHR < 145.5

No

No

RestBP < 157

Chol < 244

No

Chol < 244

Sex < 0.5

Yes

No

No

No

Yes

No

Yes

r
o
r
r

E

6
.
0

5
.
0

4
.
0

3
.
0

2
.
0

1
.
0

0
.
0

Training
Cross−Validation
Test

Thal:a

|

Ca < 0.5

Ca < 0.5

MaxHR < 161.5

ChestPain:bc

Yes

Yes

No

No

No

Yes

5

10

15

Tree Size

FIGURE 8.6. Heart data. Top: The unpruned tree. Bottom Left: Cross
-validation error, training, and test error, for diﬀerent sizes of the pruned tree.
Bottom Right: The pruned tree corresponding to the minimal cross-validation
error.

assigning the remaining to the other branch. In Figure 8.6, some of the in-
ternal nodes correspond to splitting qualitative variables. For instance, the
top internal node corresponds to splitting Thal. The text Thal:a indicates
that the left-hand branch coming out of that node consists of observations
with the ﬁrst value of the Thal variable (normal), and the right-hand node
consists of the remaining observations (ﬁxed or reversible defects). The text
ChestPain:bc two splits down the tree on the left indicates that the left-hand
branch coming out of that node consists of observations with the second
and third values of the ChestPain variable, where the possible values are
typical angina, atypical angina, non-anginal pain, and asymptomatic.

314

8. Tree-Based Methods

Figure 8.6 has a surprising characteristic: some of the splits yield two
terminal nodes that have the same predicted value. For instance, consider
the split RestECG<1 near the bottom right of the unpruned tree. Regardless
of the value of RestECG, a response value of Yes is predicted for those ob-
servations. Why, then, is the split performed at all? The split is performed
because it leads to increased node purity. That is, all 9 of the observations
corresponding to the right-hand leaf have a response value of Yes, whereas
7/11 of those corresponding to the left-hand leaf have a response value of
Yes. Why is node purity important? Suppose that we have a test obser-
vation that belongs to the region given by that right-hand leaf. Then we
can be pretty certain that its response value is Yes. In contrast, if a test
observation belongs to the region given by the left-hand leaf, then its re-
sponse value is probably Yes, but we are much less certain. Even though
the split RestECG<1 does not reduce the classiﬁcation error, it improves the
Gini index and the entropy, which are more sensitive to node purity.

8.1.3 Trees Versus Linear Models

Regression and classiﬁcation trees have a very diﬀerent ﬂavor from the more
classical approaches for regression and classiﬁcation presented in Chapters 3
and 4. In particular, linear regression assumes a model of the form

p(cid:17)

f (X) = β0 +

Xjβj,

j=1

cm · 1(X∈Rm)

whereas regression trees assume a model of the form

M(cid:17)

f (X) =

m=1

(8.8)

(8.9)

where R1, . . . , RM represent a partition of feature space, as in Figure 8.3.
Which model is better? It depends on the problem at hand. If the
relationship between the features and the response is well approximated
by a linear model as in (8.8), then an approach such as linear regression
will likely work well, and will outperform a method such as a regression
tree that does not exploit this linear structure. If instead there is a highly
non-linear and complex relationship between the features and the response
as indicated by model (8.9), then decision trees may outperform classical
approaches. An illustrative example is displayed in Figure 8.7. The rela-
tive performances of tree-based and classical approaches can be assessed by
estimating the test error, using either cross-validation or the validation set
approach (Chapter 5).

Of course, other considerations beyond simply test error may come into
play in selecting a statistical learning method; for instance, in certain set-
tings, prediction using a tree may be preferred for the sake of interpretabil-
ity and visualization.

8.1 The Basics of Decision Trees

315

2

1

2

1

2
X

0

2
X

0

1
−

2
−

2

1

1
−

2
−

−2

−1

0

X1

1

2

−2

−1

2

1

2
X

0

2
X

0

1
−

2
−

1
−

2
−

−2

−1

0

X1

1

2

−2

−1

1

2

1

2

0

X1

0

X1

FIGURE 8.7. Top Row: A two-dimensional classiﬁcation example in which
the true decision boundary is linear, and is indicated by the shaded regions.
A classical approach that assumes a linear boundary (left) will outperform a de-
cision tree that performs splits parallel to the axes (right). Bottom Row: Here the
true decision boundary is non-linear. Here a linear model is unable to capture
the true decision boundary (left), whereas a decision tree is successful (right).

8.1.4 Advantages and Disadvantages of Trees

Decision trees for regression and classiﬁcation have a number of advantages
over the more classical approaches seen in Chapters 3 and 4:

▲ Trees are very easy to explain to people. In fact, they are even easier

to explain than linear regression!

Some people believe that decision trees more closely mirror human
decision-making than do the regression and classiﬁcation approaches
seen in previous chapters.

▲ Trees can be displayed graphically, and are easily interpreted even by

a non-expert (especially if they are small).

▲ Trees can easily handle qualitative predictors without the need to

create dummy variables.

▲
316

8. Tree-Based Methods

▼ Unfortunately, trees generally do not have the same level of predictive
accuracy as some of the other regression and classiﬁcation approaches
seen in this book.

▼ Additionally, trees can be very non-robust. In other words, a small
change in the data can cause a large change in the ﬁnal estimated
tree.

However, by aggregating many decision trees, using methods like bagging,
random forests, and boosting, the predictive performance of trees can be
substantially improved. We introduce these concepts in the next section.

8.2 Bagging, Random Forests, Boosting

Bagging, random forests, and boosting use trees as building blocks to
construct more powerful prediction models.

8.2.1 Bagging

The bootstrap, introduced in Chapter 5, is an extremely powerful idea. It is
used in many situations in which it is hard or even impossible to directly
compute the standard deviation of a quantity of interest. We see here that
the bootstrap can be used in a completely diﬀerent context, in order to
improve statistical learning methods such as decision trees.

The decision trees discussed in Section 8.1 suﬀer from high variance.
This means that if we split the training data into two parts at random,
and ﬁt a decision tree to both halves, the results that we get could be
quite diﬀerent. In contrast, a procedure with low variance will yield similar
results if applied repeatedly to distinct data sets; linear regression tends
to have low variance, if the ratio of n to p is moderately large. Bootstrap
aggregation, or bagging, is a general-purpose procedure for reducing the
variance of a statistical learning method; we introduce it here because it is
particularly useful and frequently used in the context of decision trees.

Recall that given a set of n independent observations Z1, . . . , Zn, each
with variance σ2, the variance of the mean ¯Z of the observations is given
by σ2/n. In other words, averaging a set of observations reduces variance.
Hence a natural way to reduce the variance and hence increase the predic-
tion accuracy of a statistical learning method is to take many training sets
from the population, build a separate prediction model using each training
set, and average the resulting predictions. In other words, we could cal-
culate ˆf 1(x), ˆf 2(x), . . . , ˆf B(x) using B separate training sets, and average
them in order to obtain a single low-variance statistical learning model,

bagging

8.2 Bagging, Random Forests, Boosting

317

given by

ˆfavg(x) =

B(cid:17)

b=1

1
B

ˆf b(x).

Of course, this is not practical because we generally do not have access
to multiple training sets. Instead, we can bootstrap, by taking repeated
samples from the (single) training data set. In this approach we generate
B diﬀerent bootstrapped training data sets. We then train our method on
∗b(x), and ﬁnally average
the bth bootstrapped training set in order to get ˆf
all the predictions, to obtain

ˆfbag(x) =

B(cid:17)

b=1

1
B

∗b(x).
ˆf

This is called bagging.

While bagging can improve predictions for many regression methods,
it is particularly useful for decision trees. To apply bagging to regression
trees, we simply construct B regression trees using B bootstrapped training
sets, and average the resulting predictions. These trees are grown deep,
and are not pruned. Hence each individual tree has high variance, but
low bias. Averaging these B trees reduces the variance. Bagging has been
demonstrated to give impressive improvements in accuracy by combining
together hundreds or even thousands of trees into a single procedure.

Thus far, we have described the bagging procedure in the regression
context, to predict a quantitative outcome Y . How can bagging be extended
to a classiﬁcation problem where Y is qualitative? In that situation, there
are a few possible approaches, but the simplest is as follows. For a given test
observation, we can record the class predicted by each of the B trees, and
take a majority vote: the overall prediction is the most commonly occurring
class among the B predictions.

Figure 8.8 shows the results from bagging trees on the Heart data. The
test error rate is shown as a function of B, the number of trees constructed
using bootstrapped training data sets. We see that the bagging test error
rate is slightly lower in this case than the test error rate obtained from a
single tree. The number of trees B is not a critical parameter with bagging;
using a very large value of B will not lead to overﬁtting. In practice we
use a value of B suﬃciently large that the error has settled down. Using
B = 100 is suﬃcient to achieve good performance in this example.

Out-of-Bag Error Estimation

It turns out that there is a very straightforward way to estimate the test
error of a bagged model, without the need to perform cross-validation or
the validation set approach. Recall that the key to bagging is that trees are
repeatedly ﬁt to bootstrapped subsets of the observations. One can show

majority
vote

318

8. Tree-Based Methods

0
3
0

.

5
2
0

.

r
o
r
r

E

0
2

.

0

5
1

.

0

0
1
0

.

Test: Bagging
Test: RandomForest
OOB: Bagging
OOB: RandomForest

0

50

100

150

200

250

300

Number of Trees

FIGURE 8.8. Bagging and random forest results for the Heart data. The test
error (black and orange) is shown as a function of B, the number of bootstrapped
p. The dashed line
training sets used. Random forests were applied with m =
indicates the test error resulting from a single classiﬁcation tree. The green and
blue traces show the OOB error, which in this case is considerably lower.

√

that on average, each bagged tree makes use of around two-thirds of the
observations.3 The remaining one-third of the observations not used to ﬁt a
given bagged tree are referred to as the out-of-bag (OOB) observations. We
can predict the response for the ith observation using each of the trees in
which that observation was OOB. This will yield around B/3 predictions
for the ith observation. In order to obtain a single prediction for the ith
observation, we can average these predicted responses (if regression is the
goal) or can take a majority vote (if classiﬁcation is the goal). This leads
to a single OOB prediction for the ith observation. An OOB prediction
can be obtained in this way for each of the n observations, from which the
overall OOB MSE (for a regression problem) or classiﬁcation error (for a
classiﬁcation problem) can be computed. The resulting OOB error is a valid
estimate of the test error for the bagged model, since the response for each
observation is predicted using only the trees that were not ﬁt using that
observation. Figure 8.8 displays the OOB error on the Heart data. It can
be shown that with B suﬃciently large, OOB error is virtually equivalent
to leave-one-out cross-validation error. The OOB approach for estimating

out-of-bag

3This relates to Exercise 2 of Chapter 5.

8.2 Bagging, Random Forests, Boosting

319

the test error is particularly convenient when performing bagging on large
data sets for which cross-validation would be computationally onerous.

Variable Importance Measures

As we have discussed, bagging typically results in improved accuracy over
prediction using a single tree. Unfortunately, however, it can be diﬃcult to
interpret the resulting model. Recall that one of the advantages of decision
trees is the attractive and easily interpreted diagram that results, such as
the one displayed in Figure 8.1. However, when we bag a large number of
trees, it is no longer possible to represent the resulting statistical learning
procedure using a single tree, and it is no longer clear which variables
are most important to the procedure. Thus, bagging improves prediction
accuracy at the expense of interpretability.

Although the collection of bagged trees is much more diﬃcult to interpret
than a single tree, one can obtain an overall summary of the importance of
each predictor using the RSS (for bagging regression trees) or the Gini index
(for bagging classiﬁcation trees). In the case of bagging regression trees, we
can record the total amount that the RSS (8.1) is decreased due to splits
over a given predictor, averaged over all B trees. A large value indicates
an important predictor. Similarly, in the context of bagging classiﬁcation
trees, we can add up the total amount that the Gini index (8.6) is decreased
by splits over a given predictor, averaged over all B trees.

A graphical representation of the variable importances in the Heart data
is shown in Figure 8.9. We see the mean decrease in Gini index for each vari-
able, relative to the largest. The variables with the largest mean decrease
in Gini index are Thal, Ca, and ChestPain.

8.2.2 Random Forests

Random forests provide an improvement over bagged trees by way of a
small tweak that decorrelates the trees. As in bagging, we build a number
of decision trees on bootstrapped training samples. But when building these
decision trees, each time a split in a tree is considered, a random sample of
m predictors is chosen as split candidates from the full set of p predictors.
The split is allowed to use only one of those m predictors. A fresh sample of
p—that
is, the number of predictors considered at each split is approximately equal
to the square root of the total number of predictors (4 out of the 13 for the
Heart data).

m predictors is taken at each split, and typically we choose m ≈ √

In other words, in building a random forest, at each split in the tree,
the algorithm is not even allowed to consider a majority of the available
predictors. This may sound crazy, but it has a clever rationale. Suppose
that there is one very strong predictor in the data set, along with a num-
ber of other moderately strong predictors. Then in the collection of bagged

variable
importance

random
forest

320

8. Tree-Based Methods

Fbs

RestECG

ExAng

Sex

Slope

Chol

Age

RestBP

MaxHR

Oldpeak

ChestPain

Ca

Thal

0

20

40

60

80

100

Variable Importance

FIGURE 8.9. A variable importance plot for the Heart data. Variable impor-
tance is computed using the mean decrease in Gini index, and expressed relative
to the maximum.

trees, most or all of the trees will use this strong predictor in the top split.
Consequently, all of the bagged trees will look quite similar to each other.
Hence the predictions from the bagged trees will be highly correlated. Un-
fortunately, averaging many highly correlated quantities does not lead to
as large of a reduction in variance as averaging many uncorrelated quanti-
ties. In particular, this means that bagging will not lead to a substantial
reduction in variance over a single tree in this setting.
Random forests overcome this problem by forcing each split to consider
only a subset of the predictors. Therefore, on average (p − m)/p of the
splits will not even consider the strong predictor, and so other predictors
will have more of a chance. We can think of this process as decorrelating
the trees, thereby making the average of the resulting trees less variable
and hence more reliable.

The main diﬀerence between bagging and random forests is the choice
of predictor subset size m. For instance, if a random forest is built using
√
m = p, then this amounts simply to bagging. On the Heart data, random
p leads to a reduction in both test error and OOB error
forests using m =
over bagging (Figure 8.8).

Using a small value of m in building a random forest will typically be
helpful when we have a large number of correlated predictors. We applied
random forests to a high-dimensional biological data set consisting of ex-
pression measurements of 4,718 genes measured on tissue samples from 349
patients. There are around 20,000 genes in humans, and individual genes

8.2 Bagging, Random Forests, Boosting

321

have diﬀerent levels of activity, or expression, in particular cells, tissues,
and biological conditions. In this data set, each of the patient samples has
a qualitative label with 15 diﬀerent levels: either normal or 1 of 14 diﬀerent
types of cancer. Our goal was to use random forests to predict cancer type
based on the 500 genes that have the largest variance in the training set.
We randomly divided the observations into a training and a test set, and
applied random forests to the training set for three diﬀerent values of the
number of splitting variables m. The results are shown in Figure 8.10. The
error rate of a single tree is 45.7 %, and the null rate is 75.4 %.4 We see that
√
using 400 trees is suﬃcient to give good performance, and that the choice
m =
p gave a small improvement in test error over bagging (m = p) in
this example. As with bagging, random forests will not overﬁt if we increase
B, so in practice we use a value of B suﬃciently large for the error rate to
have settled down.

8.2.3 Boosting

We now discuss boosting, yet another approach for improving the predic-
tions resulting from a decision tree. Like bagging, boosting is a general
approach that can be applied to many statistical learning methods for re-
gression or classiﬁcation. Here we restrict our discussion of boosting to the
context of decision trees.

Recall that bagging involves creating multiple copies of the original train-
ing data set using the bootstrap, ﬁtting a separate decision tree to each
copy, and then combining all of the trees in order to create a single predic-
tive model. Notably, each tree is built on a bootstrap data set, independent
of the other trees. Boosting works in a similar way, except that the trees are
grown sequentially: each tree is grown using information from previously
grown trees. Boosting does not involve bootstrap sampling; instead each
tree is ﬁt on a modiﬁed version of the original data set.

Consider ﬁrst the regression setting. Like bagging, boosting involves com-
bining a large number of decision trees, ˆf 1, . . . , ˆf B. Boosting is described
in Algorithm 8.2.

What is the idea behind this procedure? Unlike ﬁtting a single large deci-
sion tree to the data, which amounts to ﬁtting the data hard and potentially
overﬁtting, the boosting approach instead learns slowly. Given the current
model, we ﬁt a decision tree to the residuals from the model. That is, we
ﬁt a tree using the current residuals, rather than the outcome Y , as the re-
sponse. We then add this new decision tree into the ﬁtted function in order
to update the residuals. Each of these trees can be rather small, with just
a few terminal nodes, determined by the parameter d in the algorithm. By

4The null rate results from simply classifying each observation to the dominant class

overall, which is in this case the normal class.

boosting

322

8. Tree-Based Methods

m=p
m=p/2
m= p

5
.
0

4
.
0

3
.
0

2
0

.

r
o
r
r

E
 
n
o
i
t
a
c
i
f
i
s
s
a
C

l

 
t
s
e
T

0

100

200

300

400

500

Number of Trees

FIGURE 8.10. Results from random forests for the 15-class gene expression
data set with p = 500 predictors. The test error is displayed as a function of
the number of trees. Each colored line corresponds to a diﬀerent value of m, the
number of predictors available for splitting at each interior tree node. Random
forests (m < p) lead to a slight improvement over bagging (m = p). A single
classiﬁcation tree has an error rate of 45.7 %.

ﬁtting small trees to the residuals, we slowly improve ˆf in areas where it
does not perform well. The shrinkage parameter λ slows the process down
even further, allowing more and diﬀerent shaped trees to attack the resid-
uals. In general, statistical learning approaches that learn slowly tend to
perform well. Note that in boosting, unlike in bagging, the construction of
each tree depends strongly on the trees that have already been grown.

We have just described the process of boosting regression trees. Boosting
classiﬁcation trees proceeds in a similar but slightly more complex way, and
the details are omitted here.

Boosting has three tuning parameters:

1. The number of trees B. Unlike bagging and random forests, boosting
can overﬁt if B is too large, although this overﬁtting tends to occur
slowly if at all. We use cross-validation to select B.

2. The shrinkage parameter λ, a small positive number. This controls the
rate at which boosting learns. Typical values are 0.01 or 0.001, and
the right choice can depend on the problem. Very small λ can require
using a very large value of B in order to achieve good performance.

3. The number d of splits in each tree, which controls the complexity
of the boosted ensemble. Often d = 1 works well, in which case each
tree is a stump, consisting of a single split. In this case, the boosted
ensemble is ﬁtting an additive model, since each term involves only a
single variable. More generally d is the interaction depth, and controls

stump

interaction
depth

8.3 Lab: Decision Trees

323

Algorithm 8.2 Boosting for Regression Trees

1. Set ˆf (x) = 0 and ri = yi for all i in the training set.

2. For b = 1, 2, . . . , B, repeat:

(a) Fit a tree ˆf b with d splits (d + 1 terminal nodes) to the training

data (X, r).

(b) Update ˆf by adding in a shrunken version of the new tree:

ˆf (x) ← ˆf (x) + λ ˆf b(x).

(c) Update the residuals,

ri ← ri − λ ˆf b(xi).

3. Output the boosted model,

ˆf (x) =

B(cid:17)

b=1

λ ˆf b(x).

(8.10)

(8.11)

(8.12)

the interaction order of the boosted model, since d splits can involve
at most d variables.

In Figure 8.11, we applied boosting to the 15-class cancer gene expression
data set, in order to develop a classiﬁer that can distinguish the normal
class from the 14 cancer classes. We display the test error as a function of
the total number of trees and the interaction depth d. We see that simple
stumps with an interaction depth of one perform well if enough of them
are included. This model outperforms the depth-two model, and both out-
perform a random forest. This highlights one diﬀerence between boosting
and random forests: in boosting, because the growth of a particular tree
takes into account the other trees that have already been grown, smaller
trees are typically suﬃcient. Using smaller trees can aid in interpretability
as well; for instance, using stumps leads to an additive model.

8.3 Lab: Decision Trees

8.3.1 Fitting Classiﬁcation Trees

The tree library is used to construct classiﬁcation and regression trees.

> library ( tree )

324

8. Tree-Based Methods

r
o
r
r

E
 
n
o
i
t
a
c
i
f
i
s
s
a
C

l

 
t
s
e
T

Boosting: depth=1
Boosting: depth=2
RandomForest: m= p

5
2
.
0

0
2

.

0

5
1
.
0

0
1
.
0

5
0
0

.

0

1000

2000

3000

4000

5000

Number of Trees

FIGURE 8.11. Results from performing boosting and random forests on the
15-class gene expression data set in order to predict cancer versus normal. The
test error is displayed as a function of the number of trees. For the two boosted
models, λ = 0.01. Depth-1 trees slightly outperform depth-2 trees, and both out-
perform the random forest, although the standard errors are around 0.02, making
none of these diﬀerences signiﬁcant. The test error rate for a single tree is 24 %.

We ﬁrst use classiﬁcation trees to analyze the Carseats data set. In these
data, Sales is a continuous variable, and so we begin by recoding it as a
binary variable. We use the ifelse() function to create a variable, called
High, which takes on a value of Yes if the Sales variable exceeds 8, and
takes on a value of No otherwise.

ifelse()

> library ( ISLR )
> attach ( Carseats )
> High = ifelse ( Sales <=8 ," No " ," Yes ")

Finally, we use the data.frame() function to merge High with the rest of
the Carseats data.

> Carseats = data . frame ( Carseats , High )

We now use the tree() function to ﬁt a classiﬁcation tree in order to predict
High using all variables but Sales. The syntax of the tree() function is quite
similar to that of the lm() function.
> tree . carseats = tree ( High∼. - Sales , Carseats )

tree()

The summary() function lists the variables that are used as internal nodes
in the tree, the number of terminal nodes, and the (training) error rate.

> summary ( tree . carseats )

C l a s s i f i c a t i o n tree :

tree ( formula = High ∼ . - Sales , data = Carseats )

Variables actually used in tree c o n s t r u c t i o n :
[1] " ShelveLoc "

" Income "

" Price "

" CompPrice "

8.3 Lab: Decision Trees

325

[5] " Populatio n "
Number of terminal nodes :
Residual mean deviance :
0.4575 = 170.7 / 373
M i s c l a s s i f i c a t i o n error rate : 0.09 = 36 / 400

" Advertisi n g " " Age "

27

" US "

We see that the training error rate is 9 %. For classiﬁcation trees, the de-
viance reported in the output of summary() is given by

(cid:17)

(cid:17)

−2

nmk log ˆpmk,

m

k

where nmk is the number of observations in the mth terminal node that
belong to the kth class. A small deviance indicates a tree that provides
a good ﬁt to the (training) data. The residual mean deviance reported is

simply the deviance divided by n−|T0|, which in this case is 400−27 = 373.

One of the most attractive properties of trees is that they can be
graphically displayed. We use the plot() function to display the tree struc-
ture, and the text() function to display the node labels. The argument
pretty=0 instructs R to include the category names for any qualitative pre-
dictors, rather than simply displaying a letter for each category.

> plot ( tree . carseats )
> text ( tree . carseats , pretty =0)

The most important indicator of Sales appears to be shelving location,
since the ﬁrst branch diﬀerentiates Good locations from Bad and Medium
locations.

If we just type the name of the tree object, R prints output corresponding
to each branch of the tree. R displays the split criterion (e.g. Price<92.5), the
number of observations in that branch, the deviance, the overall prediction
for the branch (Yes or No), and the fraction of observations in that branch
that take on values of Yes and No. Branches that lead to terminal nodes are
indicated using asterisks.

> tree . carseats
node ) , split , n , deviance , yval , ( yprob )

* denotes terminal node

1) root 400 541.5 No ( 0.590 0.410 )

2) ShelveLoc : Bad , Medium 315 390.6 No ( 0.689 0.311 )

4) Price < 92.5 46

8) Income < 57 10

56.53 Yes ( 0.304 0.696 )
12.22 No ( 0.700 0.300 )

In order to properly evaluate the performance of a classiﬁcation tree on
these data, we must estimate the test error rather than simply computing
the training error. We split the observations into a training set and a test
set, build the tree using the training set, and evaluate its performance on
the test data. The predict() function can be used for this purpose. In the
case of a classiﬁcation tree, the argument type="class" instructs R to return
the actual class prediction. This approach leads to correct predictions for
around 71.5 % of the locations in the test data set.

326

8. Tree-Based Methods

> set . seed (2)
> train = sample (1: nrow ( Carseats ) , 200)
> Carseats . test = Carseats [ - train ,]
> High . test = High [ - train ]

> tree . carseats = tree ( High∼. - Sales , Carseats , subset = train )

> tree . pred = predict ( tree . carseats , Carseats . test , type =" class ")
> table ( tree . pred , High . test )

High . test

tree . pred No Yes
27
57

86
No
Yes 30

> (86+57) /200
[1] 0.715

Next, we consider whether pruning the tree might lead to improved
results. The function cv.tree() performs cross-validation in order to
determine the optimal level of tree complexity; cost complexity pruning
is used in order to select a sequence of trees for consideration. We use
the argument FUN=prune.misclass in order to indicate that we want the
classiﬁcation error rate to guide the cross-validation and pruning process,
rather than the default for the cv.tree() function, which is deviance. The
cv.tree() function reports the number of terminal nodes of each tree con-
sidered (size) as well as the corresponding error rate and the value of the
cost-complexity parameter used (k, which corresponds to α in (8.4)).

cv.tree()

> set . seed (3)
> cv . carseats = cv . tree ( tree . carseats , FUN = prune . misclass )
> names ( cv . carseats )
[1] " size "
> cv . carseats
$size
[1] 19 17 14 13

" method "

" dev "

9

7

" k "

3

2

1

$dev
[1] 55 55 53 52 50 56 69 65 80

$k
[1]

- Inf

0.0000000

0.6666667

1.0000000

1.7500000

2.0000000

4.2500000

[8]

5.0000000 23.0000000

$method
[1] " misclass "

attr ( ," class ")
[1] " prune "

" tree . sequence "

Note that, despite the name, dev corresponds to the cross-validation error
rate in this instance. The tree with 9 terminal nodes results in the lowest
cross-validation error rate, with 50 cross-validation errors. We plot the error
rate as a function of both size and k.

> par ( mfrow = c (1 ,2) )

8.3 Lab: Decision Trees

327

> plot ( cv . carseats$size , cv . carseats$dev , type =" b ")
> plot ( cv . carseats$k , cv . carseats$dev , type =" b ")

We now apply the prune.misclass() function in order to prune the tree to prune.
obtain the nine-node tree.

misclass()

> prune . carseats = prune . misclass ( tree . carseats , best =9)
> plot ( prune . carseats )
> text ( prune . carseats , pretty =0)

How well does this pruned tree perform on the test data set? Once again,

we apply the predict() function.

> tree . pred = predict ( prune . carseats , Carseats . test , type =" class ")
> table ( tree . pred , High . test )

High . test

tree . pred No Yes
24
60

No
94
Yes 22

> (94+60) /200
[1] 0.77

Now 77 % of the test observations are correctly classiﬁed, so not only has
the pruning process produced a more interpretable tree, but it has also
improved the classiﬁcation accuracy.

If we increase the value of best, we obtain a larger pruned tree with lower

classiﬁcation accuracy:

> prune . carseats = prune . misclass ( tree . carseats , best =15)
> plot ( prune . carseats )
> text ( prune . carseats , pretty =0)
> tree . pred = predict ( prune . carseats , Carseats . test , type =" class ")
> table ( tree . pred , High . test )

High . test

tree . pred No Yes
22
62

86
No
Yes 30

> (86+62) /200
[1] 0.74

8.3.2 Fitting Regression Trees

Here we ﬁt a regression tree to the Boston data set. First, we create a
training set, and ﬁt the tree to the training data.

> library ( MASS )
> set . seed (1)
> train = sample (1: nrow ( Boston ) , nrow ( Boston ) /2)

> tree . boston = tree ( medv∼. , Boston , subset = train )

> summary ( tree . boston )

Regressio n tree :

tree ( formula = medv ∼ . , data = Boston , subset = train )

328

8. Tree-Based Methods

Variables actually used in tree c o n s t r u c t i o n :
[1] " lstat " " rm "
" dis "
Number of terminal nodes :
Residual mean deviance :
D i s t r i b u t i o n of residuals :
Median
-0.0536

Min .
-14.1000

12.65 = 3099 / 245

1 st Qu .
-2.0420

8

Mean
0.0000

3 rd Qu .
1.9600

Max .
12.6000

Notice that the output of summary() indicates that only three of the vari-
ables have been used in constructing the tree. In the context of a regression
tree, the deviance is simply the sum of squared errors for the tree. We now
plot the tree.

> plot ( tree . boston )
> text ( tree . boston , pretty =0)

The variable lstat measures the percentage of individuals with lower
socioeconomic status. The tree indicates that lower values of lstat cor-
respond to more expensive houses. The tree predicts a median house price
of $46, 400 for larger homes in suburbs in which residents have high socioe-
conomic status (rm>=7.437 and lstat<9.715).

Now we use the cv.tree() function to see whether pruning the tree will

improve performance.

> cv . boston = cv . tree ( tree . boston )
> plot ( cv . boston$size , cv . boston$dev , type = ’ b ’)

In this case, the most complex tree is selected by cross-validation. How-
ever, if we wish to prune the tree, we could do so as follows, using the
prune.tree() function:

prune.tree()

> prune . boston = prune . tree ( tree . boston , best =5)
> plot ( prune . boston )
> text ( prune . boston , pretty =0)

In keeping with the cross-validation results, we use the unpruned tree to
make predictions on the test set.

> yhat = predict ( tree . boston , newdata = Boston [ - train ,])
> boston . test = Boston [ - train ," medv "]
> plot ( yhat , boston . test )
> abline (0 ,1)
> mean (( yhat - boston . test ) ^2)
[1] 25.05

In other words, the test set MSE associated with the regression tree is
25.05. The square root of the MSE is therefore around 5.005, indicating
that this model leads to test predictions that are within around $5, 005 of
the true median home value for the suburb.

8.3.3 Bagging and Random Forests

Here we apply bagging and random forests to the Boston data, using the
randomForest package in R. The exact results obtained in this section may

8.3 Lab: Decision Trees

329

depend on the version of R and the version of the randomForest package
installed on your computer. Recall that bagging is simply a special case of
a random forest with m = p. Therefore, the randomForest() function can
be used to perform both random forests and bagging. We perform bagging
as follows:

random
Forest()

> library ( r a n d o m F o r e s t )
> set . seed (1)

> bag . boston = r a n d o m F o r e s t ( medv∼. , data = Boston , subset = train ,

mtry =13 , importanc e = TRUE )

> bag . boston

Call :

r a n d o m F o r e s t ( formula = medv ∼ . , data = Boston , mtry = 13 ,

importance = TRUE ,

subset = train )

Type of random forest : regression

Number of trees : 500

No . of variables tried at each split : 13

Mean of squared residuals : 10.77
% Var explained : 86.96

The argument mtry=13 indicates that all 13 predictors should be considered
for each split of the tree—in other words, that bagging should be done. How
well does this bagged model perform on the test set?

> yhat . bag = predict ( bag . boston , newdata = Boston [ - train ,])
> plot ( yhat . bag , boston . test )
> abline (0 ,1)
> mean (( yhat . bag - boston . test ) ^2)
[1] 13.16

The test set MSE associated with the bagged regression tree is 13.16, almost
half that obtained using an optimally-pruned single tree. We could change
the number of trees grown by randomForest() using the ntree argument:
> bag . boston = r a n d o m F o r e s t ( medv∼. , data = Boston , subset = train ,

mtry =13 , ntree =25)

> yhat . bag = predict ( bag . boston , newdata = Boston [ - train ,])
> mean (( yhat . bag - boston . test ) ^2)
[1] 13.31

Growing a random forest proceeds in exactly the same way, except that
we use a smaller value of the mtry argument. By default, randomForest()
√
uses p/3 variables when building a random forest of regression trees, and
p variables when building a random forest of classiﬁcation trees. Here we

use mtry = 6.

> set . seed (1)

> rf . boston = r a n d o m F o r e s t ( medv∼. , data = Boston , subset = train ,

mtry =6 , importance = TRUE )

> yhat . rf = predict ( rf . boston , newdata = Boston [ - train ,])
> mean (( yhat . rf - boston . test ) ^2)
[1] 11.31

330

8. Tree-Based Methods

The test set MSE is 11.31; this indicates that random forests yielded an
improvement over bagging in this case.

Using the importance() function, we can view the importance of each

variable.

> importanc e ( rf . boston )

crim
zn
indus
chas
nox
rm
age
dis
rad
tax
ptratio
black
lstat

% IncMSE I n c N o d e P u r i t y
1051.54
50.31
1017.64
56.32
1107.31
5917.26
552.27
1223.93
84.30
435.71
817.33
367.00
7713.63

12.384
2.103
8.390
2.294
12.791
30.754
10.334
14.641
3.583
8.139
11.274
8.097
30.962

importance()

Two measures of variable importance are reported. The former is based
upon the mean decrease of accuracy in predictions on the out of bag samples
when a given variable is excluded from the model. The latter is a measure
of the total decrease in node impurity that results from splits over that
variable, averaged over all trees (this was plotted in Figure 8.9). In the
case of regression trees, the node impurity is measured by the training
RSS, and for classiﬁcation trees by the deviance. Plots of these importance
measures can be produced using the varImpPlot() function.

> varImpPlo t ( rf . boston )

The results indicate that across all of the trees considered in the random
forest, the wealth level of the community (lstat) and the house size (rm)
are by far the two most important variables.

varImpPlot()

8.3.4 Boosting

Here we use the gbm package, and within it the gbm() function, to ﬁt boosted
regression trees to the Boston data set. We run gbm() with the option
distribution="gaussian" since this is a regression problem; if it were a bi-
nary classiﬁcation problem, we would use distribution="bernoulli". The
argument n.trees=5000 indicates that we want 5000 trees, and the option
interaction.depth=4 limits the depth of each tree.

gbm()

> library ( gbm )
> set . seed (1)

> boost . boston = gbm ( medv∼. , data = Boston [ train ,] , d i s t r i b u t i o n =

" gaussian " , n . trees =5000 , interactio n . depth =4)

The summary() function produces a relative inﬂuence plot and also outputs
the relative inﬂuence statistics.

8.3 Lab: Decision Trees

331

> summary ( boost . boston )

var
lstat
rm
dis
crim
nox
ptratio
black
age
tax
indus
chas
rad
zn

1
2
3
4
5
6
7
8
9
10
11
12
13

rel . inf
45.96
31.22
6.81
4.07
2.56
2.27
1.80
1.64
1.36
1.27
0.80
0.20
0.015

We see that lstat and rm are by far the most important variables. We can
also produce partial dependence plots for these two variables. These plots
illustrate the marginal eﬀect of the selected variables on the response after
integrating out the other variables. In this case, as we might expect, median
house prices are increasing with rm and decreasing with lstat.

partial
dependence
plot

> par ( mfrow = c (1 ,2) )
> plot ( boost . boston , i =" rm ")
> plot ( boost . boston , i =" lstat ")

We now use the boosted model to predict medv on the test set:

> yhat . boost = predict ( boost . boston , newdata = Boston [ - train ,] ,

n . trees =5000)

> mean (( yhat . boost - boston . test ) ^2)
[1] 11.8

The test MSE obtained is 11.8; similar to the test MSE for random forests
and superior to that for bagging. If we want to, we can perform boosting
with a diﬀerent value of the shrinkage parameter λ in (8.10). The default
value is 0.001, but this is easily modiﬁed. Here we take λ = 0.2.

> boost . boston = gbm ( medv∼. , data = Boston [ train ,] , d i s t r i b u t i o n =

" gaussian " , n . trees =5000 , interacti on . depth =4 , shrinkage =0.2 ,
verbose = F )

> yhat . boost = predict ( boost . boston , newdata = Boston [ - train ,] ,

n . trees =5000)

> mean (( yhat . boost - boston . test ) ^2)
[1] 11.5

In this case, using λ = 0.2 leads to a slightly lower test MSE than λ = 0.001.

332

8. Tree-Based Methods

8.4 Exercises

Conceptual

1. Draw an example (of your own invention) of a partition of two-
dimensional feature space that could result from recursive binary
splitting. Your example should contain at least six regions. Draw a
decision tree corresponding to this partition. Be sure to label all as-
pects of your ﬁgures, including the regions R1, R2, . . ., the cutpoints
t1, t2, . . ., and so forth.
Hint: Your result should look something like Figures 8.1 and 8.2.

2. It is mentioned in Section 8.2.3 that boosting using depth-one trees
(or stumps) leads to an additive model: that is, a model of the form

p(cid:17)

f (X) =

fj(Xj).

j=1

Explain why this is the case. You can begin with (8.12) in
Algorithm 8.2.

3. Consider the Gini index, classiﬁcation error, and entropy in a
simple classiﬁcation setting with two classes. Create a single plot
that displays each of these quantities as a function of ˆpm1. The x-
axis should display ˆpm1, ranging from 0 to 1, and the y-axis should
display the value of the Gini index, classiﬁcation error, and entropy.
Hint: In a setting with two classes, ˆpm1 = 1 − ˆpm2. You could make

this plot by hand, but it will be much easier to make in R.

4. This question relates to the plots in Figure 8.12.

(a) Sketch the tree corresponding to the partition of the predictor
space illustrated in the left-hand panel of Figure 8.12. The num-
bers inside the boxes indicate the mean of Y within each region.

(b) Create a diagram similar to the left-hand panel of Figure 8.12,
using the tree illustrated in the right-hand panel of the same
ﬁgure. You should divide up the predictor space into the correct
regions, and indicate the mean for each region.

5. Suppose we produce ten bootstrapped samples from a data set
containing red and green classes. We then apply a classiﬁcation tree
to each bootstrapped sample and, for a speciﬁc value of X, produce
10 estimates of P (Class is Red|X):

0.1, 0.15, 0.2, 0.2, 0.55, 0.6, 0.6, 0.65, 0.7, and 0.75.

8.4 Exercises

333

X2 < 1

X2 1

0

3

5

15

0

0

10

1
X1

X1 < 1

X2 < 2

X1 < 0

2.49

−1.80

0.63

−1.06

0.21

FIGURE 8.12. Left: A partition of the predictor space corresponding to Exer-
cise 4a. Right: A tree corresponding to Exercise 4b.

There are two common ways to combine these results together into a
single class prediction. One is the majority vote approach discussed in
this chapter. The second approach is to classify based on the average
probability. In this example, what is the ﬁnal classiﬁcation under each
of these two approaches?

6. Provide a detailed explanation of the algorithm that is used to ﬁt a

regression tree.

Applied

7. In the lab, we applied random forests to the Boston data using mtry=6
and using ntree=25 and ntree=500. Create a plot displaying the test
error resulting from random forests on this data set for a more com-
prehensive range of values for mtry and ntree. You can model your
plot after Figure 8.10. Describe the results obtained.

8. In the lab, a classiﬁcation tree was applied to the Carseats data set af-
ter converting Sales into a qualitative response variable. Now we will
seek to predict Sales using regression trees and related approaches,
treating the response as a quantitative variable.

(a) Split the data set into a training set and a test set.

(b) Fit a regression tree to the training set. Plot the tree, and inter-

pret the results. What test MSE do you obtain?

(c) Use cross-validation in order to determine the optimal level of
tree complexity. Does pruning the tree improve the test MSE?

(d) Use the bagging approach in order to analyze this data. What
test MSE do you obtain? Use the importance() function to de-
termine which variables are most important.

334

8. Tree-Based Methods

(e) Use random forests to analyze this data. What test MSE do you
obtain? Use the importance() function to determine which vari-
ables are most important. Describe the eﬀect of m, the number of
variables
rate
obtained.

considered at

error

each split,

on the

9. This problem involves the OJ data set which is part of the ISLR

package.

(a) Create a training set containing a random sample of 800 obser-

vations, and a test set containing the remaining observations.

(b) Fit a tree to the training data, with Purchase as the response
and the other variables as predictors. Use the summary() function
to produce summary statistics about the tree, and describe the
results obtained. What is the training error rate? How many
terminal nodes does the tree have?

(c) Type in the name of the tree object in order to get a detailed
text output. Pick one of the terminal nodes, and interpret the
information displayed.

(d) Create a plot of the tree, and interpret the results.

(e) Predict the response on the test data, and produce a confusion
matrix comparing the test labels to the predicted test labels.
What is the test error rate?

(f) Apply the cv.tree() function to the training set in order to

determine the optimal tree size.

(g) Produce a plot with tree size on the x-axis and cross-validated

classiﬁcation error rate on the y-axis.

(h) Which tree size corresponds to the lowest cross-validated classi-

ﬁcation error rate?

(i) Produce a pruned tree corresponding to the optimal tree size
obtained using cross-validation. If cross-validation does not lead
to selection of a pruned tree, then create a pruned tree with ﬁve
terminal nodes.

(j) Compare the training error rates between the pruned and un-

pruned trees. Which is higher?

(k) Compare the test error rates between the pruned and unpruned

trees. Which is higher?

10. We now use boosting to predict Salary in the Hitters data set.

(a) Remove the observations for whom the salary information is

unknown, and then log-transform the salaries.

8.4 Exercises

335

(b) Create a training set consisting of the ﬁrst 200 observations, and

a test set consisting of the remaining observations.

(c) Perform boosting on the training set with 1,000 trees for a range
of values of the shrinkage parameter λ. Produce a plot with
diﬀerent shrinkage values on the x-axis and the corresponding
training set MSE on the y-axis.

(d) Produce a plot with diﬀerent shrinkage values on the x-axis and

the corresponding test set MSE on the y-axis.

(e) Compare the test MSE of boosting to the test MSE that results
the regression approaches seen in

from applying two of
Chapters 3 and 6.

(f) Which variables appear to be the most important predictors in

the boosted model?

(g) Now apply bagging to the training set. What is the test set MSE

for this approach?

11. This question uses the Caravan data set.

(a) Create a training set consisting of the ﬁrst 1,000 observations,

and a test set consisting of the remaining observations.

(b) Fit a boosting model to the training set with Purchase as the
response and the other variables as predictors. Use 1,000 trees,
and a shrinkage value of 0.01. Which predictors appear to be
the most important?

(c) Use the boosting model to predict the response on the test data.
Predict that a person will make a purchase if the estimated prob-
ability of purchase is greater than 20 %. Form a confusion ma-
trix. What fraction of the people predicted to make a purchase
do in fact make one? How does this compare with the results
obtained from applying KNN or logistic regression to this data
set?

12. Apply boosting, bagging, and random forests to a data set of your
choice. Be sure to ﬁt the models on a training set and to evaluate their
performance on a test set. How accurate are the results compared
to simple methods like linear or logistic regression? Which of these
approaches yields the best performance?

9
Support Vector Machines

In this chapter, we discuss the support vector machine (SVM), an approach
for classiﬁcation that was developed in the computer science community in
the 1990s and that has grown in popularity since then. SVMs have been
shown to perform well in a variety of settings, and are often considered one
of the best “out of the box” classiﬁers.

The support vector machine is a generalization of a simple and intu-
itive classiﬁer called the maximal margin classiﬁer , which we introduce in
Section 9.1. Though it is elegant and simple, we will see that this classiﬁer
unfortunately cannot be applied to most data sets, since it requires that
the classes be separable by a linear boundary. In Section 9.2, we introduce
the support vector classiﬁer , an extension of the maximal margin classiﬁer
that can be applied in a broader range of cases. Section 9.3 introduces the
support vector machine, which is a further extension of the support vec-
tor classiﬁer in order to accommodate non-linear class boundaries. Support
vector machines are intended for the binary classiﬁcation setting in which
there are two classes; in Section 9.4 we discuss extensions of support vector
machines to the case of more than two classes. In Section 9.5 we discuss
the close connections between support vector machines and other statistical
methods such as logistic regression.

People often loosely refer to the maximal margin classiﬁer, the support
vector classiﬁer, and the support vector machine as “support vector
machines”. To avoid confusion, we will carefully distinguish between these
three notions in this chapter.

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 9,
© Springer Science+Business Media New York 2013

337

338

9. Support Vector Machines

9.1 Maximal Margin Classiﬁer

In this section, we deﬁne a hyperplane and introduce the concept of an
optimal separating hyperplane.

9.1.1 What Is a Hyperplane?

In a p-dimensional space, a hyperplane is a ﬂat aﬃne subspace of
dimension p − 1.1 For instance, in two dimensions, a hyperplane is a ﬂat
one-dimensional subspace—in other words, a line. In three dimensions, a
hyperplane is a ﬂat two-dimensional subspace—that is, a plane. In p > 3
dimensions, it can be hard to visualize a hyperplane, but the notion of a
(p − 1)-dimensional ﬂat subspace still applies.

The mathematical deﬁnition of a hyperplane is quite simple. In two di-

mensions, a hyperplane is deﬁned by the equation

hyperplane

β0 + β1X1 + β2X2 = 0

(9.1)

for parameters β0, β1, and β2. When we say that (9.1) “deﬁnes” the hyper-
plane, we mean that any X = (X1, X2)T for which (9.1) holds is a point
on the hyperplane. Note that (9.1) is simply the equation of a line, since
indeed in two dimensions a hyperplane is a line.

Equation 9.1 can be easily extended to the p-dimensional setting:

β0 + β1X1 + β2X2 + . . . + βpXp = 0

(9.2)

deﬁnes a p-dimensional hyperplane, again in the sense that if a point X =
(X1, X2, . . . , Xp)T in p-dimensional space (i.e. a vector of length p) satisﬁes
(9.2), then X lies on the hyperplane.

Now, suppose that X does not satisfy (9.2); rather,

β0 + β1X1 + β2X2 + . . . + βpXp > 0.

(9.3)

Then this tells us that X lies to one side of the hyperplane. On the other
hand, if

β0 + β1X1 + β2X2 + . . . + βpXp < 0,

(9.4)

then X lies on the other side of the hyperplane. So we can think of the
hyperplane as dividing p-dimensional space into two halves. One can easily
determine on which side of the hyperplane a point lies by simply calculating
the sign of the left hand side of (9.2). A hyperplane in two-dimensional
space is shown in Figure 9.1.

1The word aﬃne indicates that the subspace need not pass through the origin.

9.1 Maximal Margin Classiﬁer

339

5

.

1

0
1

.

5

.

0

2

X

0
0

.

5

.
0
−

0
.
1
−

5
.
1
−

−1.5

−1.0

−0.5

0.5

1.0

1.5

0.0
X1

FIGURE 9.1. The hyperplane 1 + 2X1 + 3X2 = 0 is shown. The blue region is
the set of points for which 1 + 2X1 + 3X2 > 0, and the purple region is the set of
points for which 1 + 2X1 + 3X2 < 0.

9.1.2 Classiﬁcation Using a Separating Hyperplane
Now suppose that we have a n× p data matrix X that consists of n training
observations in p-dimensional space,

⎛
⎜⎝

x11
...
x1p

⎞
⎟⎠ , . . . , xn =

⎛
⎜⎝

⎞
⎟⎠ ,

xn1
...
xnp

x1 =

(9.5)

and that these observations fall into two classes—that is, y1, . . . , yn ∈
{−1, 1} where −1 represents one class and 1 the other class. We also have a
∗
test observation, a p-vector of observed features x
. Our
goal is to develop a classiﬁer based on the training data that will correctly
classify the test observation using its feature measurements. We have seen
a number of approaches for this task, such as linear discriminant analysis
and logistic regression in Chapter 4, and classiﬁcation trees, bagging, and
boosting in Chapter 8. We will now see a new approach that is based upon
the concept of a separating hyperplane.

∗
. . . x
p

(cid:9)T

(cid:8)
∗
x
1

=

Suppose that it is possible to construct a hyperplane that separates the
training observations perfectly according to their class labels. Examples
of three such separating hyperplanes are shown in the left-hand panel of
Figure 9.2. We can label the observations from the blue class as yi = 1 and

separating
hyperplane

340

9. Support Vector Machines

3

2

2

X

1

0

1
−

3

2

2

X

1

0

1
−

−1

0

1

X1

2

3

−1

0

2

3

1

X1

FIGURE 9.2. Left: There are two classes of observations, shown in blue and
in purple, each of which has measurements on two variables. Three separating
hyperplanes, out of many possible, are shown in black. Right: A separating hy-
perplane is shown in black. The blue and purple grid indicates the decision rule
made by a classiﬁer based on this separating hyperplane: a test observation that
falls in the blue portion of the grid will be assigned to the blue class, and a test
observation that falls into the purple portion of the grid will be assigned to the
purple class.

those from the purple class as yi = −1. Then a separating hyperplane has

the property that

β0 + β1xi1 + β2xi2 + . . . + βpxip > 0 if yi = 1,

(9.6)

and

β0 + β1xi1 + β2xi2 + . . . + βpxip < 0 if yi = −1.

(9.7)

Equivalently, a separating hyperplane has the property that

yi(β0 + β1xi1 + β2xi2 + . . . + βpxip) > 0

(9.8)

for all i = 1, . . . , n.

If a separating hyperplane exists, we can use it to construct a very natural
classiﬁer: a test observation is assigned a class depending on which side of
the hyperplane it is located. The right-hand panel of Figure 9.2 shows
∗
an example of such a classiﬁer. That is, we classify the test observation x
∗
based on the sign of f (x
) is positive,
∗
then we assign the test observation to class 1, and if f (x
) is negative, then
we assign it to class −1. We can also make use of the magnitude of f (x
∗
). If
∗
f (x
lies far from the hyperplane,
∗
and so we can be conﬁdent about our class assignment for x
. On the other

∗
∗
∗
∗
p. If f (x
2+. . .+βpx
1+β2x
) = β0+β1x

∗
) is far from zero, then this means that x

9.1 Maximal Margin Classiﬁer

341

∗
) is close to zero, then x

∗
hand, if f (x
is located near the hyperplane, and so
∗
we are less certain about the class assignment for x
. Not surprisingly, and
as we see in Figure 9.2, a classiﬁer that is based on a separating hyperplane
leads to a linear decision boundary.

9.1.3 The Maximal Margin Classiﬁer

In general, if our data can be perfectly separated using a hyperplane, then
there will in fact exist an inﬁnite number of such hyperplanes. This is
because a given separating hyperplane can usually be shifted a tiny bit up or
down, or rotated, without coming into contact with any of the observations.
Three possible separating hyperplanes are shown in the left-hand panel
of Figure 9.2. In order to construct a classiﬁer based upon a separating
hyperplane, we must have a reasonable way to decide which of the inﬁnite
possible separating hyperplanes to use.

A natural choice is the maximal margin hyperplane (also known as the
optimal separating hyperplane), which is the separating hyperplane that
is farthest from the training observations. That is, we can compute the
(perpendicular) distance from each training observation to a given separat-
ing hyperplane; the smallest such distance is the minimal distance from the
observations to the hyperplane, and is known as the margin. The maximal
margin hyperplane is the separating hyperplane for which the margin is
largest—that is, it is the hyperplane that has the farthest minimum dis-
tance to the training observations. We can then classify a test observation
based on which side of the maximal margin hyperplane it lies. This is known
as the maximal margin classiﬁer. We hope that a classiﬁer that has a large
margin on the training data will also have a large margin on the test data,
and hence will classify the test observations correctly. Although the maxi-
mal margin classiﬁer is often successful, it can also lead to overﬁtting when
p is large.

maximal
margin
hyperplane

optimal
separating
hyperplane

margin

maximal
margin
classiﬁer

If β0, β1, . . . , βp are the coeﬃcients of the maximal margin hyperplane,
based

∗
then the maximal margin classiﬁer classiﬁes the test observation x
∗
on the sign of f (x

∗
∗
∗
2 + . . . + βpx
1 + β2x
) = β0 + β1x
p.

Figure 9.3 shows the maximal margin hyperplane on the data set of
Figure 9.2. Comparing the right-hand panel of Figure 9.2 to Figure 9.3,
we see that the maximal margin hyperplane shown in Figure 9.3 does in-
deed result in a greater minimal distance between the observations and the
separating hyperplane—that is, a larger margin. In a sense, the maximal
margin hyperplane represents the mid-line of the widest “slab” that we can
insert between the two classes.

Examining Figure 9.3, we see that three training observations are equidis-
tant from the maximal margin hyperplane and lie along the dashed lines
indicating the width of the margin. These three observations are known as

342

9. Support Vector Machines

3

2

2

X

1

0

1
−

−1

0

1
X1

2

3

FIGURE 9.3. There are two classes of observations, shown in blue and in pur-
ple. The maximal margin hyperplane is shown as a solid line. The margin is the
distance from the solid line to either of the dashed lines. The two blue points and
the purple point that lie on the dashed lines are the support vectors, and the dis-
tance from those points to the hyperplane is indicated by arrows. The purple and
blue grid indicates the decision rule made by a classiﬁer based on this separating
hyperplane.

support vectors, since they are vectors in p-dimensional space (in Figure 9.3,
p = 2) and they “support” the maximal margin hyperplane in the sense
that if these points were moved slightly then the maximal margin hyper-
plane would move as well. Interestingly, the maximal margin hyperplane
depends directly on the support vectors, but not on the other observations:
a movement to any of the other observations would not aﬀect the separating
hyperplane, provided that the observation’s movement does not cause it to
cross the boundary set by the margin. The fact that the maximal margin
hyperplane depends directly on only a small subset of the observations is
an important property that will arise later in this chapter when we discuss
the support vector classiﬁer and support vector machines.

support
vector

9.1.4 Construction of the Maximal Margin Classiﬁer

We now consider the task of constructing the maximal margin hyperplane

based on a set of n training observations x1, . . . , xn ∈ Rp and associated
class labels y1, . . . , yn ∈ {−1, 1}. Brieﬂy, the maximal margin hyperplane

is the solution to the optimization problem

9.1 Maximal Margin Classiﬁer

343

β2
j = 1,

(9.9)

(9.10)

maximize
β0,β1,...,βp

,M

M
p(cid:17)

subject to

j=1

yi(β0 + β1xi1 + β2xi2 + . . . + βpxip) ≥ M ∀ i = 1, . . . , n. (9.11)

This optimization problem (9.9)–(9.11) is actually simpler than it looks.
First of all, the constraint in (9.11) that

yi(β0 + β1xi1 + β2xi2 + . . . + βpxip) ≥ M ∀ i = 1, . . . , n

guarantees that each observation will be on the correct side of the hyper-
plane, provided that M is positive. (Actually, for each observation to be on
the correct side of the hyperplane we would simply need yi(β0 + β1xi1 +
β2xi2 +. . .+βpxip) > 0, so the constraint in (9.11) in fact requires that each
observation be on the correct side of the hyperplane, with some cushion,
provided that M is positive.)

Second, note that (9.10) is not really a constraint on the hyperplane, since
if β0 + β1xi1 + β2xi2 + . . . + βpxip = 0 deﬁnes a hyperplane, then so does
k(β0 + β1xi1 + β2xi2 + . . . + βpxip) = 0 for any k (cid:4)= 0. However, (9.10) adds

meaning to (9.11); one can show that with this constraint the perpendicular
distance from the ith observation to the hyperplane is given by

yi(β0 + β1xi1 + β2xi2 + . . . + βpxip).

Therefore, the constraints (9.10) and (9.11) ensure that each observation
is on the correct side of the hyperplane and at least a distance M from the
hyperplane. Hence, M represents the margin of our hyperplane, and the
optimization problem chooses β0, β1, . . . , βp to maximize M . This is exactly
the deﬁnition of the maximal margin hyperplane! The problem (9.9)–(9.11)
can be solved eﬃciently, but details of this optimization are outside of the
scope of this book.

9.1.5 The Non-separable Case

The maximal margin classiﬁer is a very natural way to perform classiﬁ-
cation, if a separating hyperplane exists. However, as we have hinted, in
many cases no separating hyperplane exists, and so there is no maximal
margin classiﬁer. In this case, the optimization problem (9.9)–(9.11) has no
solution with M > 0. An example is shown in Figure 9.4. In this case, we
cannot exactly separate the two classes. However, as we will see in the next
section, we can extend the concept of a separating hyperplane in order to
develop a hyperplane that almost separates the classes, using a so-called
soft margin. The generalization of the maximal margin classiﬁer to the
non-separable case is known as the support vector classiﬁer.

344

9. Support Vector Machines

2

X

0

.

2

5

.

1

0

.

1

5

.

0

0

.

0

5
.
0
−

0

.

1
−

0

1

X1

2

3

FIGURE 9.4. There are two classes of observations, shown in blue and in pur-
ple. In this case, the two classes are not separable by a hyperplane, and so the
maximal margin classiﬁer cannot be used.

9.2 Support Vector Classiﬁers

9.2.1 Overview of the Support Vector Classiﬁer

In Figure 9.4, we see that observations that belong to two classes are not
necessarily separable by a hyperplane. In fact, even if a separating hyper-
plane does exist, then there are instances in which a classiﬁer based on
a separating hyperplane might not be desirable. A classiﬁer based on a
separating hyperplane will necessarily perfectly classify all of the training
observations; this can lead to sensitivity to individual observations. An ex-
ample is shown in Figure 9.5. The addition of a single observation in the
right-hand panel of Figure 9.5 leads to a dramatic change in the maxi-
mal margin hyperplane. The resulting maximal margin hyperplane is not
satisfactory—for one thing, it has only a tiny margin. This is problematic
because as discussed previously, the distance of an observation from the
hyperplane can be seen as a measure of our conﬁdence that the obser-
vation was correctly classiﬁed. Moreover, the fact that the maximal mar-
gin hyperplane is extremely sensitive to a change in a single observation
suggests that it may have overﬁt the training data.

In this case, we might be willing to consider a classiﬁer based on a hy-
perplane that does not perfectly separate the two classes, in the interest of

9.2 Support Vector Classiﬁers

345

2

X

3

2

1

0

1
−

2

X

3

2

1

0

1
−

−1

0

1
X1

2

3

−1

0

2

3

1
X1

FIGURE 9.5. Left: Two classes of observations are shown in blue and in
purple, along with the maximal margin hyperplane. Right: An additional blue
observation has been added, leading to a dramatic shift in the maximal margin
hyperplane shown as a solid line. The dashed line indicates the maximal margin
hyperplane that was obtained in the absence of this additional point.

• Greater robustness to individual observations, and
• Better classiﬁcation of most of the training observations.

That is, it could be worthwhile to misclassify a few training observations
in order to do a better job in classifying the remaining observations.

The support vector classiﬁer, sometimes called a soft margin classiﬁer,
does exactly this. Rather than seeking the largest possible margin so that
every observation is not only on the correct side of the hyperplane but
also on the correct side of the margin, we instead allow some observations
to be on the incorrect side of the margin, or even the incorrect side of
the hyperplane. (The margin is soft because it can be violated by some
of the training observations.) An example is shown in the left-hand panel
of Figure 9.6. Most of the observations are on the correct side of the margin.
However, a small subset of the observations are on the wrong side of the
margin.

An observation can be not only on the wrong side of the margin, but also
on the wrong side of the hyperplane. In fact, when there is no separating
hyperplane, such a situation is inevitable. Observations on the wrong side of
the hyperplane correspond to training observations that are misclassiﬁed by
the support vector classiﬁer. The right-hand panel of Figure 9.6 illustrates
such a scenario.

9.2.2 Details of the Support Vector Classiﬁer

The support vector classiﬁer classiﬁes a test observation depending on
which side of a hyperplane it lies. The hyperplane is chosen to correctly

support
vector
classiﬁer
soft margin
classiﬁer

346

9. Support Vector Machines

2

X

4

3

2

1

0

1
−

10

9

8

2

X

7

1

3

5

2

4

6

4

3

2

1

0

1
−

3

12

5

4

6

10

9

8

7

11

1

2

−0.5

0.0

0.5

1.0
X1

1.5

2.0

2.5

−0.5

0.0

0.5

1.5

2.0

2.5

1.0
X1

FIGURE 9.6. Left: A support vector classiﬁer was ﬁt to a small data set. The
hyperplane is shown as a solid line and the margins are shown as dashed lines.
Purple observations: Observations 3, 4, 5, and 6 are on the correct side of the
margin, observation 2 is on the margin, and observation 1 is on the wrong side of
the margin. Blue observations: Observations 7 and 10 are on the correct side of
the margin, observation 9 is on the margin, and observation 8 is on the wrong side
of the margin. No observations are on the wrong side of the hyperplane. Right:
Same as left panel with two additional points, 11 and 12. These two observations
are on the wrong side of the hyperplane and the wrong side of the margin.

separate most of the training observations into the two classes, but may
misclassify a few observations. It is the solution to the optimization problem

maximize

M

β0,β1,...,βp,1,...,n

,M

p(cid:17)

subject to

β2
j = 1,

j=1

yi(β0 + β1xi1 + β2xi2 + . . . + βpxip) ≥ M (1 − i),
i ≥ 0,

i ≤ C,

n(cid:17)

(9.12)

(9.13)

(9.14)

(9.15)

i=1

where C is a nonnegative tuning parameter. As in (9.11), M is the width
of the margin; we seek to make this quantity as large as possible. In (9.14),
1, . . . , n are slack variables that allow individual observations to be on
the wrong side of the margin or the hyperplane; we will explain them in
greater detail momentarily. Once we have solved (9.12)–(9.15), we classify
∗
a test observation x
as before, by simply determining on which side of the
hyperplane it lies. That is, we classify the test observation based on the
∗
sign of f (x

∗
∗
1 + . . . + βpx
) = β0 + β1x
p.

The problem (9.12)–(9.15) seems complex, but insight into its behavior
can be made through a series of simple observations presented below. First
of all, the slack variable i tells us where the ith observation is located,
relative to the hyperplane and relative to the margin. If i = 0 then the ith

slack
variable

9.2 Support Vector Classiﬁers

347

observation is on the correct side of the margin, as we saw in Section 9.1.4.
If i > 0 then the ith observation is on the wrong side of the margin, and
we say that the ith observation has violated the margin. If i > 1 then it
is on the wrong side of the hyperplane.

We now consider the role of the tuning parameter C. In (9.15), C bounds
the sum of the i’s, and so it determines the number and severity of the vio-
lations to the margin (and to the hyperplane) that we will tolerate. We can
think of C as a budget for the amount that the margin can be violated
by the n observations. If C = 0 then there is no budget for violations to
the margin, and it must be the case that 1 = . . . = n = 0, in which case
(9.12)–(9.15) simply amounts to the maximal margin hyperplane optimiza-
tion problem (9.9)–(9.11). (Of course, a maximal margin hyperplane exists
only if the two classes are separable.) For C > 0 no more than C observa-
tions can be on the wrong side of the hyperplane, because if an observation
is on the wrong side of the hyperplane then i > 1, and (9.15) requires
that
violations to the margin, and so the margin will widen. Conversely, as C
decreases, we become less tolerant of violations to the margin and so the
margin narrows. An example in shown in Figure 9.7.

i=1 i ≤ C. As the budget C increases, we become more tolerant of

(cid:10)

n

In practice, C is treated as a tuning parameter that is generally chosen via
cross-validation. As with the tuning parameters that we have seen through-
out this book, C controls the bias-variance trade-oﬀ of the statistical learn-
ing technique. When C is small, we seek narrow margins that are rarely
violated; this amounts to a classiﬁer that is highly ﬁt to the data, which
may have low bias but high variance. On the other hand, when C is larger,
the margin is wider and we allow more violations to it; this amounts to
ﬁtting the data less hard and obtaining a classiﬁer that is potentially more
biased but may have lower variance.

The optimization problem (9.12)–(9.15) has a very interesting property:
it turns out that only observations that either lie on the margin or that
violate the margin will aﬀect the hyperplane, and hence the classiﬁer ob-
tained. In other words, an observation that lies strictly on the correct side
of the margin does not aﬀect the support vector classiﬁer! Changing the
position of that observation would not change the classiﬁer at all, provided
that its position remains on the correct side of the margin. Observations
that lie directly on the margin, or on the wrong side of the margin for
their class, are known as support vectors. These observations do aﬀect the
support vector classiﬁer.

The fact that only support vectors aﬀect the classiﬁer is in line with our
previous assertion that C controls the bias-variance trade-oﬀ of the support
vector classiﬁer. When the tuning parameter C is large, then the margin is
wide, many observations violate the margin, and so there are many support
vectors. In this case, many observations are involved in determining the
hyperplane. The top left panel in Figure 9.7 illustrates this setting: this
classiﬁer has low variance (since many observations are support vectors)

348

9. Support Vector Machines

3

2

1

2

X

0

1
−

2
−

3
−

3

2

1

2

X

0

1
−

2
−

3
−

−1

0

1

2

X1

3

2

1

2

X

0

1
−

2
−

3
−

3

2

1

2

X

0

1
−

2
−

3
−

−1

0

1

2

X1

−1

0

1

2

−1

0

1

2

X1

X1

FIGURE 9.7. A support vector classiﬁer was ﬁt using four diﬀerent values of the
tuning parameter C in (9.12)–(9.15). The largest value of C was used in the top
left panel, and smaller values were used in the top right, bottom left, and bottom
right panels. When C is large, then there is a high tolerance for observations being
on the wrong side of the margin, and so the margin will be large. As C decreases,
the tolerance for observations being on the wrong side of the margin decreases,
and the margin narrows.

but potentially high bias. In contrast, if C is small, then there will be fewer
support vectors and hence the resulting classiﬁer will have low bias but
high variance. The bottom right panel in Figure 9.7 illustrates this setting,
with only eight support vectors.

The fact that the support vector classiﬁer’s decision rule is based only
on a potentially small subset of the training observations (the support vec-
tors) means that it is quite robust to the behavior of observations that
are far away from the hyperplane. This property is distinct from some of
the other classiﬁcation methods that we have seen in preceding chapters,
such as linear discriminant analysis. Recall that the LDA classiﬁcation rule

9.3 Support Vector Machines

349

2

X

4

2

0

2
−

4
−

2

X

4

2

0

2
−

4
−

−4

−2

0
X1

2

4

−4

−2

2

4

0
X1

FIGURE 9.8. Left: The observations fall into two classes, with a non-linear
boundary between them. Right: The support vector classiﬁer seeks a linear bound-
ary, and consequently performs very poorly.

depends on the mean of all of the observations within each class, as well as
the within-class covariance matrix computed using all of the observations.
In contrast, logistic regression, unlike LDA, has very low sensitivity to ob-
servations far from the decision boundary. In fact we will see in Section 9.5
that the support vector classiﬁer and logistic regression are closely related.

9.3 Support Vector Machines

We ﬁrst discuss a general mechanism for converting a linear classiﬁer into
one that produces non-linear decision boundaries. We then introduce the
support vector machine, which does this in an automatic way.

9.3.1 Classiﬁcation with Non-linear Decision Boundaries

The support vector classiﬁer is a natural approach for classiﬁcation in the
two-class setting, if the boundary between the two classes is linear. How-
ever, in practice we are sometimes faced with non-linear class boundaries.
For instance, consider the data in the left-hand panel of Figure 9.8. It is
clear that a support vector classiﬁer or any linear classiﬁer will perform
poorly here. Indeed, the support vector classiﬁer shown in the right-hand
panel of Figure 9.8 is useless here.

In Chapter 7, we are faced with an analogous situation. We see there
that the performance of linear regression can suﬀer when there is a non-
linear relationship between the predictors and the outcome. In that case,
we consider enlarging the feature space using functions of the predictors,

350

9. Support Vector Machines

such as quadratic and cubic terms, in order to address this non-linearity.
In the case of the support vector classiﬁer, we could address the prob-
lem of possibly non-linear boundaries between classes in a similar way, by
enlarging the feature space using quadratic, cubic, and even higher-order
polynomial functions of the predictors. For instance, rather than ﬁtting a
support vector classiﬁer using p features

X1, X2, . . . , Xp,

we could instead ﬁt a support vector classiﬁer using 2p features

X1, X 2

1 , X2, X 2

2 , . . . , Xp, X 2
p .

Then (9.12)–(9.15) would become

β0,β11,β12....,βp1,βp2,1,...,n

M

,M

maximize
⎛
⎝β0 +

p(cid:17)

(9.16)

⎞
⎠ ≥ M (1 − i),

p(cid:17)

j=1

βj2x2
ij

subject to yi
n(cid:17)

i ≤ C, i ≥ 0,

βj1xij +
2(cid:17)

j=1

p(cid:17)

β2
jk = 1.

i=1

j=1

k=1

XjXj(cid:2) for j (cid:4)= j

Why does this lead to a non-linear decision boundary? In the enlarged
feature space, the decision boundary that results from (9.16) is in fact lin-
ear. But in the original feature space, the decision boundary is of the form
q(x) = 0, where q is a quadratic polynomial, and its solutions are gener-
ally non-linear. One might additionally want to enlarge the feature space
with higher-order polynomial terms, or with interaction terms of the form
. Alternatively, other functions of the predictors could
be considered rather than polynomials. It is not hard to see that there
are many possible ways to enlarge the feature space, and that unless we
are careful, we could end up with a huge number of features. Then compu-
tations would become unmanageable. The support vector machine, which
we present next, allows us to enlarge the feature space used by the support
vector classiﬁer in a way that leads to eﬃcient computations.

(cid:5)

9.3.2 The Support Vector Machine

The support vector machine (SVM) is an extension of the support vector
classiﬁer that results from enlarging the feature space in a speciﬁc way,
using kernels. We will now discuss this extension, the details of which are
somewhat complex and beyond the scope of this book. However, the main
idea is described in Section 9.3.1: we may want to enlarge our feature space

support
vector
machine
kernel

9.3 Support Vector Machines

351

in order to accommodate a non-linear boundary between the classes. The
kernel approach that we describe here is simply an eﬃcient computational
approach for enacting this idea.

We have not discussed exactly how the support vector classiﬁer is com-
puted because the details become somewhat technical. However, it turns
out that the solution to the support vector classiﬁer problem (9.12)–(9.15)
involves only the inner products of the observations (as opposed to the
observations themselves). The inner product of two r-vectors a and b is
deﬁned as (cid:19)a, b(cid:20) =
r
i=1 aibi. Thus the inner product of two observations
xi, xi(cid:2) is given by

(cid:10)

(cid:19)xi, xi(cid:2)(cid:20) =

p(cid:17)

xij xi(cid:2)j.

j=1

(9.17)

(9.18)

It can be shown that
• The linear support vector classiﬁer can be represented as

n(cid:17)

αi(cid:19)x, xi(cid:20),

f (x) = β0 +

i=1

where there are n parameters αi,
observation.
• To estimate the parameters α1, . . . , αn and β0, all we need are the
(cid:8)
inner products (cid:19)xi, xi(cid:2)(cid:20) between all pairs of training observations.
means n(n − 1)/2, and gives the number of pairs

i = 1, . . . , n, one per training

(cid:8)

(cid:9)

n
2

(cid:9)

n
2

(The notation
among a set of n items.)

Notice that in (9.18), in order to evaluate the function f (x), we need to
compute the inner product between the new point x and each of the training
points xi. However, it turns out that αi is nonzero only for the support
vectors in the solution—that is, if a training observation is not a support
vector, then its αi equals zero. So if S is the collection of indices of these

support points, we can rewrite any solution function of the form (9.18) as

(cid:17)

f (x) = β0 +

i∈S

αi(cid:19)x, xi(cid:20),

(9.19)

which typically involves far fewer terms than in (9.18).2

To summarize, in representing the linear classiﬁer f (x), and in computing

its coeﬃcients, all we need are inner products.

Now suppose that every time the inner product (9.17) appears in the
representation (9.18), or in a calculation of the solution for the support

2By expanding each of the inner products in (9.19), it is easy to see that f (x) is
a linear function of the coordinates of x. Doing so also establishes the correspondence
between the αi and the original parameters βj.

352

9. Support Vector Machines

vector classiﬁer, we replace it with a generalization of the inner product of
the form

K(xi, xi(cid:2) ),

(9.20)

where K is some function that we will refer to as a kernel. A kernel is a
function that quantiﬁes the similarity of two observations. For instance, we
could simply take

p(cid:17)

kernel

K(xi, xi(cid:2) ) =

xij xi(cid:2)j,

j=1

(9.21)

which would just give us back the support vector classiﬁer. Equation 9.21
is known as a linear kernel because the support vector classiﬁer is linear
in the features; the linear kernel essentially quantiﬁes the similarity of a
pair of observations using Pearson (standard) correlation. But one could
instead choose another form for (9.20). For instance, one could replace
every instance of

p
j=1 xij xi(cid:2)j with the quantity

(cid:10)

K(xi, xi(cid:2) ) = (1 +

p(cid:17)

j=1

xij xi(cid:2)j)d.

(9.22)

This is known as a polynomial kernel of degree d, where d is a positive
integer. Using such a kernel with d > 1, instead of the standard linear
kernel (9.21), in the support vector classiﬁer algorithm leads to a much more
ﬂexible decision boundary. It essentially amounts to ﬁtting a support vector
classiﬁer in a higher-dimensional space involving polynomials of degree d,
rather than in the original feature space. When the support vector classiﬁer
is combined with a non-linear kernel such as (9.22), the resulting classiﬁer is
known as a support vector machine. Note that in this case the (non-linear)
function has the form

(cid:17)

f (x) = β0 +

αiK(x, xi).

i∈S

(9.23)

The left-hand panel of Figure 9.9 shows an example of an SVM with a
polynomial kernel applied to the non-linear data from Figure 9.8. The ﬁt is
a substantial improvement over the linear support vector classiﬁer. When
d = 1, then the SVM reduces to the support vector classiﬁer seen earlier in
this chapter.

The polynomial kernel shown in (9.22) is one example of a possible
non-linear kernel, but alternatives abound. Another popular choice is the
radial kernel, which takes the form

K(xi, xi(cid:2) ) = exp(−γ

p(cid:17)

j=1

(xij − xi(cid:2)j)2).

(9.24)

polynomial
kernel

radial kernel

9.3 Support Vector Machines

353

2

X

4

2

0

2
−

4
−

2

X

4

2

0

2
−

4
−

−4

−2

0
X1

2

4

−4

−2

2

4

0
X1

FIGURE 9.9. Left: An SVM with a polynomial kernel of degree 3 is applied to
the non-linear data from Figure 9.8, resulting in a far more appropriate decision
rule. Right: An SVM with a radial kernel is applied. In this example, either kernel
is capable of capturing the decision boundary.

In (9.24), γ is a positive constant. The right-hand panel of Figure 9.9 shows
an example of an SVM with a radial kernel on this non-linear data; it also
does a good job in separating the two classes.

(cid:10)

∗
p
j=1(x
j

How does the radial kernel (9.24) actually work? If a given test obser-
∗
∗
∗
p)T is far from a training observation xi in terms of
1 . . . x
= (x
vation x
− xij)2 will be large, and so K(xi, xi(cid:2) ) =
(cid:10)
Euclidean distance, then
exp(−γ
− xij )2) will be very tiny. This means that in (9.23), xi
∗
p
j=1(x
∗
j
will play virtually no role in f (x
). Recall that the predicted class label
∗
for the test observation x
). In other words,
∗
training observations that are far from x
will play essentially no role in
∗
the predicted class label for x
. This means that the radial kernel has very
local behavior, in the sense that only nearby training observations have an
eﬀect on the class label of a test observation.

∗
is based on the sign of f (x

What is the advantage of using a kernel rather than simply enlarging
the feature space using functions of the original features, as in (9.16)? One
advantage is computational, and it amounts to the fact that using kernels,
one need only compute K(xi, xi(cid:2) ) for all
. This can be
done without explicitly working in the enlarged feature space. This is im-
portant because in many applications of SVMs, the enlarged feature space
is so large that computations are intractable. For some kernels, such as the
radial kernel (9.24), the feature space is implicit and inﬁnite-dimensional,
so we could never do the computations there anyway!

distinct pairs i, i

(cid:8)

(cid:5)

(cid:9)

n
2

354

9. Support Vector Machines

e
t
a
r
 
e
v
i
t
i
s
o
p
 
e
u
r
T

0
1

.

8
0

.

6
0

.

4
0

.

2

.
0

0
.
0

e
t
a
r
 
e
v
i
t
i
s
o
p
 
e
u
r
T

0
1

.

.

8
0

6
0

.

4
0

.

2

.
0

0
.
0

Support Vector Classifier
LDA

Support Vector Classifier
SVM: γ=10
SVM: γ=10
SVM: γ=10

−3
−2
−1

0.0

0.2

0.4

0.6

0.8

1.0

0.0

0.2

0.4

0.6

0.8

1.0

False positive rate

False positive rate

FIGURE 9.10. ROC curves for the Heart data training set. Left: The support
vector classiﬁer and LDA are compared. Right: The support vector classiﬁer is
−1.
compared to an SVM using a radial basis kernel with γ = 10

−2, and 10

−3, 10

9.3.3 An Application to the Heart Disease Data

In Chapter 8 we apply decision trees and related methods to the Heart data.
The aim is to use 13 predictors such as Age, Sex, and Chol in order to predict
whether an individual has heart disease. We now investigate how an SVM
compares to LDA on this data. After removing 6 missing observations, the
data consist of 297 subjects, which we randomly split into 207 training and
90 test observations.

We ﬁrst ﬁt LDA and the support vector classiﬁer to the training data.
Note that the support vector classiﬁer is equivalent to a SVM using a poly-
nomial kernel of degree d = 1. The left-hand panel of Figure 9.10 displays
ROC curves (described in Section 4.4.3) for the training set predictions for
both LDA and the support vector classiﬁer. Both classiﬁers compute scores
of the form ˆf (X) = ˆβ0 + ˆβ1X1 + ˆβ2X2 + . . . + ˆβpXp for each observation.
For any given cutoﬀ t, we classify observations into the heart disease or
no heart disease categories depending on whether ˆf (X) < t or ˆf (X) ≥ t.
The ROC curve is obtained by forming these predictions and computing
the false positive and true positive rates for a range of values of t. An opti-
mal classiﬁer will hug the top left corner of the ROC plot. In this instance
LDA and the support vector classiﬁer both perform well, though there is a
suggestion that the support vector classiﬁer may be slightly superior.

The right-hand panel of Figure 9.10 displays ROC curves for SVMs using
a radial kernel, with various values of γ. As γ increases and the ﬁt becomes
−1 appears to give
more non-linear, the ROC curves improve. Using γ = 10
an almost perfect ROC curve. However, these curves represent training
error rates, which can be misleading in terms of performance on new test
data. Figure 9.11 displays ROC curves computed on the 90 test observa-

9.4 SVMs with More than Two Classes

355

e
t
a
r
 
e
v
i
t
i
s
o
p
 
e
u
r
T

.

0
1

8
0

.

6
0

.

4
0

.

2

.
0

0
.
0

e
t
a
r
 
e
v
i
t
i
s
o
p
 
e
u
r
T

0
1

.

8

.

0

6

.

0

4
0

.

2

.
0

0
.
0

Support Vector Classifier
LDA

Support Vector Classifier
SVM: γ=10
SVM: γ=10
SVM: γ=10

−3
−2
−1

0.0

0.2

0.4

0.6

0.8

1.0

0.0

0.2

0.4

0.6

0.8

1.0

False positive rate

False positive rate

FIGURE 9.11. ROC curves for the test set of the Heart data. Left: The support
vector classiﬁer and LDA are compared. Right: The support vector classiﬁer is
−1.
compared to an SVM using a radial basis kernel with γ = 10

−2, and 10

−3, 10

tions. We observe some diﬀerences from the training ROC curves. In the
left-hand panel of Figure 9.11, the support vector classiﬁer appears to have
a small advantage over LDA (although these diﬀerences are not statisti-
−1, which
cally signiﬁcant). In the right-hand panel, the SVM using γ = 10
showed the best results on the training data, produces the worst estimates
on the test data. This is once again evidence that while a more ﬂexible
method will often produce lower training error rates, this does not neces-
−2
sarily lead to improved performance on test data. The SVMs with γ = 10
−3 perform comparably to the support vector classiﬁer, and all
and γ = 10
three outperform the SVM with γ = 10

−1.

9.4 SVMs with More than Two Classes

So far, our discussion has been limited to the case of binary classiﬁcation:
that is, classiﬁcation in the two-class setting. How can we extend SVMs
to the more general case where we have some arbitrary number of classes?
It turns out that the concept of separating hyperplanes upon which SVMs
are based does not lend itself naturally to more than two classes. Though
a number of proposals for extending SVMs to the K-class case have been
made, the two most popular are the one-versus-one and one-versus-all
approaches. We brieﬂy discuss those two approaches here.

9.4.1 One-Versus-One Classiﬁcation

(cid:9)
Suppose that we would like to perform classiﬁcation using SVMs, and there
are K > 2 classes. A one-versus-one or all-pairs approach constructs

(cid:8)

K
2

one-versus-
one

356

9. Support Vector Machines

SVMs, each of which compares a pair of classes. For example, one such
(cid:5)
(cid:9)
SVM might compare the kth class, coded as +1, to the k
th class, coded
as −1. We classify a test observation using each of the
K
classiﬁers, and
2
we tally the number of times that the test observation is assigned to each
of the K classes. The ﬁnal classiﬁcation is performed by assigning the test
(cid:8)
observation to the class to which it was most frequently assigned in these
K
2

pairwise classiﬁcations.

(cid:9)

(cid:8)

9.4.2 One-Versus-All Classiﬁcation

The one-versus-all approach is an alternative procedure for applying SVMs one-versus-
in the case of K > 2 classes. We ﬁt K SVMs, each time comparing one of
the K classes to the remaining K − 1 classes. Let β0k, β1k, . . . , βpk denote
the parameters that result from ﬁtting an SVM comparing the kth class
(coded as +1) to the others (coded as −1). Let x
∗
denote a test observation.
∗
∗
We assign the observation to the class for which β0k + β1kx
2 + . . . +
1 + β2kx
∗
βpkx
p is largest, as this amounts to a high level of conﬁdence that the test
observation belongs to the kth class rather than to any of the other classes.

all

9.5 Relationship to Logistic Regression

When SVMs were ﬁrst introduced in the mid-1990s, they made quite a
splash in the statistical and machine learning communities. This was due
in part to their good performance, good marketing, and also to the fact
that the underlying approach seemed both novel and mysterious. The idea
of ﬁnding a hyperplane that separates the data as well as possible, while al-
lowing some violations to this separation, seemed distinctly diﬀerent from
classical approaches for classiﬁcation, such as logistic regression and lin-
ear discriminant analysis. Moreover, the idea of using a kernel to expand
the feature space in order to accommodate non-linear class boundaries ap-
peared to be a unique and valuable characteristic.

However, since that time, deep connections between SVMs and other
more classical statistical methods have emerged. It turns out that one can
rewrite the criterion (9.12)–(9.15) for ﬁtting the support vector classiﬁer
f (X) = β0 + β1X1 + . . . + βpXp as

⎧⎨
n(cid:17)
⎩

i=1

max [0, 1 − yif (xi)] + λ

p(cid:17)

j=1

β2
j

minimize
β0,β1,...,βp

⎫⎬
⎭ ,

(9.25)

9.5 Relationship to Logistic Regression

357

where λ is a nonnegative tuning parameter. When λ is large then β1, . . . , βp
are small, more violations to the margin are tolerated, and a low-variance
but high-bias classiﬁer will result. When λ is small then few violations
to the margin will occur; this amounts to a high-variance but low-bias
classiﬁer. Thus, a small value of λ in (9.25) amounts to a small value of C
in (9.15). Note that the λ
j term in (9.25) is the ridge penalty term
from Section 6.2.1, and plays a similar role in controlling the bias-variance
trade-oﬀ for the support vector classiﬁer.

p
j=1 β2

(cid:10)

Now (9.25) takes the “Loss + Penalty” form that we have seen repeatedly

throughout this book:

minimize
β0,β1,...,βp

{L(X, y, β) + λP (β)} .

(9.26)

In (9.26), L(X, y, β) is some loss function quantifying the extent to which
the model, parametrized by β, ﬁts the data (X, y), and P (β) is a penalty
function on the parameter vector β whose eﬀect is controlled by a nonneg-
ative tuning parameter λ. For instance, ridge regression and the lasso both
take this form with

n(cid:17)

⎛
⎝yi − β0 − p(cid:17)

i=1

j=1

⎞
⎠

2

xijβj

(cid:10)

|βj| for

p
j=1

L(X, y, β) =
(cid:10)

p
j=1 β2
n(cid:17)

and with P (β) =
the lasso. In the case of (9.25) the loss function instead takes the form

j for ridge regression and P (β) =

L(X, y, β) =

i=1

max [0, 1 − yi(β0 + β1xi1 + . . . + βpxip)] .

hinge loss

This is known as hinge loss, and is depicted in Figure 9.12. However, it
turns out that the hinge loss function is closely related to the loss function
used in logistic regression, also shown in Figure 9.12.

An interesting characteristic of the support vector classiﬁer is that only
support vectors play a role in the classiﬁer obtained; observations on the
correct side of the margin do not aﬀect it. This is due to the fact that the
loss function shown in Figure 9.12 is exactly zero for observations for which

yi(β0 + β1xi1 + . . . + βpxip) ≥ 1; these correspond to observations that are
on the correct side of the margin.3 In contrast, the loss function for logistic
regression shown in Figure 9.12 is not exactly zero anywhere. But it is very
small for observations that are far from the decision boundary. Due to the
similarities between their loss functions, logistic regression and the support
vector classiﬁer often give very similar results. When the classes are well
separated, SVMs tend to behave better than logistic regression; in more
overlapping regimes, logistic regression is often preferred.

3With this hinge-loss + penalty representation, the margin corresponds to the value

one, and the width of the margin is determined by

(cid:2)

β2
j .

358

9. Support Vector Machines

8

6

s
s
o
L

4

2

0

−6

SVM Loss
Logistic Regression Loss

−2

−4
2
yi(β0 + β1xi1 + . . . + βpxip)

0

FIGURE 9.12. The SVM and logistic regression loss functions are compared,
as a function of yi(β0 + β1xi1 + . . . + βpxip). When yi(β0 + β1xi1 + . . . + βpxip) is
greater than 1, then the SVM loss is zero, since this corresponds to an observation
that is on the correct side of the margin. Overall, the two loss functions have quite
similar behavior.

When the support vector classiﬁer and SVM were ﬁrst introduced, it was
thought that the tuning parameter C in (9.15) was an unimportant “nui-
sance” parameter that could be set to some default value, like 1. However,
the “Loss + Penalty” formulation (9.25) for the support vector classiﬁer
indicates that this is not the case. The choice of tuning parameter is very
important and determines the extent to which the model underﬁts or over-
ﬁts the data, as illustrated, for example, in Figure 9.7.

We have established that the support vector classiﬁer is closely related
to logistic regression and other preexisting statistical methods. Is the SVM
unique in its use of kernels to enlarge the feature space to accommodate
non-linear class boundaries? The answer to this question is “no”. We could
just as well perform logistic regression or many of the other classiﬁcation
methods seen in this book using non-linear kernels; this is closely related
to some of the non-linear approaches seen in Chapter 7. However, for his-
torical reasons, the use of non-linear kernels is much more widespread in
the context of SVMs than in the context of logistic regression or other
methods.

Though we have not addressed it here, there is in fact an extension
of the SVM for regression (i.e. for a quantitative rather than a qualita-
tive response), called support vector regression. In Chapter 3, we saw that
least squares regression seeks coeﬃcients β0, β1, . . . , βp such that the sum
of squared residuals is as small as possible. (Recall from Chapter 3 that
residuals are deﬁned as yi − β0 − β1xi1 − ··· − βpxip.) Support vector

regression instead seeks coeﬃcients that minimize a diﬀerent type of loss,
where only residuals larger in absolute value than some positive constant

support
vector
regression

9.6 Lab: Support Vector Machines

359

contribute to the loss function. This is an extension of the margin used in
support vector classiﬁers to the regression setting.

9.6 Lab: Support Vector Machines

We use the e1071 library in R to demonstrate the support vector classiﬁer
and the SVM. Another option is the LiblineaR library, which is useful for
very large linear problems.

svm()

9.6.1 Support Vector Classiﬁer

The e1071 library contains implementations for a number of statistical
learning methods. In particular, the svm() function can be used to ﬁt a
support vector classiﬁer when the argument kernel="linear" is used. This
function uses a slightly diﬀerent formulation from (9.14) and (9.25) for the
support vector classiﬁer. A cost argument allows us to specify the cost of
a violation to the margin. When the cost argument is small, then the mar-
gins will be wide and many support vectors will be on the margin or will
violate the margin. When the cost argument is large, then the margins will
be narrow and there will be few support vectors on the margin or violating
the margin.

We now use the svm() function to ﬁt the support vector classiﬁer for a
given value of the cost parameter. Here we demonstrate the use of this
function on a two-dimensional example so that we can plot the resulting
decision boundary. We begin by generating the observations, which belong
to two classes, and checking whether the classes are linearly separable.

> set . seed (1)
> x = matrix ( rnorm (20*2) , ncol =2)
> y = c ( rep ( -1 ,10) , rep (1 ,10) )
> x [ y ==1 ,]= x [ y ==1 ,] + 1
> plot (x , col =(3 - y ) )

They are not. Next, we ﬁt the support vector classiﬁer. Note that in order
for the svm() function to perform classiﬁcation (as opposed to SVM-based
regression), we must encode the response as a factor variable. We now
create a data frame with the response coded as a factor.

> dat = data . frame ( x =x , y = as . factor ( y ) )
> library ( e1071 )

> svmfit = svm ( y∼. , data = dat , kernel =" linear " , cost =10 ,

scale = FALSE )

360

9. Support Vector Machines

The argument scale=FALSE tells the svm() function not to scale each feature
to have mean zero or standard deviation one; depending on the application,
one might prefer to use scale=TRUE.

We can now plot the support vector classiﬁer obtained:

> plot ( svmfit , dat )

Note that the two arguments to the plot.svm() function are the output
of the call to svm(), as well as the data used in the call to svm(). The
region of feature space that will be assigned to the −1 class is shown in
light blue, and the region that will be assigned to the +1 class is shown in
purple. The decision boundary between the two classes is linear (because we
used the argument kernel="linear"), though due to the way in which the
plotting function is implemented in this library the decision boundary looks
somewhat jagged in the plot.(Note that here the second feature is plotted on the
x-axis and the ﬁrst feature is plotted on the y-axis, in contrast to the behavior of
the usual plot() function in R.) The support vectors are plotted as crosses
and the remaining observations are plotted as circles; we see here that there
are seven support vectors. We can determine their identities as follows:

> s v m f i t $ i n d e x
[1]

1

2

5

7 14 16 17

We can obtain some basic information about the support vector classiﬁer
ﬁt using the summary() command:

> summary ( svmfit )
Call :

svm ( formula = y ∼ . , data = dat , kernel = " linear " , cost = 10 ,

scale = FALSE )

Parameter s :

SVM - Type :
SVM - Kernel :
cost :
gamma :

C - c l a s s i f i c a t i o n
linear
10
0.5

Number of Support Vectors :

7

( 4 3 )

Number of Classes :
Levels :

2

-1 1

This tells us, for instance, that a linear kernel was used with cost=10, and
that there were seven support vectors, four in one class and three in the
other.

What if we instead used a smaller value of the cost parameter?

> svmfit = svm ( y∼. , data = dat , kernel =" linear " , cost =0.1 ,

scale = FALSE )

> plot ( svmfit , dat )
> s v m f i t $ i n d e x
[1]

1

2

3

4

5

7

9 10 12 13 14 15 16 17 18 20

9.6 Lab: Support Vector Machines

361

Now that a smaller value of the cost parameter is being used, we obtain a
larger number of support vectors, because the margin is now wider. Unfor-
tunately, the svm() function does not explicitly output the coeﬃcients of
the linear decision boundary obtained when the support vector classiﬁer is
ﬁt, nor does it output the width of the margin.

The e1071 library includes a built-in function, tune(), to perform cross-
validation. By default, tune() performs ten-fold cross-validation on a set
of models of interest. In order to use this function, we pass in relevant
information about the set of models that are under consideration. The
following command indicates that we want to compare SVMs with a linear
kernel, using a range of values of the cost parameter.

> set . seed (1)

> tune . out = tune ( svm , y∼. , data = dat , kernel =" linear " ,

ranges = list ( cost = c (0.001 , 0.01 , 0.1 , 1 ,5 ,10 ,100) ) )

We can easily access the cross-validation errors for each of these models
using the summary() command:

tune()

> summary ( tune . out )
Parameter tuning of ’ svm ’:
- sampling method : 10 - fold cross validation
- best parameters :

cost
0.1

- best performan c e : 0.1
- Detailed performa nc e results :

cost error dispersio n
0.422
0.422
0.211
0.242
0.242
0.242
0.242

0.70
0.70
0.10
0.15
0.15
0.15
0.15

1 1 e -03
2 1 e -02
3 1 e -01
4 1 e +00
5 5 e +00
6 1 e +01
7 1 e +02

We see that cost=0.1 results in the lowest cross-validation error rate. The
tune() function stores the best model obtained, which can be accessed as
follows:

> bestmod = tune . out$best . model
> summary ( bestmod )

The predict() function can be used to predict the class label on a set of
test observations, at any given value of the cost parameter. We begin by
generating a test data set.

> xtest = matrix ( rnorm (20*2) , ncol =2)
> ytest = sample ( c ( -1 ,1) , 20 , rep = TRUE )
> xtest [ ytest ==1 ,]= xtest [ ytest ==1 ,] + 1
> testdat = data . frame ( x = xtest , y = as . factor ( ytest ) )

Now we predict the class labels of these test observations. Here we use the
best model obtained through cross-validation in order to make predictions.

362

9. Support Vector Machines

> ypred = predict ( bestmod , testdat )
> table ( predict = ypred , truth = testdat$y )

truth

predict -1
-1 11
0
1

1
1
8

Thus, with this value of cost, 19 of the test observations are correctly
classiﬁed. What if we had instead used cost=0.01?
> svmfit = svm ( y∼. , data = dat , kernel =" linear " , cost =.01 ,

scale = FALSE )

> ypred = predict ( svmfit , testdat )
> table ( predict = ypred , truth = testdat$y )

truth

predict -1
-1 11
1
0

1
2
7

In this case one additional observation is misclassiﬁed.

Now consider a situation in which the two classes are linearly separable.
Then we can ﬁnd a separating hyperplane using the svm() function. We
ﬁrst further separate the two classes in our simulated data so that they are
linearly separable:

> x [ y ==1 ,]= x [ y ==1 ,]+0.5
> plot (x , col =( y +5) /2 , pch =19)

Now the observations are just barely linearly separable. We ﬁt the support
vector classiﬁer and plot the resulting hyperplane, using a very large value
of cost so that no observations are misclassiﬁed.

> dat = data . frame ( x =x , y = as . factor ( y ) )

> svmfit = svm ( y∼. , data = dat , kernel =" linear " , cost =1 e5 )

> summary ( svmfit )
Call :

svm ( formula = y ∼ . , data = dat , kernel = " linear " , cost = 1 e

+05)

Parameter s :

SVM - Type :
SVM - Kernel :
cost :
gamma :

C - c l a s s i f i c a t i o n
linear
1 e +05
0.5

Number of Support Vectors :

3

( 1 2 )

Number of Classes :
Levels :

2

-1 1

> plot ( svmfit , dat )

No training errors were made and only three support vectors were used.
However, we can see from the ﬁgure that the margin is very narrow (because
the observations that are not support vectors, indicated as circles, are very

9.6 Lab: Support Vector Machines

363

close to the decision boundary). It seems likely that this model will perform
poorly on test data. We now try a smaller value of cost:
> svmfit = svm ( y∼. , data = dat , kernel =" linear " , cost =1)

> summary ( svmfit )
> plot ( svmfit , dat )

Using cost=1, we misclassify a training observation, but we also obtain
a much wider margin and make use of seven support vectors. It seems
likely that this model will perform better on test data than the model with
cost=1e5.

9.6.2 Support Vector Machine

In order to ﬁt an SVM using a non-linear kernel, we once again use the svm()
function. However, now we use a diﬀerent value of the parameter kernel.
To ﬁt an SVM with a polynomial kernel we use kernel="polynomial", and
to ﬁt an SVM with a radial kernel we use kernel="radial". In the former
case we also use the degree argument to specify a degree for the polynomial
kernel (this is d in (9.22)), and in the latter case we use gamma to specify a
value of γ for the radial basis kernel (9.24).

We ﬁrst generate some data with a non-linear class boundary, as follows:

> set . seed (1)
> x = matrix ( rnorm (200*2) , ncol =2)
> x [1:100 ,]= x [1:100 ,]+2
> x [101:150 ,]= x [101:150 ,] -2
> y = c ( rep (1 ,150) , rep (2 ,50) )
> dat = data . frame ( x =x , y = as . factor ( y ) )

Plotting the data makes it clear that the class boundary is indeed non-
linear:

> plot (x , col = y )

The data is randomly split into training and testing groups. We then ﬁt
the training data using the svm() function with a radial kernel and γ = 1:

> train = sample (200 ,100)

> svmfit = svm ( y∼. , data = dat [ train ,] , kernel =" radial " ,

gamma =1 ,

cost =1)

> plot ( svmfit , dat [ train ,])

The plot shows that the resulting SVM has a decidedly non-linear
boundary. The summary() function can be used to obtain some
information about the SVM ﬁt:

> summary ( svmfit )
Call :

svm ( formula = y ∼ . , data = dat , kernel = " radial " ,

gamma = 1 , cost = 1)

Parameter s :

SVM - Type :

C - c l a s s i f i c a t i o n

364

9. Support Vector Machines

SVM - Kernel :
cost :
gamma :

radial
1
1

Number of Support Vectors :

37

( 17 20 )

Number of Classes :
Levels :

2

1 2

We can see from the ﬁgure that there are a fair number of training errors
in this SVM ﬁt. If we increase the value of cost, we can reduce the number
of training errors. However, this comes at the price of a more irregular
decision boundary that seems to be at risk of overﬁtting the data.
> svmfit = svm ( y∼. , data = dat [ train ,] , kernel =" radial " , gamma =1 ,

cost =1 e5 )

> plot ( svmfit , dat [ train ,])

We can perform cross-validation using tune() to select the best choice of

γ and cost for an SVM with a radial kernel:

> set . seed (1)

> tune . out = tune ( svm , y∼. , data = dat [ train ,] , kernel =" radial " ,

ranges = list ( cost = c (0.1 ,1 ,10 ,100 ,1000) ,
gamma = c (0.5 ,1 ,2 ,3 ,4) ) )

> summary ( tune . out )
Parameter tuning of ’ svm ’:
- sampling method : 10 - fold cross validation
- best parameters :

cost gamma
2

1

- best performan c e : 0.12
- Detailed performa nc e results :
cost gamma error dispersion
0.1160
0.0823
0.0707
0.0823
0.0994
0.1354
0.0823

1e -01
1 e +00
1 e +01
1 e +02
1 e +03
1e -01
1 e +00

1
2
3
4
5
6
7
. . .

0.5
0.5
0.5
0.5
0.5
1.0
1.0

0.27
0.13
0.15
0.17
0.21
0.25
0.13

Therefore, the best choice of parameters involves cost=1 and gamma=2. We
can view the test set predictions for this model by applying the predict()
function to the data. Notice that to do this we subset the dataframe dat
using -train as an index set.

> table ( true = dat [ - train ," y "] , pred = predict ( tune . out$best . model ,

newdata = dat [ - train ,]) )

10 % of test observations are misclassiﬁed by this SVM.

9.6 Lab: Support Vector Machines

365

9.6.3 ROC Curves

The ROCR package can be used to produce ROC curves such as those in
Figures 9.10 and 9.11. We ﬁrst write a short function to plot an ROC curve
given a vector containing a numerical score for each observation, pred, and
a vector containing the class label for each observation, truth.

> library ( ROCR )
> rocplot = function ( pred , truth , ...) {
+
+
+

predob = prediction ( pred , truth )
perf = performa nc e ( predob , " tpr " , " fpr ")
plot ( perf ,...) }

SVMs and support vector classiﬁers output class labels for each observa-
tion. However, it is also possible to obtain ﬁtted values for each observation,
which are the numerical scores used to obtain the class labels. For instance,
in the case of a support vector classiﬁer, the ﬁtted value for an observation
X = (X1, X2, . . . , Xp)T takes the form ˆβ0 + ˆβ1X1 + ˆβ2X2 + . . . + ˆβpXp.
For an SVM with a non-linear kernel, the equation that yields the ﬁtted
value is given in (9.23). In essence, the sign of the ﬁtted value determines
on which side of the decision boundary the observation lies. Therefore, the
relationship between the ﬁtted value and the class prediction for a given
observation is simple: if the ﬁtted value exceeds zero then the observation
is assigned to one class, and if it is less than zero then it is assigned to the
other. In order to obtain the ﬁtted values for a given SVM model ﬁt, we
use decision.values=TRUE when ﬁtting svm(). Then the predict() function
will output the ﬁtted values.
> svmfit . opt = svm ( y∼. , data = dat [ train ,] , kernel =" radial " ,

gamma =2 , cost =1 , decision . values = T )

> fitted = attributes ( predict ( svmfit . opt , dat [ train ,] , decision .

values = TRUE ) ) $decision . values

Now we can produce the ROC plot.

> par ( mfrow = c (1 ,2) )
> rocplot ( fitted , dat [ train ," y "] , main =" Training Data ")

SVM appears to be producing accurate predictions. By increasing γ we can
produce a more ﬂexible ﬁt and generate further improvements in accuracy.
> svmfit . flex = svm ( y∼. , data = dat [ train ,] , kernel =" radial " ,

gamma =50 , cost =1 , decision . values = T )

> fitted = attributes ( predict ( svmfit . flex , dat [ train ,] , decision .

values = T ) ) $decision . values

> rocplot ( fitted , dat [ train ," y "] , add =T , col =" red ")

However, these ROC curves are all on the training data. We are really
more interested in the level of prediction accuracy on the test data. When
we compute the ROC curves on the test data, the model with γ = 2 appears
to provide the most accurate results.

366

9. Support Vector Machines

> fitted = attributes ( predict ( svmfit . opt , dat [ - train ,] , decision .

values = T ) ) $decision . values

> rocplot ( fitted , dat [ - train ," y "] , main =" Test Data ")
> fitted = attributes ( predict ( svmfit . flex , dat [ - train ,] , decision .

values = T ) ) $decision . values

> rocplot ( fitted , dat [ - train ," y "] , add =T , col =" red ")

9.6.4 SVM with Multiple Classes

If the response is a factor containing more than two levels, then the svm()
function will perform multi-class classiﬁcation using the one-versus-one ap-
proach. We explore that setting here by generating a third class of obser-
vations.

> set . seed (1)
> x = rbind (x , matrix ( rnorm (50*2) , ncol =2) )
> y = c ( y , rep (0 ,50) )
> x [ y ==0 ,2]= x [ y ==0 ,2]+2
> dat = data . frame ( x =x , y = as . factor ( y ) )
> par ( mfrow = c (1 ,1) )
> plot (x , col =( y +1) )

We now ﬁt an SVM to the data:
> svmfit = svm ( y∼. , data = dat , kernel =" radial " , cost =10 , gamma =1)

> plot ( svmfit , dat )

The e1071 library can also be used to perform support vector regression,
if the response vector that is passed in to svm() is numerical rather than a
factor.

9.6.5 Application to Gene Expression Data

We now examine the Khan data set, which consists of a number of tissue
samples corresponding to four distinct types of small round blue cell tu-
mors. For each tissue sample, gene expression measurements are available.
The data set consists of training data, xtrain and ytrain, and testing data,
xtest and ytest.

We examine the dimension of the data:

" xtest "

" ytrain "

" ytest "

63 2308

" xtrain "

> library ( ISLR )
> names ( Khan )
[1]
> dim ( Khan$xtra in )
[1]
> dim ( Khan$xtest )
[1]
> length ( Khan$ytra in )
[1] 63
> length ( Khan$ytest )
[1] 20

20 2308

9.6 Lab: Support Vector Machines

367

This data set consists of expression measurements for 2,308 genes.
The training and test sets consist of 63 and 20 observations respectively.

> table ( Khan$ytra i n )

2

1
4
8 23 12 20

3

> table ( Khan$ytes t )
1 2 3 4
3 6 6 5

We will use a support vector approach to predict cancer subtype using gene
expression measurements. In this data set, there are a very large number
of features relative to the number of observations. This suggests that we
should use a linear kernel, because the additional ﬂexibility that will result
from using a polynomial or radial kernel is unnecessary.

> dat = data . frame ( x = Khan$xtrain , y = as . factor ( Khan$ytra in ) )

> out = svm ( y∼. , data = dat , kernel =" linear " , cost =10)

> summary ( out )
Call :

svm ( formula = y ∼ . , data = dat , kernel = " linear " ,

cost = 10)

Parameter s :

SVM - Type :
SVM - Kernel :
cost :
gamma :

C - c l a s s i f i c a t i o n
linear
10
0.000433

Number of Support Vectors :

58

( 20 20 11 7 )

Number of Classes :
Levels :

4

1 2 3 4

> table ( out$fitted , dat$y )

2
1
0
8
0 23
0
0

3
0
0
0 12
0

4
0
0
0
0 20

1
2
3
4

We see that there are no training errors. In fact, this is not surprising,
because the large number of variables relative to the number of observations
implies that it is easy to ﬁnd hyperplanes that fully separate the classes. We
are most interested not in the support vector classiﬁer’s performance on the
training observations, but rather its performance on the test observations.

> dat . te = data . frame ( x = Khan$xtest , y = as . factor ( Khan$ytes t ) )
> pred . te = predict ( out , newdata = dat . te )
> table ( pred . te , dat . te$y )

pred . te 1 2 3 4
1 3 0 0 0
2 0 6 2 0
3 0 0 4 0
4 0 0 0 5

368

9. Support Vector Machines

We see that using cost=10 yields two test set errors on this data.

9.7 Exercises

Conceptual

1. This problem involves hyperplanes in two dimensions.

(a) Sketch the hyperplane 1 + 3X1 − X2 = 0. Indicate the set of
points for which 1 + 3X1 − X2 > 0, as well as the set of points
for which 1 + 3X1 − X2 < 0.
(b) On the same plot, sketch the hyperplane −2 + X1 + 2X2 = 0.
Indicate the set of points for which −2 + X1 + 2X2 > 0, as well
as the set of points for which −2 + X1 + 2X2 < 0.

2. We have seen that in p = 2 dimensions, a linear decision boundary
takes the form β0 +β1X1 +β2X2 = 0. We now investigate a non-linear
decision boundary.

(a) Sketch the curve

(1 + X1)2 + (2 − X2)2 = 4.

(b) On your sketch, indicate the set of points for which

(1 + X1)2 + (2 − X2)2 > 4,

as well as the set of points for which

(1 + X1)2 + (2 − X2)2 ≤ 4.

(c) Suppose that a classiﬁer assigns an observation to the blue class

if

(1 + X1)2 + (2 − X2)2 > 4,

and to the red class otherwise. To what class is the observation
(0, 0) classiﬁed? (−1, 1)? (2, 2)? (3, 8)?

(d) Argue that while the decision boundary in (c) is not linear in
1 , X2, and

terms of X1 and X2, it is linear in terms of X1, X 2
X 2
2 .

3. Here we explore the maximal margin classiﬁer on a toy data set.

(a) We are given n = 7 observations in p = 2 dimensions. For each

observation, there is an associated class label.

Obs. X1 X2
4
2
4
4
1
3
1

1
2
3
4
5
6
7

3
2
4
1
2
4
4

9.7 Exercises

369

Y
Red
Red
Red
Red
Blue
Blue
Blue

Sketch the observations.

(b) Sketch the optimal separating hyperplane, and provide the equa-

tion for this hyperplane (of the form (9.1)).

(c) Describe the classiﬁcation rule for the maximal margin classiﬁer.
It should be something along the lines of “Classify to Red if
β0 + β1X1 + β2X2 > 0, and classify to Blue otherwise.” Provide
the values for β0, β1, and β2.

(d) On your sketch, indicate the margin for the maximal margin

hyperplane.

(e) Indicate the support vectors for the maximal margin classiﬁer.

(f) Argue that a slight movement of the seventh observation would

not aﬀect the maximal margin hyperplane.

(g) Sketch a hyperplane that is not the optimal separating hyper-

plane, and provide the equation for this hyperplane.

(h) Draw an additional observation on the plot so that the two

classes are no longer separable by a hyperplane.

Applied

4. Generate a simulated two-class data set with 100 observations and
two features in which there is a visible but non-linear separation be-
tween the two classes. Show that in this setting, a support vector
machine with a polynomial kernel (with degree greater than 1) or a
radial kernel will outperform a support vector classiﬁer on the train-
ing data. Which technique performs best on the test data? Make
plots and report training and test error rates in order to back up
your assertions.

5. We have seen that we can ﬁt an SVM with a non-linear kernel in order
to perform classiﬁcation using a non-linear decision boundary. We will
now see that we can also obtain a non-linear decision boundary by
performing logistic regression using non-linear transformations of the
features.

370

9. Support Vector Machines

(a) Generate a data set with n = 500 and p = 2, such that the obser-
vations belong to two classes with a quadratic decision boundary
between them. For instance, you can do this as follows:

> x1 = runif (500) -0.5
> x2 = runif (500) -0.5
> y =1*( x1 ^2 - x2 ^2 > 0)

(b) Plot the observations, colored according to their class labels.
Your plot should display X1 on the x-axis, and X2 on the y-
axis.

(c) Fit a logistic regression model to the data, using X1 and X2 as

predictors.

(d) Apply this model to the training data in order to obtain a pre-
dicted class label for each training observation. Plot the ob-
servations, colored according to the predicted class labels. The
decision boundary should be linear.

(e) Now ﬁt a logistic regression model to the data using non-linear

1 , X1×X2, log(X2),

functions of X1 and X2 as predictors (e.g. X 2
and so forth).

(f) Apply this model to the training data in order to obtain a pre-
dicted class label for each training observation. Plot the ob-
servations, colored according to the predicted class labels. The
decision boundary should be obviously non-linear. If it is not,
then repeat (a)-(e) until you come up with an example in which
the predicted class labels are obviously non-linear.

(g) Fit a support vector classiﬁer to the data with X1 and X2 as
predictors. Obtain a class prediction for each training observa-
tion. Plot the observations, colored according to the predicted
class labels.

(h) Fit a SVM using a non-linear kernel to the data. Obtain a class
prediction for each training observation. Plot the observations,
colored according to the predicted class labels.

(i) Comment on your results.

6. At the end of Section 9.6.1, it is claimed that in the case of data that
is just barely linearly separable, a support vector classiﬁer with a
small value of cost that misclassiﬁes a couple of training observations
may perform better on test data than one with a huge value of cost
that does not misclassify any training observations. You will now
investigate this claim.

(a) Generate two-class data with p = 2 in such a way that the classes

are just barely linearly separable.

9.7 Exercises

371

(b) Compute the cross-validation error rates for support vector
classiﬁers with a range of cost values. How many training er-
rors are misclassiﬁed for each value of cost considered, and how
does this relate to the cross-validation errors obtained?

(c) Generate an appropriate test data set, and compute the test
errors corresponding to each of the values of cost considered.
Which value of cost leads to the fewest test errors, and how
does this compare to the values of cost that yield the fewest
training errors and the fewest cross-validation errors?

(d) Discuss your results.

7. In this problem, you will use support vector approaches in order to
predict whether a given car gets high or low gas mileage based on the
Auto data set.

(a) Create a binary variable that takes on a 1 for cars with gas
mileage above the median, and a 0 for cars with gas mileage
below the median.

(b) Fit a support vector classiﬁer to the data with various values
of cost, in order to predict whether a car gets high or low gas
mileage. Report the cross-validation errors associated with dif-
ferent values of this parameter. Comment on your results.

(c) Now repeat (b), this time using SVMs with radial and polyno-
mial basis kernels, with diﬀerent values of gamma and degree and
cost. Comment on your results.

(d) Make some plots to back up your assertions in (b) and (c).

Hint: In the lab, we used the plot() function for svm objects
only in cases with p = 2. When p > 2, you can use the plot()
function to create plots displaying pairs of variables at a time.
Essentially, instead of typing

> plot ( svmfit , dat )

where svmfit contains your ﬁtted model and dat is a data frame
containing your data, you can type
> plot ( svmfit , dat , x1∼x4 )

in order to plot just the ﬁrst and fourth variables. However, you
must replace x1 and x4 with the correct variable names. To ﬁnd
out more, type ?plot.svm.

8. This problem involves the OJ data set which is part of the ISLR

package.

372

9. Support Vector Machines

(a) Create a training set containing a random sample of 800
remaining

containing the

observations, and a test
observations.

set

(b) Fit a support vector classiﬁer to the training data using
cost=0.01, with Purchase as the response and the other variables
as predictors. Use the summary() function to produce summary
statistics, and describe the results obtained.

(c) What are the training and test error rates?

(d) Use the tune() function to select an optimal cost. Consider val-

ues in the range 0.01 to 10.

(e) Compute the training and test error rates using this new value

for cost.

(f) Repeat parts (b) through (e) using a support vector machine

with a radial kernel. Use the default value for gamma.

(g) Repeat parts (b) through (e) using a support vector machine

with a polynomial kernel. Set degree=2.

(h) Overall, which approach seems to give the best results on this

data?

10
Unsupervised Learning

this book concerns

such as
Most of
regression and classiﬁcation. In the supervised learning setting, we typically
have access to a set of p features X1, X2, . . . , Xp, measured on n obser-
vations, and a response Y also measured on those same n observations.
The goal is then to predict Y using X1, X2, . . . , Xp.

supervised learning methods

This chapter will instead focus on unsupervised learning, a set of sta-
tistical tools intended for the setting in which we have only a set of fea-
tures X1, X2, . . . , Xp measured on n observations. We are not interested
in prediction, because we do not have an associated response variable Y .
Rather, the goal is to discover interesting things about the measurements
on X1, X2, . . . , Xp. Is there an informative way to visualize the data? Can
we discover subgroups among the variables or among the observations?
Unsupervised learning refers to a diverse set of techniques for answering
questions such as these. In this chapter, we will focus on two particu-
lar types of unsupervised learning: principal components analysis, a tool
used for data visualization or data pre-processing before supervised tech-
niques are applied, and clustering, a broad class of methods for discovering
unknown subgroups in data.

10.1 The Challenge of Unsupervised Learning

Supervised learning is a well-understood area. In fact, if you have read
the preceding chapters in this book, then you should by now have a good

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7 10,
© Springer Science+Business Media New York 2013

373

exploratory
data analysis

374

10. Unsupervised Learning

grasp of supervised learning. For instance, if you are asked to predict a
binary outcome from a data set, you have a very well developed set of tools
at your disposal (such as logistic regression, linear discriminant analysis,
classiﬁcation trees, support vector machines, and more) as well as a clear
understanding of how to assess the quality of the results obtained (using
cross-validation, validation on an independent test set, and so forth).

In contrast, unsupervised learning is often much more challenging. The
exercise tends to be more subjective, and there is no simple goal for the
analysis, such as prediction of a response. Unsupervised learning is often
performed as part of an exploratory data analysis. Furthermore, it can be
hard to assess the results obtained from unsupervised learning methods,
since there is no universally accepted mechanism for performing cross-
validation or validating results on an independent data set. The reason
for this diﬀerence is simple. If we ﬁt a predictive model using a supervised
learning technique, then it is possible to check our work by seeing how
well our model predicts the response Y on observations not used in ﬁtting
the model. However, in unsupervised learning, there is no way to check our
work because we don’t know the true answer—the problem is unsupervised.
Techniques for unsupervised learning are of growing importance in a
number of ﬁelds. A cancer researcher might assay gene expression levels in
100 patients with breast cancer. He or she might then look for subgroups
among the breast cancer samples, or among the genes, in order to obtain
a better understanding of the disease. An online shopping site might try
to identify groups of shoppers with similar browsing and purchase histo-
ries, as well as items that are of particular interest to the shoppers within
each group. Then an individual shopper can be preferentially shown the
items in which he or she is particularly likely to be interested, based on
the purchase histories of similar shoppers. A search engine might choose
what search results to display to a particular individual based on the click
histories of other individuals with similar search patterns. These statistical
learning tasks, and many more, can be performed via unsupervised learning
techniques.

10.2 Principal Components Analysis

Principal components are discussed in Section 6.3.1 in the context of
principal components regression. When faced with a large set of corre-
lated variables, principal components allow us to summarize this set with
a smaller number of representative variables that collectively explain most
of the variability in the original set. The principal component directions
are presented in Section 6.3.1 as directions in feature space along which
the original data are highly variable. These directions also deﬁne lines and
subspaces that are as close as possible to the data cloud. To perform

10.2 Principal Components Analysis

375

principal components regression, we simply use principal components as
predictors in a regression model in place of the original larger set of vari-
ables.

Principal component analysis (PCA) refers to the process by which prin-
cipal components are computed, and the subsequent use of these compo-
nents in understanding the data. PCA is an unsupervised approach, since
it involves only a set of features X1, X2, . . . , Xp, and no associated response
Y . Apart from producing derived variables for use in supervised learning
problems, PCA also serves as a tool for data visualization (visualization of
the observations or visualization of the variables). We now discuss PCA in
greater detail, focusing on the use of PCA as a tool for unsupervised data
exploration, in keeping with the topic of this chapter.

principal
component
analysis

10.2.1 What Are Principal Components?

(cid:9)

p
2

(cid:8)

Suppose that we wish to visualize n observations with measurements on a
set of p features, X1, X2, . . . , Xp, as part of an exploratory data analysis.
We could do this by examining two-dimensional scatterplots of the data,
each of which contains the n observations’ measurements on two of the
= p(p−1)/2 such scatterplots; for example,
features. However, there are
with p = 10 there are 45 plots! If p is large, then it will certainly not be
possible to look at all of them; moreover, most likely none of them will
be informative since they each contain just a small fraction of the total
information present in the data set. Clearly, a better method is required to
visualize the n observations when p is large. In particular, we would like to
ﬁnd a low-dimensional representation of the data that captures as much of
the information as possible. For instance, if we can obtain a two-dimensional
representation of the data that captures most of the information, then we
can plot the observations in this low-dimensional space.

PCA provides a tool to do just this. It ﬁnds a low-dimensional represen-
tation of a data set that contains as much as possible of the variation. The
idea is that each of the n observations lives in p-dimensional space, but not
all of these dimensions are equally interesting. PCA seeks a small number
of dimensions that are as interesting as possible, where the concept of in-
teresting is measured by the amount that the observations vary along each
dimension. Each of the dimensions found by PCA is a linear combination
of the p features. We now explain the manner in which these dimensions,
or principal components, are found.

The ﬁrst principal component of a set of features X1, X2, . . . , Xp is the

normalized linear combination of the features

Z1 = φ11X1 + φ21X2 + . . . + φp1Xp

(10.1)

(cid:10)

that has the largest variance. By normalized, we mean that
j1 = 1.
We refer to the elements φ11, . . . , φp1 as the loadings of the ﬁrst principal

p
j=1 φ2

loading

376

10. Unsupervised Learning

component; together, the loadings make up the principal component load-
ing vector, φ1 = (φ11 φ21 . . . φp1)T . We constrain the loadings so that
their sum of squares is equal to one, since otherwise setting these elements
to be arbitrarily large in absolute value could result in an arbitrarily large
variance.
Given a n × p data set X, how do we compute the ﬁrst principal com-
ponent? Since we are only interested in variance, we assume that each of
the variables in X has been centered to have mean zero (that is, the col-
umn means of X are zero). We then look for the linear combination of the
sample feature values of the form

zi1 = φ11xi1 + φ21xi2 + . . . + φp1xip

(10.2)

(cid:10)

j1=1.
that has largest sample variance, subject to the constraint that
In other words, the ﬁrst principal component loading vector solves the op-
timization problem

p
j=1 φ2

⎧⎪⎨
⎪⎩

1
n

n(cid:17)

⎛
⎝ p(cid:17)

i=1

j=1

⎞
⎠2

⎫⎪⎬
⎪⎭ subject to

p(cid:17)

j=1

maximize
φ11,...,φp1

φj1xij

φ2
j1 = 1.

(10.3)

(cid:10)

(cid:10)
From (10.2) we can write the objective in (10.3) as 1
i1. Since
n
n
1
i=1 xij = 0, the average of the z11, . . . , zn1 will be zero as well. Hence
n
the objective that we are maximizing in (10.3) is just the sample variance of
the n values of zi1. We refer to z11, . . . , zn1 as the scores of the ﬁrst princi- score
pal component. Problem (10.3) can be solved via an eigen decomposition,
a standard technique in linear algebra, but details are outside of the scope
of this book.

n
i=1 z2

There is a nice geometric interpretation for the ﬁrst principal component.
The loading vector φ1 with elements φ11, φ21, . . . , φp1 deﬁnes a direction in
feature space along which the data vary the most. If we project the n data
points x1, . . . , xn onto this direction, the projected values are the princi-
pal component scores z11, . . . , zn1 themselves. For instance, Figure 6.14 on
page 230 displays the ﬁrst principal component loading vector (green solid
line) on an advertising data set. In these data, there are only two features,
and so the observations as well as the ﬁrst principal component loading
vector can be easily displayed. As can be seen from (6.19), in that data set
φ11 = 0.839 and φ21 = 0.544.

After the ﬁrst principal component Z1 of the features has been deter-
mined, we can ﬁnd the second principal component Z2. The second prin-
cipal component is the linear combination of X1, . . . , Xp that has maximal
variance out of all linear combinations that are uncorrelated with Z1. The
second principal component scores z12, z22, . . . , zn2 take the form

zi2 = φ12xi1 + φ22xi2 + . . . + φp2xip,

(10.4)

10.2 Principal Components Analysis

377

Murder
Assault
UrbanPop
Rape

PC1

PC2
0.5358995 −0.4181809
0.5831836 −0.1879856
0.8728062
0.2781909
0.1673186
0.5434321

TABLE 10.1. The principal component loading vectors, φ1 and φ2, for the
USArrests data. These are also displayed in Figure 10.1.

where φ2 is the second principal component loading vector, with elements
φ12, φ22, . . . , φp2. It turns out that constraining Z2 to be uncorrelated with
Z1 is equivalent to constraining the direction φ2 to be orthogonal (perpen-
dicular) to the direction φ1. In the example in Figure 6.14, the observations
lie in two-dimensional space (since p = 2), and so once we have found φ1,
there is only one possibility for φ2, which is shown as a blue dashed line.
(From Section 6.3.1, we know that φ12 = 0.544 and φ22 = −0.839.) But in

a larger data set with p > 2 variables, there are multiple distinct principal
components, and they are deﬁned in a similar manner. To ﬁnd φ2, we solve
a problem similar to (10.3) with φ2 replacing φ1, and with the additional
constraint that φ2 is orthogonal to φ1.1

Once we have computed the principal components, we can plot them
against each other in order to produce low-dimensional views of the data.
For instance, we can plot the score vector Z1 against Z2, Z1 against Z3,
Z2 against Z3, and so forth. Geometrically, this amounts to projecting
the original data down onto the subspace spanned by φ1, φ2, and φ3, and
plotting the projected points.

We illustrate the use of PCA on the USArrests data set. For each of the
50 states in the United States, the data set contains the number of arrests
per 100, 000 residents for each of three crimes: Assault, Murder, and Rape.
We also record UrbanPop (the percent of the population in each state living
in urban areas). The principal component score vectors have length n = 50,
and the principal component loading vectors have length p = 4. PCA was
performed after standardizing each variable to have mean zero and standard
deviation one. Figure 10.1 plots the ﬁrst two principal components of these
data. The ﬁgure represents both the principal component scores and the
loading vectors in a single biplot display. The loadings are also given in
Table 10.1.

In Figure 10.1, we see that the ﬁrst loading vector places approximately
equal weight on Assault, Murder, and Rape, with much less weight on

biplot

1On a technical note, the principal component directions φ1, φ2, φ3, . . . are the
ordered sequence of eigenvectors of the matrix XT X, and the variances of the compo-
nents are the eigenvalues. There are at most min(n − 1, p) principal components.

378

10. Unsupervised Learning

−0.5

0.0

0.5

UrbanPop

3

2

1

t

n
e
n
o
p
m
o
C

 
l

i

a
p
c
n
i
r

 

P
d
n
o
c
e
S

1
−

2
−

3
−

Hawaii

Rhode Island
Utah

Massachusetts

New Jersey

Connecticut

Washington

Wisconsin

Minnesota

Pennsylvania

Ohio

Oregon
Delaware

Nebraska

Kansas

Oklahoma

Indiana

Missouri

0

New Hampshire

Iowa

Maine

rth Dakota

Idaho

Virginia

Wyoming

Montana

South Dakota

Kentucky

Vermont

West Virginia

Arkansas

Alabama

Alaska

Georgia

Murder

Tennessee

Louisiana

Colorado

Illinois

New York
Arizona
Rape

Texas

Michigan

New Mexico

Maryland

Assault

California

5

.

0

Nevada

Florida

0
0

.

.

5
0
−

South Carolina

North Carolina
Mississippi

−3

−2

−1

0

1

2

3

First Principal Component

FIGURE 10.1. The ﬁrst two principal components for the USArrests data. The
blue state names represent the scores for the ﬁrst two principal components. The
orange arrows indicate the ﬁrst two principal component loading vectors (with
axes on the top and right). For example, the loading for Rape on the ﬁrst com-
ponent is 0.54, and its loading on the second principal component 0.17 (the word
Rape is centered at the point (0.54, 0.17)). This ﬁgure is known as a biplot, be-
cause it displays both the principal component scores and the principal component
loadings.

UrbanPop. Hence this component roughly corresponds to a measure of overall
rates of serious crimes. The second loading vector places most of its weight
on UrbanPop and much less weight on the other three features. Hence, this
component roughly corresponds to the level of urbanization of the state.
Overall, we see that the crime-related variables (Murder, Assault, and Rape)
are located close to each other, and that the UrbanPop variable is far from
the other three. This indicates that the crime-related variables are corre-
lated with each other—states with high murder rates tend to have high
assault and rape rates—and that the UrbanPop variable is less correlated
with the other three.

10.2 Principal Components Analysis

379

We can examine diﬀerences between the states via the two principal com-
ponent score vectors shown in Figure 10.1. Our discussion of the loading
vectors suggests that states with large positive scores on the ﬁrst compo-
nent, such as California, Nevada and Florida, have high crime rates, while
states like North Dakota, with negative scores on the ﬁrst component, have
low crime rates. California also has a high score on the second component,
indicating a high level of urbanization, while the opposite is true for states
like Mississippi. States close to zero on both components, such as Indiana,
have approximately average levels of both crime and urbanization.

10.2.2 Another Interpretation of Principal Components

The ﬁrst two principal component loading vectors in a simulated three-
dimensional data set are shown in the left-hand panel of Figure 10.2; these
two loading vectors span a plane along which the observations have the
highest variance.

In the previous section, we describe the principal component loading vec-
tors as the directions in feature space along which the data vary the most,
and the principal component scores as projections along these directions.
However, an alternative interpretation for principal components can also be
useful: principal components provide low-dimensional linear surfaces that
are closest to the observations. We expand upon that interpretation here.
The ﬁrst principal component loading vector has a very special property:
it is the line in p-dimensional space that is closest to the n observations
(using average squared Euclidean distance as a measure of closeness). This
interpretation can be seen in the left-hand panel of Figure 6.15; the dashed
lines indicate the distance between each observation and the ﬁrst principal
component loading vector. The appeal of this interpretation is clear: we
seek a single dimension of the data that lies as close as possible to all of
the data points, since such a line will likely provide a good summary of the
data.

The notion of principal components as the dimensions that are clos-
est to the n observations extends beyond just the ﬁrst principal com-
ponent. For instance, the ﬁrst two principal components of a data set
span the plane that is closest to the n observations, in terms of average
squared Euclidean distance. An example is shown in the left-hand panel
of Figure 10.2. The ﬁrst three principal components of a data set span
the three-dimensional hyperplane that is closest to the n observations, and
so forth.

Using this interpretation, together the ﬁrst M principal component score
vectors and the ﬁrst M principal component loading vectors provide the
best M -dimensional approximation (in terms of Euclidean distance) to
the ith observation xij . This representation can be written

380

10. Unsupervised Learning

t

n
e
n
o
p
m
o
c
 
l

i

a
p
c
n
i
r
p

 

d
n
o
c
e
S

0
1

.

5

.

0

0
0

.

5

.

0
−

.

0
1
−

−1.0

−0.5

0.0

0.5
First principal component

1.0

FIGURE 10.2. Ninety observations simulated in three dimensions. Left: the
ﬁrst two principal component directions span the plane that best ﬁts the data. It
minimizes the sum of squared distances from each point to the plane. Right: the
ﬁrst two principal component score vectors give the coordinates of the projection
of the 90 observations onto the plane. The variance in the plane is maximized.

xij ≈ M(cid:17)

m=1

zimφjm

(10.5)

(assuming the original data matrix X is column-centered). In other words,
together the M principal component score vectors and M principal com-
ponent loading vectors can give a good approximation to the data when
M is suﬃciently large. When M = min(n − 1, p), then the representation
is exact: xij =

M
m=1 zimφjm.

(cid:10)

10.2.3 More on PCA

Scaling the Variables

We have already mentioned that before PCA is performed, the variables
should be centered to have mean zero. Furthermore, the results obtained
when we perform PCA will also depend on whether the variables have been
individually scaled (each multiplied by a diﬀerent constant). This is in
contrast to some other supervised and unsupervised learning techniques,
such as linear regression, in which scaling the variables has no eﬀect. (In
linear regression, multiplying a variable by a factor of c will simply lead to
multiplication of the corresponding coeﬃcient estimate by a factor of 1/c,
and thus will have no substantive eﬀect on the model obtained.)

For instance, Figure 10.1 was obtained after scaling each of the variables
to have standard deviation one. This is reproduced in the left-hand plot in
Figure 10.3. Why does it matter that we scaled the variables? In these data,

10.2 Principal Components Analysis

381

Scaled

−0.5

0.0

0.5

−0.5

UrbanPop

t
n
e
n
o
p
m
o
C

i

 
l
a
p
c
n
i
r

 

P
d
n
o
c
e
S

3

2

1

0

1
−

2
−

3
−

*

*

*

*
*

*
*

*

*
*
*

*
*

*

*

*
*

*

*

*

*

*

*

*

*
*

*

*

*

*

*

*

*

5
.
0

0
.
0

5

.

0
−

t
n
e
n
o
p
m
o
C

i

 
l
a
p
c
n
i
r

 

P
d
n
o
c
e
S

0
5
1

0
0
1

0
5

0

0
5
−

0
0
1
−

*
*

*

*
*
*
Rape
*

*

*

Assault
*
*
Murder

*

*
*

*

*

*

Unscaled
0.0

UrbanPop

0.5

1.0

0
.
1

5
.
0

*
*
*
*

*
*

*

*
*
*

*
*
*
*
*
*
*
*
*
*

Rape
*
*
*
*
*
*
*
* *
*
Murder
*
*

*
*

*
*

*
*
*
*
*

*
*

*

*

*
*

*

*

Assau

0
.
0

*

5

.

0
−

−3

−2

−1

0

1

2

3

−100

−50

0

50

100

150

First Principal Component

First Principal Component

FIGURE 10.3. Two principal component biplots for the USArrests data. Left:
the same as Figure 10.1, with the variables scaled to have unit standard deviations.
Right: principal components using unscaled data. Assault has by far the largest
loading on the ﬁrst principal component because it has the highest variance among
the four variables. In general, scaling the variables to have standard deviation one
is recommended.

the variables are measured in diﬀerent units; Murder, Rape, and Assault are
reported as the number of occurrences per 100, 000 people, and UrbanPop
is the percentage of the state’s population that lives in an urban area.
These four variables have variance 18.97, 87.73, 6945.16, and 209.5, respec-
tively. Consequently, if we perform PCA on the unscaled variables, then
the ﬁrst principal component loading vector will have a very large loading
for Assault, since that variable has by far the highest variance. The right-
hand plot in Figure 10.3 displays the ﬁrst two principal components for the
USArrests data set, without scaling the variables to have standard devia-
tion one. As predicted, the ﬁrst principal component loading vector places
almost all of its weight on Assault, while the second principal component
loading vector places almost all of its weight on UrpanPop. Comparing this
to the left-hand plot, we see that scaling does indeed have a substantial
eﬀect on the results obtained.

However, this result is simply a consequence of the scales on which the
variables were measured. For instance, if Assault were measured in units
of the number of occurrences per 100 people (rather than number of oc-
currences per 100, 000 people), then this would amount to dividing all of
the elements of that variable by 1, 000. Then the variance of the variable
would be tiny, and so the ﬁrst principal component loading vector would
have a very small value for that variable. Because it is undesirable for the
principal components obtained to depend on an arbitrary choice of scaling,
we typically scale each variable to have standard deviation one before we
perform PCA.

382

10. Unsupervised Learning

In certain settings, however, the variables may be measured in the same
units. In this case, we might not wish to scale the variables to have stan-
dard deviation one before performing PCA. For instance, suppose that the
variables in a given data set correspond to expression levels for p genes.
Then since expression is measured in the same “units” for each gene, we
might choose not to scale the genes to each have standard deviation one.

Uniqueness of the Principal Components

Each principal component loading vector is unique, up to a sign ﬂip. This
means that two diﬀerent software packages will yield the same principal
component loading vectors, although the signs of those loading vectors
may diﬀer. The signs may diﬀer because each principal component loading
vector speciﬁes a direction in p-dimensional space: ﬂipping the sign has no
eﬀect as the direction does not change. (Consider Figure 6.14—the principal
component loading vector is a line that extends in either direction, and
ﬂipping its sign would have no eﬀect.) Similarly, the score vectors are unique
up to a sign ﬂip, since the variance of Z is the same as the variance of −Z.
It is worth noting that when we use (10.5) to approximate xij we multiply
zim by φjm. Hence, if the sign is ﬂipped on both the loading and score
vectors, the ﬁnal product of the two quantities is unchanged.

The Proportion of Variance Explained

In Figure 10.2, we performed PCA on a three-dimensional data set (left-
hand panel) and projected the data onto the ﬁrst two principal component
loading vectors in order to obtain a two-dimensional view of the data (i.e.
the principal component score vectors; right-hand panel). We see that this
two-dimensional representation of the three-dimensional data does success-
fully capture the major pattern in the data: the orange, green, and cyan
observations that are near each other in three-dimensional space remain
nearby in the two-dimensional representation. Similarly, we have seen on
the USArrests data set that we can summarize the 50 observations and 4
variables using just the ﬁrst two principal component score vectors and the
ﬁrst two principal component loading vectors.

We can now ask a natural question: how much of the information in
a given data set is lost by projecting the observations onto the ﬁrst few
principal components? That is, how much of the variance in the data is not
contained in the ﬁrst few principal components? More generally, we are
interested in knowing the proportion of variance explained (PVE) by each
principal component. The total variance present in a data set (assuming
that the variables have been centered to have mean zero) is deﬁned as

p(cid:17)

j=1

Var(Xj) =

p(cid:17)

j=1

1
n

n(cid:17)

i=1

x2
ij ,

(10.6)

proportion
of variance
explained

10.2 Principal Components Analysis

383

i

l

d
e
n
a
p
x
E
 
e
c
n
a
i
r
a
V

 
.
p
o
r
P

0
.
1

8
.
0

6
.
0

4
.
0

2
.
0

0

.

0

i

l

d
e
n
a
p
x
E
 
e
c
n
a
i
r
a
V

 
.
p
o
r
P
 
e
v
i
t
a
u
m
u
C

l

0
.
1

8
.
0

6
.
0

4
.
0

2
.
0

0

.

0

1.0

1.5

2.0

2.5

3.0

3.5

4.0

1.0

1.5

2.0

2.5

3.0

3.5

4.0

Principal Component

Principal Component

FIGURE 10.4. Left: a scree plot depicting the proportion of variance explained
by each of the four principal components in the USArrests data. Right: the cu-
mulative proportion of variance explained by the four principal components in the
USArrests data.

and the variance explained by the mth principal component is

n(cid:17)

i=1

1
n

z2
im =

1
n

n(cid:17)

⎛
⎝ p(cid:17)

i=1

j=1

⎞
⎠2

φjmxij

.

(10.7)

Therefore, the PVE of the mth principal component is given by

(cid:10)

(cid:18)(cid:10)
(cid:10)

n
i=1

p
j=1

p
(cid:10)
j=1 φjmxij

n
i=1 x2
ij

(cid:19)2

.

(10.8)

The PVE of each principal component is a positive quantity. In order to
compute the cumulative PVE of the ﬁrst M principal components, we
can simply sum (10.8) over each of the ﬁrst M PVEs. In total, there are
min(n − 1, p) principal components, and their PVEs sum to one.

In the USArrests data, the ﬁrst principal component explains 62.0 % of
the variance in the data, and the next principal component explains 24.7 %
of the variance. Together, the ﬁrst two principal components explain almost
87 % of the variance in the data, and the last two principal components
explain only 13 % of the variance. This means that Figure 10.1 provides a
pretty accurate summary of the data using just two dimensions. The PVE
of each principal component, as well as the cumulative PVE, is shown
in Figure 10.4. The left-hand panel is known as a scree plot, and will be
discussed next.

Deciding How Many Principal Components to Use
In general, a n × p data matrix X has min(n − 1, p) distinct principal
components. However, we usually are not interested in all of them; rather,

scree plot

384

10. Unsupervised Learning

we would like to use just the ﬁrst few principal components in order to
visualize or interpret the data. In fact, we would like to use the smallest
number of principal components required to get a good understanding of the
data. How many principal components are needed? Unfortunately, there is
no single (or simple!) answer to this question.

We typically decide on the number of principal components required
to visualize the data by examining a scree plot, such as the one shown
in the left-hand panel of Figure 10.4. We choose the smallest number of
principal components that are required in order to explain a sizable amount
of the variation in the data. This is done by eyeballing the scree plot, and
looking for a point at which the proportion of variance explained by each
subsequent principal component drops oﬀ. This is often referred to as an
elbow in the scree plot. For instance, by inspection of Figure 10.4, one
might conclude that a fair amount of variance is explained by the ﬁrst
two principal components, and that there is an elbow after the second
component. After all, the third principal component explains less than ten
percent of the variance in the data, and the fourth principal component
explains less than half that and so is essentially worthless.

However, this type of visual analysis is inherently ad hoc. Unfortunately,
there is no well-accepted objective way to decide how many principal com-
ponents are enough. In fact, the question of how many principal compo-
nents are enough is inherently ill-deﬁned, and will depend on the speciﬁc
area of application and the speciﬁc data set. In practice, we tend to look
at the ﬁrst few principal components in order to ﬁnd interesting patterns
in the data. If no interesting patterns are found in the ﬁrst few principal
components, then further principal components are unlikely to be of inter-
est. Conversely, if the ﬁrst few principal components are interesting, then
we typically continue to look at subsequent principal components until no
further interesting patterns are found. This is admittedly a subjective ap-
proach, and is reﬂective of the fact that PCA is generally used as a tool for
exploratory data analysis.

On the other hand, if we compute principal components for use in a
supervised analysis, such as the principal components regression presented
in Section 6.3.1, then there is a simple and objective way to determine how
many principal components to use: we can treat the number of principal
component score vectors to be used in the regression as a tuning parameter
to be selected via cross-validation or a related approach. The comparative
simplicity of selecting the number of principal components for a supervised
analysis is one manifestation of the fact that supervised analyses tend to
be more clearly deﬁned and more objectively evaluated than unsupervised
analyses.

clustering

10.3 Clustering Methods

385

10.2.4 Other Uses for Principal Components

We saw in Section 6.3.1 that we can perform regression using the principal
component score vectors as features. In fact, many statistical techniques,
such as regression, classiﬁcation, and clustering, can be easily adapted to
use the n × M matrix whose columns are the ﬁrst M (cid:15) p principal com-
ponent score vectors, rather than using the full n × p data matrix. This
can lead to less noisy results, since it is often the case that the signal (as
opposed to the noise) in a data set is concentrated in its ﬁrst few principal
components.

10.3 Clustering Methods

Clustering refers to a very broad set of techniques for ﬁnding subgroups, or
clusters, in a data set. When we cluster the observations of a data set, we
seek to partition them into distinct groups so that the observations within
each group are quite similar to each other, while observations in diﬀerent
groups are quite diﬀerent from each other. Of course, to make this concrete,
we must deﬁne what it means for two or more observations to be similar
or diﬀerent. Indeed, this is often a domain-speciﬁc consideration that must
be made based on knowledge of the data being studied.

For instance, suppose that we have a set of n observations, each with p
features. The n observations could correspond to tissue samples for patients
with breast cancer, and the p features could correspond to measurements
collected for each tissue sample; these could be clinical measurements, such
as tumor stage or grade, or they could be gene expression measurements.
We may have a reason to believe that there is some heterogeneity among
the n tissue samples; for instance, perhaps there are a few diﬀerent un-
known subtypes of breast cancer. Clustering could be used to ﬁnd these
subgroups. This is an unsupervised problem because we are trying to dis-
cover structure—in this case, distinct clusters—on the basis of a data set.
The goal in supervised problems, on the other hand, is to try to predict
some outcome vector such as survival time or response to drug treatment.
Both clustering and PCA seek to simplify the data via a small number

of summaries, but their mechanisms are diﬀerent:

• PCA looks to ﬁnd a low-dimensional representation of the observa-

tions that explain a good fraction of the variance;

• Clustering looks to ﬁnd homogeneous subgroups among the observa-

tions.

Another application of clustering arises in marketing. We may have ac-
cess to a large number of measurements (e.g. median household income,
occupation, distance from nearest urban area, and so forth) for a large

K-means
clustering

hierarchical
clustering

dendrogram

386

10. Unsupervised Learning

number of people. Our goal is to perform market segmentation by identify-
ing subgroups of people who might be more receptive to a particular form
of advertising, or more likely to purchase a particular product. The task of
performing market segmentation amounts to clustering the people in the
data set.

Since clustering is popular in many ﬁelds, there exist a great number of
clustering methods. In this section we focus on perhaps the two best-known
clustering approaches: K-means clustering and hierarchical clustering. In
K-means clustering, we seek to partition the observations into a pre-speciﬁed
number of clusters. On the other hand, in hierarchical clustering, we do
not know in advance how many clusters we want; in fact, we end up with
a tree-like visual representation of the observations, called a dendrogram,
that allows us to view at once the clusterings obtained for each possible
number of clusters, from 1 to n. There are advantages and disadvantages
to each of these clustering approaches, which we highlight in this chapter.
In general, we can cluster observations on the basis of the features in
order to identify subgroups among the observations, or we can cluster fea-
tures on the basis of the observations in order to discover subgroups among
the features. In what follows, for simplicity we will discuss clustering obser-
vations on the basis of the features, though the converse can be performed
by simply transposing the data matrix.

10.3.1 K-Means Clustering

K-means clustering is a simple and elegant approach for partitioning a
data set into K distinct, non-overlapping clusters. To perform K-means
clustering, we must ﬁrst specify the desired number of clusters K; then the
K-means algorithm will assign each observation to exactly one of the K
clusters. Figure 10.5 shows the results obtained from performing K-means
clustering on a simulated example consisting of 150 observations in two
dimensions, using three diﬀerent values of K.

The K-means clustering procedure results from a simple and intuitive
mathematical problem. We begin by deﬁning some notation. Let C1, . . . , CK
denote sets containing the indices of the observations in each cluster. These
sets satisfy two properties:

1. C1 ∪ C2 ∪ . . . ∪ CK = {1, . . . , n}. In other words, each observation

belongs to at least one of the K clusters.

2. Ck ∩ Ck(cid:2) = ∅ for all k (cid:4)= k

(cid:5)

. In other words, the clusters are non-

overlapping: no observation belongs to more than one cluster.

For instance, if the ith observation is in the kth cluster, then i ∈ Ck. The

idea behind K-means clustering is that a good clustering is one for which the
within-cluster variation is as small as possible. The within-cluster variation

K=2

K=3

K=4

10.3 Clustering Methods

387

FIGURE 10.5. A simulated data set with 150 observations in two-dimensional
space. Panels show the results of applying K-means clustering with diﬀerent val-
ues of K, the number of clusters. The color of each observation indicates the clus-
ter to which it was assigned using the K-means clustering algorithm. Note that
there is no ordering of the clusters, so the cluster coloring is arbitrary. These
cluster labels were not used in clustering; instead, they are the outputs of the
clustering procedure.

for cluster Ck is a measure W (Ck) of the amount by which the observations
within a cluster diﬀer from each other. Hence we want to solve the problem

(cid:30)

K(cid:17)

/

minimize
C1,...,CK

k=1

W (Ck)

.

(10.9)

In words, this formula says that we want to partition the observations into
K clusters such that the total within-cluster variation, summed over all K
clusters, is as small as possible.

Solving (10.9) seems like a reasonable idea, but in order to make it
actionable we need to deﬁne the within-cluster variation. There are many
possible ways to deﬁne this concept, but by far the most common choice
involves squared Euclidean distance. That is, we deﬁne

W (Ck) =

(cid:17)

p(cid:17)

i,i(cid:2)∈Ck

j=1

1|Ck|

(xij − xi(cid:2)j)2,

(10.10)

where |Ck| denotes the number of observations in the kth cluster. In other

words, the within-cluster variation for the kth cluster is the sum of all of
the pairwise squared Euclidean distances between the observations in the
kth cluster, divided by the total number of observations in the kth cluster.
Combining (10.9) and (10.10) gives the optimization problem that deﬁnes
K-means clustering,

⎧⎨
⎩

minimize
C1,...,CK

K(cid:17)

k=1

(cid:17)

p(cid:17)

i,i(cid:2)∈Ck

j=1

1|Ck|

(xij − xi(cid:2)j)2

⎫⎬
⎭ .

(10.11)

388

10. Unsupervised Learning

Now, we would like to ﬁnd an algorithm to solve (10.11)—that is, a
method to partition the observations into K clusters such that the objective
of (10.11) is minimized. This is in fact a very diﬃcult problem to solve
precisely, since there are almost K n ways to partition n observations into K
clusters. This is a huge number unless K and n are tiny! Fortunately, a very
simple algorithm can be shown to provide a local optimum—a pretty good
solution—to the K-means optimization problem (10.11). This approach is
laid out in Algorithm 10.1.

Algorithm 10.1 K-Means Clustering

1. Randomly assign a number, from 1 to K, to each of the observations.

These serve as initial cluster assignments for the observations.

2. Iterate until the cluster assignments stop changing:

(a) For each of the K clusters, compute the cluster centroid. The
kth cluster centroid is the vector of the p feature means for the
observations in the kth cluster.

(b) Assign each observation to the cluster whose centroid is closest

(where closest is deﬁned using Euclidean distance).

Algorithm 10.1 is guaranteed to decrease the value of the objective
(10.11) at each step. To understand why, the following identity is illu-
minating:

(cid:17)

p(cid:17)

1|Ck|

i,i(cid:2)∈Ck

(xij − xi(cid:2)j)2 = 2

(cid:17)

p(cid:17)

i∈Ck

j=1

(xij − ¯xkj )2,

(10.12)

j=1

(cid:10)

i∈Ck xij

where ¯xkj = 1|Ck|
is the mean for feature j in cluster Ck.
In Step 2(a) the cluster means for each feature are the constants that
minimize the sum-of-squared deviations, and in Step 2(b), reallocating the
observations can only improve (10.12). This means that as the algorithm
is run, the clustering obtained will continually improve until the result no
longer changes; the objective of (10.11) will never increase. When the result
no longer changes, a local optimum has been reached. Figure 10.6 shows
the progression of the algorithm on the toy example from Figure 10.5.
K-means clustering derives its name from the fact that in Step 2(a), the
cluster centroids are computed as the mean of the observations assigned to
each cluster.

Because the K-means algorithm ﬁnds a local rather than a global opti-
mum, the results obtained will depend on the initial (random) cluster as-
signment of each observation in Step 1 of Algorithm 10.1. For this reason,
it is important to run the algorithm multiple times from diﬀerent random

Data

Step 1

Iteration 1, Step 2a

10.3 Clustering Methods

389

Iteration 1, Step 2b

Iteration 2, Step 2a

Final Results

FIGURE 10.6. The progress of the K-means algorithm on the example of Fig-
ure 10.5 with K=3. Top left: the observations are shown. Top center: in Step 1
of the algorithm, each observation is randomly assigned to a cluster. Top right:
in Step 2(a), the cluster centroids are computed. These are shown as large col-
ored disks. Initially the centroids are almost completely overlapping because the
initial cluster assignments were chosen at random. Bottom left: in Step 2(b),
each observation is assigned to the nearest centroid. Bottom center: Step 2(a) is
once again performed, leading to new cluster centroids. Bottom right: the results
obtained after ten iterations.

initial conﬁgurations. Then one selects the best solution, i.e. that for which
the objective (10.11) is smallest. Figure 10.7 shows the local optima ob-
tained by running K-means clustering six times using six diﬀerent initial
cluster assignments, using the toy data from Figure 10.5. In this case, the
best clustering is the one with an objective value of 235.8.

As we have seen, to perform K-means clustering, we must decide how
many clusters we expect in the data. The problem of selecting K is far from
simple. This issue, along with other practical considerations that arise in
performing K-means clustering, is addressed in Section 10.3.3.

390

10. Unsupervised Learning

320.9

235.8

235.8

235.8

235.8

310.9

FIGURE 10.7. K-means clustering performed six times on the data from Fig-
ure 10.5 with K = 3, each time with a diﬀerent random assignment of the ob-
servations in Step 1 of the K-means algorithm. Above each plot is the value of
the objective (10.11). Three diﬀerent local optima were obtained, one of which
resulted in a smaller value of the objective and provides better separation between
the clusters. Those labeled in red all achieved the same best solution, with an
objective value of 235.8.

10.3.2 Hierarchical Clustering

One potential disadvantage of K-means clustering is that it requires us to
pre-specify the number of clusters K. Hierarchical clustering is an alter-
native approach which does not require that we commit to a particular
choice of K. Hierarchical clustering has an added advantage over K-means
clustering in that it results in an attractive tree-based representation of the
observations, called a dendrogram.

In this section, we describe bottom-up or agglomerative

clustering.

This is the most common type of hierarchical clustering, and refers to
the fact that a dendrogram (generally depicted as an upside-down tree; see

bottom-up

agglomerative

10.3 Clustering Methods

391

4

2

X

2

0

2
−

−6

−4

−2
X1

0

2

FIGURE 10.8. Forty-ﬁve observations generated in two-dimensional space. In
reality there are three distinct classes, shown in separate colors. However, we will
treat these class labels as unknown and will seek to cluster the observations in
order to discover the classes from the data.

Figure 10.9) is built starting from the leaves and combining clusters up to
the trunk. We will begin with a discussion of how to interpret a dendrogram
and then discuss how hierarchical clustering is actually performed—that is,
how the dendrogram is built.

Interpreting a Dendrogram

We begin with the simulated data set shown in Figure 10.8, consisting of
45 observations in two-dimensional space. The data were generated from a
three-class model; the true class labels for each observation are shown in
distinct colors. However, suppose that the data were observed without the
class labels, and that we wanted to perform hierarchical clustering of the
data. Hierarchical clustering (with complete linkage, to be discussed later)
yields the result shown in the left-hand panel of Figure 10.9. How can we
interpret this dendrogram?

In the left-hand panel of Figure 10.9, each leaf of the dendrogram rep-
resents one of the 45 observations in Figure 10.8. However, as we move
up the tree, some leaves begin to fuse into branches. These correspond to
observations that are similar to each other. As we move higher up the tree,
branches themselves fuse, either with leaves or other branches. The earlier
(lower in the tree) fusions occur, the more similar the groups of observa-
tions are to each other. On the other hand, observations that fuse later
(near the top of the tree) can be quite diﬀerent. In fact, this statement
can be made precise: for any two observations, we can look for the point in
the tree where branches containing those two observations are ﬁrst fused.
The height of this fusion, as measured on the vertical axis, indicates how

392

10. Unsupervised Learning

0
1

8

6

4

2

0

0
1

8

6

4

2

0

0
1

8

6

4

2

0

FIGURE 10.9. Left: dendrogram obtained from hierarchically clustering the data
from Figure 10.8 with complete linkage and Euclidean distance. Center: the den-
drogram from the left-hand panel, cut at a height of nine (indicated by the dashed
line). This cut results in two distinct clusters, shown in diﬀerent colors. Right:
the dendrogram from the left-hand panel, now cut at a height of ﬁve. This cut
results in three distinct clusters, shown in diﬀerent colors. Note that the colors
were not used in clustering, but are simply used for display purposes in this ﬁgure.

diﬀerent the two observations are. Thus, observations that fuse at the very
bottom of the tree are quite similar to each other, whereas observations
that fuse close to the top of the tree will tend to be quite diﬀerent.

This highlights a very important point in interpreting dendrograms that
is often misunderstood. Consider the left-hand panel of Figure 10.10, which
shows a simple dendrogram obtained from hierarchically clustering nine
observations. One can see that observations 5 and 7 are quite similar to
each other, since they fuse at the lowest point on the dendrogram. Obser-
vations 1 and 6 are also quite similar to each other. However, it is tempting
but incorrect to conclude from the ﬁgure that observations 9 and 2 are
quite similar to each other on the basis that they are located near each
other on the dendrogram. In fact, based on the information contained in
the dendrogram, observation 9 is no more similar to observation 2 than it
is to observations 8, 5, and 7. (This can be seen from the right-hand panel
of Figure 10.10, in which the raw data are displayed.) To put it mathe-
matically, there are 2n−1 possible reorderings of the dendrogram, where n
is the number of leaves. This is because at each of the n − 1 points where
fusions occur, the positions of the two fused branches could be swapped
without aﬀecting the meaning of the dendrogram. Therefore, we cannot
draw conclusions about the similarity of two observations based on their
proximity along the horizontal axis. Rather, we draw conclusions about
the similarity of two observations based on the location on the vertical axis
where branches containing those two observations ﬁrst are fused.

0

.

3

5
2

.

0
2

.

5

.

1

.

0
1

5

.

0

0

.

0

3

4

9

2

8

1 6

5 7

10.3 Clustering Methods

393

2

X

5

.

0

.

0
0

5

.

0
−

.

0
1
−

5

.
1
−

3

4

1

6

−1.5

−1.0

−0.5

9

2

0.0

X1

7

5

8

0.5

1.0

FIGURE 10.10. An illustration of how to properly interpret a dendrogram with
nine observations in two-dimensional space. Left: a dendrogram generated using
Euclidean distance and complete linkage. Observations 5 and 7 are quite similar
to each other, as are observations 1 and 6. However, observation 9 is no more
similar to observation 2 than it is to observations 8, 5, and 7, even though obser-
vations 9 and 2 are close together in terms of horizontal distance. This is because
observations 2, 8, 5, and 7 all fuse with observation 9 at the same height, approx-
imately 1.8. Right: the raw data used to generate the dendrogram can be used to
conﬁrm that indeed, observation 9 is no more similar to observation 2 than it is
to observations 8, 5, and 7.

Now that we understand how to interpret the left-hand panel of Fig-
ure 10.9, we can move on to the issue of identifying clusters on the basis
of a dendrogram. In order to do this, we make a horizontal cut across the
dendrogram, as shown in the center and right-hand panels of Figure 10.9.
The distinct sets of observations beneath the cut can be interpreted as clus-
ters. In the center panel of Figure 10.9, cutting the dendrogram at a height
of nine results in two clusters, shown in distinct colors. In the right-hand
panel, cutting the dendrogram at a height of ﬁve results in three clusters.
Further cuts can be made as one descends the dendrogram in order to ob-
tain any number of clusters, between 1 (corresponding to no cut) and n
(corresponding to a cut at height 0, so that each observation is in its own
cluster). In other words, the height of the cut to the dendrogram serves
the same role as the K in K-means clustering: it controls the number of
clusters obtained.

Figure 10.9 therefore highlights a very attractive aspect of hierarchical
clustering: one single dendrogram can be used to obtain any number of
clusters. In practice, people often look at the dendrogram and select by eye
a sensible number of clusters, based on the heights of the fusion and the
number of clusters desired. In the case of Figure 10.9, one might choose to
select either two or three clusters. However, often the choice of where to
cut the dendrogram is not so clear.

394

10. Unsupervised Learning

The term hierarchical refers to the fact that clusters obtained by cutting
the dendrogram at a given height are necessarily nested within the clusters
obtained by cutting the dendrogram at any greater height. However, on
an arbitrary data set, this assumption of hierarchical structure might be
unrealistic. For instance, suppose that our observations correspond to a
group of people with a 50–50 split of males and females, evenly split among
Americans, Japanese, and French. We can imagine a scenario in which the
best division into two groups might split these people by gender, and the
best division into three groups might split them by nationality. In this case,
the true clusters are not nested, in the sense that the best division into three
groups does not result from taking the best division into two groups and
splitting up one of those groups. Consequently, this situation could not be
well-represented by hierarchical clustering. Due to situations such as this
one, hierarchical clustering can sometimes yield worse (i.e. less accurate)
results than K-means clustering for a given number of clusters.

The Hierarchical Clustering Algorithm

The hierarchical clustering dendrogram is obtained via an extremely simple
algorithm. We begin by deﬁning some sort of dissimilarity measure between
each pair of observations. Most often, Euclidean distance is used; we will
discuss the choice of dissimilarity measure later in this chapter. The algo-
rithm proceeds iteratively. Starting out at the bottom of the dendrogram,
each of the n observations is treated as its own cluster. The two clusters
that are most similar to each other are then fused so that there now are
n− 1 clusters. Next the two clusters that are most similar to each other are
fused again, so that there now are n − 2 clusters. The algorithm proceeds
in this fashion until all of the observations belong to one single cluster, and
the dendrogram is complete. Figure 10.11 depicts the ﬁrst few steps of the
algorithm, for the data from Figure 10.9. To summarize, the hierarchical
clustering algorithm is given in Algorithm 10.2.

This algorithm seems simple enough, but one issue has not been ad-
dressed. Consider the bottom right panel in Figure 10.11. How did we
determine that the cluster {5, 7} should be fused with the cluster {8}?
We have a concept of the dissimilarity between pairs of observations, but
how do we deﬁne the dissimilarity between two clusters if one or both of
the clusters contains multiple observations? The concept of dissimilarity
between a pair of observations needs to be extended to a pair of groups
of observations. This extension is achieved by developing the notion of
linkage, which deﬁnes the dissimilarity between two groups of observa-
tions. The four most common types of linkage—complete, average, single,
and centroid —are brieﬂy described in Table 10.2. Average, complete, and
single linkage are most popular among statisticians. Average and complete

linkage

Algorithm 10.2 Hierarchical Clustering

10.3 Clustering Methods

395

1. Begin with n observations and a measure (such as Euclidean dis-
= n(n− 1)/2 pairwise dissimilarities. Treat each

(cid:8)

(cid:9)

tance) of all the
observation as its own cluster.

n
2

2. For i = n, n − 1, . . . , 2:

(a) Examine all pairwise inter-cluster dissimilarities among the i
clusters and identify the pair of clusters that are least dissimilar
(that is, most similar). Fuse these two clusters. The dissimilarity
between these two clusters indicates the height in the dendro-
gram at which the fusion should be placed.
the i − 1 remaining clusters.

(b) Compute the new pairwise inter-cluster dissimilarities among

Linkage

Complete

Single

Average

Centroid

Description

Maximal intercluster dissimilarity. Compute all pairwise dis-
similarities between the observations in cluster A and the
observations in cluster B, and record the largest of these
dissimilarities.
Minimal intercluster dissimilarity. Compute all pairwise dis-
similarities between the observations in cluster A and the
observations in cluster B, and record the smallest of these
dissimilarities. Single linkage can result in extended, trailing
clusters in which single observations are fused one-at-a-time.
Mean intercluster dissimilarity. Compute all pairwise dis-
similarities between the observations in cluster A and the
observations in cluster B, and record the average of these
dissimilarities.
Dissimilarity between the centroid for cluster A (a mean
vector of length p) and the centroid for cluster B. Centroid
linkage can result in undesirable inversions.

TABLE 10.2. A summary of the four most commonly-used types of linkage in
hierarchical clustering.

linkage are generally preferred over single linkage, as they tend to yield
more balanced dendrograms. Centroid linkage is often used in genomics,
but suﬀers from a major drawback in that an inversion can occur, whereby
two clusters are fused at a height below either of the individual clusters in
the dendrogram. This can lead to diﬃculties in visualization as well as in in-
terpretation of the dendrogram. The dissimilarities computed in Step 2(b)
of the hierarchical clustering algorithm will depend on the type of linkage
used, as well as on the choice of dissimilarity measure. Hence, the resulting

inversion

396

10. Unsupervised Learning

2

X

2

X

5
0

.

0

.

0

5

.

0
−

0

.

1
−

5

.

1
−

5
0

.

0

.

0

5

.

0
−

0

.

1
−

5

.

1
−

3

4

1

6

−1.5

−1.0

−0.5

3

4

1

6

−1.5

−1.0

−0.5

9

2

0.0
X1

9

2

0.0
X1

7

8

5

2

X

5
0

.

0

.

0

5

.

0
−

0

.

1
−

5

.

1
−

3

4

1

6

0.5

1.0

−1.5

−1.0

−0.5

7

8

5

2

X

5

.

0

0

.

0

5

.

0
−

0

.

1
−

5

.

1
−

3

4

1

6

0.5

1.0

−1.5

−1.0

−0.5

9

2

0.0
X1

9

2

0.0
X1

7

5

8

0.5

1.0

7

5

8

0.5

1.0

FIGURE 10.11. An illustration of the ﬁrst few steps of the hierarchical
clustering algorithm, using the data from Figure 10.10, with complete linkage
and Euclidean distance. Top Left: initially, there are nine distinct clusters,
{1}, {2}, . . . ,{9}. Top Right: the two clusters that are closest together, {5} and
{7}, are fused into a single cluster. Bottom Left: the two clusters that are closest
together, {6} and {1}, are fused into a single cluster. Bottom Right: the two clus-
ters that are closest together using complete linkage, {8} and the cluster {5, 7},
are fused into a single cluster.

dendrogram typically depends quite strongly on the type of linkage used,
as is shown in Figure 10.12.

Choice of Dissimilarity Measure

Thus far, the examples in this chapter have used Euclidean distance as the
dissimilarity measure. But sometimes other dissimilarity measures might
be preferred. For example, correlation-based distance considers two obser-
vations to be similar if their features are highly correlated, even though the
observed values may be far apart in terms of Euclidean distance. This is

Average Linkage

Complete Linkage

Single Linkage

10.3 Clustering Methods

397

FIGURE 10.12. Average, complete, and single linkage applied to an example
data set. Average and complete linkage tend to yield more balanced clusters.

an unusual use of correlation, which is normally computed between vari-
ables; here it is computed between the observation proﬁles for each pair
of observations. Figure 10.13 illustrates the diﬀerence between Euclidean
and correlation-based distance. Correlation-based distance focuses on the
shapes of observation proﬁles rather than their magnitudes.

The choice of dissimilarity measure is very important, as it has a strong
eﬀect on the resulting dendrogram. In general, careful attention should be
paid to the type of data being clustered and the scientiﬁc question at hand.
These considerations should determine what type of dissimilarity measure
is used for hierarchical clustering.

For instance, consider an online retailer interested in clustering shoppers
based on their past shopping histories. The goal is to identify subgroups
of similar shoppers, so that shoppers within each subgroup can be shown
items and advertisements that are particularly likely to interest them. Sup-
pose the data takes the form of a matrix where the rows are the shoppers
and the columns are the items available for purchase; the elements of the
data matrix indicate the number of times a given shopper has purchased a
given item (i.e. a 0 if the shopper has never purchased this item, a 1 if the
shopper has purchased it once, etc.) What type of dissimilarity measure
should be used to cluster the shoppers? If Euclidean distance is used, then
shoppers who have bought very few items overall (i.e. infrequent users of
the online shopping site) will be clustered together. This may not be desir-
able. On the other hand, if correlation-based distance is used, then shoppers
with similar preferences (e.g. shoppers who have bought items A and B but

398

10. Unsupervised Learning

0
2

5
1

0
1

5

0

Observation 1
Observation 2
Observation 3

2

3

1

5

10

15

20

Variable Index

FIGURE 10.13. Three observations with measurements on 20 variables are
shown. Observations 1 and 3 have similar values for each variable and so there
is a small Euclidean distance between them. But they are very weakly correlated,
so they have a large correlation-based distance. On the other hand, observations
1 and 2 have quite diﬀerent values for each variable, and so there is a large
Euclidean distance between them. But they are highly correlated, so there is a
small correlation-based distance between them.

never items C or D) will be clustered together, even if some shoppers with
these preferences are higher-volume shoppers than others. Therefore, for
this application, correlation-based distance may be a better choice.

In addition to carefully selecting the dissimilarity measure used, one must
also consider whether or not the variables should be scaled to have stan-
dard deviation one before the dissimilarity between the observations is
computed. To illustrate this point, we continue with the online shopping
example just described. Some items may be purchased more frequently than
others; for instance, a shopper might buy ten pairs of socks a year, but a
computer very rarely. High-frequency purchases like socks therefore tend
to have a much larger eﬀect on the inter-shopper dissimilarities, and hence
on the clustering ultimately obtained, than rare purchases like computers.
This may not be desirable. If the variables are scaled to have standard de-
viation one before the inter-observation dissimilarities are computed, then
each variable will in eﬀect be given equal importance in the hierarchical
clustering performed. We might also want to scale the variables to have
standard deviation one if they are measured on diﬀerent scales; otherwise,
the choice of units (e.g. centimeters versus kilometers) for a particular vari-
able will greatly aﬀect the dissimilarity measure obtained. It should come
as no surprise that whether or not it is a good decision to scale the variables
before computing the dissimilarity measure depends on the application at
hand. An example is shown in Figure 10.14. We note that the issue of
whether or not to scale the variables before performing clustering applies
to K-means clustering as well.

10.3 Clustering Methods

399

0
1

8

6

4

2

0

2
1

.

0

.

1

8

.

0

6

.

0

4
.
0

2
.
0

0
.
0

0
0
5
1

0
0
0
1

0
0
5

0

Socks

Computers

Socks

Computers

Socks

Computers

FIGURE 10.14. An eclectic online retailer sells two items: socks and computers.
Left: the number of pairs of socks, and computers, purchased by eight online shop-
pers is displayed. Each shopper is shown in a diﬀerent color. If inter-observation
dissimilarities are computed using Euclidean distance on the raw variables, then
the number of socks purchased by an individual will drive the dissimilarities ob-
tained, and the number of computers purchased will have little eﬀect. This might be
undesirable, since (1) computers are more expensive than socks and so the online
retailer may be more interested in encouraging shoppers to buy computers than
socks, and (2) a large diﬀerence in the number of socks purchased by two shoppers
may be less informative about the shoppers’ overall shopping preferences than a
small diﬀerence in the number of computers purchased. Center: the same data
is shown, after scaling each variable by its standard deviation. Now the number
of computers purchased will have a much greater eﬀect on the inter-observation
dissimilarities obtained. Right: the same data are displayed, but now the y-axis
represents the number of dollars spent by each online shopper on socks and on
computers. Since computers are much more expensive than socks, now computer
purchase history will drive the inter-observation dissimilarities obtained.

10.3.3 Practical Issues in Clustering

Clustering can be a very useful tool for data analysis in the unsupervised
setting. However, there are a number of issues that arise in performing
clustering. We describe some of these issues here.

Small Decisions with Big Consequences

In order to perform clustering, some decisions must be made.

• Should the observations or features ﬁrst be standardized in some way?
For instance, maybe the variables should be centered to have mean
zero and scaled to have standard deviation one.

400

10. Unsupervised Learning

• In the case of hierarchical clustering,

– What dissimilarity measure should be used?

– What type of linkage should be used?

– Where should we cut the dendrogram in order to obtain clusters?
• In the case of K-means clustering, how many clusters should we look

for in the data?

Each of these decisions can have a strong impact on the results obtained.
In practice, we try several diﬀerent choices, and look for the one with
the most useful or interpretable solution. With these methods, there is no
single right answer—any solution that exposes some interesting aspects of
the data should be considered.

Validating the Clusters Obtained

Any time clustering is performed on a data set we will ﬁnd clusters. But we
really want to know whether the clusters that have been found represent
true subgroups in the data, or whether they are simply a result of clustering
the noise. For instance, if we were to obtain an independent set of observa-
tions, then would those observations also display the same set of clusters?
This is a hard question to answer. There exist a number of techniques for
assigning a p-value to a cluster in order to assess whether there is more
evidence for the cluster than one would expect due to chance. However,
there has been no consensus on a single best approach. More details can
be found in Hastie et al. (2009).

Other Considerations in Clustering

Both K-means and hierarchical clustering will assign each observation to
a cluster. However, sometimes this might not be appropriate. For instance,
suppose that most of the observations truly belong to a small number of
(unknown) subgroups, and a small subset of the observations are quite
diﬀerent from each other and from all other observations. Then since K-
means and hierarchical clustering force every observation into a cluster, the
clusters found may be heavily distorted due to the presence of outliers that
do not belong to any cluster. Mixture models are an attractive approach
for accommodating the presence of such outliers. These amount to a soft
version of K-means clustering, and are described in Hastie et al. (2009).

In addition, clustering methods generally are not very robust to pertur-
bations to the data. For instance, suppose that we cluster n observations,
and then cluster the observations again after removing a subset of the n
observations at random. One would hope that the two sets of clusters ob-
tained would be quite similar, but often this is not the case!

10.4 Lab 1: Principal Components Analysis

401

A Tempered Approach to Interpreting the Results of Clustering

We have described some of the issues associated with clustering. However,
clustering can be a very useful and valid statistical tool if used properly. We
mentioned that small decisions in how clustering is performed, such as how
the data are standardized and what type of linkage is used, can have a large
eﬀect on the results. Therefore, we recommend performing clustering with
diﬀerent choices of these parameters, and looking at the full set of results
in order to see what patterns consistently emerge. Since clustering can be
non-robust, we recommend clustering subsets of the data in order to get a
sense of the robustness of the clusters obtained. Most importantly, we must
be careful about how the results of a clustering analysis are reported. These
results should not be taken as the absolute truth about a data set. Rather,
they should constitute a starting point for the development of a scientiﬁc
hypothesis and further study, preferably on an independent data set.

10.4 Lab 1: Principal Components Analysis

In this lab, we perform PCA on the USArrests data set, which is part of
the base R package. The rows of the data set contain the 50 states, in
alphabetical order.

> states = row . names ( USArrests )
> states

The columns of the data set contain the four variables.

> names ( USArrests )
[1] " Murder "

" Assault "

" UrbanPop " " Rape "

We ﬁrst brieﬂy examine the data. We notice that the variables have vastly
diﬀerent means.

> apply ( USArrests , 2 , mean )

Murder
7.79

Assault UrbanPop
65.54

170.76

Rape
21.23

Note that the apply() function allows us to apply a function—in this case,
the mean() function—to each row or column of the data set. The second
input here denotes whether we wish to compute the mean of the rows, 1,
or the columns, 2. We see that there are on average three times as many
rapes as murders, and more than eight times as many assaults as rapes.
We can also examine the variances of the four variables using the apply()
function.

> apply ( USArrests , 2 , var )
Assault UrbanPop
209.5

Murder
19.0

6945.2

Rape
87.7

prcomp()

402

10. Unsupervised Learning

Not surprisingly, the variables also have vastly diﬀerent variances: the
UrbanPop variable measures the percentage of the population in each state
living in an urban area, which is not a comparable number to the num-
ber of rapes in each state per 100,000 individuals. If we failed to scale the
variables before performing PCA, then most of the principal components
that we observed would be driven by the Assault variable, since it has by
far the largest mean and variance. Thus, it is important to standardize the
variables to have mean zero and standard deviation one before performing
PCA.

We now perform principal components analysis using the prcomp() func-

tion, which is one of several functions in R that perform PCA.

> pr . out = prcomp ( USArrests , scale = TRUE )

By default, the prcomp() function centers the variables to have mean zero.
By using the option scale=TRUE, we scale the variables to have standard
deviation one. The output from prcomp() contains a number of useful quan-
tities.

> names ( pr . out )
[1] " sdev "

" rotation " " center "

" scale "

" x "

The center and scale components correspond to the means and standard
deviations of the variables that were used for scaling prior to implementing
PCA.

> pr . out$cente r

Murder
7.79

Assault UrbanPop
65.54

170.76

Rape
21.23

> pr . out$scale

Murder
4.36

Assault UrbanPop
14.47

83.34

Rape
9.37

The rotation matrix provides the principal component loadings; each col-
umn of pr.out$rotation contains the corresponding principal component
loading vector.2

> pr . o u t $ r o t a t i o n

PC2

PC1
-0.536
-0.583

Murder
Assault
UrbanPop -0.278 -0.873 -0.378
Rape
0.818

PC4
PC3
0.418 -0.341
0.649
0.188 -0.268 -0.743
0.134
0.089

-0.543 -0.167

We see that there are four distinct principal components. This is to be
expected because there are in general min(n − 1, p) informative principal
components in a data set with n observations and p variables.

2This function names it the rotation matrix, because when we matrix-multiply the
X matrix by pr.out$rotation, it gives us the coordinates of the data in the rotated
coordinate system. These coordinates are the principal component scores.

10.4 Lab 1: Principal Components Analysis

403

Using the prcomp() function, we do not need to explicitly multiply the
data by the principal component loading vectors in order to obtain the
principal component score vectors. Rather the 50 × 4 matrix x has as its
columns the principal component score vectors. That is, the kth column is
the kth principal component score vector.

> dim ( pr . out$x )
[1] 50

4

We can plot the ﬁrst two principal components as follows:

> biplot ( pr . out , scale =0)

The scale=0 argument to biplot() ensures that the arrows are scaled to
represent the loadings; other values for scale give slightly diﬀerent biplots
with diﬀerent interpretations.

Notice that this ﬁgure is a mirror image of Figure 10.1. Recall that
the principal components are only unique up to a sign change, so we can
reproduce Figure 10.1 by making a few small changes:

biplot()

> pr . o u t $ r o t a t i o n = - pr . o u t $ r o t a t i o n
> pr . out$x = - pr . out$x
> biplot ( pr . out , scale =0)

The prcomp() function also outputs the standard deviation of each prin-
cipal component. For instance, on the USArrests data set, we can access
these standard deviations as follows:

> pr . out$sdev
[1] 1.575 0.995 0.597 0.416

The variance explained by each principal component is obtained by squar-
ing these:

> pr . var = pr . out$sdev ^2
> pr . var
[1] 2.480 0.990 0.357 0.173

To compute the proportion of variance explained by each principal compo-
nent, we simply divide the variance explained by each principal component
by the total variance explained by all four principal components:

> pve = pr . var / sum ( pr . var )
> pve
[1] 0.6201 0.2474 0.0891 0.0434

We see that the ﬁrst principal component explains 62.0 % of the variance
in the data, the next principal component explains 24.7 % of the variance,
and so forth. We can plot the PVE explained by each component, as well
as the cumulative PVE, as follows:

> plot ( pve , xlab =" Principal Component " , ylab =" Proportio n of

Variance Explained " , ylim = c (0 ,1) , type = ’ b ’)

> plot ( cumsum ( pve ) , xlab =" Principal Component " , ylab ="

Cumulative Proportio n of Variance Explained " , ylim = c (0 ,1) ,
type = ’ b ’)

404

10. Unsupervised Learning

The result is shown in Figure 10.4. Note that the function cumsum() com-
putes the cumulative sum of the elements of a numeric vector. For instance:

cumsum()

> a = c (1 ,2 ,8 , -3)
> cumsum ( a )
[1]

3 11

1

8

10.5 Lab 2: Clustering

10.5.1 K-Means Clustering

The function kmeans() performs K-means clustering in R. We begin with
a simple simulated example in which there truly are two clusters in the
data: the ﬁrst 25 observations have a mean shift relative to the next 25
observations.

kmeans()

> set . seed (2)
> x = matrix ( rnorm (50*2) , ncol =2)
> x [1:25 ,1]= x [1:25 ,1]+3
> x [1:25 ,2]= x [1:25 ,2] -4

We now perform K-means clustering with K = 2.

> km . out = kmeans (x ,2 , nstart =20)

The cluster assignments of
km.out$cluster.

> km . out$clust e r

the 50 observations are contained in

[1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 1 1 1

[30] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

The K-means clustering perfectly separated the observations into two clus-
ters even though we did not supply any group information to kmeans(). We
can plot the data, with each observation colored according to its cluster
assignment.

> plot (x , col =( km . out$clust er +1) , main =" K - Means Clustering

Results with K =2" , xlab ="" , ylab ="" , pch =20 , cex =2)

Here the observations can be easily plotted because they are two-dimensional.
If there were more than two variables then we could instead perform PCA
and plot the ﬁrst two principal components score vectors.

In this example, we knew that there really were two clusters because
we generated the data. However, for real data, in general we do not know
the true number of clusters. We could instead have performed K-means
clustering on this example with K = 3.

> set . seed (4)
> km . out = kmeans (x ,3 , nstart =20)
> km . out
K - means clusterin g with 3 clusters of sizes 10 , 23 , 17

10.5 Lab 2: Clustering

405

Cluster means :

[ ,1]

[ ,2]
1
2.3001545 -2.69622023
2 -0.3820397 -0.08740753
3
3.7789567 -4.56200798

Clustering vector :

[1] 3 1 3 1 3 3 3 1 3 1 3 1 3 1 3 1 3 3 3 3 3 1 3 3 3 2 2 2 2

2 2 2 2 2 2 2 2 2 2 2 2 2 2 1 2 1 2 2 2 2

Within cluster sum of squares by cluster :
[1] 19.56137 52.67700 25.74089

( between_S S / total_SS =

79.3 %)

Available components :

[1] " cluster "

" centers "

" tot . withinss " " betweenss "

" totss "
" size "

" withinss "

> plot (x , col =( km . out$clust er +1) , main =" K - Means Clustering

Results with K =3" , xlab ="" , ylab ="" , pch =20 , cex =2)

When K = 3, K-means clustering splits up the two clusters.

To run the kmeans() function in R with multiple initial cluster assign-
ments, we use the nstart argument. If a value of nstart greater than one
is used, then K-means clustering will be performed using multiple random
assignments in Step 1 of Algorithm 10.1, and the kmeans() function will
report only the best results. Here we compare using nstart=1 to nstart=20.

> set . seed (3)
> km . out = kmeans (x ,3 , nstart =1)
> km . out$tot . withinss
[1] 104.3319
> km . out = kmeans (x ,3 , nstart =20)
> km . out$tot . withinss
[1] 97.9793

Note that km.out$tot.withinss is the total within-cluster sum of squares,
which we seek to minimize by performing K-means clustering (Equation
10.11). The individual within-cluster sum-of-squares are contained in the
vector km.out$withinss.

We strongly recommend always running K-means clustering with a large
value of nstart, such as 20 or 50, since otherwise an undesirable local
optimum may be obtained.

When performing K-means clustering, in addition to using multiple ini-
tial cluster assignments, it is also important to set a random seed using the
set.seed() function. This way, the initial cluster assignments in Step 1 can
be replicated, and the K-means output will be fully reproducible.

406

10. Unsupervised Learning

10.5.2 Hierarchical Clustering

The hclust() function implements hierarchical clustering in R. In the fol-
lowing example we use the data from Section 10.5.1 to plot the hierarchical
clustering dendrogram using complete, single, and average linkage cluster-
ing, with Euclidean distance as the dissimilarity measure. We begin by
clustering observations using complete linkage. The dist() function is used
to compute the 50 × 50 inter-observation Euclidean distance matrix.

hclust()

dist()

> hc . complete = hclust ( dist ( x ) , method =" complete ")

We could just as easily perform hierarchical clustering with average or
single linkage instead:

> hc . average = hclust ( dist ( x ) , method =" average ")
> hc . single = hclust ( dist ( x ) , method =" single ")

We can now plot the dendrograms obtained using the usual plot() function.
The numbers at the bottom of the plot identify each observation.

> par ( mfrow = c (1 ,3) )
> plot ( hc . complete , main =" Complete Linkage " , xlab ="" , sub ="" ,

cex =.9)

> plot ( hc . average , main =" Average Linkage " , xlab ="" , sub ="" ,

cex =.9)

> plot ( hc . single , main =" Single Linkage " , xlab ="" , sub ="" ,

cex =.9)

To determine the cluster labels for each observation associated with a

given cut of the dendrogram, we can use the cutree() function:

cutree()

> cutree ( hc . complete , 2)

[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2

[30] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
> cutree ( hc . average , 2)

[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2

[30] 2 2 2 1 2 2 2 2 2 2 2 2 2 2 1 2 1 2 2 2 2
> cutree ( hc . single , 2)

[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1 1

[30] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

For this data, complete and average linkage generally separate the observa-
tions into their correct groups. However, single linkage identiﬁes one point
as belonging to its own cluster. A more sensible answer is obtained when
four clusters are selected, although there are still two singletons.

> cutree ( hc . single , 4)

[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 3 3 3 3

[30] 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 3 3 3 3 3

To scale the variables before performing hierarchical clustering of the

observations, we use the scale() function:

scale()

> xsc = scale ( x )
> plot ( hclust ( dist ( xsc ) , method =" complete ") , main =" H i e r a r c h i c a l

Clustering with Scaled Features ")

10.6 Lab 3: NCI60 Data Example

407

Correlation-based distance can be computed using the as.dist() func-
tion, which converts an arbitrary square symmetric matrix into a form that
the hclust() function recognizes as a distance matrix. However, this only
makes sense for data with at least three features since the absolute corre-
lation between any two observations with measurements on two features is
always 1. Hence, we will cluster a three-dimensional data set.

as.dist()

> x = matrix ( rnorm (30*3) , ncol =3)
> dd = as . dist (1 - cor ( t ( x ) ) )
> plot ( hclust ( dd , method =" complete ") , main =" Complete Linkage

with Correlation - Based Distance " , xlab ="" , sub ="")

10.6 Lab 3: NCI60 Data Example

Unsupervised techniques are often used in the analysis of genomic data.
In particular, PCA and hierarchical clustering are popular tools. We illus-
trate these techniques on the NCI60 cancer cell line microarray data, which
consists of 6,830 gene expression measurements on 64 cancer cell lines.

> library ( ISLR )
> nci . labs = NCI60$lab s
> nci . data = NCI60$dat a

Each cell line is labeled with a cancer type. We do not make use of the
cancer types in performing PCA and clustering, as these are unsupervised
techniques. But after performing PCA and clustering, we will check to
see the extent to which these cancer types agree with the results of these
unsupervised techniques.

The data has 64 rows and 6,830 columns.

> dim ( nci . data )
[1]

64 6830

We begin by examining the cancer types for the cell lines.

> nci . labs [1:4]
[1] " CNS "
" CNS "
> table ( nci . labs )
nci . labs

" CNS "

" RENAL "

BREAST
7

6
OVARIAN
6

7
LEUKEMIA MCF7A - repro MCF7D - repro
1
RENAL
9

1
PROSTATE
2

1
MELANOMA
8
UNKNOWN
1

CNS
5

COLON K562A - repro K562B - repro
1
NSCLC
9

408

10. Unsupervised Learning

10.6.1 PCA on the NCI60 Data

We ﬁrst perform PCA on the data after scaling the variables (genes) to
have standard deviation one, although one could reasonably argue that it
is better not to scale the genes.

> pr . out = prcomp ( nci . data , scale = TRUE )

We now plot the ﬁrst few principal component score vectors, in order to
visualize the data. The observations (cell lines) corresponding to a given
cancer type will be plotted in the same color, so that we can see to what
extent the observations within a cancer type are similar to each other. We
ﬁrst create a simple function that assigns a distinct color to each element
of a numeric vector. The function will be used to assign a color to each of
the 64 cell lines, based on the cancer type to which it corresponds.

Cols = function ( vec ) {
+
+
+

}

cols = rainbow ( length ( unique ( vec ) ) )
return ( cols [ as . numeric ( as . factor ( vec ) ) ])

Note that the rainbow() function takes as its argument a positive integer,
and returns a vector containing that number of distinct colors. We now can
plot the principal component score vectors.

rainbow()

> par ( mfrow = c (1 ,2) )
> plot ( pr . out$x [ ,1:2] , col = Cols ( nci . labs ) , pch =19 ,

xlab =" Z1 " , ylab =" Z2 ")

> plot ( pr . out$x [ , c (1 ,3) ] , col = Cols ( nci . labs ) , pch =19 ,

xlab =" Z1 " , ylab =" Z3 ")

The resulting plots are shown in Figure 10.15. On the whole, cell lines
corresponding to a single cancer type do tend to have similar values on the
ﬁrst few principal component score vectors. This indicates that cell lines
from the same cancer type tend to have pretty similar gene expression
levels.

We can obtain a summary of the proportion of variance explained (PVE)
of the ﬁrst few principal components using the summary() method for a
prcomp object (we have truncated the printout):

> summary ( pr . out )
Importanc e of component s :

Standard deviation
Proportio n of Variance
Cumulativ e Proportio n

PC1

PC2

PC3

PC4

PC5
27.853 21.4814 19.8205 17.0326 15.9718
0.0374
0.3185

0.0575
0.2387

0.0425
0.2812

0.0676
0.1812

0.114
0.114

Using the plot() function, we can also plot the variance explained by the
ﬁrst few principal components.

> plot ( pr . out )

Note that the height of each bar in the bar plot is given by squaring the
corresponding element of pr.out$sdev. However, it is more informative to

10.6 Lab 3: NCI60 Data Example

409

2
Z

0
2

0

0
2
−

0
4
−

0
6
−

3
Z

0
4

0
2

0

0
2
−

0
4
−

−40

−20

0

20

40

60

−40

−20

0

20

40

60

Z1

Z1

FIGURE 10.15. Projections of the NCI60 cancer cell lines onto the ﬁrst three
principal components (in other words, the scores for the ﬁrst three principal com-
ponents). On the whole, observations belonging to a single cancer type tend to
lie near each other in this low-dimensional space. It would not have been possible
to visualize the data without using a dimension reduction method such as PCA,
possible scatterplots, none of
since based on the full data set there are
2
which would have been particularly informative.

6,830

(cid:6)

(cid:7)

plot the PVE of each principal component (i.e. a scree plot) and the cu-
mulative PVE of each principal component. This can be done with just a
little work.

> pve =100* pr . out$sdev ^2/ sum ( pr . out$sdev ^2)
> par ( mfrow = c (1 ,2) )
> plot ( pve ,

type =" o " , ylab =" PVE " , xlab =" Principal Component " ,

col =" blue ")

> plot ( cumsum ( pve ) , type =" o " , ylab =" Cumulative PVE " , xlab ="

Principal Component " , col =" brown3 ")

(Note that the elements of pve can also be computed directly from the sum-
mary, summary(pr.out)$importance[2,], and the elements of cumsum(pve)
are given by summary(pr.out)$importance[3,].) The resulting plots are shown
in Figure 10.16. We see that together, the ﬁrst seven principal components
explain around 40 % of the variance in the data. This is not a huge amount
of the variance. However, looking at the scree plot, we see that while each
of the ﬁrst seven principal components explain a substantial amount of
variance, there is a marked decrease in the variance explained by further
principal components. That is, there is an elbow in the plot after approx-
imately the seventh principal component. This suggests that there may
be little beneﬁt to examining more than seven or so principal components
(though even examining seven principal components may be diﬃcult).

410

10. Unsupervised Learning

E
V
P

0
1

8

6

4

2

0

0
0
1

0
8

0
6

0
4

0
2

E
V
P
e
v
i
t

 

l

a
u
m
u
C

0

10

20

30

40

50

60

0

10

20

30

40

50

60

Principal Component

Principal Component

FIGURE 10.16. The PVE of the principal components of the NCI60 cancer cell
line microarray data set. Left: the PVE of each principal component is shown.
Right: the cumulative PVE of the principal components is shown. Together, all
principal components explain 100 % of the variance.

10.6.2 Clustering the Observations of the NCI60 Data

We now proceed to hierarchically cluster the cell lines in the NCI60 data,
with the goal of ﬁnding out whether or not the observations cluster into
distinct types of cancer. To begin, we standardize the variables to have
mean zero and standard deviation one. As mentioned earlier, this step is
optional and should be performed only if we want each gene to be on the
same scale.

> sd . data = scale ( nci . data )

We now perform hierarchical clustering of the observations using complete,
single, and average linkage. Euclidean distance is used as the dissimilarity
measure.

> par ( mfrow = c (1 ,3) )
> data . dist = dist ( sd . data )
> plot ( hclust ( data . dist ) , labels = nci . labs , main =" Complete

Linkage " , xlab ="" , sub ="" , ylab ="")

> plot ( hclust ( data . dist , method =" average ") , labels = nci . labs ,

main =" Average Linkage " , xlab ="" , sub ="" , ylab ="")

> plot ( hclust ( data . dist , method =" single ") , labels = nci . labs ,

main =" Single Linkage " , xlab ="" , sub ="" , ylab ="")

The results are shown in Figure 10.17. We see that the choice of linkage
certainly does aﬀect the results obtained. Typically, single linkage will tend
to yield trailing clusters: very large clusters onto which individual observa-
tions attach one-by-one. On the other hand, complete and average linkage
tend to yield more balanced, attractive clusters. For this reason, complete
and average linkage are generally preferred to single linkage. Clearly cell
lines within a single cancer type do tend to cluster together, although the

10.6 Lab 3: NCI60 Data Example

411

Complete Linkage

L
A
N
E
R

S
N
C

S
N
C

C
L
C
S
N

T
S
A
E
R
B

T
S
A
E
R
B

T
S
A
E
R
B

I

I

N
A
R
A
V
O

N
A
R
A
V
O

C
L
C
S
N

L
A
N
E
R

A
M
O
N
A
L
E
M

I

N
A
R
A
V
O

N
O
L
O
C

N
O
L
O
C

I

N
A
R
A
V
O

E
T
A
T
S
O
R
P

C
L
C
S
N

C
L
C
S
N

C
L
C
S
N

L
A
N
E
R

C
L
C
S
N

E
T
A
T
S
O
R
P

A
M
O
N
A
L
E
M

I

N
A
R
A
V
O

L
A
N
E
R

L
A
N
E
R

C
L
C
S
N

C
L
C
S
N

S
N
C

C
L
C
S
N

S
N
C

S
N
C

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

I

N
A
R
A
V
O

N
W
O
N
K
N
U

N
O
L
O
C

N
O
L
O
C

T
S
A
E
R
B

N
O
L
O
C

N
O
L
O
C

N
O
L
O
C

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

T
S
A
E
R
B

T
S
A
E
R
B

I

A
M
E
K
U
E
L

I

I

A
M
E
K
U
E
L

A
M
E
K
U
E
L

I

A
M
E
K
U
E
L

I

A
M
E
K
U
E
oL
r
p
e
r
−
A
2
6
5
K

I

A
M
E
K
U
E
L

o
r
p
e
r
−
B
2
6
5
K

T
S
A
E
R
B

o
r
p
e
r
−
A
7
F
C
M

o
r
p
e
r
−
D
7
F
C
M

Average Linkage

L
A
N
E
R

C
L
C
S
N

C
L
C
S
N

T
S
A
E
R
B

T
S
A
E
R
B

I

A
M
E
K
U
E
L

I

A
M
E
K
U
E
L

I

A
M
E
K
U
E
L

I

I

A
M
E
K
U
E
L

A
M
E
K
U
E
L

I

A
M
E
K
U
E
L

o
r
p
e
r
−
B
2
6
5
K

o
r
p
e
r
−
A
2
6
5
K

T
S
A
E
R
B

o
r
p
e
r
−
A
7
F
C
M

o
r
p
e
r
−
D
7
F
C
M

N
O
L
O
C

N
O
L
O
C

N
O
L
O
C

L
A
N
E
R

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

C
L
C
S
N

I

I

N
A
R
A
V
O

N
A
R
A
V
O

I

N
A
R
A
V
O

I

N
A
R
A
V
O

N
W
O
N
K
N
U

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

T
S
A
E
R
B

T
S
A
E
R
B

S
N
C

C
L
C
S
N

A
M
O
N
A
L
E
M

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

S
N
C

S
N
C

L
A
N
E
R

L
A
N
E
R

C
L
C
S
N

C
L
C
S
N

E
T
A
T
S
O
R
P

C
L
C
S
N

N
O
L
O
C

N
O
L
O
C

C
L
C
S
N

C
L
C
S
N

I

N
A
R
A
V
O

E
T
A
T
S
O
R
P

I

N
A
R
A
V
O

N
O
L
O
C

N
O
L
O
C

S
N
C

S
N
C

T
S
A
E
R
B

T
S
A
E
R
B

Single Linkage

S
N
C

C
L
C
S
N

C
L
C
S
N

I

I

N
A
R
A
V
O

A
M
E
K
U
E
L

C
L
C
S
N

T
S
A
E
R
B

N
O
L
O
C

T
S
A
E
R
B

I

N
A
R
A
V
O

L
A
N
E
R

T
S
A
E
R
B

I

A
M
E
K
U
E
L

S
N
C

I

A
M
E
K
U
E
L

I

I

A
M
E
K
U
E
L

A
M
E
K
U
E
L

I

A
M
E
K
U
E
L

o
r
p
e
r
−
B
2
6
5
K

o
r
p
e
r
−
A
2
6
5
K

C
L
C
S
N

C
L
C
S
N

N
O
L
O
C

I

N
A
R
A
V
O

E
T
A
T
S
O
R
P

A
M
O
N
A
L
E
M

C
L
C
S
N

L
A
N
E
R

N
O
L
O
C

E
T
A
T
S
O
R
P

N
O
L
O
C

I

N
A
R
A
V
O

N
O
L
O
C

N
O
L
O
C

C
L
C
S
N

C
L
C
S
N

L
A
N
E
R

C
L
C
S
N

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

L
A
N
E
R

S
N
C

S
N
C

S
N
C

L
A
N
E
R

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

N
O
L
O
C

T
S
A
E
R
B

I

N
A
R
A
V
O

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

A
M
O
N
A
L
E
M

T
S
A
E
R
B

T
S
A
E
R
B

I

N
A
R
A
V
O

N
W
O
N
K
N
U

T
S
A
E
R
B

o
r
p
e
r
−
A
7
F
C
M

o
r
p
e
r
−
D
7
F
C
M

0
6
1

0
2
1

0
8

0
4

0
2
1

0
0
1

0
8

0
6

0
4

0
0
1

0
8

0
6

0
4

FIGURE 10.17. The NCI60 cancer cell line microarray data, clustered with av-
erage, complete, and single linkage, and using Euclidean distance as the dissim-
ilarity measure. Complete and average linkage tend to yield evenly sized clusters
whereas single linkage tends to yield extended clusters to which single leaves are
fused one by one.

412

10. Unsupervised Learning

clustering is not perfect. We will use complete linkage hierarchical cluster-
ing for the analysis that follows.

We can cut the dendrogram at the height that will yield a particular

number of clusters, say four:

> hc . out = hclust ( dist ( sd . data ) )
> hc . clusters = cutree ( hc . out ,4)
> table ( hc . clusters , nci . labs )

There are some clear patterns. All the leukemia cell lines fall in cluster 3,
while the breast cancer cell lines are spread out over three diﬀerent clusters.
We can plot the cut on the dendrogram that produces these four clusters:

> par ( mfrow = c (1 ,1) )
> plot ( hc . out , labels = nci . labs )
> abline ( h =139 , col =" red ")

The abline() function draws a straight line on top of any existing plot
in R. The argument h=139 plots a horizontal line at height 139 on the den-
drogram; this is the height that results in four distinct clusters. It is easy
to verify that the resulting clusters are the same as the ones we obtained
using cutree(hc.out,4).

Printing the output of hclust gives a useful brief summary of the object:

> hc . out

Call :
hclust ( d = dist ( dat ) )

Cluster method
Distance
Number of objects : 64

: complete
: euclidean

We claimed earlier in Section 10.3.2 that K-means clustering and hier-
archical clustering with the dendrogram cut to obtain the same number
of clusters can yield very diﬀerent results. How do these NCI60 hierarchical
clustering results compare to what we get if we perform K-means clustering
with K = 4?

> set . seed (2)
> km . out = kmeans ( sd . data , 4 , nstart =20)
> km . clusters = km . out$cluste r
> table ( km . clusters , hc . clusters )

hc . clusters

km . clusters

1
1 11
0
2
3
9
4 20

2
0
0
0
7

3
0
8
0
0

4
9
0
0
0

We see that the four clusters obtained using hierarchical clustering and K-
means clustering are somewhat diﬀerent. Cluster 2 in K-means clustering is
identical to cluster 3 in hierarchical clustering. However, the other clusters

10.7 Exercises

413

diﬀer: for instance, cluster 4 in K-means clustering contains a portion of
the observations assigned to cluster 1 by hierarchical clustering, as well as
all of the observations assigned to cluster 2 by hierarchical clustering.

Rather than performing hierarchical clustering on the entire data matrix,
we can simply perform hierarchical clustering on the ﬁrst few principal
component score vectors, as follows:

> hc . out = hclust ( dist ( pr . out$x [ ,1:5]) )
> plot ( hc . out , labels = nci . labs , main =" Hier . Clust . on First

Five Score Vectors ")

> table ( cutree ( hc . out ,4) , nci . labs )

Not surprisingly, these results are diﬀerent from the ones that we obtained
when we performed hierarchical clustering on the full data set. Sometimes
performing clustering on the ﬁrst few principal component score vectors
can give better results than performing clustering on the full data. In this
situation, we might view the principal component step as one of denois-
ing the data. We could also perform K-means clustering on the ﬁrst few
principal component score vectors rather than the full data set.

10.7 Exercises

Conceptual

1. This problem involves the K-means clustering algorithm.

(a) Prove (10.12).

(b) On the basis of this identity, argue that the K-means clustering
algorithm (Algorithm 10.1) decreases the objective (10.11) at
each iteration.

2. Suppose that we have four observations, for which we compute a

dissimilarity matrix, given by

⎡
⎢⎢⎣

0.3

0.3
0.4 0.5
0.7 0.8

0.4
0.5

0.45

⎤
⎥⎥⎦ .

0.7
0.8
0.45

For instance, the dissimilarity between the ﬁrst and second obser-
vations is 0.3, and the dissimilarity between the second and fourth
observations is 0.8.

(a) On the basis of this dissimilarity matrix, sketch the dendrogram
that results from hierarchically clustering these four observa-
tions using complete linkage. Be sure to indicate on the plot the
height at which each fusion occurs, as well as the observations
corresponding to each leaf in the dendrogram.

414

10. Unsupervised Learning

(b) Repeat (a), this time using single linkage clustering.
(c) Suppose that we cut the dendogram obtained in (a) such that

two clusters result. Which observations are in each cluster?

(d) Suppose that we cut the dendogram obtained in (b) such that

two clusters result. Which observations are in each cluster?

(e) It is mentioned in the chapter that at each fusion in the den-
drogram, the position of the two clusters being fused can be
swapped without changing the meaning of the dendrogram. Draw
a dendrogram that is equivalent to the dendrogram in (a), for
which two or more of the leaves are repositioned, but for which
the meaning of the dendrogram is the same.

3. In this problem, you will perform K-means clustering manually, with
K = 2, on a small example with n = 6 observations and p = 2
features. The observations are as follows.

Obs. X1 X2
4
3
4
1
2
0

1
1
0
5
6
4

1
2
3
4
5
6

(a) Plot the observations.
(b) Randomly assign a cluster label to each observation. You can
use the sample() command in R to do this. Report the cluster
labels for each observation.

(c) Compute the centroid for each cluster.
(d) Assign each observation to the centroid to which it is closest, in
terms of Euclidean distance. Report the cluster labels for each
observation.

(e) Repeat (c) and (d) until the answers obtained stop changing.
(f) In your plot from (a), color the observations according to the

cluster labels obtained.

4. Suppose that for a particular data set, we perform hierarchical clus-
tering using single linkage and using complete linkage. We obtain two
dendrograms.

(a) At a certain point on the single linkage dendrogram, the clus-
ters {1, 2, 3} and {4, 5} fuse. On the complete linkage dendro-
gram, the clusters {1, 2, 3} and {4, 5} also fuse at a certain point.
Which fusion will occur higher on the tree, or will they fuse at
the same height, or is there not enough information to tell?

10.7 Exercises

415

(b) At a certain point on the single linkage dendrogram, the clusters
{5} and {6} fuse. On the complete linkage dendrogram, the clus-
ters {5} and {6} also fuse at a certain point. Which fusion will
occur higher on the tree, or will they fuse at the same height, or
is there not enough information to tell?

5. In words, describe the results that you would expect if you performed
K-means clustering of the eight shoppers in Figure 10.14, on the
basis of their sock and computer purchases, with K = 2. Give three
answers, one for each of the variable scalings displayed. Explain.

6. A researcher collects expression measurements for 1,000 genes in 100
tissue samples. The data can be written as a 1, 000 × 100 matrix,
which we call X,
in which each row represents a gene and each col-
umn a tissue sample. Each tissue sample was processed on a diﬀerent
day, and the columns of X are ordered so that the samples that were
processed earliest are on the left, and the samples that were processed
later are on the right. The tissue samples belong to two groups: con-
trol (C) and treatment (T). The C and T samples were processed
in a random order across the days. The researcher wishes to deter-
mine whether each gene’s expression measurements diﬀer between the
treatment and control groups.

As a pre-analysis (before comparing T versus C), the researcher per-
forms a principal component analysis of the data, and ﬁnds that the
ﬁrst principal component (a vector of length 100) has a strong linear
trend from left to right, and explains 10 % of the variation. The re-
searcher now remembers that each patient sample was run on one of
two machines, A and B, and machine A was used more often in the
earlier times while B was used more often later. The researcher has
a record of which sample was run on which machine.

(a) Explain what it means that the ﬁrst principal component “ex-

plains 10 % of the variation”.

(b) The researcher decides to replace the (j, i)th element of X with

xji − φj1zi1

where zi1 is the ith score, and φj1 is the jth loading, for the ﬁrst
principal component. He will then perform a two-sample t-test
on each gene in this new data set in order to determine whether
its expression diﬀers between the two conditions. Critique this
idea, and suggest a better approach. (The principal component
analysis is performed on XT ).

(c) Design and run a small simulation experiment to demonstrate

the superiority of your idea.

416

10. Unsupervised Learning

Applied

7. In the chapter, we mentioned the use of correlation-based distance
and Euclidean distance as dissimilarity measures for hierarchical clus-
tering. It turns out that these two measures are almost equivalent:
if
each observation has been centered to have mean zero and standard
deviation one, and if we let rij denote the correlation between the ith
and jth observations, then the quantity 1− rij is proportional to the

squared Euclidean distance between the ith and jth observations.

On the USArrests data, show that this proportionality holds.

Hint: The Euclidean distance can be calculated using the dist() func-
tion, and correlations can be calculated using the cor() function.

8. In Section 10.2.3, a formula for calculating PVE was given in Equa-
tion 10.8. We also saw that the PVE can be obtained using the sdev
output of the prcomp() function.

On the USArrests data, calculate PVE in two ways:

(a) Using the sdev output of the prcomp() function, as was done in

Section 10.2.3.

(b) By applying Equation 10.8 directly. That is, use the prcomp()
function to compute the principal component loadings. Then,
use those loadings in Equation 10.8 to obtain the PVE.

These two approaches should give the same results.

Hint: You will only obtain the same results in (a) and (b) if the same
data is used in both cases. For instance, if in (a) you performed
prcomp() using centered and scaled variables, then you must center
and scale the variables before applying Equation 10.3 in (b).

9. Consider the USArrests data. We will now perform hierarchical clus-

tering on the states.

(a) Using hierarchical

clustering with complete

linkage and

Euclidean distance, cluster the states.

(b) Cut the dendrogram at a height that results in three distinct

clusters. Which states belong to which clusters?

(c) Hierarchically cluster the states using complete linkage and Eu-
clidean distance, after scaling the variables to have standard de-
viation one.

(d) What eﬀect does scaling the variables have on the hierarchical
clustering obtained? In your opinion, should the variables be
scaled before the inter-observation dissimilarities are computed?
Provide a justiﬁcation for your answer.

10. In this problem, you will generate simulated data, and then perform

PCA and K-means clustering on the data.

10.7 Exercises

417

(a) Generate a simulated data set with 20 observations in each of

three classes (i.e. 60 observations total), and 50 variables.
Hint: There are a number of functions in R that you can use to
generate data. One example is the rnorm() function; runif() is
another option. Be sure to add a mean shift to the observations
in each class so that there are three distinct classes.

(b) Perform PCA on the 60 observations and plot the ﬁrst two prin-
cipal component score vectors. Use a diﬀerent color to indicate
the observations in each of the three classes. If the three classes
appear separated in this plot, then continue on to part (c). If
not, then return to part (a) and modify the simulation so that
there is greater separation between the three classes. Do not
continue to part (c) until the three classes show at least some
separation in the ﬁrst two principal component score vectors.

(c) Perform K-means clustering of the observations with K = 3.
How well do the clusters that you obtained in K-means cluster-
ing compare to the true class labels?
Hint: You can use the table() function in R to compare the true
class labels to the class labels obtained by clustering. Be careful
how you interpret the results: K-means clustering will arbitrarily
number the clusters, so you cannot simply check whether the true
class labels and clustering labels are the same.

(d) Perform K-means clustering with K = 2. Describe your results.

(e) Now perform K-means clustering with K = 4, and describe your

results.

(f) Now perform K-means clustering with K = 3 on the ﬁrst two
principal component score vectors, rather than on the raw data.
That is, perform K-means clustering on the 60 × 2 matrix of
which the ﬁrst column is the ﬁrst principal component score
vector, and the second column is the second principal component
score vector. Comment on the results.

(g) Using the scale() function, perform K-means clustering with
K = 3 on the data after scaling each variable to have standard
deviation one. How do these results compare to those obtained
in (b)? Explain.

11. On the book website, www.StatLearning.com, there is a gene expres-
sion data set (Ch10Ex11.csv) that consists of 40 tissue samples with
measurements on 1,000 genes. The ﬁrst 20 samples are from healthy
patients, while the second 20 are from a diseased group.

418

10. Unsupervised Learning

(a) Load in the data using read.csv(). You will need to select

header=F.

(b) Apply hierarchical clustering to the samples using correlation-
based distance, and plot the dendrogram. Do the genes separate
the samples into the two groups? Do your results depend on the
type of linkage used?

(c) Your collaborator wants to know which genes diﬀer the most
across the two groups. Suggest a way to answer this question,
and apply it here.

Index

Cp, 78, 205, 206, 210–213
R2, 68–71, 79–80, 103, 212
(cid:2)2 norm, 216
(cid:2)1 norm, 219

additive, 12, 86–90, 104
additivity, 282, 283
adjusted R2, 78, 205, 206,

210–213

Advertising data set, 15, 16,
20, 59, 61–63, 68, 69,
71–76, 79, 81, 82, 87,
88, 102–104

agglomerative clustering, 390
Akaike information criterion, 78,

205, 206, 210–213

alternative hypothesis, 67
analysis of variance, 290
area under the curve, 147
argument, 42
AUC, 147
Auto data set, 14, 48, 49, 56,
90–93, 121, 122, 171,
176–178, 180, 182, 191,
193–195, 299, 371

backﬁtting, 284, 300
backward stepwise selection, 79,

208–209, 247

bagging, 12, 26, 303, 316–319,

328–330

baseline, 86
basis function, 270, 273
Bayes

classiﬁer, 37–40, 139
decision boundary, 140
error, 37–40

Bayes’ theorem, 138, 139, 226
Bayesian, 226–227
Bayesian information criterion,
78, 205, 206, 210–213
best subset selection, 205, 221,

244–247

bias, 33–36, 65, 82
bias-variance

decomposition, 34
trade-oﬀ, 33–37, 42, 105,

149, 217, 230, 239, 243,
278, 307, 347, 357

binary, 28, 130
biplot, 377, 378

G. James et al., An Introduction to Statistical Learning: with Applications in R,
Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7,
© Springer Science+Business Media New York 2013

419

420

Index

Boolean, 159
boosting, 12, 25, 26, 303, 316,

321–323, 330–331

bootstrap, 12, 175, 187–190,

316

cross-validation, 12, 33, 36,
175–186, 205, 227,
248–251

k-fold, 181–184
leave-one-out, 178–181

Boston data set, 14, 56, 110,

curse of dimensionality, 108, 168,

113, 126, 173, 201, 264,
299, 327, 328, 330, 333

bottom-up clustering, 390
boxplot, 50
branch, 305

Caravan data set, 14, 165, 335
Carseats data set, 14, 117, 123,

324, 333
categorical, 3, 28
classiﬁcation, 3, 12, 28–29,

37–42, 127–173,
337–353

error rate, 311
tree, 311–314, 323–327

classiﬁer, 127
cluster analysis, 26–28
clustering, 4, 26–28, 385–401

K-means, 12, 386–389
agglomerative, 390
bottom-up, 390
hierarchical, 386, 390–401

coeﬃcient, 61
College data set, 14, 54, 263,

300

collinearity, 99–103
conditional probability, 37
conﬁdence interval, 66–67, 81,

82, 103, 268

confounding, 136
confusion matrix, 145, 158
continuous, 3
contour plot, 46
contrast, 86
correlation, 70, 74, 396
Credit data set, 83, 84, 86, 89,

90, 99–102

242–243

data frame, 48
Data sets

Advertising, 15, 16, 20, 59,

61–63, 68, 69, 71–76,
79, 81, 82, 87, 88,
102–104

Auto, 14, 48, 49, 56, 90–93,
121, 122, 171, 176–178,
180, 182, 191, 193–195,
299, 371

Boston, 14, 56, 110, 113,

126, 173, 201, 264, 299,
327, 328, 330, 333
Caravan, 14, 165, 335
Carseats, 14, 117, 123, 324,

333

College, 14, 54, 263, 300
Credit, 83, 84, 86, 89, 90,

99–102

Default, 14, 128–137,
144–148, 198, 199

Heart, 312, 313, 317–320,

354, 355

Hitters, 14, 244, 251, 255,
256, 304, 305, 310, 311,
334

Income, 16–18, 22–24
Khan, 14, 366
NCI60, 4, 5, 14, 407,

409–412

OJ, 14, 334, 371
Portfolio, 14, 194
Smarket, 3, 14, 154, 161,

163, 171

USArrests, 14, 377, 378,

381–383

Wage, 1, 2, 9, 10, 14, 267,

269, 271, 272, 274–277,
280, 281, 283, 284, 286,
287, 299

Weekly, 14, 171, 200
decision tree, 12, 303–316
Default data set, 14, 128–137,

144–148, 198, 199

degrees of freedom, 32, 241, 271,

272, 278

dendrogram, 386, 390–396
density function, 138
dependent variable, 15
derivative, 272, 278
deviance, 206
dimension reduction, 204,

228–238

discriminant function, 141
dissimilarity, 396–398
distance

correlation-based, 396–398,

416

Euclidean, 379, 387, 388,

394, 396–398

double-exponential distribution,

227

dummy variable, 82–86, 130,

134, 269

eﬀective degrees of freedom, 278
elbow, 409
entropy, 311–312, 332
error

irreducible, 18, 32
rate, 37
reducible, 18
term, 16

Euclidean distance, 379, 387,

388, 394, 396–398, 416

expected value, 19
exploratory data analysis, 374

F-statistic, 75
factor, 84
false discovery proportion, 147

Index

421

false negative, 147
false positive, 147
false positive rate, 147, 149, 354
feature, 15
feature selection, 204
Fisher’s linear discriminant, 141
ﬁt, 21
ﬁtted value, 93
ﬂexible, 22
for loop, 193
forward stepwise selection, 78,

207–208, 247

function, 42

Gaussian (normal) distribution,

138, 139, 142–143

generalized additive model, 6, 26,

265, 266, 282–287, 294
generalized linear model, 6, 156,

192

Gini index, 311–312, 319, 332

Heart data set, 312, 313,

317–320, 354, 355

heatmap, 47
heteroscedasticity, 95–96
hierarchical clustering, 390–396

dendrogram, 390–394
inversion, 395
linkage, 394–396

hierarchical principle, 89
high-dimensional, 78, 208, 239
hinge loss, 357
histogram, 50
Hitters data set, 14, 244, 251,

255, 256, 304, 305, 310,
311, 334
hold-out set, 176
hyperplane, 338–343
hypothesis test, 67–68, 75, 95

Income data set, 16–18, 22–24
independent variable, 15
indicator function, 268
inference, 17, 19

422

Index

inner product, 351
input variable, 15
integral, 278
interaction, 60, 81, 87–90, 104,

286

intercept, 61, 63
interpretability, 203
inversion, 395
irreducible error, 18, 39, 82,

103

K-means clustering, 12, 386–389
K-nearest neighbors

classiﬁer, 12, 38–40, 127
regression, 104–109

kernel, 350–353, 356, 367

linear, 352
non-linear, 349–353
polynomial, 352, 354
radial, 352–354, 363

Khan data set, 14, 366
knot, 266, 271, 273–275

Laplace distribution, 227
lasso, 12, 25, 219–227, 241–242,

309, 357

leaf, 305, 391
least squares, 6, 21, 61–63, 133,

203
line, 63
weighted, 96

level, 84
leverage, 97–99
likelihood function, 133
linear, 2, 86
linear combination, 121, 204,

229, 375

linear discriminant analysis, 6,
12, 127, 130, 138–147,
348, 354
linear kernel, 352
linear model, 20, 21, 59
linear regression, 6, 12

multiple, 71–82
simple, 61–71

linkage, 394–396, 410
average, 394–396
centroid, 394–396
complete, 391, 394–396
single, 394–396

local regression, 266, 294
logistic

function, 132

logistic regression, 6, 12, 26, 127,
131–137, 286–287, 349,
356–357

multiple, 135–137

logit, 132, 286, 291
loss function, 277, 357
low-dimensional, 238

main eﬀects, 88, 89
majority vote, 317
Mallow’s Cp, 78, 205, 206,

210–213
margin, 341, 357
matrix multiplication, 12
maximal margin

classiﬁer, 337–343
hyperplane, 341

maximum likelihood, 132–133,

135

mean squared error, 29
misclassiﬁcation error, 37
missing data, 49
mixed selection, 79
model assessment, 175
model selection, 175
multicollinearity, 243
multivariate Gaussian, 142–143
multivariate normal, 142–143

natural spline, 274, 278, 293
NCI60 data set, 4, 5, 14, 407,

409–412

negative predictive value, 147,

149

node

internal, 305
purity, 311–312
terminal, 305

noise, 22, 228
non-linear, 2, 12, 265–301

decision boundary, 349–353
kernel, 349–353

non-parametric, 21, 23–24,

104–109, 168

normal (Gaussian) distribution,

138, 139, 142–143

null, 145

hypothesis, 67
model, 78, 205, 220

odds, 132, 170
OJ data set, 14, 334, 371
one-standard-error rule, 214
one-versus-all, 356
one-versus-one, 355
optimal separating hyperplane,

341

optimism of training error, 32
ordered categorical variable, 292
orthogonal, 233, 377

basis, 288

out-of-bag, 317–319
outlier, 96–97
output variable, 15
overﬁtting, 22, 24, 26, 32, 80,

144, 207, 341

p-value, 67–68, 73
parameter, 61
parametric, 21–23, 104–109
partial least squares, 12, 230,

237–238, 258, 259

path algorithm, 224
perpendicular, 233
polynomial

kernel, 352, 354
regression, 90–92, 265–268,

271

population regression line, 63
Portfolio data set, 14, 194
positive predictive value, 147,

149

Index

423

posterior

distribution, 226
mode, 226
probability, 139

power, 101, 147
precision, 147
prediction, 17

interval, 82, 103

predictor, 15
principal components, 375
analysis, 12, 230–236,

374–385

loading vector, 375, 376
proportion of variance

explained, 382–384, 408

regression, 12, 230–236,

256–257, 374–375, 385

score vector, 376
scree plot, 383–384

prior

distribution, 226
probability, 138

projection, 204
pruning, 307–309

cost complexity, 307–309
weakest link, 307–309

quadratic, 91
quadratic discriminant analysis,

4, 149–150

qualitative, 3, 28, 127, 176

variable, 82–86

quantitative, 3, 28, 127, 176

R functions
x2, 125
abline(), 112, 122, 301,

412

anova(), 116, 290, 291
apply(), 250, 401
as.dist(), 407
as.factor(), 50
attach(), 50
biplot(), 403
boot(), 194–196, 199

424

Index

bs(), 293, 300
c(), 43
cbind(), 164, 289
coef(), 111, 157, 247, 251
confint(), 111
contour(), 46
contrasts(), 118, 157
cor(), 44, 122, 155, 416
cumsum(), 404
cut(), 292
cutree(), 406
cv.glm(), 192, 193, 199
cv.glmnet(), 254
cv.tree(), 326, 328, 334
data.frame(), 171, 201,

262, 324

dev.off(), 46
dim(), 48, 49
dist(), 406, 416
fix(), 48, 54
for(), 193
gam(), 284, 294, 296
gbm(), 330
glm(), 156, 161, 192, 199,

291

glmnet(), 251, 253–255
hatvalues(), 113
hclust(), 406, 407
hist(), 50, 55
I(), 115, 289, 291, 296
identify(), 50
ifelse(), 324
image(), 46
importance(), 330, 333,

334

is.na(), 244
jitter(), 292
jpeg(), 46
kmeans(), 404, 405
knn(), 163, 164
lda(), 161, 163
legend(), 125
length(), 43
library(), 109, 110
lines(), 112

lm(), 110, 112, 113, 115,

116, 121, 122, 156, 161,
191, 192, 254, 256, 288,
294, 324

lo(), 296
loadhistory(), 51
loess(), 294
ls(), 43
matrix(), 44
mean(), 45, 158, 191, 401
median(), 171
model.matrix(), 251
na.omit(), 49, 244
names(), 49, 111
ns(), 293
pairs(), 50, 55
par(), 112, 289
pcr(), 256, 258
pdf(), 46
persp(), 47
plot(), 45, 46, 49, 55, 112,
122, 246, 295, 325, 360,
371, 406, 408
plot.gam(), 295
plot.svm(), 360
plsr(), 258
points(), 246
poly(), 116, 191, 288–290,

299

prcomp(), 402, 403, 416
predict(), 111, 157,

161–163, 191, 249, 250,
252, 253, 289, 291, 292,
296, 325, 327, 361, 364,
365

print(), 172
prune.misclass(), 327
prune.tree(), 328
q(), 51
qda(), 163
quantile(), 201
rainbow(), 408
randomForest(), 329
range(), 56
read.csv(), 49, 54, 418

read.table(), 48, 49
regsubsets(), 244–249, 262
residuals(), 112
return(), 172
rm(), 43
rnorm(), 44, 45, 124, 262,

417

rstudent(), 112
runif(), 417
s(), 294
sample(), 191, 194, 414
savehistory(), 51
scale(), 165, 406, 417
sd(), 45
seq(), 46
set.seed(), 45, 191, 405
smooth.spline(), 293, 294
sqrt(), 44, 45
sum(), 244
summary(), 51, 55, 113, 121,
122, 157, 196, 199, 244,
245, 256, 257, 295, 324,
325, 328, 330, 334, 360,
361, 363, 372, 408

svm(), 359–363, 365, 366
table(), 158, 417
text(), 325
title(), 289
tree(), 304, 324
tune(), 361, 364, 372
update(), 114
var(), 45
varImpPlot(), 330
vif(), 114
which.max(), 113, 246
which.min(), 246
write.table(), 48

radial kernel, 352–354, 363
random forest, 12, 303, 316,

319–321, 328–330

recall, 147
receiver operating characteristic

(ROC), 147, 354–355
recursive binary splitting, 306,

Index

425

reducible error, 18, 81
regression, 3, 12, 28–29

local, 265, 266, 280–282
piecewise polynomial, 271
polynomial, 265–268,

276–277

spline, 266, 270, 293
tree, 304–311, 327–328

regularization, 204, 215
replacement, 189
resampling, 175–190
residual, 62, 72

plot, 92
standard error, 66, 68–69,

79–80, 102
studentized, 97
sum of squares, 62, 70, 72

residuals, 239, 321
response, 15
ridge regression, 12, 215–219,

357

robust, 345, 348, 400
ROC curve, 147, 354–355
rug plot, 292

scale equivariant, 217
scatterplot, 49
scatterplot matrix, 50
scree plot, 383–384, 409

elbow, 384

seed, 191
semi-supervised learning, 28
sensitivity, 145, 147
separating hyperplane, 338–343
shrinkage, 204, 215

penalty, 215

signal, 228
slack variable, 346
slope, 61, 63
Smarket data set, 3, 14, 154,

161, 163, 171

smoother, 286
smoothing spline, 266, 277–280,

293

309, 311

soft margin classiﬁer, 343–345

426

Index

soft-thresholding, 225
sparse, 219, 228
sparsity, 219
speciﬁcity, 145, 147, 148
spline, 265, 271–280

cubic, 273
linear, 273
natural, 274, 278
regression, 266, 271–277
smoothing, 31, 266, 277–280
thin-plate, 23

standard error, 65, 93
standardize, 165
statistical model, 1
step function, 105, 265, 268–270
stepwise model selection, 12,

205, 207

stump, 322
subset selection, 204–214
subtree, 308
supervised learning, 26–28, 237
support vector, 342, 347, 357

classiﬁer, 337, 343–349
machine, 12, 26, 349–359
regression, 358

synergy, 60, 81, 87–90, 104
systematic, 16

t-distribution, 67, 153
t-statistic, 67
test

error, 37, 40, 158
MSE, 29–34
observations, 30
set, 32

time series, 94
total sum of squares, 70
tracking, 94
train, 21
training

data, 21
error, 37, 40, 158
MSE, 29–33

tree, 303–316
tree-based method, 303
true negative, 147
true positive, 147
true positive rate, 147, 149, 354
truncated power basis, 273
tuning parameter, 215
Type I error, 147
Type II error, 147

unsupervised learning, 26–28,

230, 237, 373–413

USArrests data set, 14, 377,

378, 381–383

validation set, 176

approach, 176–178

variable, 15

dependent, 15
dummy, 82–86, 89–90
importance, 319, 330
independent, 15
indicator, 37
input, 15
output, 15
qualitative, 82–86, 89–90
selection, 78, 204, 219

variance, 19, 33–36

inﬂation factor, 101–103,

114

varying coeﬃcient model, 282
vector, 43

Wage data set, 1, 2, 9, 10, 14,

267, 269, 271, 272,
274–277, 280, 281, 283,
284, 286, 287, 299

weakest link pruning, 308
Weekly data set, 14, 171, 200
weighted least squares, 96, 282
within class covariance, 143
workspace, 51
wrapper, 289

