C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Gaussian Processes for Machine Learning

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Adaptive Computation and Machine Learning
Thomas Dietterich, Editor
Christopher Bishop, David Heckerman, Michael Jordan, and Michael Kearns, Associate Editors

Bioinformatics: The Machine Learning Approach,
Pierre Baldi and Søren Brunak

Reinforcement Learning: An Introduction,
Richard S. Sutton and Andrew G. Barto

Graphical Models for Machine Learning and Digital Communication,
Brendan J. Frey

Learning in Graphical Models,
Michael I. Jordan

Causation, Prediction, and Search, second edition,
Peter Spirtes, Clark Glymour, and Richard Scheines

Principles of Data Mining,
David Hand, Heikki Mannila, and Padhraic Smyth

Bioinformatics: The Machine Learning Approach, second edition,
Pierre Baldi and Søren Brunak

Learning Kernel Classiﬁers: Theory and Algorithms,
Ralf Herbrich

Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond,
Bernhard Sch¨olkopf and Alexander J. Smola

Introduction to Machine Learning,
Ethem Alpaydin

Gaussian Processes for Machine Learning,
Carl Edward Rasmussen and Christopher K. I. Williams

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Gaussian Processes for Machine Learning

Carl Edward Rasmussen
Christopher K. I. Williams

The MIT Press
Cambridge, Massachusetts
London, England

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

c(cid:13) 2006 Massachusetts Institute of Technology

All rights reserved. No part of this book may be reproduced in any form by any electronic or mechanical
means (including photocopying, recording, or information storage and retrieval) without permission in
writing from the publisher.

MIT Press books may be purchased at special quantity discounts for business or sales promotional use.
For information, please email special sales@mitpress.mit.edu or write to Special Sales Department,
The MIT Press, 55 Hayward Street, Cambridge, MA 02142.

Typeset by the authors using LATEX 2ε.
This book was printed and bound in the United States of America.

Library of Congress Cataloging-in-Publication Data

Rasmussen, Carl Edward.

Gaussian processes for machine learning / Carl Edward Rasmussen, Christopher K. I. Williams.

p. cm. —(Adaptive computation and machine learning)

Includes bibliographical references and indexes.
ISBN 0-262-18253-X
1. Gaussian processes—Data processing. 2. Machine learning—Mathematical models.
I. Williams, Christopher K. I. II. Title. III. Series.

QA274.4.R37 2006
519.2'3—dc22

10 9 8 7 6

5 4 3

2

2005053433

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

The actual science of logic is conversant at present only with things either
certain, impossible, or entirely doubtful, none of which (fortunately) we have to
reason on. Therefore the true logic for this world is the calculus of Probabilities,
which takes account of the magnitude of the probability which is, or ought to
be, in a reasonable man’s mind.

— James Clerk Maxwell [1850]

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Contents

Series Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
xi
Preface
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
Symbols and Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii

1 Introduction

1.1 A Pictorial Introduction to Bayesian Modelling . . . . . . . . . . . . . . .
1.2 Roadmap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 Regression

2.1 Weight-space View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.1 The Standard Linear Model . . . . . . . . . . . . . . . . . . . . . .
2.1.2 Projections of Inputs into Feature Space . . . . . . . . . . . . . . .
2.2 Function-space View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Varying the Hyperparameters . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Decision Theory for Regression . . . . . . . . . . . . . . . . . . . . . . . .
2.5 An Example Application . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.6 Smoothing, Weight Functions and Equivalent Kernels
. . . . . . . . . . .
Incorporating Explicit Basis Functions . . . . . . . . . . . . . . . . . . . .
2.7.1 Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . .
2.8 History and Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.9 Exercises
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

∗ 2.7

1
3
5

7
7
8
11
13
19
21
22
24
27
29
29
30

3 Classiﬁcation

3.1 Classiﬁcation Problems

33
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
34
3.1.1 Decision Theory for Classiﬁcation . . . . . . . . . . . . . . . . . .
35
3.2 Linear Models for Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . .
37
3.3 Gaussian Process Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . .
39
3.4 The Laplace Approximation for the Binary GP Classiﬁer . . . . . . . . . .
41
3.4.1 Posterior
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
3.4.2 Predictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
44
3.4.3
Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
45
3.4.4 Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . .
47
∗ 3.5 Multi-class Laplace Approximation . . . . . . . . . . . . . . . . . . . . . .
48
Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
3.6 Expectation Propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
3.6.1 Predictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
56
3.6.2 Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.6.3
Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
3.7 Experiments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3.7.1 A Toy Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . .
60
3.7.2 One-dimensional Example
. . . . . . . . . . . . . . . . . . . . . .
62
3.7.3 Binary Handwritten Digit Classiﬁcation Example . . . . . . . . . .
63
3.7.4
10-class Handwritten Digit Classiﬁcation Example . . . . . . . . .
70
3.8 Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
∗Sections marked by an asterisk contain advanced material that may be omitted on a ﬁrst reading.

3.5.1

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

viii

Contents

∗ 3.9 Appendix: Moment Derivations . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.10 Exercises

74
75

4 Covariance Functions
∗

4.1 Preliminaries

4.2 Examples of Covariance Functions

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.1.1 Mean Square Continuity and Diﬀerentiability . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . .
4.2.1
Stationary Covariance Functions . . . . . . . . . . . . . . . . . . .
4.2.2 Dot Product Covariance Functions . . . . . . . . . . . . . . . . . .
4.2.3 Other Non-stationary Covariance Functions . . . . . . . . . . . . .
4.2.4 Making New Kernels from Old . . . . . . . . . . . . . . . . . . . .
4.3 Eigenfunction Analysis of Kernels . . . . . . . . . . . . . . . . . . . . . . .
4.3.1 An Analytic Example . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.2 Numerical Approximation of Eigenfunctions . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . .

79
79
81
81
82
89
90
94
96
97
98
99
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102

String Kernels
4.4.1
4.4.2 Fisher Kernels

4.4 Kernels for Non-vectorial Inputs

4.5 Exercises

∗

5 Model Selection and Adaptation of Hyperparameters

105
5.1 The Model Selection Problem . . . . . . . . . . . . . . . . . . . . . . . . . 106
5.2 Bayesian Model Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
5.3 Cross-validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
5.4 Model Selection for GP Regression . . . . . . . . . . . . . . . . . . . . . . 112
5.4.1 Marginal Likelihood . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.4.2 Cross-validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
5.4.3 Examples and Discussion . . . . . . . . . . . . . . . . . . . . . . . 118
5.5 Model Selection for GP Classiﬁcation . . . . . . . . . . . . . . . . . . . . . 124
5.5.1 Derivatives of the Marginal Likelihood for Laplace’s Approximation 125
5.5.2 Derivatives of the Marginal Likelihood for EP . . . . . . . . . . . . 127
5.5.3 Cross-validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
5.5.4 Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

5.6 Exercises

∗
∗

6 Relationships between GPs and Other Models

129
6.1 Reproducing Kernel Hilbert Spaces . . . . . . . . . . . . . . . . . . . . . . 129
6.2 Regularization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
6.2.1 Regularization Deﬁned by Diﬀerential Operators . . . . . . . . . . 133
6.2.2 Obtaining the Regularized Solution . . . . . . . . . . . . . . . . . . 135
6.2.3 The Relationship of the Regularization View to Gaussian Process

∗

∗
∗ 6.4 Support Vector Machines

Prediction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
6.3 Spline Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
6.3.1 A 1-d Gaussian Process Spline Construction . . . . . . . . . . . . . 138
. . . . . . . . . . . . . . . . . . . . . . . . . . . 141
Support Vector Classiﬁcation . . . . . . . . . . . . . . . . . . . . . 141
Support Vector Regression . . . . . . . . . . . . . . . . . . . . . . 145
∗ 6.5 Least-squares Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . 146
6.5.1 Probabilistic Least-squares Classiﬁcation . . . . . . . . . . . . . . . 147

6.4.1
6.4.2

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Contents

ix

∗ 6.6 Relevance Vector Machines

6.7 Exercises

. . . . . . . . . . . . . . . . . . . . . . . . . . 149
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

7.1.1

Some Speciﬁc Examples of Equivalent Kernels

7 Theoretical Perspectives
7.1 The Equivalent Kernel

151
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
. . . . . . . . . . . 153
∗ 7.2 Asymptotic Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
7.2.1 Consistency
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
7.2.2 Equivalence and Orthogonality . . . . . . . . . . . . . . . . . . . . 157
∗ 7.3 Average-case Learning Curves . . . . . . . . . . . . . . . . . . . . . . . . . 159
∗ 7.4 PAC-Bayesian Analysis
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
7.4.1 The PAC Framework . . . . . . . . . . . . . . . . . . . . . . . . . . 162
7.4.2 PAC-Bayesian Analysis
. . . . . . . . . . . . . . . . . . . . . . . . 163
7.4.3 PAC-Bayesian Analysis of GP Classiﬁcation . . . . . . . . . . . . . 164
7.5 Comparison with Other Supervised Learning Methods . . . . . . . . . . . 165
∗ 7.6 Appendix: Learning Curve for the Ornstein-Uhlenbeck Process . . . . . . 168
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169

7.7 Exercises

8 Approximation Methods for Large Datasets

171
8.1 Reduced-rank Approximations of the Gram Matrix . . . . . . . . . . . . . 171
8.2 Greedy Approximation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
8.3 Approximations for GPR with Fixed Hyperparameters . . . . . . . . . . . 175
8.3.1
Subset of Regressors . . . . . . . . . . . . . . . . . . . . . . . . . . 175
8.3.2 The Nystr¨om Method . . . . . . . . . . . . . . . . . . . . . . . . . 177
8.3.3
. . . . . . . . . . . . . . . . . . . . . . . . . 177
8.3.4 Projected Process Approximation . . . . . . . . . . . . . . . . . . . 178
8.3.5 Bayesian Committee Machine . . . . . . . . . . . . . . . . . . . . . 180
8.3.6
. . . . . . . . . . . . . . . . . 181
8.3.7 Comparison of Approximate GPR Methods . . . . . . . . . . . . . 182
8.4 Approximations for GPC with Fixed Hyperparameters . . . . . . . . . . . 185
. . . . . . . . 185

∗ 8.5 Approximating the Marginal Likelihood and its Derivatives
∗ 8.6 Appendix: Equivalence of SR and GPR Using the Nystr¨om Approximate

Iterative Solution of Linear Systems

Subset of Datapoints

Kernel

8.7 Exercises

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187

9 Further Issues and Conclusions

189
9.1 Multiple Outputs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190
9.2 Noise Models with Dependencies . . . . . . . . . . . . . . . . . . . . . . . 190
9.3 Non-Gaussian Likelihoods . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.4 Derivative Observations . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
9.5 Prediction with Uncertain Inputs . . . . . . . . . . . . . . . . . . . . . . . 192
9.6 Mixtures of Gaussian Processes . . . . . . . . . . . . . . . . . . . . . . . . 192
9.7 Global Optimization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
9.8 Evaluation of Integrals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
9.9 Student’s t Process
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
9.10 Invariances
9.11 Latent Variable Models
. . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
9.12 Conclusions and Future Directions . . . . . . . . . . . . . . . . . . . . . . 196

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

x

Contents

Appendix A Mathematical Background

199
A.1 Joint, Marginal and Conditional Probability . . . . . . . . . . . . . . . . . 199
A.2 Gaussian Identities
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
A.3 Matrix Identities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
A.3.1 Matrix Derivatives . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
A.3.2 Matrix Norms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
A.4 Cholesky Decomposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
A.5 Entropy and Kullback-Leibler Divergence . . . . . . . . . . . . . . . . . . 203
A.6 Limits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
A.7 Measure and Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
A.7.1 Lp Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
A.8 Fourier Transforms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
A.9 Convexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206

Appendix B Gaussian Markov Processes

B.1 Fourier Analysis

B.2 Continuous-time Gaussian Markov Processes

207
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
B.1.1 Sampling and Periodization . . . . . . . . . . . . . . . . . . . . . . 209
. . . . . . . . . . . . . . . . 211
B.2.1 Continuous-time GMPs on R . . . . . . . . . . . . . . . . . . . . . 211
B.2.2 The Solution of the Corresponding SDE on the Circle . . . . . . . 213
. . . . . . . . . . . . . . . . . . 214
B.3.1 Discrete-time GMPs on Z . . . . . . . . . . . . . . . . . . . . . . . 214
B.3.2 The Solution of the Corresponding Diﬀerence Equation on PN . . 215

B.3 Discrete-time Gaussian Markov Processes

B.4 The Relationship Between Discrete-time and Sampled Continuous-time

GMPs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
B.5 Markov Processes in Higher Dimensions . . . . . . . . . . . . . . . . . . . 218

Appendix C Datasets and Code

Bibliography

Author Index

Subject Index

221

223

239

245

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Series Foreword

The goal of building systems that can adapt to their environments and learn
from their experience has attracted researchers from many ﬁelds, including com-
puter science, engineering, mathematics, physics, neuroscience, and cognitive
science. Out of this research has come a wide variety of learning techniques that
have the potential to transform many scientiﬁc and industrial ﬁelds. Recently,
several research communities have converged on a common set of issues sur-
rounding supervised, unsupervised, and reinforcement learning problems. The
MIT Press series on Adaptive Computation and Machine Learning seeks to
unify the many diverse strands of machine learning research and to foster high
quality research and innovative applications.

One of the most active directions in machine learning has been the de-
velopment of practical Bayesian methods for challenging learning problems.
Gaussian Processes for Machine Learning presents one of the most important
Bayesian machine learning approaches based on a particularly eﬀective method
for placing a prior distribution over the space of functions. Carl Edward Ras-
mussen and Chris Williams are two of the pioneers in this area, and their book
describes the mathematical foundations and practical application of Gaussian
processes in regression and classiﬁcation tasks. They also show how Gaussian
processes can be interpreted as a Bayesian version of the well-known support
vector machine methods. Students and researchers who study this book will be
able to apply Gaussian process methods in creative ways to solve a wide range
of problems in science and engineering.

Thomas Dietterich

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Preface

Over the last decade there has been an explosion of work in the “kernel ma-
chines” area of machine learning. Probably the best known example of this is
work on support vector machines, but during this period there has also been
much activity concerning the application of Gaussian process models to ma-
chine learning tasks. The goal of this book is to provide a systematic and uni-
ﬁed treatment of this area. Gaussian processes provide a principled, practical,
probabilistic approach to learning in kernel machines. This gives advantages
with respect to the interpretation of model predictions and provides a well-
founded framework for learning and model selection. Theoretical and practical
developments of over the last decade have made Gaussian processes a serious
competitor for real supervised learning applications.

Roughly speaking a stochastic process is a generalization of a probability
distribution (which describes a ﬁnite-dimensional random variable) to func-
tions. By focussing on processes which are Gaussian, it turns out that the
computations required for inference and learning become relatively easy. Thus,
the supervised learning problems in machine learning which can be thought of
as learning a function from examples can be cast directly into the Gaussian
process framework.

Our interest in Gaussian process (GP) models in the context of machine
learning was aroused in 1994, while we were both graduate students in Geoﬀ
Hinton’s Neural Networks lab at the University of Toronto. This was a time
when the ﬁeld of neural networks was becoming mature and the many con-
nections to statistical physics, probabilistic models and statistics became well
known, and the ﬁrst kernel-based learning algorithms were becoming popular.
In retrospect it is clear that the time was ripe for the application of Gaussian
processes to machine learning problems.

Many researchers were realizing that neural networks were not so easy to
apply in practice, due to the many decisions which needed to be made: what
architecture, what activation functions, what learning rate, etc., and the lack of
a principled framework to answer these questions. The probabilistic framework
was pursued using approximations by MacKay [1992b] and using Markov chain
Monte Carlo (MCMC) methods by Neal [1996]. Neal was also a graduate stu-
dent in the same lab, and in his thesis he sought to demonstrate that using the
Bayesian formalism, one does not necessarily have problems with “overﬁtting”
when the models get large, and one should pursue the limit of large models.
While his own work was focused on sophisticated Markov chain methods for
inference in large ﬁnite networks, he did point out that some of his networks
became Gaussian processes in the limit of inﬁnite size, and “there may be sim-
pler ways to do inference in this case.”

It is perhaps interesting to mention a slightly wider historical perspective.
The main reason why neural networks became popular was that they allowed
the use of adaptive basis functions, as opposed to the well known linear models.
The adaptive basis functions, or hidden units, could “learn” hidden features

kernel machines

Gaussian process

Gaussian processes
in machine learning

neural networks

large neural networks
≡ Gaussian processes

adaptive basis functions

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

xiv

many ﬁxed basis
functions

useful representations

supervised learning
in statistics

statistics and
machine learning

data and models

algorithms and
predictions

bridging the gap

Preface

useful for the modelling problem at hand. However, this adaptivity came at the
cost of a lot of practical problems. Later, with the advancement of the “kernel
era”, it was realized that the limitation of ﬁxed basis functions is not a big
restriction if only one has enough of them, i.e. typically inﬁnitely many, and
one is careful to control problems of overﬁtting by using priors or regularization.
The resulting models are much easier to handle than the adaptive basis function
models, but have similar expressive power.

Thus, one could claim that (as far a machine learning is concerned) the
adaptive basis functions were merely a decade-long digression, and we are now
back to where we came from. This view is perhaps reasonable if we think of
models for solving practical learning problems, although MacKay [2003, ch. 45],
for example, raises concerns by asking “did we throw out the baby with the bath
water?”, as the kernel view does not give us any hidden representations, telling
us what the useful features are for solving a particular problem. As we will
argue in the book, one answer may be to learn more sophisticated covariance
functions, and the “hidden” properties of the problem are to be found here.
An important area of future developments for GP models is the use of more
expressive covariance functions.

Supervised learning problems have been studied for more than a century
in statistics, and a large body of well-established theory has been developed.
More recently, with the advance of aﬀordable, fast computation, the machine
learning community has addressed increasingly large and complex problems.

Much of the basic theory and many algorithms are shared between the
statistics and machine learning community. The primary diﬀerences are perhaps
the types of the problems attacked, and the goal of learning. At the risk of
oversimpliﬁcation, one could say that in statistics a prime focus is often in
understanding the data and relationships in terms of models giving approximate
summaries such as linear relations or independencies. In contrast, the goals in
machine learning are primarily to make predictions as accurately as possible and
to understand the behaviour of learning algorithms. These diﬀering objectives
have led to diﬀerent developments in the two ﬁelds: for example, neural network
algorithms have been used extensively as black-box function approximators in
machine learning, but to many statisticians they are less than satisfactory,
because of the diﬃculties in interpreting such models.

Gaussian process models in some sense bring together work in the two com-
munities. As we will see, Gaussian processes are mathematically equivalent to
many well known models, including Bayesian linear models, spline models, large
neural networks (under suitable conditions), and are closely related to others,
such as support vector machines. Under the Gaussian process viewpoint, the
models may be easier to handle and interpret than their conventional coun-
terparts, such as e.g. neural networks. In the statistics community Gaussian
processes have also been discussed many times, although it would probably be
excessive to claim that their use is widespread except for certain speciﬁc appli-
cations such as spatial models in meteorology and geology, and the analysis of
computer experiments. A rich theory also exists for Gaussian process models

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Preface

in the time series analysis literature; some pointers to this literature are given
in Appendix B.

The book is primarily intended for graduate students and researchers in
machine learning at departments of Computer Science, Statistics and Applied
Mathematics. As prerequisites we require a good basic grounding in calculus,
linear algebra and probability theory as would be obtained by graduates in nu-
merate disciplines such as electrical engineering, physics and computer science.
For preparation in calculus and linear algebra any good university-level text-
book on mathematics for physics or engineering such as Arfken [1985] would
be ﬁne. For probability theory some familiarity with multivariate distributions
(especially the Gaussian) and conditional probability is required. Some back-
ground mathematical material is also provided in Appendix A.

The main focus of the book is to present clearly and concisely an overview
of the main ideas of Gaussian processes in a machine learning context. We have
also covered a wide range of connections to existing models in the literature,
and cover approximate inference for faster practical algorithms. We have pre-
sented detailed algorithms for many methods to aid the practitioner. Software
implementations are available from the website for the book, see Appendix C.
We have also included a small set of exercises in each chapter; we hope these
will help in gaining a deeper understanding of the material.

In order limit the size of the volume, we have had to omit some topics, such
as, for example, Markov chain Monte Carlo methods for inference. One of the
most diﬃcult things to decide when writing a book is what sections not to write.
Within sections, we have often chosen to describe one algorithm in particular
in depth, and mention related work only in passing. Although this causes the
omission of some material, we feel it is the best approach for a monograph, and
hope that the reader will gain a general understanding so as to be able to push
further into the growing literature of GP models.

The book has a natural split into two parts, with the chapters up to and
including chapter 5 covering core material, and the remaining sections covering
the connections to other methods, fast approximations, and more specialized
properties. Some sections are marked by an asterisk. These sections may be
omitted on a ﬁrst reading, and are not pre-requisites for later (un-starred)
material.

We wish to express our considerable gratitude to the many people with
whom we have interacted during the writing of this book. In particular Moray
Allan, David Barber, Peter Bartlett, Miguel Carreira-Perpi˜n´an, Marcus Gal-
lagher, Manfred Opper, Anton Schwaighofer, Matthias Seeger, Hanna Wallach,
Joe Whittaker, and Andrew Zisserman all read parts of the book and provided
valuable feedback. Dilan G¨or¨ur, Malte Kuss, Iain Murray, Joaquin Qui˜nonero-
Candela, Leif Rasmussen and Sam Roweis were especially heroic and provided
comments on the whole manuscript. We thank Chris Bishop, Miguel Carreira-
Perpi˜n´an, Nando de Freitas, Zoubin Ghahramani, Peter Gr¨unwald, Mike Jor-
dan, John Kent, Radford Neal, Joaquin Qui˜nonero-Candela, Ryan Rifkin, Ste-
fan Schaal, Anton Schwaighofer, Matthias Seeger, Peter Sollich, Ingo Steinwart,

xv

intended audience

focus

scope

book organization

∗

acknowledgements

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

xvi

Preface

errata

looking ahead

Amos Storkey, Volker Tresp, Sethu Vijayakumar, Grace Wahba, Joe Whittaker
and Tong Zhang for valuable discussions on speciﬁc issues. We also thank Bob
Prior and the staﬀ at MIT Press for their support during the writing of the
book. We thank the Gatsby Computational Neuroscience Unit (UCL) and Neil
Lawrence at the Department of Computer Science, University of Sheﬃeld for
hosting our visits and kindly providing space for us to work, and the Depart-
ment of Computer Science at the University of Toronto for computer support.
Thanks to John and Fiona for their hospitality on numerous occasions. Some
of the diagrams in this book have been inspired by similar diagrams appearing
in published work, as follows: Figure 3.5, Sch¨olkopf and Smola [2002]; Fig-
ure 5.2, MacKay [1992b]. CER gratefully acknowledges ﬁnancial support from
the German Research Foundation (DFG). CKIW thanks the School of Infor-
matics, University of Edinburgh for granting him sabbatical leave for the period
October 2003-March 2004.

Finally, we reserve our deepest appreciation for our wives Agnes and Bar-
bara, and children Ezra, Kate, Miro and Ruth for their patience and under-
standing while the book was being written.

Despite our best eﬀorts it is inevitable that some errors will make it through
to the printed version of the book. Errata will be made available via the book’s
website at

http://www.GaussianProcess.org/gpml

We have found the joint writing of this book an excellent experience. Although
hard at times, we are conﬁdent that the end result is much better than either
one of us could have written alone.

Now, ten years after their ﬁrst introduction into the machine learning com-
munity, Gaussian processes are receiving growing attention. Although GPs
have been known for a long time in the statistics and geostatistics ﬁelds, and
their use can perhaps be traced back as far as the end of the 19th century, their
application to real problems is still in its early phases. This contrasts somewhat
the application of the non-probabilistic analogue of the GP, the support vec-
tor machine, which was taken up more quickly by practitioners. Perhaps this
has to do with the probabilistic mind-set needed to understand GPs, which is
not so generally appreciated. Perhaps it is due to the need for computational
short-cuts to implement inference for large datasets. Or it could be due to the
lack of a self-contained introduction to this exciting ﬁeld—with this volume, we
hope to contribute to the momentum gained by Gaussian processes in machine
learning.

Carl Edward Rasmussen and Chris Williams
T¨ubingen and Edinburgh, summer 2005

Second printing: We thank Baback Moghaddam, Mikhail Parakhin, Leif Ras-
mussen, Benjamin Sobotta, Kevin S. Van Horn and Aki Vehtari for reporting
errors in the ﬁrst printing which have now been corrected.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Symbols and Notation

Matrices are capitalized and vectors are in bold type. We do not generally distinguish between proba-
bilities and probability densities. A subscript asterisk, such as in X∗, indicates reference to a test set
quantity. A superscript asterisk denotes complex conjugate.

Symbol
\
,
c=
|K|
|y|
hf, giH
kfkH
y>
∝
∼
∇ or ∇f
∇∇
0 or 0n
1 or 1n
C
cholesky(A)
cov(f∗)
D
D
diag(w)
diag(W )
δpq
E or Eq(x)[z(x)]
f(x) or f
f∗
¯f∗
GP

h(x) or h(x)
H or H(X)
I or In
Jν(z)
k(x, x0)
K or K(X, X)
K∗
k(x∗) or k∗
Kf or K

(cid:1)1/2

i y2
i

Meaning
left matrix divide: A\b is the vector x which solves Ax = b
an equality which acts as a deﬁnition
equality up to an additive constant
determinant of K matrix

Euclidean length of vector y, i.e.(cid:0)P

RKHS inner product
RKHS norm
the transpose of vector y
proportional to; e.g. p(x|y) ∝ f(x, y) means that p(x|y) is equal to f(x, y) times
a factor which is independent of x
distributed according to; example: x ∼ N (µ, σ2)
partial derivatives (w.r.t. f)
the (Hessian) matrix of second derivatives
vector of all 0’s (of length n)
vector of all 1’s (of length n)
number of classes in a classiﬁcation problem
Cholesky decomposition: L is a lower triangular matrix such that LL> = A
Gaussian process posterior covariance
dimension of input space X
data set: D = {(xi, yi)|i = 1, . . . , n}
(vector argument) a diagonal matrix containing the elements of vector w
(matrix argument) a vector containing the diagonal elements of matrix W
Kronecker delta, δpq = 1 iﬀ p = q and 0 otherwise
expectation; expectation of z(x) when x ∼ q(x)
Gaussian process (or vector of) latent function values, f = (f(x1), . . . , f(xn))>
Gaussian process (posterior) prediction (random variable)
Gaussian process posterior mean
Gaussian process with mean function m(x) and covariance function k(x, x0)
either ﬁxed basis function (or set of basis functions) or weight function
set of basis functions evaluated at all training points
the identity matrix (of size n)
Bessel function of the ﬁrst kind
covariance (or kernel) function evaluated at x and x0
n × n covariance (or Gram) matrix
n × n∗ matrix K(X, X∗), the covariance between training and test cases
vector, short for K(X, x∗), when there is only a single test case
covariance matrix for the (noise free) f values

Gaussian process: f ∼ GP(cid:0)m(x), k(x, x0)(cid:1), the function f is distributed as a

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

xviii

Symbol

Ky

Kν(z)
L(a, b)
log(z)
log2(z)
‘ or ‘d
λ(z)
m(x)
µ
N (µ, Σ) or N (x|µ, Σ)
N (x)
n and n∗
N
NH
N
O(·)

O
y|x and p(y|x)
PN
φ(xi) or Φ(X)
Φ(z)
π(x)
ˆπ(x∗)
¯π(x∗)
R
RL(f) or RL(c)
˜RL(l|x∗)
Rc
S(s)
σ(z)
σ2
f
σ2
n
θ
tr(A)
Tl
V or Vq(x)[z(x)]
X
X
X∗
xi
xdi
Z

Symbols and Notation

Meaning
covariance matrix for the (noisy) y values; for independent homoscedastic noise,
Ky = Kf + σ2
nI
modiﬁed Bessel function
loss function, the loss of predicting b, when a is true; note argument order
natural logarithm (base e)
logarithm to the base 2
characteristic length-scale (for input dimension d)

logistic function, λ(z) = 1/(cid:0)1 + exp(−z)(cid:1)

the mean function of a Gaussian process
a measure (see section A.7)
(the variable x has a) Gaussian (Normal) distribution with mean vector µ and
covariance matrix Σ
short for unit Gaussian x ∼ N (0, I)
number of training (and test) cases
dimension of feature space
number of hidden units in a neural network
the natural numbers, the positive integers
big Oh; for functions f and g on N, we write f(n) = O(g(n)) if the ratio
f(n)/g(n) remains bounded as n → ∞
either matrix of all zeros or diﬀerential operator
conditional random variable y given x and its probability (density)
the regular n-polygon
feature map of input xi (or input set X)

cumulative unit Gaussian: Φ(z) = (2π)−1/2R z

−∞ exp(−t2/2)dt

the sigmoid of the latent value: π(x) = σ(f(x)) (stochastic if f(x) is stochastic)
MAP prediction: π evaluated at ¯f(x∗).
mean prediction: expected value of π(x∗). Note, in general that ˆπ(x∗) 6= ¯π(x∗)
the real numbers
the risk or expected loss for f, or classiﬁer c (averaged w.r.t. inputs and outputs)
expected loss for predicting l, averaged w.r.t. the model’s pred. distr. at x∗
decision region for class c
power spectrum
any sigmoid function, e.g. logistic λ(z), cumulative Gaussian Φ(z), etc.
variance of the (noise free) signal
noise variance
vector of hyperparameters (parameters of the covariance function)
trace of (square) matrix A
the circle with circumference l
variance; variance of z(x) when x ∼ q(x)
input space and also the index set for the stochastic process
D × n matrix of the training inputs {xi}n
matrix of test inputs
the ith training input
the dth coordinate of the ith training input xi
the integers . . . ,−2, −1, 0, 1, 2, . . .

i=1: the design matrix

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 1

Introduction

In this book we will be concerned with supervised learning, which is the problem
of learning input-output mappings from empirical data (the training dataset).
Depending on the characteristics of the output, this problem is known as either
regression, for continuous outputs, or classiﬁcation, when outputs are discrete.
A well known example is the classiﬁcation of images of handwritten digits.
The training set consists of small digitized images, together with a classiﬁcation
from 0, . . . , 9, normally provided by a human. The goal is to learn a mapping
from image to classiﬁcation label, which can then be used on new, unseen
images. Supervised learning is an attractive way to attempt to tackle this
problem, since it is not easy to specify accurately the characteristics of, say, the
handwritten digit 4.

An example of a regression problem can be found in robotics, where we wish
to learn the inverse dynamics of a robot arm. Here the task is to map from
the state of the arm (given by the positions, velocities and accelerations of the
joints) to the corresponding torques on the joints. Such a model can then be
used to compute the torques needed to move the arm along a given trajectory.
Another example would be in a chemical plant, where we might wish to predict
the yield as a function of process parameters such as temperature, pressure,
amount of catalyst etc.

In general we denote the input as x, and the output (or target) as y. The
input is usually represented as a vector x as there are in general many input
variables—in the handwritten digit recognition example one may have a 256-
dimensional input obtained from a raster scan of a 16 × 16 image, and in the
robot arm example there are three input measurements for each joint in the
arm. The target y may either be continuous (as in the regression case) or
discrete (as in the classiﬁcation case). We have a dataset D of n observations,
D = {(xi, yi)|i = 1, . . . , n}.

Given this training data we wish to make predictions for new inputs x∗
that we have not seen in the training set. Thus it is clear that the problem
at hand is inductive; we need to move from the ﬁnite training data D to a

digit classiﬁcation

robotic control

the dataset

training is inductive

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2

Introduction

two approaches

Gaussian process

consistency

tractability

function f that makes predictions for all possible input values. To do this we
must make assumptions about the characteristics of the underlying function,
as otherwise any function which is consistent with the training data would be
equally valid. A wide variety of methods have been proposed to deal with the
supervised learning problem; here we describe two common approaches. The
ﬁrst is to restrict the class of functions that we consider, for example by only
considering linear functions of the input. The second approach is (speaking
rather loosely) to give a prior probability to every possible function, where
higher probabilities are given to functions that we consider to be more likely, for
example because they are smoother than other functions.1 The ﬁrst approach
has an obvious problem in that we have to decide upon the richness of the class
of functions considered; if we are using a model based on a certain class of
functions (e.g. linear functions) and the target function is not well modelled by
this class, then the predictions will be poor. One may be tempted to increase the
ﬂexibility of the class of functions, but this runs into the danger of overﬁtting,
where we can obtain a good ﬁt to the training data, but perform badly when
making test predictions.

The second approach appears to have a serious problem, in that surely
there are an uncountably inﬁnite set of possible functions, and how are we
going to compute with this set in ﬁnite time? This is where the Gaussian
process comes to our rescue. A Gaussian process is a generalization of the
Gaussian probability distribution. Whereas a probability distribution describes
random variables which are scalars or vectors (for multivariate distributions),
a stochastic process governs the properties of functions. Leaving mathematical
sophistication aside, one can loosely think of a function as a very long vector,
each entry in the vector specifying the function value f(x) at a particular input
x. It turns out, that although this idea is a little na¨ıve, it is surprisingly close
what we need. Indeed, the question of how we deal computationally with these
inﬁnite dimensional objects has the most pleasant resolution imaginable: if you
ask only for the properties of the function at a ﬁnite number of points, then
inference in the Gaussian process will give you the same answer if you ignore the
inﬁnitely many other points, as if you would have taken them all into account!
And these answers are consistent with answers to any other ﬁnite queries you
may have. One of the main attractions of the Gaussian process framework is
precisely that it unites a sophisticated and consistent view with computational
tractability.

It should come as no surprise that these ideas have been around for some
time, although they are perhaps not as well known as they might be. Indeed,
many models that are commonly employed in both machine learning and statis-
tics are in fact special cases of, or restricted kinds of Gaussian processes. In this
volume, we aim to give a systematic and uniﬁed treatment of the area, showing
connections to related models.

1These two approaches may be regarded as imposing a restriction bias and a preference

bias respectively; see e.g. Mitchell [1997].

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

1.1 A Pictorial Introduction to Bayesian Modelling

3

(a), prior

(b), posterior

Figure 1.1: Panel (a) shows four samples drawn from the prior distribution. Panel
(b) shows the situation after two datapoints have been observed. The mean prediction
is shown as the solid line and four samples from the posterior are shown as dashed
lines. In both plots the shaded region denotes twice the standard deviation at each
input value x.

1.1 A Pictorial Introduction to Bayesian Mod-

elling

In this section we give graphical illustrations of how the second (Bayesian)
method works on some simple regression and classiﬁcation examples.

We ﬁrst consider a simple 1-d regression problem, mapping from an input
x to an output f(x). In Figure 1.1(a) we show a number of sample functions
drawn at random from the prior distribution over functions speciﬁed by a par-
ticular Gaussian process which favours smooth functions. This prior is taken
to represent our prior beliefs over the kinds of functions we expect to observe,
before seeing any data. In the absence of knowledge to the contrary we have
assumed that the average value over the sample functions at each x is zero.
Although the speciﬁc random functions drawn in Figure 1.1(a) do not have a
mean of zero, the mean of f(x) values for any ﬁxed x would become zero, in-
dependent of x as we kept on drawing more functions. At any value of x we
can also characterize the variability of the sample functions by computing the
variance at that point. The shaded region denotes twice the pointwise standard
deviation; in this case we used a Gaussian process which speciﬁes that the prior
variance does not depend on x.

Suppose that we are then given a dataset D = {(x1, y1), (x2, y2)} consist-
ing of two observations, and we wish now to only consider functions that pass
though these two data points exactly. (It is also possible to give higher pref-
erence to functions that merely pass “close” to the datapoints.) This situation
is illustrated in Figure 1.1(b). The dashed lines show sample functions which
are consistent with D, and the solid line depicts the mean value of such func-
tions. Notice how the uncertainty is reduced close to the observations. The
combination of the prior and the data leads to the posterior distribution over
functions.

regression

random functions

mean function

pointwise variance

functions that agree
with observations

posterior over functions

00.51−2−1012input, xf(x)00.51−2−1012input, xf(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4

non-parametric

inference

prior speciﬁcation

covariance function

modelling and
interpreting

classiﬁcation

squashing function

Introduction

If more datapoints were added one would see the mean function adjust itself
to pass through these points, and that the posterior uncertainty would reduce
close to the observations. Notice, that since the Gaussian process is not a
parametric model, we do not have to worry about whether it is possible for the
model to ﬁt the data (as would be the case if e.g. you tried a linear model on
strongly non-linear data). Even when a lot of observations have been added,
there may still be some ﬂexibility left in the functions. One way to imagine the
reduction of ﬂexibility in the distribution of functions as the data arrives is to
draw many random functions from the prior, and reject the ones which do not
agree with the observations. While this is a perfectly valid way to do inference,
it is impractical for most purposes—the exact analytical computations required
to quantify these properties will be detailed in the next chapter.

The speciﬁcation of the prior is important, because it ﬁxes the properties of
the functions considered for inference. Above we brieﬂy touched on the mean
and pointwise variance of the functions. However, other characteristics can also
be speciﬁed and manipulated. Note that the functions in Figure 1.1(a) are
smooth and stationary (informally, stationarity means that the functions look
similar at all x locations). These are properties which are induced by the co-
variance function of the Gaussian process; many other covariance functions are
possible. Suppose, that for a particular application, we think that the functions
in Figure 1.1(a) vary too rapidly (i.e. that their characteristic length-scale is
too short). Slower variation is achieved by simply adjusting parameters of the
covariance function. The problem of learning in Gaussian processes is exactly
the problem of ﬁnding suitable properties for the covariance function. Note,
that this gives us a model of the data, and characteristics (such a smoothness,
characteristic length-scale, etc.) which we can interpret.

We now turn to the classiﬁcation case, and consider the binary (or two-
class) classiﬁcation problem. An example of this is classifying objects detected
in astronomical sky surveys into stars or galaxies. Our data has the label +1 for
stars and −1 for galaxies, and our task will be to predict π(x), the probability
that an example with input vector x is a star, using as inputs some features
that describe each object. Obviously π(x) should lie in the interval [0, 1]. A
Gaussian process prior over functions does not restrict the output to lie in this
interval, as can be seen from Figure 1.1(a). The approach that we shall adopt
is to squash the prior function f pointwise through a response function which
restricts the output to lie in [0, 1]. A common choice for this function is the
logistic function λ(z) = (1 + exp(−z))−1, illustrated in Figure 1.2(b). Thus the
prior over f induces a prior over probabilistic classiﬁcations π.

This set up is illustrated in Figure 1.2 for a 2-d input space.

In panel
(a) we see a sample drawn from the prior over functions f which is squashed
through the logistic function (panel (b)). A dataset is shown in panel (c), where
the white and black circles denote classes +1 and −1 respectively. As in the
regression case the eﬀect of the data is to downweight in the posterior those
functions that are incompatible with the data. A contour plot of the posterior
mean for π(x) is shown in panel (d). In this example we have chosen a short
characteristic length-scale for the process so that it can vary fairly rapidly; in

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

1.2 Roadmap

5

(a)

(b)

(c)

(d)

Figure 1.2: Panel (a) shows a sample from prior distribution on f in a 2-d input
space. Panel (b) is a plot of the logistic function λ(z). Panel (c) shows the location
of the data points, where the open circles denote the class label +1, and closed circles
denote the class label −1. Panel (d) shows a contour plot of the mean predictive
probability as a function of x; the decision boundaries between the two classes are
shown by the thicker lines.

this case notice that all of the training points are correctly classiﬁed, including
the two “outliers” in the NE and SW corners. By choosing a diﬀerent length-
scale we can change this behaviour, as illustrated in section 3.7.1.

1.2 Roadmap

The book has a natural split into two parts, with the chapters up to and includ-
ing chapter 5 covering core material, and the remaining chapters covering the
connections to other methods, fast approximations, and more specialized prop-
erties. Some sections are marked by an asterisk. These sections may be omitted
on a ﬁrst reading, and are not pre-requisites for later (un-starred) material.

−50501logistic function(cid:176)(cid:176)(cid:176)•(cid:176)(cid:176)(cid:176)(cid:176)(cid:176)•(cid:176)••••••(cid:176)••0.250.50.50.50.750.25C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6

regression

classiﬁcation

covariance functions

learning

connections

theory

fast approximations

Introduction

Chapter 2 contains the deﬁnition of Gaussian processes, in particular for the
use in regression. It also discusses the computations needed to make predic-
tions for regression. Under the assumption of Gaussian observation noise the
computations needed to make predictions are tractable and are dominated by
the inversion of a n × n matrix. In a short experimental section, the Gaussian
process model is applied to a robotics task.

Chapter 3 considers the classiﬁcation problem for both binary and multi-
class cases. The use of a non-linear response function means that exact compu-
tation of the predictions is no longer possible analytically. We discuss a number
of approximation schemes, include detailed algorithms for their implementation
and discuss some experimental comparisons.

As discussed above, the key factor that controls the properties of a Gaussian
process is the covariance function. Much of the work on machine learning so far,
has used a very limited set of covariance functions, possibly limiting the power
of the resulting models. In chapter 4 we discuss a number of valid covariance
functions and their properties and provide some guidelines on how to combine
covariance functions into new ones, tailored to speciﬁc needs.

Many covariance functions have adjustable parameters, such as the char-
acteristic length-scale and variance illustrated in Figure 1.1. Chapter 5 de-
scribes how such parameters can be inferred or learned from the data, based on
either Bayesian methods (using the marginal likelihood) or methods of cross-
validation. Explicit algorithms are provided for some schemes, and some simple
practical examples are demonstrated.

Gaussian process predictors are an example of a class of methods known as
kernel machines; they are distinguished by the probabilistic viewpoint taken.
In chapter 6 we discuss other kernel machines such as support vector machines
(SVMs), splines, least-squares classiﬁers and relevance vector machines (RVMs),
and their relationships to Gaussian process prediction.

In chapter 7 we discuss a number of more theoretical issues relating to
Gaussian process methods including asymptotic analysis, average-case learning
curves and the PAC-Bayesian framework.

One issue with Gaussian process prediction methods is that their basic com-
plexity is O(n3), due to the inversion of a n×n matrix. For large datasets this is
prohibitive (in both time and space) and so a number of approximation methods
have been developed, as described in chapter 8.

The main focus of the book is on the core supervised learning problems of
regression and classiﬁcation.
In chapter 9 we discuss some rather less standard
settings that GPs have been used in, and complete the main part of the book
with some conclusions.

Appendix A gives some mathematical background, while Appendix B deals
speciﬁcally with Gaussian Markov processes. Appendix C gives details of how
to access the data and programs that were used to make the some of the ﬁgures
and run the experiments described in the book.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 2

Regression

Supervised learning can be divided into regression and classiﬁcation problems.
Whereas the outputs for classiﬁcation are discrete class labels, regression is
concerned with the prediction of continuous quantities. For example, in a ﬁ-
nancial application, one may attempt to predict the price of a commodity as
a function of interest rates, currency exchange rates, availability and demand.
In this chapter we describe Gaussian process methods for regression problems;
classiﬁcation problems are discussed in chapter 3.

There are several ways to interpret Gaussian process (GP) regression models.
One can think of a Gaussian process as deﬁning a distribution over functions,
and inference taking place directly in the space of functions, the function-space
view. Although this view is appealing it may initially be diﬃcult to grasp,
so we start our exposition in section 2.1 with the equivalent weight-space view
which may be more familiar and accessible to many, and continue in section
2.2 with the function-space view. Gaussian processes often have characteristics
that can be changed by setting certain parameters and in section 2.3 we discuss
how the properties change as these parameters are varied. The predictions
from a GP model take the form of a full predictive distribution; in section 2.4
we discuss how to combine a loss function with the predictive distributions
using decision theory to make point predictions in an optimal way. A practical
comparative example involving the learning of the inverse dynamics of a robot
arm is presented in section 2.5. We give some theoretical analysis of Gaussian
process regression in section 2.6, and discuss how to incorporate explicit basis
functions into the models in section 2.7. As much of the material in this chapter
can be considered fairly standard, we postpone most references to the historical
overview in section 2.8.

2.1 Weight-space View

The simple linear regression model where the output is a linear combination of
the inputs has been studied and used extensively. Its main virtues are simplic-

two equivalent views

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8

Regression

ity of implementation and interpretability. Its main drawback is that it only
allows a limited ﬂexibility; if the relationship between input and output can-
not reasonably be approximated by a linear function, the model will give poor
predictions.

In this section we ﬁrst discuss the Bayesian treatment of the linear model.
We then make a simple enhancement to this class of models by projecting the
inputs into a high-dimensional feature space and applying the linear model
there. We show that in some feature spaces one can apply the “kernel trick” to
carry out computations implicitly in the high dimensional space; this last step
leads to computational savings when the dimensionality of the feature space is
large compared to the number of data points.

We have a training set D of n observations, D = {(xi, yi) | i = 1, . . . , n},
where x denotes an input vector (covariates) of dimension D and y denotes
a scalar output or target (dependent variable); the column vector inputs for
all n cases are aggregated in the D × n design matrix 1 X, and the targets
are collected in the vector y, so we can write D = (X, y). In the regression
setting the targets are real values. We are interested in making inferences about
the relationship between inputs and targets, i.e. the conditional distribution of
the targets given the inputs (but we are not interested in modelling the input
distribution itself).

2.1.1 The Standard Linear Model

We will review the Bayesian analysis of the standard linear regression model
with Gaussian noise

f(x) = x>w,

y = f(x) + ε,

(2.1)

where x is the input vector, w is a vector of weights (parameters) of the linear
model, f is the function value and y is the observed target value. Often a bias
weight or oﬀset is included, but as this can be implemented by augmenting the
input vector x with an additional element whose value is always one, we do not
explicitly include it in our notation. We have assumed that the observed values
y diﬀer from the function values f(x) by additive noise, and we will further
assume that this noise follows an independent, identically distributed Gaussian
distribution with zero mean and variance σ2
n
ε ∼ N (0, σ2
n).

(2.2)

training set

design matrix

bias, oﬀset

likelihood

This noise assumption together with the model directly gives rise to the likeli-
hood, the probability density of the observations given the parameters, which is

1In statistics texts the design matrix is usually taken to be the transpose of our deﬁnition,
but our choice is deliberate and has the advantage that a data point is a standard (column)
vector.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.1 Weight-space View

factored over cases in the training set (because of the independence assumption)
to give

nY

i=1

p(y|X, w) =

=

p(yi|xi, w) =

nY
exp(cid:0) − 1

i=1

1√
2πσn

exp(cid:0)− (yi − x>

(cid:1)
|y − X>w|2(cid:1) = N (X>w, σ2

i w)2

2σ2
n

1
(2πσ2
n)n/2

2σ2
n

(2.3)

nI),

where |z| denotes the Euclidean length of vector z. In the Bayesian formalism
we need to specify a prior over the parameters, expressing our beliefs about the
parameters before we look at the observations. We put a zero mean Gaussian
prior with covariance matrix Σp on the weights
w ∼ N (0, Σp).

(2.4)

The rˆole and properties of this prior will be discussed in section 2.2; for now
we will continue the derivation with the prior as speciﬁed.

Inference in the Bayesian linear model is based on the posterior distribution

over the weights, computed by Bayes’ rule, (see eq. (A.3))2

posterior =

likelihood × prior
marginal likelihood ,

p(w|y, X) = p(y|X, w)p(w)

p(y|X)

,

(2.5)

where the normalizing constant, also known as the marginal likelihood (see page
19), is independent of the weights and given by

p(y|X) =

p(y|X, w)p(w) dw.

(2.6)

Z

9

prior

posterior

marginal likelihood

The posterior in eq. (2.5) combines the likelihood and the prior, and captures
everything we know about the parameters. Writing only the terms from the
likelihood and prior which depend on the weights, and “completing the square”
we obtain

p(w|X, y) ∝ exp(cid:0)− 1
∝ exp(cid:0)− 1

(y − X>w)>(y − X>w)(cid:1) exp(cid:0)− 1
(cid:1)(w − ¯w)(cid:1),
(w − ¯w)>(cid:0) 1

XX> + Σ−1

p w(cid:1)

w>Σ−1

(2.7)

2σ2
n

2

p

2

σ2
n

where ¯w = σ−2
posterior distribution as Gaussian with mean ¯w and covariance matrix A−1

p )−1Xy, and we recognize the form of the

n XX> + Σ−1

n (σ−2

p(w|X, y) ∼ N ( ¯w =

A−1Xy, A−1),

1
σ2
n

(2.8)

n XX> + Σ−1

where A = σ−2
p . Notice that for this model (and indeed for any
Gaussian posterior) the mean of the posterior distribution p(w|y, X) is also
its mode, which is also called the maximum a posteriori (MAP) estimate of
2Often Bayes’ rule is stated as p(a|b) = p(b|a)p(a)/p(b); here we use it in a form where we
additionally condition everywhere on the inputs X (but neglect this extra conditioning for
the prior which is independent of the inputs).

MAP estimate

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

10

Regression

(a)

(b)

(c)

(d)

Figure 2.1: Example of Bayesian linear model f (x) = w1 + w2x with intercept
w1 and slope parameter w2. Panel (a) shows the contours of the prior distribution
p(w) ∼ N (0, I), eq. (2.4). Panel (b) shows three training points marked by crosses.
Panel (c) shows contours of the likelihood p(y|X, w) eq. (2.3), assuming a noise level of
σn = 1; note that the slope is much more “well determined” than the intercept. Panel
(d) shows the posterior, p(w|X, y) eq. (2.7); comparing the maximum of the posterior
to the likelihood, we see that the intercept has been shrunk towards zero whereas the
more ’well determined’ slope is almost unchanged. All contour plots give the 1 and
2 standard deviation equi-probability contours. Superimposed on the data in panel
(b) are the predictive mean plus/minus two standard deviations of the (noise-free)
predictive distribution p(f∗|x∗, X, y), eq. (2.9).

w. In a non-Bayesian setting the negative log prior is sometimes thought of
as a penalty term, and the MAP point is known as the penalized maximum
likelihood estimate of the weights, and this may cause some confusion between
the two approaches. Note, however, that in the Bayesian setting the MAP
estimate plays no special rˆole.3 The penalized maximum likelihood procedure

3In this case, due to symmetries in the model and posterior, it happens that the mean
of the predictive distribution is the same as the prediction at the mean of the posterior.
However, this is not the case in general.

intercept, w1slope, w2−2−1012−2−1012−505−505input, xoutput, yintercept, w1slope, w2−2−1012−2−1012intercept, w1slope, w2−2−1012−2−1012C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

11

ridge regression

predictive distribution

feature space

polynomial regression

linear in the parameters

2.1 Weight-space View

is known in this case as ridge regression [Hoerl and Kennard, 1970] because of
the eﬀect of the quadratic penalty term 1

p w from the log prior.

2 w>Σ−1

To make predictions for a test case we average over all possible parameter
values, weighted by their posterior probability. This is in contrast to non-
Bayesian schemes, where a single parameter is typically chosen by some crite-
rion. Thus the predictive distribution for f∗ , f(x∗) at x∗ is given by averaging
the output of all possible linear models w.r.t. the Gaussian posterior

p(f∗|x∗, X, y) =

p(f∗|x∗, w)p(w|X, y) dw

(2.9)

Z
= N(cid:0) 1

σ2
n

∗ A−1x∗(cid:1).

∗ A−1Xy, x>
x>

The predictive distribution is again Gaussian, with a mean given by the poste-
rior mean of the weights from eq. (2.8) multiplied by the test input, as one would
expect from symmetry considerations. The predictive variance is a quadratic
form of the test input with the posterior covariance matrix, showing that the
predictive uncertainties grow with the magnitude of the test input, as one would
expect for a linear model.

An example of Bayesian linear regression is given in Figure 2.1. Here we
have chosen a 1-d input space so that the weight-space is two-dimensional and
can be easily visualized. Contours of the Gaussian prior are shown in panel (a).
The data are depicted as crosses in panel (b). This gives rise to the likelihood
shown in panel (c) and the posterior distribution in panel (d). The predictive
distribution and its error bars are also marked in panel (b).

2.1.2 Projections of Inputs into Feature Space

In the previous section we reviewed the Bayesian linear model which suﬀers
from limited expressiveness. A very simple idea to overcome this problem is to
ﬁrst project the inputs into some high dimensional space using a set of basis
functions and then apply the linear model in this space instead of directly on
the inputs themselves. For example, a scalar input x could be projected into
the space of powers of x: φ(x) = (1, x, x2, x3, . . .)> to implement polynomial
regression. As long as the projections are ﬁxed functions (i.e. independent of
the parameters w) the model is still linear in the parameters, and therefore
analytically tractable.4 This idea is also used in classiﬁcation, where a dataset
which is not linearly separable in the original data space may become linearly
separable in a high dimensional feature space, see section 3.3. Application of
this idea begs the question of how to choose the basis functions? As we shall
demonstrate (in chapter 5), the Gaussian process formalism allows us to answer
this question. For now, we assume that the basis functions are given.

Speciﬁcally, we introduce the function φ(x) which maps a D-dimensional
input vector x into an N dimensional feature space. Further let the matrix

4Models with adaptive basis functions, such as e.g. multilayer perceptrons, may at ﬁrst
seem like a useful extension, but they are much harder to treat, except in the limit of an
inﬁnite number of hidden units, see section 4.2.3.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

12

Regression

explicit feature space
formulation

alternative formulation

computational load

kernel

kernel trick

Φ(X) be the aggregation of columns φ(x) for all cases in the training set. Now
the model is

(2.10)
where the vector of parameters now has length N. The analysis for this model
is analogous to the standard linear model, except that everywhere Φ(X) is
substituted for X. Thus the predictive distribution becomes

f(x) = φ(x)>w,

f∗|x∗, X, y ∼ N(cid:0) 1

φ(x∗)>A−1Φy, φ(x∗)>A−1φ(x∗)(cid:1)

(2.11)

σ2
n

with Φ = Φ(X) and A = σ−2
p . To make predictions using this
equation we need to invert the A matrix of size N × N which may not be
convenient if N, the dimension of the feature space, is large. However, we can
rewrite the equation in the following way

n ΦΦ> + Σ−1

f∗|x∗, X, y ∼ N(cid:0)φ

>
nI)−1y,
∗ ΣpΦ(K + σ2
∗ Σpφ∗ − φ
>
>
∗ ΣpΦ(K + σ2

φ

nI)−1Φ>Σpφ∗(cid:1),

(2.12)

nI) = σ−2

n Φ(Φ>ΣpΦ + σ2

where we have used the shorthand φ(x∗) = φ∗ and deﬁned K = Φ>ΣpΦ.
To show this for the mean, ﬁrst note that using the deﬁnitions of A and K
we have σ−2
n Φ(K + σ2
nI) = AΣpΦ. Now multiplying
through by A−1 from left and (K + σ2
n A−1Φ =
nI)−1, showing the equivalence of the mean expressions in eq. (2.11)
ΣpΦ(K + σ2
and eq. (2.12). For the variance we use the matrix inversion lemma, eq. (A.9),
setting Z−1 = Σp, W −1 = σ2
In eq. (2.12) we
need to invert matrices of size n × n which is more convenient when n < N.
Geometrically, note that n datapoints can span at most n dimensions in the
feature space.

nI)−1 from the right gives σ−2

nI and V = U = Φ therein.

>
∗ ΣpΦ, or φ

Notice that in eq. (2.12) the feature space always enters in the form of
>
Φ>ΣpΦ, φ
∗ Σpφ∗; thus the entries of these matrices are invariably of
the form φ(x)>Σpφ(x0) where x and x0 are in either the training or the test sets.
Let us deﬁne k(x, x0) = φ(x)>Σpφ(x0). For reasons that will become clear later
we call k(·,·) a covariance function or kernel. Notice that φ(x)>Σpφ(x0) is an
inner product (with respect to Σp). As Σp is positive deﬁnite we can deﬁne Σ1/2
so that (Σ1/2
)2 = Σp; for example if the SVD (singular value decomposition)
of Σp = U DU>, where D is diagonal, then one form for Σ1/2
is U D1/2U>.
Then deﬁning ψ(x) = Σ1/2
p φ(x) we obtain a simple dot product representation
k(x, x0) = ψ(x) · ψ(x0).

p

p

p

If an algorithm is deﬁned solely in terms of inner products in input space
then it can be lifted into feature space by replacing occurrences of those inner
products by k(x, x0); this is sometimes called the kernel trick. This technique is
particularly valuable in situations where it is more convenient to compute the
kernel than the feature vectors themselves. As we will see in the coming sections,
this often leads to considering the kernel as the object of primary interest, and
its corresponding feature space as having secondary practical importance.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.2 Function-space View

13

2.2 Function-space View

An alternative and equivalent way of reaching identical results to the previous
section is possible by considering inference directly in function space. We use
a Gaussian process (GP) to describe a distribution over functions. Formally:

Deﬁnition 2.1 A Gaussian process is a collection of random variables, any
(cid:3)
ﬁnite number of which have a joint Gaussian distribution.

Gaussian process

A Gaussian process is completely speciﬁed by its mean function and co-
variance function. We deﬁne mean function m(x) and the covariance function
k(x, x0) of a real process f(x) as

covariance and
mean function

m(x) = E[f(x)],

k(x, x0) = E[(f(x) − m(x))(f(x0) − m(x0))],

and will write the Gaussian process as

f(x) ∼ GP(cid:0)m(x), k(x, x0)(cid:1).

(2.13)

(2.14)

Usually, for notational simplicity we will take the mean function to be zero,
although this need not be done, see section 2.7.

In our case the random variables represent the value of the function f(x)
at location x. Often, Gaussian processes are deﬁned over time, i.e. where the
index set of the random variables is time. This is not (normally) the case in
our use of GPs; here the index set X is the set of possible inputs, which could
be more general, e.g. RD. For notational convenience we use the (arbitrary)
enumeration of the cases in the training set to identify the random variables
such that fi , f(xi) is the random variable corresponding to the case (xi, yi)
as would be expected.

A Gaussian process is deﬁned as a collection of random variables. Thus, the
deﬁnition automatically implies a consistency requirement, which is also some-
times known as the marginalization property. This property simply means
that if the GP e.g. speciﬁes (y1, y2) ∼ N (µ, Σ), then it must also specify
y1 ∼ N (µ1, Σ11) where Σ11 is the relevant submatrix of Σ, see eq. (A.6).
In other words, examination of a larger set of variables does not change the
distribution of the smaller set. Notice that the consistency requirement is au-
tomatically fulﬁlled if the covariance function speciﬁes entries of the covariance
matrix.5 The deﬁnition does not exclude Gaussian processes with ﬁnite index
sets (which would be simply Gaussian distributions), but these are not partic-
ularly interesting for our purposes.

5Note, however, that if you instead speciﬁed e.g. a function for the entries of the inverse
covariance matrix, then the marginalization property would no longer be fulﬁlled, and one
could not think of this as a consistent collection of random variables—this would not qualify
as a Gaussian process.

index set ≡
input domain

marginalization
property

ﬁnite index set

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

14

Bayesian linear model
is a Gaussian process

basis functions

smoothness

characteristic
length-scale

Regression

A simple example of a Gaussian process can be obtained from our Bayesian
linear regression model f(x) = φ(x)>w with prior w ∼ N (0, Σp). We have for
the mean and covariance

E[f(x)] = φ(x)>E[w] = 0,

E[f(x)f(x0)] = φ(x)>E[ww>]φ(x0) = φ(x)>Σpφ(x0).

(2.15)

Thus f(x) and f(x0) are jointly Gaussian with zero mean and covariance given
by φ(x)>Σpφ(x0). Indeed, the function values f(x1), . . . , f(xn) corresponding
to any number of input points n are jointly Gaussian, although if N < n then
this Gaussian is singular (as the joint covariance matrix will be of rank N).

In this chapter our running example of a covariance function will be the
squared exponential 6 (SE) covariance function; other covariance functions are
discussed in chapter 4. The covariance function speciﬁes the covariance between
pairs of random variables

cov(cid:0)f(xp), f(xq)(cid:1) = k(xp, xq) = exp(cid:0)− 1

2|xp − xq|2(cid:1).

(2.16)

Note, that the covariance between the outputs is written as a function of the
inputs. For this particular covariance function, we see that the covariance is
almost unity between variables whose corresponding inputs are very close, and
decreases as their distance in the input space increases.

It can be shown (see section 4.3.1) that the squared exponential covariance
function corresponds to a Bayesian linear regression model with an inﬁnite
number of basis functions. Indeed for every positive deﬁnite covariance function
k(·,·), there exists a (possibly inﬁnite) expansion in terms of basis functions
(see Mercer’s theorem in section 4.3). We can also obtain the SE covariance
function from the linear combination of an inﬁnite number of Gaussian-shaped
basis functions, see eq. (4.13) and eq. (4.30).

The speciﬁcation of the covariance function implies a distribution over func-
tions. To see this, we can draw samples from the distribution of functions evalu-
ated at any number of points; in detail, we choose a number of input points,7 X∗
and write out the corresponding covariance matrix using eq. (2.16) elementwise.
Then we generate a random Gaussian vector with this covariance matrix

f∗ ∼ N(cid:0)0, K(X∗, X∗)(cid:1),

(2.17)

and plot the generated values as a function of the inputs. Figure 2.2(a) shows
three such samples. The generation of multivariate Gaussian samples is de-
scribed in section A.2.

In the example in Figure 2.2 the input values were equidistant, but this
need not be the case. Notice that “informally” the functions look smooth.
In fact the squared exponential covariance function is inﬁnitely diﬀerentiable,
leading to the process being inﬁnitely mean-square diﬀerentiable (see section
4.1). We also see that the functions seem to have a characteristic length-scale,

6Sometimes this covariance function is called the Radial Basis Function (RBF) or Gaussian;

here we prefer squared exponential.

7Technically, these input points play the rˆole of test inputs and therefore carry a subscript

asterisk; this will become clearer later when both training and test points are involved.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.2 Function-space View

15

(a), prior

(b), posterior

Figure 2.2: Panel (a) shows three functions drawn at random from a GP prior;
the dots indicate values of y actually generated; the two other functions have (less
correctly) been drawn as lines by joining a large number of evaluated points. Panel (b)
shows three random functions drawn from the posterior, i.e. the prior conditioned on
the ﬁve noise free observations indicated. In both plots the shaded area represents the
pointwise mean plus and minus two times the standard deviation for each input value
(corresponding to the 95% conﬁdence region), for the prior and posterior respectively.

which informally can be thought of as roughly the distance you have to move in
input space before the function value can change signiﬁcantly, see section 4.2.1.
For eq. (2.16) the characteristic length-scale is around one unit. By replacing
|xp−xq| by |xp−xq|/‘ in eq. (2.16) for some positive constant ‘ we could change
the characteristic length-scale of the process. Also, the overall variance of the
random function can be controlled by a positive pre-factor before the exp in
eq. (2.16). We will discuss more about how such factors aﬀect the predictions
in section 2.3, and say more about how to set such scale parameters in chapter
5.

Prediction with Noise-free Observations

We are usually not primarily interested in drawing random functions from the
prior, but want to incorporate the knowledge that the training data provides
about the function. Initially, we will consider the simple special case where the
observations are noise free, that is we know {(xi, fi)|i = 1, . . . , n}. The joint
distribution of the training outputs, f, and the test outputs f∗ according to the
prior is

(cid:20) K(X, X) K(X, X∗)

(cid:20) f

(cid:21)(cid:19)

.

(2.18)

K(X∗, X) K(X∗, X∗)

(cid:21)

f∗

(cid:18)

∼ N

0,

magnitude

joint prior

If there are n training points and n∗ test points then K(X, X∗) denotes the
n × n∗ matrix of the covariances evaluated at all pairs of training and test
points, and similarly for the other entries K(X, X), K(X∗, X∗) and K(X∗, X).
To get the posterior distribution over functions we need to restrict this joint
prior distribution to contain only those functions which agree with the observed
data points. Graphically in Figure 2.2 you may think of generating functions
from the prior, and rejecting the ones that disagree with the observations, al-

graphical rejection

−505−2−1012input, xoutput, f(x)−505−2−1012input, xoutput, f(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

16

Regression

noise-free predictive
distribution

predictive distribution

though this strategy would not be computationally very eﬃcient. Fortunately,
in probabilistic terms this operation is extremely simple, corresponding to con-
ditioning the joint Gaussian prior distribution on the observations (see section
A.2 for further details) to give

f∗|X∗, X, f ∼ N(cid:0)K(X∗, X)K(X, X)−1f ,

K(X∗, X∗) − K(X∗, X)K(X, X)−1K(X, X∗)(cid:1).

(2.19)

Function values f∗ (corresponding to test inputs X∗) can be sampled from the
joint posterior distribution by evaluating the mean and covariance matrix from
eq. (2.19) and generating samples according to the method described in section
A.2.

Figure 2.2(b) shows the results of these computations given the ﬁve data-
points marked with + symbols. Notice that it is trivial to extend these compu-
tations to multidimensional inputs – one simply needs to change the evaluation
of the covariance function in accordance with eq. (2.16), although the resulting
functions may be harder to display graphically.

Prediction using Noisy Observations

It is typical for more realistic modelling situations that we do not have access
to function values themselves, but only noisy versions thereof y = f(x) + ε.8
Assuming additive independent identically distributed Gaussian noise ε with
variance σ2

n, the prior on the noisy observations becomes

cov(yp, yq) = k(xp, xq) + σ2

nδpq or cov(y) = K(X, X) + σ2

nI,

(2.20)

where δpq is a Kronecker delta which is one iﬀ p = q and zero otherwise. It
follows from the independence9 assumption about the noise, that a diagonal
matrix10 is added, in comparison to the noise free case, eq. (2.16). Introducing
the noise term in eq. (2.18) we can write the joint distribution of the observed
target values and the function values at the test locations under the prior as

(cid:21)

(cid:20) y

f∗

(cid:18)

(cid:20) K(X, X) + σ2

K(X∗, X)

∼ N

0,

(cid:21)(cid:19)

nI K(X, X∗)
K(X∗, X∗)

.

(2.21)

Deriving the conditional distribution corresponding to eq. (2.19) we arrive at
the key predictive equations for Gaussian process regression

f∗|X, y, X∗ ∼ N(cid:0)¯f∗, cov(f∗)(cid:1), where

¯f∗ , E[f∗|X, y, X∗] = K(X∗, X)[K(X, X) + σ2

cov(f∗) = K(X∗, X∗) − K(X∗, X)[K(X, X) + σ2

nI(cid:3)−1

nI]−1y,
K(X, X∗).

(2.22)
(2.23)
(2.24)

8There are some situations where it is reasonable to assume that the observations are

noise-free, for example for computer simulations, see e.g. Sacks et al. [1989].

9More complicated noise models with non-trivial covariance structure can also be handled,

see section 9.2.

10Notice that the Kronecker delta is on the index of the cases, not the value of the input;
for the signal part of the covariance function the input value is the index set to the random
variables describing the function, for the noise part it is the identity of the point.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.2 Function-space View



f1 

f∗
6 6 6 6

y1
6 6

y∗
6

Observations

Gaussian ﬁeld

yc
6


fc 

6 6 6

17

correspondence with
weight-space view

compact notation

predictive distribution

linear predictor

Inputs

x1

x2

x∗

xc

Figure 2.3: Graphical model (chain graph) for a GP for regression. Squares rep-
resent observed variables and circles represent unknowns. The thick horizontal bar
represents a set of fully connected nodes. Note that an observation yi is conditionally
independent of all other nodes given the corresponding latent variable, fi. Because of
the marginalization property of GPs addition of further inputs, x, latent variables, f ,
and unobserved targets, y∗, does not change the distribution of any other variables.

Notice that we now have exact correspondence with the weight space view in
eq. (2.12) when identifying K(C, D) = Φ(C)>ΣpΦ(D), where C, D stand for ei-
ther X or X∗. For any set of basis functions, we can compute the corresponding
covariance function as k(xp, xq) = φ(xp)>Σpφ(xq); conversely, for every (posi-
tive deﬁnite) covariance function k, there exists a (possibly inﬁnite) expansion
in terms of basis functions, see section 4.3.

The expressions involving K(X, X), K(X, X∗) and K(X∗, X∗) etc. can look
rather unwieldy, so we now introduce a compact form of the notation setting
K = K(X, X) and K∗ = K(X, X∗). In the case that there is only one test
point x∗ we write k(x∗) = k∗ to denote the vector of covariances between the
test point and the n training points. Using this compact notation and for a
single test point x∗, equations 2.23 and 2.24 reduce to

¯f∗ = k>

∗ (K + σ2

nI)−1y,

V[f∗] = k(x∗, x∗) − k>

∗ (K + σ2

nI)−1k∗.

(2.25)
(2.26)

Let us examine the predictive distribution as given by equations 2.25 and 2.26.
Note ﬁrst that the mean prediction eq. (2.25) is a linear combination of obser-
vations y; this is sometimes referred to as a linear predictor. Another way to
look at this equation is to see it as a linear combination of n kernel functions,
each one centered on a training point, by writing

nX

¯f(x∗) =

αik(xi, x∗)

(2.27)

i=1

nI)−1y. The fact that the mean prediction for f(x∗) can be
where α = (K + σ2
written as eq. (2.27) despite the fact that the GP can be represented in terms
of a (possibly inﬁnite) number of basis functions is one manifestation of the
representer theorem; see section 6.2 for more on this point. We can understand
this result intuitively because although the GP deﬁnes a joint Gaussian dis-
tribution over all of the y variables, one for each point in the index set X , for

representer theorem

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

18

Regression

(a), posterior

(b), posterior covariance

Figure 2.4: Panel (a) is identical to Figure 2.2(b) showing three random functions
drawn from the posterior. Panel (b) shows the posterior co-variance between f (x) and
f (x0) for the same data for three diﬀerent values of x0. Note, that the covariance at
close points is high, falling to zero at the training points (where there is no variance,
since it is a noise-free process), then becomes negative, etc. This happens because if
the smooth function happens to be less than the mean on one side of the data point,
it tends to exceed the mean on the other side, causing a reversal of the sign of the
covariance at the data points. Note for contrast that the prior covariance is simply
of Gaussian shape and never negative.

making predictions at x∗ we only care about the (n+1)-dimensional distribution
deﬁned by the n training points and the test point. As a Gaussian distribu-
tion is marginalized by just taking the relevant block of the joint covariance
matrix (see section A.2) it is clear that conditioning this (n+1)-dimensional
distribution on the observations gives us the desired result. A graphical model
representation of a GP is given in Figure 2.3.

Note also that the variance in eq. (2.24) does not depend on the observed
targets, but only on the inputs; this is a property of the Gaussian distribution.
The variance is the diﬀerence between two terms: the ﬁrst term K(X∗, X∗) is
simply the prior covariance; from that is subtracted a (positive) term, repre-
senting the information the observations gives us about the function. We can
very simply compute the predictive distribution of test targets y∗ by adding
nI to the variance in the expression for cov(f∗).
σ2

The predictive distribution for the GP model gives more than just pointwise
errorbars of the simpliﬁed eq. (2.26). Although not stated explicitly, eq. (2.24)
holds unchanged when X∗ denotes multiple test inputs; in this case the co-
variance of the test targets are computed (whose diagonal elements are the
pointwise variances). In fact, eq. (2.23) is the mean function and eq. (2.24) the
covariance function of the (Gaussian) posterior process; recall the deﬁnition
of Gaussian process from page 13. The posterior covariance in illustrated in
Figure 2.4(b).

It will be useful (particularly for chapter 5) to introduce the marginal likeli-
hood (or evidence) p(y|X) at this point. The marginal likelihood is the integral

noisy predictions

joint predictions

posterior process

marginal likelihood

−505−2−1012input, xoutput, f(x)−505−0.200.20.40.6input, xpost. covariance, cov(f(x),f(x’))x’=−2x’=1x’=3C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.3 Varying the Hyperparameters

19

o

input: X (inputs), y (targets), k (covariance function), σ2

n (noise level),

x∗ (test input)

nI)

o

predictive mean eq. (2.25)

2 y>α −P

2: L := cholesky(K + σ2
α := L>\(L\y)
4: ¯f∗ := k>
∗ α
v := L\k∗
predictive variance eq. (2.26)
6: V[f∗] := k(x∗, x∗) − v>v
log p(y|X) := − 1
eq. (2.30)
8: return: ¯f∗ (mean), V[f∗] (variance), log p(y|X) (log marginal likelihood)
Algorithm 2.1: Predictions and log marginal likelihood for Gaussian process regres-
sion. The implementation addresses the matrix inversion required by eq. (2.25) and
(2.26) using Cholesky factorization, see section A.4. For multiple test cases lines
4-6 are repeated. The log determinant required in eq. (2.30) is computed from the
Cholesky factor (for large n it may not be possible to represent the determinant itself).
The computational complexity is n3/6 for the Cholesky decomposition in line 2, and
n2/2 for solving triangular systems in line 3 and (for each test case) in line 5.

i log Lii − n

2 log 2π

of the likelihood times the prior
p(y|X) =

Z

p(y|f , X)p(f|X) df .

(2.28)

The term marginal likelihood refers to the marginalization over the function
values f. Under the Gaussian process model the prior is Gaussian, f|X ∼
N (0, K), or

log p(f|X) = − 1

2 log |K| − n
2 log 2π,
(2.29)
and the likelihood is a factorized Gaussian y|f ∼ N (f , σ2
nI) so we can make use
of equations A.7 and A.8 to perform the integration yielding the log marginal
likelihood

2 f>K−1f − 1

log p(y|X) = − 1

2 y>(K + σ2

nI)−1y − 1

2 log |K + σ2

nI| − n

2 log 2π.

This result can also be obtained directly by observing that y ∼ N (0, K + σ2

(2.30)
nI).
A practical implementation of Gaussian process regression (GPR) is shown
in Algorithm 2.1. The algorithm uses Cholesky decomposition, instead of di-
rectly inverting the matrix, since it is faster and numerically more stable, see
section A.4. The algorithm returns the predictive mean and variance for noise
free test data—to compute the predictive distribution for noisy test data y∗,
simply add the noise variance σ2

n to the predictive variance of f∗.

2.3 Varying the Hyperparameters

Typically the covariance functions that we use will have some free parameters.
For example, the squared-exponential covariance function in one dimension has
the following form

f exp(cid:0)− 1

2‘2 (xp − xq)2(cid:1) + σ2

nδpq.

ky(xp, xq) = σ2

(2.31)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

20

Regression

(a), ‘ = 1

hyperparameters

(b), ‘ = 0.3

(c), ‘ = 3

Figure 2.5: (a) Data is generated from a GP with hyperparameters (‘, σf , σn) =
(1, 1, 0.1), as shown by the + symbols. Using Gaussian process prediction with these
hyperparameters we obtain a 95% conﬁdence region for the underlying function f
(shown in grey). Panels (b) and (c) again show the 95% conﬁdence region, but this
time for hyperparameter values (0.3, 1.08, 0.00005) and (3.0, 1.16, 0.89) respectively.

The covariance is denoted ky as it is for the noisy targets y rather than for the
underlying function f. Observe that the length-scale ‘, the signal variance σ2
f
and the noise variance σ2
n can be varied. In general we call the free parameters
hyperparameters.11

In chapter 5 we will consider various methods for determining the hyperpa-
rameters from training data. However, in this section our aim is more simply to
explore the eﬀects of varying the hyperparameters on GP prediction. Consider
the data shown by + signs in Figure 2.5(a). This was generated from a GP
with the SE kernel with (‘, σf , σn) = (1, 1, 0.1). The ﬁgure also shows the 2
standard-deviation error bars for the predictions obtained using these values of
the hyperparameters, as per eq. (2.24). Notice how the error bars get larger
for input values that are distant from any training points. Indeed if the x-axis

11We refer to the parameters of the covariance function as hyperparameters to emphasize
that they are parameters of a non-parametric model; in accordance with the weight-space
view, section 2.1, the parameters (weights) of the underlying parametric model have been
integrated out.

−505−3−2−10123input, xoutput, y−505−3−2−10123input, xoutput, y−505−3−2−10123input, xoutput, yC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.4 Decision Theory for Regression

21

were extended one would see the error bars reﬂect the prior standard deviation
of the process σf away from the data.

If we set the length-scale shorter so that ‘ = 0.3 and kept the other pa-
rameters the same, then generating from this process we would expect to see
plots like those in Figure 2.5(a) except that the x-axis should be rescaled by a
factor of 0.3; equivalently if the same x-axis was kept as in Figure 2.5(a) then
a sample function would look much more wiggly.

If we make predictions with a process with ‘ = 0.3 on the data generated
from the ‘ = 1 process then we obtain the result in Figure 2.5(b). The remaining
two parameters were set by optimizing the marginal likelihood, as explained in
chapter 5. In this case the noise parameter is reduced to σn = 0.00005 as the
greater ﬂexibility of the “signal” means that the noise level can be reduced.
This can be observed at the two datapoints near x = 2.5 in the plots. In Figure
2.5(a) (‘ = 1) these are essentially explained as a similar function value with
diﬀering noise. However, in Figure 2.5(b) (‘ = 0.3) the noise level is very low,
so these two points have to be explained by a sharp variation in the value of
the underlying function f. Notice also that the short length-scale means that
the error bars in Figure 2.5(b) grow rapidly away from the datapoints.

In contrast, we can set the length-scale longer, for example to ‘ = 3, as shown
in Figure 2.5(c). Again the remaining two parameters were set by optimizing the
marginal likelihood. In this case the noise level has been increased to σn = 0.89
and we see that the data is now explained by a slowly varying function with a
lot of noise.

Of course we can take the position of a quickly-varying signal with low noise,
or a slowly-varying signal with high noise to extremes; the former would give rise
to a white-noise process model for the signal, while the latter would give rise to a
constant signal with added white noise. Under both these models the datapoints
produced should look like white noise. However, studying Figure 2.5(a) we see
that white noise is not a convincing model of the data, as the sequence of y’s does
not alternate suﬃciently quickly but has correlations due to the variability of
the underlying function. Of course this is relatively easy to see in one dimension,
but methods such as the marginal likelihood discussed in chapter 5 generalize
to higher dimensions and allow us to score the various models. In this case the
marginal likelihood gives a clear preference for (‘, σf , σn) = (1, 1, 0.1) over the
other two alternatives.

2.4 Decision Theory for Regression

In the previous sections we have shown how to compute predictive distributions
for the outputs y∗ corresponding to the novel test input x∗. The predictive dis-
tribution is Gaussian with mean and variance given by eq. (2.25) and eq. (2.26).
In practical applications, however, we are often forced to make a decision about
how to act, i.e. we need a point-like prediction which is optimal in some sense.
To this end we need a loss function, L(ytrue, yguess), which speciﬁes the loss (or

too short length-scale

too long length-scale

model comparison

optimal predictions
loss function

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

22

Regression

non-Bayesian paradigm
Bayesian paradigm

penalty) incurred by guessing the value yguess when the true value is ytrue. For
example, the loss function could equal the absolute deviation between the guess
and the truth.

Notice that we computed the predictive distribution without reference to
the loss function. In non-Bayesian paradigms, the model is typically trained
by minimizing the empirical risk (or loss). In contrast, in the Bayesian setting
there is a clear separation between the likelihood function (used for training, in
addition to the prior) and the loss function. The likelihood function describes
how the noisy measurements are assumed to deviate from the underlying noise-
free function. The loss function, on the other hand, captures the consequences
of making a speciﬁc choice, given an actual true state. The likelihood and loss
function need not have anything in common.12

expected loss, risk

absolute error loss
squared error loss

robot arm

Our goal is to make the point prediction yguess which incurs the smallest loss,
but how can we achieve that when we don’t know ytrue? Instead, we minimize
the expected loss or risk, by averaging w.r.t. our model’s opinion as to what the
truth might be

Z

˜RL(yguess|x∗) =

L(y∗, yguess)p(y∗|x∗,D) dy∗.

(2.32)

Thus our best guess, in the sense that it minimizes the expected loss, is

yoptimal|x∗ = argmin

yguess

˜RL(yguess|x∗).

(2.33)

In general the value of yguess that minimizes the risk for the loss function |yguess−
y∗| is the median of p(y∗|x∗,D), while for the squared loss (yguess − y∗)2 it is
the mean of this distribution. When the predictive distribution is Gaussian
the mean and the median coincide, and indeed for any symmetric loss function
and symmetric predictive distribution we always get yguess as the mean of the
predictive distribution. However, in many practical problems the loss functions
can be asymmetric, e.g. in safety critical applications, and point predictions
may be computed directly from eq. (2.32) and eq. (2.33). A comprehensive
treatment of decision theory can be found in Berger [1985].

2.5 An Example Application

In this section we use Gaussian process regression to learn the inverse dynamics
of a seven degrees-of-freedom SARCOS anthropomorphic robot arm. The task
is to map from a 21-dimensional input space (7 joint positions, 7 joint velocities,
7 joint accelerations) to the corresponding 7 joint torques. This task has pre-
viously been used to study regression algorithms by Vijayakumar and Schaal
[2000], Vijayakumar et al. [2002] and Vijayakumar et al. [2005].13 Following

12Beware of fallacious arguments like: a Gaussian likelihood implies a squared error loss

function.

13We thank Sethu Vijayakumar for providing us with the data.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.5 An Example Application

this previous work we present results below on just one of the seven mappings,
from the 21 input variables to the ﬁrst of the seven torques.

One might ask why it is necessary to learn this mapping; indeed there exist
physics-based rigid-body-dynamics models which allow us to obtain the torques
from the position, velocity and acceleration variables. However, the real robot
arm is actuated hydraulically and is rather lightweight and compliant, so the
assumptions of the rigid-body-dynamics model are violated (as we see below).
It is worth noting that the rigid-body-dynamics model is nonlinear, involving
trigonometric functions and squares of the input variables.

An inverse dynamics model can be used in the following manner: a planning
module decides on a trajectory that takes the robot from its start to goal states,
and this speciﬁes the desired positions, velocities and accelerations at each time.
The inverse dynamics model is used to compute the torques needed to achieve
this trajectory and errors are corrected using a feedback controller.

The dataset consists of 48,933 input-output pairs, of which 44,484 were used
as a training set and the remaining 4,449 were used as a test set. The inputs
were linearly rescaled to have zero mean and unit variance on the training set.
The outputs were centered so as to have zero mean on the training set.

Given a prediction method, we can evaluate the quality of predictions in
several ways. Perhaps the simplest is the squared error loss, where we compute
the squared residual (y∗ − ¯f(x∗))2 between the mean prediction and the target
at each test point. This can be summarized by the mean squared error (MSE),
by averaging over the test set. However, this quantity is sensitive to the overall
scale of the target values, so it makes sense to normalize by the variance of the
targets of the test cases to obtain the standardized mean squared error (SMSE).
This causes the trivial method of guessing the mean of the training targets to
have a SMSE of approximately 1.

Additionally if we produce a predictive distribution at each test input we
can evaluate the negative log probability of the target under the model.14 As
GPR produces a Gaussian predictive density, one obtains

− log p(y∗|D, x∗) =

1
2

log(2πσ2∗) +

(y∗ − ¯f(x∗))2

2σ2∗

,

(2.34)

where the predictive variance σ2∗ for GPR is computed as σ2∗ = V(f∗) + σ2
n,
where V(f∗) is given by eq. (2.26); we must include the noise variance σ2
n as we
are predicting the noisy target y∗. This loss can be standardized by subtracting
the loss that would be obtained under the trivial model which predicts using
a Gaussian with the mean and variance of the training data. We denote this
the standardized log loss (SLL). The mean SLL is denoted MSLL. Thus the
MSLL will be approximately zero for simple methods and negative for better
methods.

A number of models were tested on the data. A linear regression (LR) model
provides a simple baseline for the SMSE. By estimating the noise level from the

14 It makes sense to use the negative log probability so as to obtain a loss, not a utility.

23

why learning?

MSE

SMSE

MSLL

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

24

Regression

Method
LR
RBD
LWPR
GPR

SMSE MSLL
0.075
-1.29
0.104
0.040
0.011

-2.25

–
–

Table 2.1: Test results on the inverse dynamics problem for a number of diﬀerent
methods. The “–” denotes a missing entry, caused by two methods not producing full
predictive distributions, so MSLL could not be evaluated.

residuals on the training set one can also obtain a predictive variance and thus
get a MSLL value for LR. The rigid-body-dynamics (RBD) model has a number
of free parameters; these were estimated by Vijayakumar et al. [2005] using a
least-squares ﬁtting procedure. We also give results for the locally weighted
projection regression (LWPR) method of Vijayakumar et al. [2005] which is an
on-line method that cycles through the dataset multiple times. For the GP
models it is computationally expensive to make use of all 44,484 training cases
due to the O(n3) scaling of the basic algorithm. In chapter 8 we present several
diﬀerent approximate GP methods for large datasets. The result given in Table
2.1 was obtained with the subset of regressors (SR) approximation with a subset
size of 4096. This result is taken from Table 8.1, which gives full results of the
various approximation methods applied to the inverse dynamics problem. The
squared exponential covariance function was used with a separate length-scale
parameter for each of the 21 input dimensions, plus the signal and noise variance
n. These parameters were set by optimizing the marginal
parameters σ2
likelihood eq. (2.30) on a subset of the data (see also chapter 5).

f and σ2

The results for the various methods are presented in Table 2.1. Notice that
the problem is quite non-linear, so the linear regression model does poorly in
comparison to non-linear methods.15 The non-linear method LWPR improves
over linear regression, but is outperformed by GPR.

2.6 Smoothing, Weight Functions and Equiva-

lent Kernels

Gaussian process regression aims to reconstruct the underlying signal f by
removing the contaminating noise ε. To do this it computes a weighted average
of the noisy observations y as ¯f(x∗) = k(x∗)>(K +σ2
nI)−1y; as ¯f(x∗) is a linear
combination of the y values, Gaussian process regression is a linear smoother
(see Hastie and Tibshirani [1990, sec. 2.8] for further details). In this section
we study smoothing ﬁrst in terms of a matrix analysis of the predictions at the
training points, and then in terms of the equivalent kernel.

15It is perhaps surprising that RBD does worse than linear regression. However, Stefan
Schaal (pers. comm., 2004) states that the RBD parameters were optimized on a very large
dataset, of which the training data used here is subset, and if the RBD model were optimized
w.r.t. this training set one might well expect it to outperform linear regression.

linear smoother

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.6 Smoothing, Weight Functions and Equivalent Kernels

25

The predicted mean values ¯f at the training points are given by

nI)−1y.

¯f = K(K + σ2

Let K have the eigendecomposition K = Pn
eigenvectors are mutually orthogonal. Let y =Pn

i , where λi is the ith
eigenvalue and ui is the corresponding eigenvector. As K is real and sym-
metric positive semideﬁnite, its eigenvalues are real and non-negative, and its
i=1γiui for some coeﬃcients
γi = u>

i=1λiuiu>

(2.35)

i y. Then

¯f =

γiλi

λi + σ2
n

ui.

(2.36)

nX

i=1

n) (cid:28) 1 then the component in y along ui is eﬀectively
Notice that if λi/(λi + σ2
eliminated. For most covariance functions that are used in practice the eigen-
values are larger for more slowly varying eigenvectors (e.g. fewer zero-crossings)
so that this means that high-frequency components in y are smoothed out.
The eﬀective number of parameters or degrees of freedom of the smoother is
n), see Hastie and Tibshirani
deﬁned as tr(K(K + σ2
[1990, sec. 3.5]. Notice that this counts the number of eigenvectors which are
not eliminated.

nI)−1) =Pn

i=1 λi/(λi + σ2

We can deﬁne a vector of functions h(x∗) = (K + σ2

nI)−1k(x∗). Thus we
have ¯f(x∗) = h(x∗)>y, making it clear that the mean prediction at a point
x∗ is a linear combination of the target values y. For a ﬁxed test point x∗,
h(x∗) gives the vector of weights applied to targets y. h(x∗) is called the weight
function [Silverman, 1984]. As Gaussian process regression is a linear smoother,
the weight function does not depend on y. Note the diﬀerence between a
linear model, where the prediction is a linear combination of the inputs, and a
linear smoother, where the prediction is a linear combination of the training set
targets.

Understanding the form of the weight function is made complicated by the
matrix inversion of K+σ2
nI and the fact that K depends on the speciﬁc locations
of the n datapoints. Idealizing the situation one can consider the observations
to be “smeared out” in x-space at some density of observations. In this case
analytic tools can be brought to bear on the problem, as shown in section 7.1.
By analogy to kernel smoothing, Silverman [1984] called the idealized weight
function the equivalent kernel; see also Girosi et al. [1995, sec. 2.1].

A kernel smoother centres a kernel function16 κ on x∗ and then computes
κi = κ(|xi − x∗|/‘) for each data point (xi, yi), where ‘ is a length-scale. The
Gaussian is a commonly used kernel function. The prediction for f(x∗) is
j=1 κj. This is also known

i=1wiyi where wi = κi/Pn

computed as ˆf(x∗) =Pn

as the Nadaraya-Watson estimator, see e.g. Scott [1992, sec. 8.1].

The weight function and equivalent kernel for a Gaussian process are illus-
trated in Figure 2.6 for a one-dimensional input variable x. We have used the
squared exponential covariance function and have set the length-scale ‘ = 0.0632
(so that ‘2 = 0.004). There are n = 50 training points spaced randomly along

16Note that this kernel function does not need to be a valid covariance function.

eigendecomposition

degrees of freedom

weight function

equivalent kernel

kernel smoother

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

26

Regression

(a)

(c)

(b)

(d)

Figure 2.6: Panels (a)-(c) show the weight function h(x∗) (dots) corresponding to
the n = 50 training points, the equivalent kernel (solid) and the original squared
exponential kernel (dashed). Panel (d) shows the equivalent kernels for two diﬀerent
data densities. See text for further details. The small cross at the test point is to
scale in all four plots.

the x-axis. Figures 2.6(a) and 2.6(b) show the weight function and equivalent
kernel for x∗ = 0.5 and x∗ = 0.05 respectively, for σ2
n = 0.1. Figure 2.6(c) is also
for x∗ = 0.5 but uses σ2
n = 10. In each case the dots correspond to the weight
function h(x∗) and the solid line is the equivalent kernel, whose construction is
explained below. The dashed line shows a squared exponential kernel centered
on the test point, scaled to have the same height as the maximum value in the
equivalent kernel. Figure 2.6(d) shows the variation in the equivalent kernel as
a function of n, the number of datapoints in the unit interval.

Many interesting observations can be made from these plots. Observe that
the equivalent kernel has (in general) a shape quite diﬀerent to the original SE
kernel. In Figure 2.6(a) the equivalent kernel is clearly oscillatory (with negative
sidelobes) and has a higher spatial frequency than the original kernel. Figure
2.6(b) shows similar behaviour although due to edge eﬀects the equivalent kernel
is truncated relative to that in Figure 2.6(a). In Figure 2.6(c) we see that at
higher noise levels the negative sidelobes are reduced and the width of the
equivalent kernel is similar to the original kernel. Also note that the overall
height of the equivalent kernel in (c) is reduced compared to that in (a) and

00.20.40.60.8100.200.20.40.60.8100.200.20.40.60.8100.0500.20.40.60.8100.110250C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.7 Incorporating Explicit Basis Functions

27

(b)—it averages over a wider area. The more oscillatory equivalent kernel for
lower noise levels can be understood in terms of the eigenanalysis above; at
higher noise levels only the large λ (slowly varying) components of y remain,
while for smaller noise levels the more oscillatory components are also retained.
In Figure 2.6(d) we have plotted the equivalent kernel for n = 10 and n =
250 datapoints in [0, 1]; notice how the width of the equivalent kernel decreases
as n increases. We discuss this behaviour further in section 7.1.

The plots of equivalent kernels in Figure 2.6 were made by using a dense
grid of ngrid points on [0, 1] and then computing the smoother matrix K(K +
gridI)−1. Each row of this matrix is the equivalent kernel at the appropriate
σ2
location. However, in order to get the scaling right one has to set σ2
grid =
nngrid/n; for ngrid > n this means that the eﬀective variance at each of the
σ2
ngrid points is larger, but as there are correspondingly more points this eﬀect
cancels out. This can be understood by imagining the situation if there were
ngrid/n independent Gaussian observations with variance σ2
grid at a single x-
position; this would be equivalent to one Gaussian observation with variance
n. In eﬀect the n observations have been smoothed out uniformly along the
σ2
interval. The form of the equivalent kernel can be obtained analytically if we
go to the continuum limit and look to smooth a noisy function. The relevant
theory and some example equivalent kernels are given in section 7.1.

2.7

Incorporating Explicit Basis Functions

∗

It is common but by no means necessary to consider GPs with a zero mean func-
tion. Note that this is not necessarily a drastic limitation, since the mean of the
posterior process is not conﬁned to be zero. Yet there are several reasons why
one might wish to explicitly model a mean function, including interpretability
of the model, convenience of expressing prior information and a number of an-
alytical limits which we will need in subsequent chapters. The use of explicit
basis functions is a way to specify a non-zero mean over functions, but as we
will see in this section, one can also use them to achieve other interesting eﬀects.
Using a ﬁxed (deterministic) mean function m(x) is trivial: Simply apply
the usual zero mean GP to the diﬀerence between the observations and the
ﬁxed mean function. With

f(x) ∼ GP(cid:0)m(x), k(x, x0)(cid:1),

the predictive mean becomes

¯f∗ = m(X∗) + K(X∗, X)K−1

y (y − m(X)),

where Ky = K + σ2
eq. (2.24).

nI, and the predictive variance remains unchanged from

However, in practice it can often be diﬃcult to specify a ﬁxed mean function.
In many cases it may be more convenient to specify a few ﬁxed basis functions,

ﬁxed mean function

(2.37)

(2.38)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

28

stochastic mean
function

polynomial regression

whose coeﬃcients, β, are to be inferred from the data. Consider

g(x) = f(x) + h(x)>β, where f(x) ∼ GP(cid:0)0, k(x, x0)(cid:1),

(2.39)

Regression

here f(x) is a zero mean GP, h(x) are a set of ﬁxed basis functions, and β are
additional parameters. This formulation expresses that the data is close to a
global linear model with the residuals being modelled by a GP. This idea was
explored explicitly as early as 1975 by Blight and Ott [1975], who used the GP
to model the residuals from a polynomial regression, i.e. h(x) = (1, x, x2, . . .).
When ﬁtting the model, one could optimize over the parameters β jointly with
the hyperparameters of the covariance function. Alternatively, if we take the
prior on β to be Gaussian, β ∼ N (b, B), we can also integrate out these
parameters. Following O’Hagan [1978] we obtain another GP

g(x) ∼ GP(cid:0)h(x)>b, k(x, x0) + h(x)>Bh(x0)(cid:1),

(2.40)

now with an added contribution in the covariance function caused by the un-
certainty in the parameters of the mean. Predictions are made by plugging
the mean and covariance functions of g(x) into eq. (2.39) and eq. (2.24). After
rearranging, we obtain
¯g(X∗) = H>
cov(g∗) = cov(f∗) + R>(B−1 + HK−1

y (y − H> ¯β) = ¯f(X∗) + R> ¯β,

∗ ¯β + K>

∗ K−1

y H>)−1R,

(2.41)

y H>)−1(HK−1

where the H matrix collects the h(x) vectors for all training (and H∗ all test)
cases, ¯β = (B−1 + HK−1
y K∗.
Notice the nice interpretation of the mean expression, eq. (2.41) top line: ¯β is
the mean of the global linear model parameters, being a compromise between
the data term and prior, and the predictive mean is simply the mean linear
output plus what the GP model predicts from the residuals. The covariance is
the sum of the usual covariance term and a new non-negative contribution.

y y + B−1b), and R = H∗ − HK−1

Exploring the limit of the above expressions as the prior on the β param-
eter becomes vague, B−1 → O (where O is the matrix of zeros), we obtain a
predictive distribution which is independent of b

¯g(X∗) = ¯f(X∗) + R> ¯β,
cov(g∗) = cov(f∗) + R>(HK−1

y H>)−1R,

(2.42)

y H>)−1HK−1

where the limiting ¯β = (HK−1
y y. Notice that predictions under
the limit B−1 → O should not be implemented na¨ıvely by plugging the modiﬁed
covariance function from eq. (2.40) into the standard prediction equations, since
the entries of the covariance function tend to inﬁnity, thus making it unsuitable
for numerical implementation. Instead eq. (2.42) must be used. Even if the
non-limiting case is of interest, eq. (2.41) is numerically preferable to a direct
implementation based on eq. (2.40), since the global linear part will often add
some very large eigenvalues to the covariance matrix, aﬀecting its condition
number.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.8 History and Related Work

2.7.1 Marginal Likelihood

In this short section we brieﬂy discuss the marginal likelihood for the model
with a Gaussian prior β ∼ N (b, B) on the explicit parameters from eq. (2.40),
as this will be useful later, particularly in section 6.3.1. We can express the
marginal likelihood from eq. (2.30) as

29

log p(y|X, b, B) = − 1
− 1

2(H>b − y)>(Ky + H>BH)−1(H>b − y)
2 log |Ky + H>BH| − n

2 log 2π,

(2.43)

where we have included the explicit mean. We are interested in exploring the
limit where B−1 → O, i.e. when the prior is vague. In this limit the mean of the
prior is irrelevant (as was the case in eq. (2.42)), so without loss of generality
(for the limiting case) we assume for now that the mean is zero, b = 0, giving

log p(y|X, b=0, B) = − 1
− 1
y H> and C = K−1

2 y>K−1
y y + 1
2 log |Ky| − 1

where A = B−1 + HK−1
the matrix inversion lemma, eq. (A.9) and eq. (A.10).

2 y>Cy
2 log |B| − 1
y H>A−1HK−1

y

and we have used

2 log |A| − n

2 log 2π,

(2.44)

We now explore the behaviour of the log marginal likelihood in the limit of
vague priors on β. In this limit the variances of the Gaussian in the directions
spanned by columns of H> will become inﬁnite, and it is clear that this will
require special treatment. The log marginal likelihood consists of three terms:
a quadratic form in y, a log determinant term, and a term involving log 2π.
Performing an eigendecomposition of the covariance matrix we see that the
contributions to quadratic form term from the inﬁnite-variance directions will
be zero. However, the log determinant term will tend to minus inﬁnity. The
standard solution [Wahba, 1985, Ansley and Kohn, 1985] in this case is to
project y onto the directions orthogonal to the span of H> and compute the
marginal likelihood in this subspace. Let the rank of H> be m. Then as
shown in Ansley and Kohn [1985] this means that we must discard the terms
− 1
2 log |B| − m
log p(y|X) = − 1
where A = HK−1

2 log 2π from eq. (2.44) to give
2 y>Cy − 1
y H>A−1HK−1
y .

y H> and C = K−1

2 log |A| − n−m

2 log |Ky| − 1

2 y>K−1

y y + 1

log 2π,

2

(2.45)

2.8 History and Related Work

Prediction with Gaussian processes is certainly not a very recent topic, espe-
cially for time series analysis; the basic theory goes back at least as far as the
work of Wiener [1949] and Kolmogorov [1941] in the 1940’s. Indeed Lauritzen
[1981] discusses relevant work by the Danish astronomer T. N. Thiele dating
from 1880.

time series

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

30

geostatistics

kriging

computer experiments

machine learning

Regression

Gaussian process prediction is also well known in the geostatistics ﬁeld (see,
e.g. Matheron, 1973; Journel and Huijbregts, 1978) where it is known as krig-
ing,17 and in meteorology [Thompson, 1956, Daley, 1991] although this litera-
ture naturally has focussed mostly on two- and three-dimensional input spaces.
Whittle [1963, sec. 5.4] also suggests the use of such methods for spatial pre-
diction. Ripley [1981] and Cressie [1993] provide useful overviews of Gaussian
process prediction in spatial statistics.

Gradually it was realized that Gaussian process prediction could be used in
a general regression context. For example O’Hagan [1978] presents the general
theory as given in our equations 2.23 and 2.24, and applies it to a number of
one-dimensional regression problems. Sacks et al. [1989] describe GPR in the
context of computer experiments (where the observations y are noise free) and
discuss a number of interesting directions such as the optimization of parameters
in the covariance function (see our chapter 5) and experimental design (i.e. the
choice of x-points that provide most information on f). The authors describe
a number of computer simulations that were modelled, including an example
where the response variable was the clock asynchronization in a circuit and the
inputs were six transistor widths. Santner et al. [2003] is a recent book on the
use of GPs for the design and analysis of computer experiments.

Williams and Rasmussen [1996] described Gaussian process regression in
a machine learning context, and described optimization of the parameters in
the covariance function, see also Rasmussen [1996]. They were inspired to use
Gaussian process by the connection to inﬁnite neural networks as described in
section 4.2.3 and in Neal [1996]. The “kernelization” of linear ridge regression
described above is also known as kernel ridge regression see e.g. Saunders et al.
[1998].

Relationships between Gaussian process prediction and regularization the-
ory, splines, support vector machines (SVMs) and relevance vector machines
(RVMs) are discussed in chapter 6.

2.9 Exercises

1. Replicate the generation of random functions from Figure 2.2. Use a
regular (or random) grid of scalar inputs and the covariance function from
eq. (2.16). Hints on how to generate random samples from multi-variate
Gaussian distributions are given in section A.2.
Invent some training
data points, and make random draws from the resulting GP posterior
using eq. (2.19).

2. In eq. (2.11) we saw that the predictive variance at x∗ under the feature
space regression model was var(f(x∗)) = φ(x∗)>A−1φ(x∗). Show that
cov(f(x∗), f(x0
∗). Check that this is compatible with
the expression given in eq. (2.24).

∗)) = φ(x∗)>A−1φ(x0

17Matheron named the method after the South African mining engineer D. G. Krige.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

2.9 Exercises

31

3. The Wiener process is deﬁned for x ≥ 0 and has f(0) = 0. (See sec-
tion B.2.1 for further details.)
It has mean zero and a non-stationary
covariance function k(x, x0) = min(x, x0). If we condition on the Wiener
process passing through f(1) = 0 we obtain a process known as the Brow-
nian bridge (or tied-down Wiener process). Show that this process has
covariance k(x, x0) = min(x, x0)− xx0 for 0 ≤ x, x0 ≤ 1 and mean 0. Write
a computer program to draw samples from this process at a ﬁnite grid of
x points in [0, 1].

4. Let varn(f(x∗)) be the predictive variance of a Gaussian process regres-
sion model at x∗ given a dataset of size n. The corresponding predictive
variance using a dataset of only the ﬁrst n − 1 training points is de-
noted varn−1(f(x∗)). Show that varn(f(x∗)) ≤ varn−1(f(x∗)), i.e. that
the predictive variance at x∗ cannot increase as more training data is ob-
tained. One way to approach this problem is to use the partitioned matrix
equations given in section A.3 to decompose varn(f(x∗)) = k(x∗, x∗) −
k>
nI)−1k∗. An alternative information theoretic argument is given
∗ (K +σ2
in Williams and Vivarelli [2000]. Note that while this conclusion is true
for Gaussian process priors and Gaussian noise models it does not hold
generally, see Barber and Saad [1996].

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 3

Classiﬁcation

In chapter 2 we have considered regression problems, where the targets are
real valued. Another important class of problems is classiﬁcation 1 problems,
where we wish to assign an input pattern x to one of C classes, C1, . . . ,CC.
Practical examples of classiﬁcation problems are handwritten digit recognition
(where we wish to classify a digitized image of a handwritten digit into one of
ten classes 0-9), and the classiﬁcation of objects detected in astronomical sky
surveys into stars or galaxies. (Information on the distribution of galaxies in
the universe is important for theories of the early universe.) These examples
nicely illustrate that classiﬁcation problems can either be binary (or two-class,
C = 2) or multi-class (C > 2).

We will focus attention on probabilistic classiﬁcation, where test predictions
take the form of class probabilities; this contrasts with methods which provide
only a guess at the class label, and this distinction is analogous to the diﬀerence
between predictive distributions and point predictions in the regression setting.
Since generalization to test cases inherently involves some level of uncertainty,
it seems natural to attempt to make predictions in a way that reﬂects these
uncertainties. In a practical application one may well seek a class guess, which
can be obtained as the solution to a decision problem, involving the predictive
probabilities as well as a speciﬁcation of the consequences of making speciﬁc
predictions (the loss function).

Both classiﬁcation and regression can be viewed as function approximation
problems. Unfortunately, the solution of classiﬁcation problems using Gaussian
processes is rather more demanding than for the regression problems considered
in chapter 2. This is because we assumed in the previous chapter that the
likelihood function was Gaussian; a Gaussian process prior combined with a
Gaussian likelihood gives rise to a posterior Gaussian process over functions,
and everything remains analytically tractable. For classiﬁcation models, where
the targets are discrete class labels, the Gaussian likelihood is inappropriate;2

1In the statistics literature classiﬁcation is often called discrimination.
2One may choose to ignore the discreteness of the target values, and use a regression
treatment, where all targets happen to be say ±1 for binary classiﬁcation. This is known as

binary, multi-class

probabilistic
classiﬁcation

non-Gaussian likelihood

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

34

Classiﬁcation

in this chapter we treat methods of approximate inference for classiﬁcation,
where exact inference is not feasible.3

Section 3.1 provides a general discussion of classiﬁcation problems, and de-
scribes the generative and discriminative approaches to these problems.
In
section 2.1 we saw how Gaussian process regression (GPR) can be obtained
In section 3.2 we describe an analogue of
by generalizing linear regression.
linear regression in the classiﬁcation case, logistic regression.
In section 3.3
logistic regression is generalized to yield Gaussian process classiﬁcation (GPC)
using again the ideas behind the generalization of linear regression to GPR.
For GPR the combination of a GP prior with a Gaussian likelihood gives rise
to a posterior which is again a Gaussian process. In the classiﬁcation case the
likelihood is non-Gaussian but the posterior process can be approximated by a
GP. The Laplace approximation for GPC is described in section 3.4 (for binary
classiﬁcation) and in section 3.5 (for multi-class classiﬁcation), and the expecta-
tion propagation algorithm (for binary classiﬁcation) is described in section 3.6.
Both of these methods make use of a Gaussian approximation to the posterior.
Experimental results for GPC are given in section 3.7, and a discussion of these
results is provided in section 3.8.

3.1 Classiﬁcation Problems

generative approach

discriminative approach

generative model
example

The natural starting point for discussing approaches to classiﬁcation is the
joint probability p(y, x), where y denotes the class label. Using Bayes’ theorem
this joint probability can be decomposed either as p(y)p(x|y) or as p(x)p(y|x).
This gives rise to two diﬀerent approaches to classiﬁcation problems. The ﬁrst,
which we call the generative approach, models the class-conditional distribu-
tions p(x|y) for y = C1, . . . ,CC and also the prior probabilities of each class,
and then computes the posterior probability for each class using

.

(3.1)

p(y|x) =

PC
p(y)p(x|y)
c=1 p(Cc)p(x|Cc)

The alternative approach, which we call the discriminative approach, focusses
on modelling p(y|x) directly. Dawid [1976] calls the generative and discrimina-
tive approaches the sampling and diagnostic paradigms, respectively.

To turn both the generative and discriminative approaches into practical
methods we will need to create models for either p(x|y), or p(y|x) respectively.4
These could either be of parametric form, or non-parametric models such as
those based on nearest neighbours. For the generative case a simple, com-

least-squares classiﬁcation, see section 6.5.

3Note, that the important distinction is between Gaussian and non-Gaussian likelihoods;
regression with a non-Gaussian likelihood requires a similar treatment, but since classiﬁcation
deﬁnes an important conceptual and application area, we have chosen to treat it in a separate
chapter; for non-Gaussian likelihoods in general, see section 9.3.

4For the generative approach inference for p(y) is generally straightforward, being esti-
mation of a binomial probability in the binary case, or a multinomial probability in the
multi-class case.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.1 Classiﬁcation Problems

35

discriminative model
example

response function

probit regression

generative or
discriminative?

missing values

mon choice would be to model the class-conditional densities with Gaussians:
p(x|Cc) = N (µc, Σc). A Bayesian treatment can be obtained by placing appro-
priate priors on the mean and covariance of each of the Gaussians. However,
note that this Gaussian model makes a strong assumption on the form of class-
conditional density and if this is inappropriate the model may perform poorly.
For the binary discriminative case one simple idea is to turn the output of a
regression model into a class probability using a response function (the inverse
of a link function), which “squashes” its argument, which can lie in the domain
(−∞,∞), into the range [0, 1], guaranteeing a valid probabilistic interpretation.

One example is the linear logistic regression model

p(C1|x) = λ(x>w), where λ(z) =

1

1 + exp(−z) ,

(3.2)

standard normal distribution Φ(z) =R z

which combines the linear model with the logistic response function. Another
common choice of response function is the cumulative density function of a
−∞ N (x|0, 1)dx. This approach is known
as probit regression. Just as we gave a Bayesian approach to linear regression in
chapter 2 we can take a parallel approach to logistic regression, as discussed in
section 3.2. As in the regression case, this model is an important step towards
the Gaussian process classiﬁer.

Given that there are the generative and discriminative approaches, which
one should we prefer? This is perhaps the biggest question in classiﬁcation,
and we do not believe that there is a right answer, as both ways of writing the
joint p(y, x) are correct. However, it is possible to identify some strengths and
weaknesses of the two approaches. The discriminative approach is appealing
in that it is directly modelling what we want, p(y|x). Also, density estimation
for the class-conditional distributions is a hard problem, particularly when x is
high dimensional, so if we are just interested in classiﬁcation then the generative
approach may mean that we are trying to solve a harder problem than we need
to. However, to deal with missing input values, outliers and unlabelled data
points in a principled fashion it is very helpful to have access to p(x), and
this can be obtained from marginalizing out the class label y from the joint
y p(y)p(x|y) in the generative approach. A further factor in the
choice of a generative or discriminative approach could also be which one is
most conducive to the incorporation of any prior information which is available.
See Ripley [1996, sec. 2.1] for further discussion of these issues. The Gaussian
process classiﬁers developed in this chapter are discriminative.

as p(x) = P

3.1.1 Decision Theory for Classiﬁcation
The classiﬁers described above provide predictive probabilities p(y∗|x∗) for a
test input x∗. However, sometimes one actually needs to make a decision and
to do this we need to consider decision theory. Decision theory for the regres-
sion problem was considered in section 2.4; here we discuss decision theory for
classiﬁcation problems. A comprehensive treatment of decision theory can be
found in Berger [1985].

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

36

loss, risk

zero-one loss

asymmetric loss

Bayes classiﬁer

decision regions

reject option

risk minimization

Classiﬁcation

given x is RL(c0|x) =P

Let L(c, c0) be the loss incurred by making decision c0 if the true class is Cc.
Usually L(c, c) = 0 for all c. The expected loss5 (or risk) of taking decision c0
c L(c, c0)p(Cc|x) and the optimal decision c∗ is the one
that minimizes RL(c0|x). One common choice of loss function is the zero-one
loss, where a penalty of one unit is paid for an incorrect classiﬁcation, and 0
for a correct one. In this case the optimal decision rule is to choose the class Cc
that maximizes6 p(Cc|x), as this minimizes the expected error at x. However,
the zero-one loss is not always appropriate. A classic example of this is the
diﬀerence in loss of failing to spot a disease when carrying out a medical test
compared to the cost of a false positive on the test, so that L(c, c0) 6= L(c0, c).
The optimal classiﬁer (using zero-one loss) is known as the Bayes classi-
ﬁer. By this construction the feature space is divided into decision regions
R1, . . . ,RC such that a pattern falling in decision region Rc is assigned to class
Cc. (There can be more than one decision region corresponding to a single class.)
The boundaries between the decision regions are known as decision surfaces or
decision boundaries.

One would expect misclassiﬁcation errors to occur in regions where the max-
imum class probability maxj p(Cj|x) is relatively low. This could be due to
either a region of strong overlap between classes, or lack of training examples
within this region. Thus one sensible strategy is to add a reject option so that
if maxj p(Cj|x) ≥ θ for a threshold θ in (0, 1) then we go ahead and classify
the pattern, otherwise we reject it and leave the classiﬁcation task to a more
sophisticated system. For multi-class classiﬁcation we could alternatively re-
quire the gap between the most probable and the second most probable class to
exceed θ, and otherwise reject. As θ is varied from 0 to 1 one obtains an error-
reject curve, plotting the percentage of patterns classiﬁed incorrectly against
the percentage rejected. Typically the error rate will fall as the rejection rate
increases. Hansen et al. [1997] provide an analysis of the error-reject trade-oﬀ.
We have focused above on the probabilistic approach to classiﬁcation, which
involves a two-stage approach of ﬁrst computing a posterior distribution over
functions and then combining this with the loss function to produce a decision.
However, it is worth noting that some authors argue that if our goal is to
eventually make a decision then we should aim to approximate the classiﬁcation
function that minimizes the risk (expected loss), which is deﬁned as

Z

L(cid:0)y, c(x)(cid:1)p(y, x) dydx,

RL(c) =

(3.3)

where p(y, x) is the joint distribution of inputs and targets and c(x) is a clas-
siﬁcation function that assigns an input pattern x to one of C classes (see
Pn
e.g. Vapnik [1995, ch. 1]). As p(y, x) is unknown, in this approach one often
then seeks to minimize an objective function which includes the empirical risk
i=1 L(yi, c(xi)) as well as a regularization term. While this is a reasonable

5In Economics one usually talks of maximizing expected utility rather than minimizing
expected loss; loss is negative utility. This suggests that statisticians are pessimists while
economists are optimists.

6If more than one class has equal posterior probability then ties can be broken arbitrarily.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.2 Linear Models for Classiﬁcation

37

method, we note that the probabilistic approach allows the same inference stage
to be re-used with diﬀerent loss functions, it can help us to incorporate prior
knowledge on the function and/or noise model, and has the advantage of giving
probabilistic predictions which can be helpful e.g. for the reject option.

3.2 Linear Models for Classiﬁcation

In this section we brieﬂy review linear models for binary classiﬁcation, which
form the foundation of Gaussian process classiﬁcation models in the next sec-
tion. We follow the SVM literature and use the labels y = +1 and y = −1 to
distinguish the two classes, although for the multi-class case in section 3.5 we
use 0/1 labels. The likelihood is

p(y =+1|x, w) = σ(x>w),

(3.4)

given the weight vector w and σ(z) can be any sigmoid7 function. When using
the logistic, σ(z) = λ(z) from eq. (3.2), the model is usually called simply logistic
regression, but to emphasize the parallels to linear regression we prefer the term
linear logistic regression. When using the cumulative Gaussian σ(z) = Φ(z),
we call the model linear probit regression.

As the probability of the two classes must sum to 1, we have p(y =−1|x, w) =
1 − p(y = +1|x, w). Thus for a data point (xi, yi) the likelihood is given by
i w) if yi = −1. For symmetric likelihood
i w) if yi = +1, and 1 − σ(x>
σ(x>
functions, such as the logistic or probit where σ(−z) = 1 − σ(z), this can be
written more concisely as

p(yi|xi, w) = σ(yifi),

(3.5)

log(cid:0)p(y = +1|x)/p(y =−1|x)(cid:1) we see that the logistic regression model can be

where fi , f(xi) = x>
i w. Deﬁning the logit transformation as logit(x) =
written as logit(x) = x>w. The logit(x) function is also called the log odds
ratio. Generalized linear modelling [McCullagh and Nelder, 1983] deals with
the issue of extending linear models to non-Gaussian data scenarios; the logit
transformation is the canonical link function for binary data and this choice
simpliﬁes the algebra and algorithms.

Given a dataset D = {(xi, yi)|i = 1, . . . , n}, we assume that the labels are
generated independently, conditional on f(x). Using the same Gaussian prior
w ∼ N (0, Σp) as for regression in eq. (2.4) we then obtain the un-normalized
log posterior

nX

i=1

log p(w|X, y) c= −1
2

w>Σ−1

p w +

log σ(yifi).

(3.6)

In the linear regression case with Gaussian noise the posterior was Gaussian
with mean and covariance as given in eq. (2.8). For classiﬁcation the posterior
7A sigmoid function is a monotonically increasing function mapping from R to [0, 1]. It

derives its name from being shaped like a letter S.

linear logistic regression

linear probit regression

concise notation

logit

log odds ratio

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

38

concavity

unique maximum

IRLS algorithm

properties of maximum
likelihood

Classiﬁcation

does not have a simple analytic form. However, it is easy to show that for
some sigmoid functions, such as the logistic and cumulative Gaussian, the log
likelihood is a concave function of w for ﬁxed D. As the quadratic penalty on
w is also concave then the log posterior is a concave function, which means
that it is relatively easy to ﬁnd its unique maximum. The concavity can also be
derived from the fact that the Hessian of log p(w|X, y) is negative deﬁnite (see
section A.9 for further details). The standard algorithm for ﬁnding the maxi-
mum is Newton’s method, which in this context is usually called the iteratively
reweighted least squares (IRLS) algorithm, as described e.g. in McCullagh and
Nelder [1983]. However, note that Minka [2003] provides evidence that other
optimization methods (e.g. conjugate gradient ascent) may be faster than IRLS.
Notice that a maximum likelihood treatment (corresponding to an unpe-
nalized version of eq. (3.6)) may result in some undesirable outcomes. If the
dataset is linearly separable (i.e. if there exists a hyperplane which separates the
positive and negative examples) then maximizing the (unpenalized) likelihood
will cause |w| to tend to inﬁnity, However, this will still give predictions in [0, 1]
for p(y = +1|x, w), although these predictions will be “hard” (i.e. zero or one).
If the problem is ill-conditioned, e.g. due to duplicate (or linearly dependent)
input dimensions, there will be no unique solution.

predictions

softmax
multiple logistic

As an example, consider linear logistic regression in the case where x-space
is two dimensional and there is no bias weight so that w is also two-dimensional.
The prior in weight space is Gaussian and for simplicity we have set Σp = I.
Contours of the prior p(w) are illustrated in Figure 3.1(a). If we have a data set
D as shown in Figure 3.1(b) then this induces a posterior distribution in weight
space as shown in Figure 3.1(c). Notice that the posterior is non-Gaussian
and unimodal, as expected. The dataset is not linearly separable but a weight
vector in the direction (1, 1)> is clearly a reasonable choice, as the posterior
distribution shows. To make predictions based the training set D for a test
point x∗ we have

p(y∗ =+1|x∗,D) =

p(y∗ =+1|w, x∗)p(w|D) dw,

(3.7)

Z

integrating the prediction p(y∗ =+1|w, x∗) = σ(x>
∗ w) over the posterior distri-
bution of weights. This leads to contours of the predictive distribution as shown
in Figure 3.1(d). Notice how the contours are bent, reﬂecting the integration
of many diﬀerent but plausible w’s.

In the multi-class case we use the multiple logistic (or softmax) function

where wc is the weight vector for class c, and all weight vectors are col-
lected into the matrix W . The corresponding log likelihood is of the form
i wc0))]. As in the binary case the log

i wc − log(P

PC
c=1 δc,yi[x>

c0 exp(x>

Pn

i=1

likelihood is a concave function of W .

It is interesting to note that in a generative approach where the class-
conditional distributions p(x|y) are Gaussian with the same covariance matrix,

p(y = Cc|x, W ) =

P
exp(x>wc)
c0 exp(x>wc0) ,

(3.8)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.3 Gaussian Process Classiﬁcation

39

(a)

(b)

(c)

(d)

Figure 3.1: Linear logistic regression: Panel (a) shows contours of the prior distri-
bution p(w) = N (0, I). Panel (b) shows the dataset, with circles indicating class +1
and crosses denoting class −1. Panel (c) shows contours of the posterior distribution
p(w|D). Panel (d) shows contours of the predictive distribution p(y∗ = +1|x∗).

p(y|x) has the form given by eq. (3.4) and eq. (3.8) for the two- and multi-class
cases respectively (when the constant function 1 is included in x).

3.3 Gaussian Process Classiﬁcation

For binary classiﬁcation the basic idea behind Gaussian process prediction
is very simple—we place a GP prior over the latent function f(x) and then
“squash” this through the logistic function to obtain a prior on π(x) , p(y =
+1|x) = σ(f(x)). Note that π is a deterministic function of f, and since f
is stochastic, so is π. This construction is illustrated in Figure 3.2 for a one-
It is a natural generalization of the linear logistic
dimensional input space.

latent function

−2−1012−2−1012w1w2−505−505x1x2−2−1012−2−1012w1w2−505−505x1x20.10.50.9C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

40

Classiﬁcation

(a)

(b)

Figure 3.2: Panel (a) shows a sample latent function f (x) drawn from a Gaussian
process as a function of x. Panel (b) shows the result of squashing this sample func-
tion through the logistic logit function, λ(z) = (1 + exp(−z))−1 to obtain the class
probability π(x) = λ(f (x)).

regression model and parallels the development from linear regression to GP
regression that we explored in section 2.1. Speciﬁcally, we replace the linear
f(x) function from the linear logistic model in eq. (3.6) by a Gaussian process,
and correspondingly the Gaussian prior on the weights by a GP prior.

The latent function f plays the rˆole of a nuisance function: we do not
observe values of f itself (we observe only the inputs X and the class labels y)
and we are not particularly interested in the values of f, but rather in π, in
particular for test cases π(x∗). The purpose of f is solely to allow a convenient
formulation of the model, and the computational goal pursued in the coming
sections will be to remove (integrate out) f.

We have tacitly assumed that the latent Gaussian process is noise-free, and
combined it with smooth likelihood functions, such as the logistic or probit.
However, one can equivalently think of adding independent noise to the latent
process in combination with a step-function likelihood. In particular, assuming
Gaussian noise and a step-function likelihood is exactly equivalent to a noise-
free8 latent process and probit likelihood, see exercise 3.10.1.

nuisance function

noise-free latent process

Inference is naturally divided into two steps: ﬁrst computing the distribution

of the latent variable corresponding to a test case

p(f∗|X, y, x∗) =

p(f∗|X, x∗, f)p(f|X, y) df ,

(3.9)

Z

Z

where p(f|X, y) = p(y|f)p(f|X)/p(y|X) is the posterior over the latent vari-
ables, and subsequently using this distribution over the latent f∗ to produce a
probabilistic prediction

¯π∗ , p(y∗ =+1|X, y, x∗) =

σ(f∗)p(f∗|X, y, x∗) df∗.

(3.10)

8This equivalence explains why no numerical problems arise from considering a noise-free
process if care is taken with the implementation, see also comment at the end of section 3.4.3.

−4−2024input, xlatent function, f(x)01input, xclass probability, π(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.4 The Laplace Approximation for the Binary GP Classiﬁer

41

In the regression case (with Gaussian likelihood) computation of predictions was
straightforward as the relevant integrals were Gaussian and could be computed
analytically.
In classiﬁcation the non-Gaussian likelihood in eq. (3.9) makes
the integral analytically intractable. Similarly, eq. (3.10) can be intractable
analytically for certain sigmoid functions, although in the binary case it is
only a one-dimensional integral so simple numerical techniques are generally
adequate.

Thus we need to use either analytic approximations of integrals, or solutions
based on Monte Carlo sampling. In the coming sections, we describe two ana-
lytic approximations which both approximate the non-Gaussian joint posterior
with a Gaussian one: the ﬁrst is the straightforward Laplace approximation
method [Williams and Barber, 1998], and the second is the more sophisticated
expectation propagation (EP) method due to Minka [2001]. (The cavity TAP ap-
proximation of Opper and Winther [2000] is closely related to the EP method.)
A number of other approximations have also been suggested, see e.g. Gibbs and
MacKay [2000], Jaakkola and Haussler [1999], and Seeger [2000]. Neal [1999]
describes the use of Markov chain Monte Carlo (MCMC) approximations. All
of these methods will typically scale as O(n3); for large datasets there has been
much work on further approximations to reduce computation time, as discussed
in chapter 8.

The Laplace approximation for the binary case is described in section 3.4,
and for the multi-class case in section 3.5. The EP method for binary clas-
siﬁcation is described in section 3.6. Relationships between Gaussian process
classiﬁers and other techniques such as spline classiﬁers, support vector ma-
chines and least-squares classiﬁcation are discussed in sections 6.3, 6.4 and 6.5
respectively.

3.4 The Laplace Approximation for the Binary

GP Classiﬁer

Laplace’s method utilizes a Gaussian approximation q(f|X, y) to the poste-
rior p(f|X, y) in the integral (3.9). Doing a second order Taylor expansion
of log p(f|X, y) around the maximum of the posterior, we obtain a Gaussian
approximation

q(f|X, y) = N (f|ˆf , A−1) ∝ exp(cid:0)− 1

2(f − ˆf)>A(f − ˆf)(cid:1),

(3.11)
where ˆf = argmaxf p(f|X, y) and A = −∇∇ log p(f|X, y)|f =ˆf is the Hessian of
the negative log posterior at that point.

The structure of the rest of this section is as follows: In section 3.4.1 we
describe how to ﬁnd ˆf and A. Section 3.4.2 explains how to make predictions
having obtained q(f|y), and section 3.4.3 gives more implementation details
for the Laplace GP classiﬁer. The Laplace approximation for the marginal
likelihood is described in section 3.4.4.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

42

Classiﬁcation

(a), logistic

(b), probit

Figure 3.3: The log likelihood and its derivatives for a single case as a function of
zi = yifi, for (a) the logistic, and (b) the cumulative Gaussian likelihood. The two
likelihood functions are fairly similar, the main qualitative diﬀerence being that for
large negative arguments the log logistic behaves linearly whereas the log cumulative
Gaussian has a quadratic penalty. Both likelihoods are log concave.

3.4.1 Posterior
By Bayes’ rule the posterior over the latent variables is given by p(f|X, y) =
p(y|f)p(f|X)/p(y|X), but as p(y|X) is independent of f, we need only consider
the un-normalized posterior when maximizing w.r.t. f. Taking the logarithm
and introducing expression eq. (2.29) for the GP prior gives

Ψ(f) , log p(y|f) + log p(f|X)

= log p(y|f) − 1
2

f>K−1f − 1
2

log |K| − n
2

log 2π.

(3.12)

Diﬀerentiating eq. (3.12) w.r.t. f we obtain

∇Ψ(f) = ∇ log p(y|f) − K−1f ,
∇∇Ψ(f) = ∇∇ log p(y|f) − K−1 = −W − K−1,

(3.13)
(3.14)
where W , −∇∇ log p(y|f) is diagonal, since the likelihood factorizes over
cases (the distribution for yi depends only on fi, not on fj6=i). Note, that if the
likelihood p(y|f) is log concave, the diagonal elements of W are non-negative,
and the Hessian in eq. (3.14) is negative deﬁnite, so that Ψ(f) is concave and
has a unique maximum (see section A.9 for further details).

There are many possible functional forms of the likelihood, which gives the
target class probability as a function of the latent variable f. Two commonly
used likelihood functions are the logistic, and the cumulative Gaussian, see
Figure 3.3. The expressions for the log likelihood for these likelihood functions
and their ﬁrst and second derivatives w.r.t. the latent variable are given in the

un-normalized posterior

log likelihoods
and their derivatives

−202−3−2−101latent times target, zi=yifi    log likelihood, log p(yi|fi)log likelihood1st derivative2nd derivative−202−6−4−202latent times target, zi=yifi    log likelihood, log p(yi|fi)log likelihood1st derivative2nd derivativeC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.4 The Laplace Approximation for the Binary GP Classiﬁer

43

following table:

log p(yi|fi)

− log(cid:0)1 + exp(−yifi)(cid:1)

∂
∂fi

log p(yi|fi)
ti − πi
yiN (fi)
Φ(yifi)

∂2
log p(yi|fi)
∂f 2
i
−πi(1 − πi)

(3.15)

(3.16)

log Φ(yifi)

where we have deﬁned πi = p(yi = 1|fi) and t = (y + 1)/2. At the maximum
of Ψ(f) we have

− N (fi)2
Φ(yifi)2 − yifiN (fi)
∇Ψ = 0 =⇒ ˆf = K(cid:0)∇ log p(y|ˆf)(cid:1),

(3.17)
as a self-consistent equation for ˆf (but since ∇ log p(y|ˆf) is a non-linear function
of ˆf, eq. (3.17) cannot be solved directly). To ﬁnd the maximum of Ψ we use
Newton’s method, with the iteration

Φ(yifi)

f new = f − (∇∇Ψ)−1∇Ψ = f + (K−1 + W )−1(∇ log p(y|f) − K−1f)

= (K−1 + W )−1(cid:0)W f + ∇ log p(y|f)(cid:1).

(3.18)

To gain more intuition about this update, let us consider what happens to
datapoints that are well-explained under f so that ∂ log p(yi|fi)/∂fi and Wii
are close to zero for these points. As an approximation, break f into two
subvectors, f1 that corresponds to points that are not well-explained, and f2 to
those that are. Then it is easy to show (see exercise 3.10.4) that

= K11(I11 + W11K11)−1(cid:0)W11f1 + ∇ log p(y1|f1)(cid:1),

(3.19)

f new
1
f new
2

= K21K−1

11 f new

1

,

where K21 denotes the n2 × n1 block of K containing the covariance between
is computed by ignoring
the two groups of points, etc. This means that f new
using the
entirely the well-explained points, and f new
usual GP prediction methods (i.e. treating these points like test points). Of
course, if the predictions of f new
fail to match the targets correctly they would
cease to be well-explained and so be updated on the next iteration.

is predicted from f new

2

1

2

1

Having found the maximum posterior ˆf, we can now specify the Laplace
approximation to the posterior as a Gaussian with mean ˆf and covariance matrix
given by the negative inverse Hessian of Ψ from eq. (3.14)

q(f|X, y) = N(cid:0)ˆf , (K−1 + W )−1(cid:1).

(3.20)

One problem with the Laplace approximation is that it is essentially un-
controlled, in that the Hessian (evaluated at ˆf) may give a poor approximation
to the true shape of the posterior. The peak could be much broader or nar-
rower than the Hessian indicates, or it could be a skew peak, while the Laplace
approximation assumes it has elliptical contours.

Newton’s method

intuition on inﬂuence of
well-explained points

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

44

Classiﬁcation

3.4.2 Predictions

latent mean

The posterior mean for f∗ under the Laplace approximation can be expressed
by combining the GP predictive mean eq. (2.25) with eq. (3.17) into

Eq[f∗|X, y, x∗] = k(x∗)>K−1ˆf = k(x∗)>∇ log p(y|ˆf).

(3.21)

Compare this with the exact mean, given by Opper and Winther [2000] as

Ep[f∗|X, y, x∗] =

=

E[f∗|f , X, x∗]p(f|X, y)df
k(x∗)>K−1f p(f|X, y)df = k(x∗)>K−1E[f|X, y],

(3.22)

Z
Z

where we have used the fact that for a GP E[f∗|f , X, x∗] = k(x∗)>K−1f and
have let E[f|X, y] denote the posterior mean of f given X and y. Notice the
similarity between the middle expression of eq. (3.21) and eq. (3.22), where the
exact (intractable) average E[f|X, y] has been replaced with the modal value
ˆf = Eq[f|X, y].

A simple observation from eq. (3.21) is that positive training examples will
give rise to a positive coeﬃcient for their kernel function (as ∇i log p(yi|fi) > 0
in this case), while negative examples will give rise to a negative coeﬃcient;
this is analogous to the solution to the support vector machine, see eq. (6.34).
Also note that training points which have ∇i log p(yi|fi) ’ 0 (i.e. that are
well-explained under ˆf) do not contribute strongly to predictions at novel test
points; this is similar to the behaviour of non-support vectors in the support
vector machine (see section 6.4).

We can also compute Vq[f∗|X, y], the variance of f∗|X, y under the Gaussian

approximation. This comprises of two terms, i.e.

Vq[f∗|X, y, x∗] = Ep(f∗|X,x∗,f )[(f∗ − E[f∗|X, x∗, f])2]

+ Eq(f|X,y)[(E[f∗|X, x∗, f] − E[f∗|X, y, x∗])2].

(3.23)

The ﬁrst term is due to the variance of f∗ if we condition on a particular value
of f, and is given by k(x∗, x∗) − k(x∗)>K−1k(x∗), cf. eq. (2.19). The second
term in eq. (3.23) is due to the fact that E[f∗|X, x∗, f] = k(x∗)>K−1f depends
on f and thus there is an additional term of k(x∗)>K−1 cov(f|X, y)K−1k(x∗).
Under the Gaussian approximation cov(f|X, y) = (K−1 + W )−1, and thus
∗ K−1(K−1 + W )−1K−1k∗

Vq[f∗|X, y, x∗] = k(x∗, x∗)−k>
= k(x∗, x∗)−k>

∗ K−1k∗ + k>
∗ (K + W −1)−1k∗,

(3.24)

where the last line is obtained using the matrix inversion lemma eq. (A.9).
Given the mean and variance of f∗, we make predictions by computing

¯π∗ ’ Eq[π∗|X, y, x∗] =

σ(f∗)q(f∗|X, y, x∗) df∗,

(3.25)

Z

sign of kernel
coeﬃcients

latent variance

averaged predictive
probability

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.4 The Laplace Approximation for the Binary GP Classiﬁer

45

MAP prediction

identical binary
decisions

where q(f∗|X, y, x∗) is Gaussian with mean and variance given by equations
3.21 and 3.24 respectively. Notice that because of the non-linear form of the
sigmoid the predictive probability from eq. (3.25) is diﬀerent from the sigmoid
of the expectation of f: ˆπ∗ = σ(Eq[f∗|y]). We will call the latter the MAP
prediction to distinguish it from the averaged predictions from eq. (3.25).

In fact, as shown in Bishop [1995, sec. 10.3], the predicted test labels
given by choosing the class of highest probability obtained by averaged and
MAP predictions are identical for binary 9 classiﬁcation. To see this, note
that the decision boundary using the the MAP value Eq[f∗|X, y, x∗] corre-
sponds to σ(Eq[f∗|X, y, x∗]) = 1/2 or Eq[f∗|X, y, x∗] = 0. The decision bound-
ary of the averaged prediction, Eq[π∗|X, y, x∗] = 1/2, also corresponds to
Eq[f∗|X, y, x∗] = 0. This follows from the fact that σ(f∗) − 1/2 is antisym-
metric while q(f∗|X, y, x∗) is symmetric.

Thus if we are concerned only about the most probable classiﬁcation, it is
not necessary to compute predictions using eq. (3.25). However, as soon as we
also need a conﬁdence in the prediction (e.g. if we are concerned about a reject
option) we need Eq[π∗|X, y, x∗]. If σ(z) is the cumulative Gaussian function
then eq. (3.25) can be computed analytically, as shown in section 3.9. On
the other hand if σ is the logistic function then we need to resort to sampling
methods or analytical approximations to compute this one-dimensional integral.
One attractive method is to note that the logistic function λ(z) is the c.d.f.
(cumulative density function) corresponding to the p.d.f. (probability density
function) p(z) = sech2(z/2)/4; this is known as the logistic or sech-squared
distribution, see Johnson et al. [1995, ch. 23]. Then by approximating p(z) as a
mixture of Gaussians, one can approximate λ(z) by a linear combination of error
functions. This approximation was used by Williams and Barber [1998, app. A]
and Wood and Kohn [1998]. Another approximation suggested in MacKay
[1992d] is ¯π∗ ’ λ(κ(f∗|y) ¯f∗), where κ2(f∗|y) = (1 + πVq[f∗|X, y, x∗]/8)−1.
The eﬀect of the latent predictive variance is, as the approximation suggests,
to “soften” the prediction that would be obtained using the MAP prediction
ˆπ∗ = λ( ¯f∗), i.e. to move it towards 1/2.

3.4.3

Implementation

We give implementations for ﬁnding the Laplace approximation in Algorithm
3.1 and for making predictions in Algorithm 3.2. Care is taken to avoid numer-
ically unstable computations while minimizing the computational eﬀort; both
can be achieved simultaneously. It turns out that several of the desired terms
can be expressed in terms of the symmetric positive deﬁnite matrix

B = I + W

(3.26)
computation of which costs only O(n2), since W is diagonal. The B matrix has
eigenvalues bounded below by 1 and bounded above by 1 + n maxij(Kij)/4, so
for many covariance functions B is guaranteed to be well-conditioned, and it is

1
2 KW

1
2 ,

9For multi-class predictions discussed in section 3.5 the situation is more complicated.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

46

Classiﬁcation

1
2 KW

1

2 )

B = I + W

1
2 KW

1
2

)

input: K (covariance matrix), y (±1 targets), p(y|f) (likelihood function)
initialization
Newton iteration
eval. W e.g. using eq. (3.15) or (3.16)

2: f := 0
repeat
4: W := −∇∇ log p(y|f)
L := cholesky(I + W
b := W f + ∇ log p(y|f)
a := b − W
2 L>\(L\(W
f := Ka

6:

1

1

8:

2 Kb))

i log Lii

objective: − 1

2 a>f + log p(y|f) −P

eq. (3.18) using eq. (3.27)
2 a>f + log p(y|f)
until convergence
10: log q(y|X, θ) := − 1
eq. (3.32)
return: ˆf := f (post. mode), log q(y|X, θ) (approx. log marg. likelihood)
Algorithm 3.1: Mode-ﬁnding for binary Laplace GPC. Commonly used convergence
criteria depend on the diﬀerence in successive values of the objective function Ψ(f )
from eq. (3.12), the magnitude of the gradient vector ∇Ψ(f ) from eq. (3.13) and/or the
magnitude of the diﬀerence in successive values of f . In a practical implementation
one needs to secure against divergence by checking that each iteration leads to an
increase in the objective (and trying a smaller step size if not). The computational
complexity is dominated by the Cholesky decomposition in line 5 which takes n3/6
operations (times the number of Newton iterations), all other operations are at most
quadratic in n.

thus numerically safe to compute its Cholesky decomposition LL> = B, which
is useful in computing terms involving B−1 and |B|.

The mode-ﬁnding procedure uses the Newton iteration given in eq. (3.18),
involving the matrix (K−1 +W )−1. Using the matrix inversion lemma eq. (A.9)
we get

(K−1 + W )−1 = K − KW

(3.27)
where B is given in eq. (3.26). The advantage is that whereas K may have
eigenvalues arbitrarily close to zero (and thus be numerically unstable to invert),
we can safely work with B. In addition, Algorithm 3.1 keeps the vector a =
K−1f in addition to f, as this allows evaluation of the part of the objective
Ψ(f) in eq. (3.12) which depends on f without explicit reference to K−1 (again
to avoid possible numerical problems).

2 B−1W

1
2 K,

1

Similarly, for the computation of the predictive variance Vq[f∗|y] from eq. (3.24)

we need to evaluate a quadratic form involving the matrix (K + W −1)−1. Re-
writing this as

(K + W −1)−1 = W

1

2 W − 1

2 (K + W −1)−1W − 1

2 W

1

2 = W

1

2 B−1W

1
2

(3.28)

achieves numerical stability (as opposed to inverting W itself, which may have
arbitrarily small eigenvalues). Thus the predictive variance from eq. (3.24) can
be computed as

Vq[f∗|y] = k(x∗, x∗) − k(x∗)>W

1

2 (LL>)−1W

1

2 k(x∗)

= k(x∗, x∗) − v>v, where v = L\(W

1

2 k(x∗)),

(3.29)

which was also used by Seeger [2003, p. 27].

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.4 The Laplace Approximation for the Binary GP Classiﬁer

47

input: ˆf (mode), X (inputs), y (±1 targets), k (covariance function),

p(y|f) (likelihood function), x∗ test input

2: W := −∇∇ log p(y|ˆf)
1
L := cholesky(I + W
2 KW
4: ¯f∗ := k(x∗)>∇ log p(y|ˆf)
6: V[f∗] := k(x∗, x∗) − v>v

v := L\(cid:0)W
¯π∗ :=R σ(z)N (z| ¯f∗, V[f∗])dz

2 k(x∗)(cid:1)

1

1

2 )

o

B = I + W

1
2 KW

1
2

eq. (3.21)

eq. (3.24) using eq. (3.29)
eq. (3.25)

8: return: ¯π∗ (predictive class probability (for class 1))
Algorithm 3.2: Predictions for binary Laplace GPC. The posterior mode ˆf (which
can be computed using Algorithm 3.1) is input. For multiple test inputs lines 4− 7 are
applied to each test input. Computational complexity is n3/6 operations once (line
3) plus n2 operations per test case (line 5). The one-dimensional integral in line 7
can be done analytically for cumulative Gaussian likelihood, otherwise it is computed
using an approximation or numerical quadrature.

In practice we compute the Cholesky decomposition LL> = B during the
Newton steps in Algorithm 3.1, which can be re-used to compute the predictive
variance by doing backsubstitution with L as discussed above.
In addition,
L may again be re-used to compute |In + W
2| = |B| (needed for the

computation of the marginal likelihood eq. (3.32)) as log |B| = 2P log Lii. To

save computation, one could use an incomplete Cholesky factorization in the
Newton steps, as suggested by Fine and Scheinberg [2002].

1
2 KW

1

Sometimes it is suggested that it can be useful to replace K by K +I where
 is a small constant, to improve the numerical conditioning10 of K. However,
by taking care with the implementation details as above this should not be
necessary.

3.4.4 Marginal Likelihood

incomplete Cholesky
factorization

Z

It will also be useful (particularly for chapter 5) to compute the Laplace ap-
proximation of the marginal likelihood p(y|X). (For the regression case with
Gaussian noise the marginal likelihood can again be calculated analytically, see
eq. (2.30).) We have

p(y|X) =

p(y|f)p(f|X) df =

(3.30)
Using a Taylor expansion of Ψ(f) locally around ˆf we obtain Ψ(f) ’ Ψ(ˆf) −
2(f −ˆf)>A(f −ˆf) and thus an approximation q(y|X) to the marginal likelihood
1
as

p(y|X) ’ q(y|X) = exp(cid:0)Ψ(ˆf)(cid:1)Z

exp(cid:0)− 1

2(f − ˆf)>A(f − ˆf)(cid:1) df .

(3.31)

Z

exp(cid:0)Ψ(f)(cid:1) df .

10Neal [1999] refers to this as adding “jitter” in the context of Markov chain Monte Carlo
(MCMC) based inference; in his work the latent variables f are explicitly represented in
the Markov chain which makes addition of jitter diﬃcult to avoid. Within the analytical
approximations of the distribution of f considered here, jitter is unnecessary.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

48

Classiﬁcation

This Gaussian integral can be evaluated analytically to obtain an approximation
to the log marginal likelihood

log q(y|X, θ) = − 1

ˆf>K−1ˆf + log p(y|ˆf) − 1

(3.32)
where |B| = |K| · |K−1 + W| = |In + W
2|, and θ is a vector of hyper-
parameters of the covariance function (which have previously been suppressed
from the notation for brevity).

1
2 KW

2 log |B|,

2

1

∗

3.5 Multi-class Laplace Approximation

f = (cid:0)f 1

(cid:1)>

Our presentation follows Williams and Barber [1998]. We ﬁrst introduce the
vector of latent function values at all n training points and for all C classes

.

(3.33)

n, f 2

1 , . . . , f 2

n, . . . , f C

1 , . . . , f C
n

1 , . . . , f 1
Thus f has length Cn.
In the following we will generally refer to quantities
pertaining to a particular class with superscript c, and a particular case by
subscript i (as usual); thus e.g. the vector of C latents for a particular case is
fi. However, as an exception, vectors or matrices formed from the covariance
function for class c will have a subscript c. The prior over f has the form
f ∼ N (0, K). As we have assumed that the C latent processes are uncorrelated,
the covariance matrix K is block diagonal in the matrices K1, . . . , KC. Each
individual matrix Kc expresses the correlations of the latent function values
within the class c. Note that the covariance functions pertaining to the diﬀerent
classes can be diﬀerent. Let y be a vector of the same length as f which for
each i = 1, . . . , n has an entry of 1 for the class which is the label for example
i and 0 for the other C − 1 entries.

softmax

un-normalized posterior

Let πc

i denote output of the softmax at training point i, i.e.

p(yc

i|fi) = πc

i =

P

i )
exp(f c
i ) .
c0 exp(f c0

(3.34)

Then π is a vector of the same length as f with entries πc
analogue of eq. (3.12) is the log of the un-normalized posterior

i . The multi-class

2 f>K−1f +y>f− nX

log(cid:0) CX

Ψ(f) , − 1

(cid:1)− 1

exp f c
i

2 log |K|− Cn

2 log 2π. (3.35)

As in the binary case we seek the MAP value ˆf of p(f|X, y). By diﬀerentiating
eq. (3.35) w.r.t. f we obtain

i=1

c=1

(3.36)
Thus at the maximum we have ˆf = K(y − ˆπ). Diﬀerentiating again, and using

∇Ψ = −K−1f + y − π.

exp(f j

i ) = πc

i δcc0 + πc

i πc0
i ,

(3.37)

logX

j

− ∂2
∂f c

i ∂f c0

i

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.5 Multi-class Laplace Approximation

49

we obtain11

∇∇Ψ = −K−1 − W, where W , diag(π) − ΠΠ>,

(3.38)
where Π is a Cn×n matrix obtained by stacking vertically the diagonal matrices
diag(πc), and πc is the subvector of π pertaining to class c. As in the binary case
notice that −∇∇Ψ is positive deﬁnite, thus Ψ(f) is concave and the maximum
is unique (see also exercise 3.10.2).

predictive
distribution for f∗

Z

As in the binary case we use Newton’s method to search for the mode of Ψ,

giving

f new = (K−1 + W )−1(W f + y − π).

(3.39)
This update if coded na¨ıvely would take O(C 3n3) as matrices of size Cn have to
be inverted. However, as described in section 3.5.1, we can utilize the structure
of W to bring down the computational load to O(Cn3).

The Laplace approximation gives us a Gaussian approximation q(f|X, y) to
the posterior p(f|X, y). To make predictions at a test point x∗ we need to com-
pute the posterior distribution q(f∗|X, y, x∗) where f(x∗) , f∗ = (f 1∗ , . . . , f C∗ )>.
In general we have

q(f∗|X, y, x∗) =

p(f∗|X, x∗, f)q(f|X, y) df .

(3.40)
As p(f∗|X, x∗, f) and q(f|X, y) are both Gaussian, q(f∗|X, y, x∗) will also be
Gaussian and we need only compute its mean and covariance. The predictive
mean for class c is given by

Eq[f c(x∗)|X, y, x∗] = kc(x∗)>K−1

c

ˆf c = kc(x∗)>(yc − ˆπc),

(3.41)

where kc(x∗) is the vector of covariances between the test point and each of
the training points for the cth covariance function, and ˆf c is the subvector of
ˆf pertaining to class c. The last equality comes from using eq. (3.36) at the
maximum ˆf. Note the close correspondence to eq. (3.21). This can be put into
a vector form Eq[f∗|y] = Q>

∗ (y − ˆπ) by deﬁning the Cn × C matrix
k1(x∗)

0



0
...
0

Q∗ =

 .

k2(x∗)

...
0

0
0
...

. . .
. . .
...
. . . kC(x∗)

(3.42)

(3.43)

Using a similar argument to eq. (3.23) we obtain

covq(f∗|X, y, x∗) = Σ + Q>

∗ K−1(K−1 + W )−1K−1Q∗

= diag(k(x∗, x∗)) − Q>

∗ (K + W −1)−1Q∗,

where Σ is a diagonal C × C matrix with Σcc = kc(x∗, x∗)− k>
c (x∗)K−1
and k(x∗, x∗) is a vector of covariances, whose c’th element is kc(x∗, x∗).

c kc(x∗),

11There is a sign error in equation 23 of Williams and Barber [1998] but not in their

implementation.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

50

Classiﬁcation

input: K (covariance matrix), y (0/1 targets)

2: f := 0
repeat

initialization
Newton iteration
compute π and Π from f with eq. (3.34) and defn. of Π under eq. (3.38)
for c := 1 . . . C do

4:

6:

c )
E is block diag. D

1

2 (ICn + D

1

1
2 KD

2 )−1D
2 log determinant

1
2

compute 1

1
2
c KcD

1
2

zc :=P

L := cholesky(In + D
c L>\(L\D
Ec := D
c )
i log Lii

1
2

1
2

8:

10: M := cholesky(P

c Ec)

end for
b := (D − ΠΠ>)f + y − π
c := EKb
a := b− c + ERM>\(M\(R>c))
f := Ka

12:

14:

b = W f + y − π from eq. (3.39)

)
2 a>f + y>f +P
i log(cid:0)P
c)(cid:1) −P

c exp(f i

i log(cid:0)P

eq. (3.39) using eq. (3.45) and (3.47)

c)(cid:1)

2 a>f + y>f +P

objective: − 1

c exp(f i
until convergence
16: log q(y|X, θ) := − 1
eq. (3.44)
return: ˆf := f (post. mode), log q(y|X, θ) (approx. log marg. likelihood)
Algorithm 3.3: Mode-ﬁnding for multi-class Laplace GPC, where D = diag(π), R
is a matrix of stacked identity matrices and a subscript c on a block diagonal matrix
indicates the n × n submatrix pertaining to class c. The computational complexity
is dominated by the Cholesky decomposition in lines 6 and 10 and the forward and
backward substitutions in line 7 with total complexity O((C + 1)n3) (times the num-
ber of Newton iterations), all other operations are at most O(Cn2) when exploiting
diagonal and block diagonal structures. The memory requirement is O(Cn2). For
comments on convergence criteria for line 15 and avoiding divergence, refer to the
caption of Algorithm 3.1 on page 46.

c zc

We now need to consider the predictive distribution q(π∗|y) which is ob-
tained by softmaxing the Gaussian q(f∗|y). In the binary case we saw that the
predicted classiﬁcation could be obtained by thresholding the mean value of the
Gaussian. In the multi-class case one does need to take the variability around
the mean into account as it can aﬀect the overall classiﬁcation (see exercise
3.10.3). One simple way (which will be used in Algorithm 3.4) to estimate
the mean prediction Eq[π∗|y]
is to draw samples from the Gaussian q(f∗|y),
softmax them and then average.

marginal likelihood

The Laplace approximation to the marginal likelihood can be obtained in

the same way as for the binary case, yielding
log p(y|X, θ) ’ log q(y|X, θ)

ˆf>K−1ˆf + y>ˆf − nX

= − 1

2

(cid:16) CX

log

exp ˆf c

i

(cid:17) − 1

2 log |ICn + W

(3.44)
2|.

1

1
2 KW

i=1

c=1

As for the inversion of K−1 + W , the determinant term can be computed eﬃ-
ciently by exploiting the structure of W , see section 3.5.1.

In this section we have described the Laplace approximation for multi-class
classiﬁcation. However, there has also been some work on EP-type methods for
the multi-class case, see Seeger and Jordan [2004].

1
2
c KcD

1
2

c )

for c := 1 . . . C do

4:

1
2

L := cholesky(In + D
c L>\(L\D
Ec := D
c )

M := cholesky(P

1
2

6: end for

8: for c := 1 . . . C do

c Ec)
µc∗ := (yc − πc)>kc∗
b := Eckc∗
c := Ec(R(M>\(M\(R>b))))
for c0 := 1 . . . C do

Σcc0 := c>kc0
∗

end for
Σcc := Σcc + kc(x∗, x∗) − b>kc∗

10:

12:

14:

E is block diag. D

1

2 (ICn + D

1
2 KD

1

2 )−1D

1
2

latent test mean from eq. (3.41)

)

latent test covariance from eq. (3.43)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.5 Multi-class Laplace Approximation

51

input: K (covariance matrix), ˆf (posterior mode), x∗ (test input)

2: compute π and Π from ˆf using eq. (3.34) and defn. of Π under eq. (3.38)

16: end for
π∗ := 0

18: for i := 1 : S do
f∗ ∼ N (µ∗, Σ)

π∗ := π∗ + exp(f c∗)/P

20:

initialize Monte Carlo loop to estimate
predictive class probabilities using S samples
sample latent values from joint Gaussian posterior
c0 exp(f c0
accumulate probability eq. (3.34)
∗ )

22: ¯π∗ := π∗/S

end for
normalize MC estimate of prediction vector
return: Eq(f )[π(f(x∗))|x∗, X, y] := ¯π∗ (predicted class probability vector)
Algorithm 3.4: Predictions for multi-class Laplace GPC, where D = diag(π), R is
a matrix of stacked identity matrices and a subscript c on a block diagonal matrix
indicates the n × n submatrix pertaining to class c. The computational complexity
is dominated by the Cholesky decomposition in lines 4 and 7 with a total complexity
O((C + 1)n3), the memory requirement is O(Cn2). For multiple test cases repeat
from line 8 for each test case (in practice, for multiple test cases one may reorder the
computations in lines 8-16 to avoid referring to all Ec matrices repeatedly).

3.5.1

Implementation

The implementation follows closely the implementation for the binary case de-
tailed in section 3.4.3, with the slight complications that K is now a block
diagonal matrix of size Cn × Cn and the W matrix is no longer diagonal, see
eq. (3.38). Care has to be taken to exploit the structure of these matrices to
reduce the computational burden.

The Newton iteration from eq. (3.39) requires the inversion of K−1 + W ,

which we ﬁrst re-write as

(K−1 + W )−1 = K − K(K + W −1)−1K,

(3.45)

using the matrix inversion lemma, eq. (A.9). In the following the inversion of
the above matrix K + W −1 is our main concern. First, however, we apply the

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

52

Classiﬁcation

matrix inversion lemma, eq. (A.9) to the W matrix:12

W −1 = (D − ΠΠ>)−1 = D−1 − R(I − R>DR)−1R>

(3.46)

= D−1 − RO−1R>,

where D = diag(π), R = D−1Π is a Cn× n matrix of stacked In unit matrices,
c Dc = In and O is
the zero matrix. Introducing the above in K + W −1 and applying the matrix
inversion lemma, eq. (A.9) again we have
(K + W −1)−1 = (K + D−1 − RO−1R>)−1

we use the fact that π normalizes over classes: R>DR =P
= E − ER(O + R>ER)−1R>E = E − ER(P

and R>ER =P

(3.47)
c Ec)−1R>E.
2 is a block diagonal matrix
c Ec. The Newton iterations can now be computed by inserting
eq. (3.47) and (3.45) in eq. (3.39), as detailed in Algorithm 3.3. The predictions
use an equivalent route to compute the Gaussian posterior, and the ﬁnal step
of deriving predictive class probabilities is done by Monte Carlo, as shown in
Algorithm 3.4.

where E = (K + D−1)−1 = D

1

2 )−1D

1

1

2 (I + D

1
2 KD

3.6 Expectation Propagation

The expectation propagation (EP) algorithm [Minka, 2001] is a general approxi-
mation tool with a wide range of applications. In this section we present only its
application to the speciﬁc case of a GP model for binary classiﬁcation. We note
that Opper and Winther [2000] presented a similar method for binary GPC
based on the ﬁxed-point equations of the Thouless-Anderson-Palmer (TAP)
type of mean-ﬁeld approximation from statistical physics. The ﬁxed points for
the two methods are the same, although the precise details of the two algorithms
are diﬀerent. The EP algorithm naturally lends itself to sparse approximations,
which will not be discussed in detail here, but touched upon in section 8.4.

The object of central importance is the posterior distribution over the latent
variables, p(f|X, y). In the following notation we suppress the explicit depen-
dence on hyperparameters, see section 3.6.2 for their treatment. The posterior
is given by Bayes’ rule, as the product of a normalization term, the prior and
the likelihood

p(f|X, y) =

p(f|X)

(3.48)
where the prior p(f|X) is Gaussian and we have utilized the fact that the likeli-
hood factorizes over the training cases. The normalization term is the marginal
likelihood

i=1

p(yi|fi),

Z = p(y|X) =

p(f|X)

p(yi|fi) df .

(3.49)

nY

nY

1
Z

Z

12Readers who are disturbed by our sloppy treatment of the inverse of singular matrices
are invited to insert the matrix (1 − ε)In between Π and Π> in eq. (3.46) and verify that
eq. (3.47) coincides with the limit ε → 0.

i=1

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.6 Expectation Propagation

53

So far, everything is exactly as in the regression case discussed in chapter 2.
However, in the case of classiﬁcation the likelihood p(yi|fi) is not Gaussian,
a property that was used heavily in arriving at analytical solutions for the
regression framework. In this section we use the probit likelihood (see page 35)
for binary classiﬁcation

(3.50)
and this makes the posterior in eq. (3.48) analytically intractable. To overcome
this hurdle in the EP framework we approximate the likelihood by a local like-
lihood approximation 13 in the form of an un-normalized Gaussian function in
the latent variable fi

p(yi|fi) = Φ(fiyi),

p(yi|fi) ’ ti(fi| ˜Zi, ˜µi, ˜σ2

i ) , ˜ZiN (fi|˜µi, ˜σ2
i ),

(3.51)

site parameters

which deﬁnes the site parameters ˜Zi, ˜µi and ˜σ2
i . Remember that the notation
N is used for a normalized Gaussian distribution. Notice that we are approxi-
mating the likelihood, i.e. a probability distribution which normalizes over the
targets yi, by an un-normalized Gaussian distribution over the latent variables
fi. This is reasonable, because we are interested in how the likelihood behaves
as a function of the latent fi. In the regression setting we utilized the Gaussian
shape of the likelihood, but more to the point, the Gaussian distribution for
the outputs yi also implied a Gaussian shape as a function of the latent vari-
able fi. In order to compute the posterior we are of course primarily interested
in how the likelihood behaves as a function of fi.14 The property that the
likelihood should normalize over yi (for any value of fi) is not simultaneously
achievable with the desideratum of Gaussian dependence on fi; in the EP ap-
proximation we abandon exact normalization for tractability. The product of
the (independent) local likelihoods ti is

nY

i ) = N (˜µ, ˜Σ)Y

ti(fi| ˜Zi, ˜µi, ˜σ2

˜Zi,

(3.52)

i=1

i

where ˜µ is the vector of ˜µi and ˜Σ is diagonal with ˜Σii = ˜σ2
the posterior p(f|X, y) by q(f|X, y)

i . We approximate

nY

i=1

q(f|X, y) , 1
ZEP
with µ = Σ˜Σ−1 ˜µ, and Σ = (K−1 + ˜Σ−1)−1,

ti(fi| ˜Zi, ˜µi, ˜σ2

p(f|X)

i ) = N (µ, Σ),

(3.53)

where we have used eq. (A.7) to compute the product (and by deﬁnition, we
know that the distribution must normalize correctly over f). Notice, that we use
the tilde-parameters ˜µ and ˜Σ (and ˜Z) for the local likelihood approximations,

13Note, that although each likelihood approximation is local, the posterior approximation
produced by the EP algorithm is global because the latent variables are coupled through the
prior.

14However, for computing the marginal likelihood normalization becomes crucial, see section

3.6.2.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

54

Classiﬁcation

and plain µ and Σ for the parameters of the approximate posterior. The nor-
malizing term of eq. (3.53), ZEP = q(y|X), is the EP algorithm’s approximation
to the normalizing term Z from eq. (3.48) and eq. (3.49).

KL divergence

How do we choose the parameters of the local approximating distributions
ti? One of the most obvious ideas would be to minimize the Kullback-Leibler
(KL) divergence (see section A.5) between the posterior and its approximation:

KL(cid:0)p(f|X, y)||q(f|X, y)(cid:1). Direct minimization of this KL divergence for the
choose to minimize the reversed KL divergence KL(cid:0)q(f|X, y)||p(f|X, y)(cid:1) with

joint distribution on f turns out to be intractable.
(One can alternatively
respect to the distribution q(f|X, y); this has been used to carry out variational
inference for GPC, see, e.g. Seeger [2000].)

Instead, the key idea in the EP algorithm is to update the individual ti ap-
proximations sequentially. Conceptually this is done by iterating the following
four steps: we start from some current approximate posterior, from which we
leave out the current ti, giving rise to a marginal cavity distribution. Secondly,
we combine the cavity distribution with the exact likelihood p(yi|fi) to get the
desired (non-Gaussian) marginal. Thirdly, we choose a Gaussian approximation
to the non-Gaussian marginal, and in the ﬁnal step we compute the ti which
makes the posterior have the desired marginal from step three. These four steps
are iterated until convergence.

In more detail, we optimize the ti approximations sequentially, using the
approximation so far for all the other variables. In particular the approximate
posterior for fi contains three kinds of terms:

1. the prior p(f|X)
2. the local approximate likelihoods tj for all cases j 6= i
3. the exact likelihood for case i, p(yi|fi) = Φ(yifi)

Our goal is to combine these sources of information and choose parameters of ti
such that the marginal posterior is as accurate as possible. We will ﬁrst combine
the prior and the local likelihood approximations into the cavity distribution

Z

p(f|X)Y

j6=i

q−i(fi) ∝

tj(fj| ˜Zj, ˜µj, ˜σ2

j )dfj,

(3.54)

and subsequently combine this with the exact likelihood for case i. Concep-
tually, one can think of the combination of prior and the n − 1 approximate
likelihoods in eq. (3.54) in two ways, either by explicitly multiplying out the
terms, or (equivalently) by removing approximate likelihood i from the approx-
imate posterior in eq. (3.53). Here we will follow the latter approach. The
marginal for fi from q(f|X, y) is obtained by using eq. (A.6) in eq. (3.53) to
give

(3.55)
i = Σii. This marginal eq. (3.55) contains one approximate term

q(fi|X, y) = N (fi|µi, σ2
i ),

where σ2

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.6 Expectation Propagation

55

(namely ti) “too many”, so we need to divide it by ti to get the cavity dis-
tribution

cavity distribution

q−i(fi) , N (fi|µ−i, σ2−i),
i µi − ˜σ−2

where µ−i = σ2−i(σ−2

i ˜µi), and σ2−i = (σ−2

i − ˜σ−2

i

(3.56)

)−1.

Note that the cavity distribution and its parameters carry the subscript −i,
indicating that they include all cases except number i. The easiest way to
verify eq. (3.56) is to multiply the cavity distribution by the local likelihood
approximation ti from eq. (3.51) using eq. (A.7) to recover the marginal in
eq. (3.55). Notice that despite the appearance of eq. (3.56), the cavity mean
and variance are (of course) not dependent on ˜µi and ˜σ2

i , see exercise 3.10.5.

To proceed, we need to ﬁnd the new (un-normalized) Gaussian marginal
which best approximates the product of the cavity distribution and the exact
likelihood

(3.57)
It is well known that when q(x) is Gaussian, the distribution q(x) which min-

imizes KL(cid:0)p(x)||q(x)(cid:1) is the one whose ﬁrst and second moments match that

i ) ’ q−i(fi)p(yi|fi).

ˆq(fi) , ˆZiN (ˆµi, ˆσ2

of p(x), see eq. (A.24). As ˆq(fi) is un-normalized we choose additionally to
impose the condition that the zero-th moments (normalizing constants) should
match when choosing the parameters of ˆq(fi) to match the right hand side of
eq. (3.57). This process is illustrated in Figure 3.4.

The derivation of the moments is somewhat lengthy, so we have moved the

details to section 3.9. The desired posterior marginal moments are

ˆZi = Φ(zi),
i = σ2−i − σ4−iN (zi)
(1 + σ2−i)Φ(zi)

ˆµi = µ−i +
N (zi)
Φ(zi)

zi +

(cid:16)

ˆσ2

yiσ2−iN (zi)
√
(cid:17)
Φ(zi)
1 + σ2−i

where

,

,

(3.58)

√

zi = yiµ−i
1 + σ2−i

.

The ﬁnal step is to compute the parameters of the approximation ti which
achieves a match with the desired moments. In particular, the product of the
cavity distribution and the local approximation must have the desired moments,
leading to

˜µi = ˜σ2
˜Zi = ˆZi

p
i ˆµi − σ−2−i µ−i),
i (ˆσ−2
√
2π

i exp(cid:0) 1

σ2−i + ˜σ2

i = (ˆσ−2
˜σ2

i − σ−2−i )−1,
2(µ−i − ˜µi)2/(σ2−i + ˜σ2

i )(cid:1),

(3.59)

which is easily veriﬁed by multiplying the cavity distribution by the local ap-
proximation using eq. (A.7) to obtain eq. (3.58). Note that the desired marginal
posterior variance ˆσ2
i given by eq. (3.58) is guaranteed to be smaller than the
cavity variance, such that ˜σ2

i > 0 is always satisﬁed.15

This completes the update for a local likelihood approximation ti. We then
have to update the approximate posterior using eq. (3.53), but since only a

15In cases where the likelihood is log concave, one can show that ˜σ2

i > 0, but for a general

likelihood there may be no such guarantee.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

56

Classiﬁcation

(a)

(b)

Figure 3.4: Approximating a single likelihood term by a Gaussian. Panel (a) dash-
dotted: the exact likelihood, Φ(fi) (the corresponding target being yi = 1) as a
function of the latent fi, dotted: Gaussian cavity distribution N (fi|µ−i = 1, σ2−i = 9),
solid: posterior, dashed: posterior approximation. Panel (b) shows an enlargement of
panel (a).

single site has changed one can do this with a computationally eﬃcient rank-
one update, see section 3.6.3. The EP algorithm is used iteratively, updating
each local approximation in turn. It is clear that several passes over the data
are required, since an update of one local approximation potentially inﬂuences
all of the approximate marginal posteriors.

3.6.1 Predictions

The procedure for making predictions in the EP framework closely resembles
the algorithm for the Laplace approximation in section 3.4.2. EP gives a Gaus-
sian approximation to the posterior distribution, eq. (3.53). The approximate
predictive mean for the latent variable f∗ becomes

Eq[f∗|X, y, x∗] = k>

∗ K−1µ = k>
= k>

∗ K−1(K−1 + ˜Σ−1)−1 ˜Σ−1 ˜µ
∗ (K + ˜Σ)−1 ˜µ.

(3.60)

The approximate latent predictive variance is analogous to the derivation from
eq. (3.23) and eq. (3.24), with ˜Σ playing the rˆole of W

Vq[f∗|X, y, x∗] = k(x∗, x∗) − k>

∗ (K + ˜Σ)−1k∗.

(3.61)

q(y∗ = 1|X, y, x∗) = Eq[π∗|X, y, x∗] =

The approximate predictive distribution for the binary target becomes
Φ(f∗)q(f∗|X, y, x∗) df∗,

(3.62)
where q(f∗|X, y, x∗) is the approximate latent predictive Gaussian with mean
and variance given by eq. (3.60) and eq. (3.61). This integral is readily evaluated
using eq. (3.80), giving the predictive probability

Z

(cid:17)

q(y∗ = 1|X, y, x∗) = Φ

k>
∗ (K + ˜Σ)−1 ˜µ

1 + k(x∗, x∗) − k>

∗ (K + ˜Σ)−1k∗

.

(3.63)

(cid:16)

p

−5051000.20.40.60.81likelihoodcavityposteriorapproximation−5051000.020.040.060.080.10.120.14C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.6 Expectation Propagation

3.6.2 Marginal Likelihood

57

The EP approximation to the marginal likelihood can be found from the nor-
malization of eq. (3.53)

Z

nY

ZEP = q(y|X) =

p(f|X)

ti(fi| ˜Zi, ˜µi, ˜σ2

i ) df .

(3.64)

Using eq. (A.7) and eq. (A.8) in an analogous way to the treatment of the
regression setting in equations (2.28) and (2.30) we arrive at

i=1

log(ZEP|θ) = −1
2
√

log Φ(cid:0) yiµ−i

log |K + ˜Σ| − 1
nX
2

(cid:1) +

nX

+

1
2

i=1

i=1

1 + σ2−i

˜µ>(K + ˜Σ)−1 ˜µ

log(σ2−i + ˜σ2

i ) +

nX

i=1

(3.65)

(µ−i − ˜µi)2
i ) ,
2(σ2−i + ˜σ2

where θ denotes the hyperparameters of the covariance function. This expres-
sion has a nice intuitive interpretation: the ﬁrst two terms are the marginal
likelihood for a regression model for ˜µ, each component of which has inde-
pendent Gaussian noise of variance ˜Σii (as ˜Σ is diagonal), cf. eq. (2.30). The
remaining three terms come from the normalization constants ˜Zi. The ﬁrst
of these penalizes the cavity (or leave-one-out) distributions for not agreeing
with the classiﬁcation labels, see eq. (3.82). In other words, we can see that
the marginal likelihood combines two desiderata, (1) the means of the local
likelihood approximations should be well predicted by a GP, and (2) the corre-
sponding latent function, when ignoring a particular training example, should
be able to predict the corresponding classiﬁcation label well.

3.6.3

Implementation

The implementation for the EP algorithm follows the derivation in the previous
section closely, except that care has to be taken to achieve numerical stability,
in similar ways to the considerations for Laplace’s method in section 3.4.3.
In addition, we wish to be able to speciﬁcally handle the case were some site
variances ˜σ2
i may tend to inﬁnity; this corresponds to ignoring the corresponding
likelihood terms, and can form the basis of sparse approximations, touched upon
in section 8.4. In this limit, everything remains well-deﬁned, although this is
not obvious e.g. from looking at eq. (3.65). It turns out to be slightly more
convenient to use natural parameters ˜τi, ˜νi and τ−i, ν−i for the site and cavity
parameters
˜τi = ˜σ−2
i ,
rather than ˜σ2
importance is

ν−i = τ−iµ−i (3.66)
i , ˜µi and σ2−i, µ−i themselves. The symmetric matrix of central

τ−i = σ−2−i ,

˜S = diag(˜τ ),

˜ν = ˜S ˜µ,

(3.67)
which plays a rˆole equivalent to eq. (3.26). Expressions involving the inverse of
B are computed via Cholesky factorization, which is numerically stable since

B = I + ˜S

1
2 ,

1

2 K ˜S

natural parameters

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

58

Classiﬁcation

input: K (covariance matrix), y (±1 targets)

2: ˜ν := 0, ˜τ := 0, Σ := K, µ := 0

initialization and eq. (3.53)

repeat

o

4:

6:

8:

10:

12:

14:

for i := 1 to n do
i − ˜τi
i µi − ˜νi
i − τ−i − ˜τi and ˜τi := ˜τi + ∆˜τ
o
i ˆµi − ν−i

τ−i := σ−2
ν−i := σ−2
compute the marginal moments ˆµi and ˆσ2
∆˜τ := ˆσ−2
i
˜νi := ˆσ−2

Σ := Σ −(cid:0)(∆˜τ)−1 + Σii

(cid:1)−1si s>

i

o

compute approximate cavity para-
meters ν−i and τ−i using eq. (3.56)
using eq. (3.58)
update site parameters
˜τi and ˜νi using eq. (3.59)
update Σ and µ by eq. (3.70) and
eq. (3.53). si is column i of Σ

µ := Σ˜ν

end for
L := cholesky(In + ˜S
2 )
V := L>\ ˜S
Σ := K − V >V and µ := Σ˜ν

2 K ˜S

1
2 K

1

1

)

re-compute the approximate
posterior parameters Σ and µ
using eq. (3.53) and eq. (3.68)

16: until convergence
compute log ZEP

using eq. (3.65), (3.73) and (3.74) and the existing L
18: return: ˜ν, ˜τ (natural site param.), log ZEP (approx. log marg. likelihood)
Algorithm 3.5: Expectation Propagation for binary classiﬁcation. The targets y are
used only in line 7. In lines 13-15 the parameters of the approximate posterior are
re-computed (although they already exist); this is done because of the large number of
rank-one updates in line 10 which would eventually cause loss of numerical precision
in Σ. The computational complexity is dominated by the rank-one updates in line
10, which takes O(n2) per variable, i.e. O(n3) for an entire sweep over all variables.
Similarly re-computing Σ in lines 13-15 is O(n3).

the eigenvalues of B are bounded below by one. The parameters of the Gaussian
approximate posterior from eq. (3.53) are computed as
Σ = (K−1 + ˜S)−1 = K − K(K + ˜S−1)−1K = K − K ˜S

2 K. (3.68)

2 B−1 ˜S

1

1

After updating the parameters of a site, we need to update the approximate
posterior eq. (3.53) taking the new site parameters into account. For the inverse
covariance matrix of the approximate posterior we have from eq. (3.53)
Σ−1 = K−1 + ˜S, and thus Σ−1
)eie>
i , (3.69)
where ei is a unit vector in direction i, and we have used that ˜S = diag(˜τ ).
Using the matrix inversion lemma eq. (A.9), on eq. (3.69) we obtain the new Σ

new = K−1 + ˜Sold + (˜τ new

i − ˜τ old

i

Σnew = Σold −

i − ˜τ old
˜τ new
i − ˜τ old
1 + (˜τ new

i

i

)Σold
ii

sis>
i ,

(3.70)

in time O(n2), where si is the i’th column of Σold. The posterior mean is then
calculated from eq. (3.53).

In the EP algorithm each site is updated in turn, and several passes over all
sites are required. Pseudocode for the EP-GPC algorithm is given in Algorithm

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.6 Expectation Propagation

59

input: ˜ν, ˜τ (natural site param.), X (inputs), y (±1 targets),

1

2 )

1

1

1

z := ˜S

2 K ˜S
2 K ˜ν))

2 L>\(L\( ˜S

v := L\(cid:0) ˜S

2: L := cholesky(In + ˜S
4: ¯f∗ := k(x∗)>(˜ν − z)
6: V[f∗] := k(x∗, x∗) − v>v
1 + V[f∗])

2 k(x∗)(cid:1)

¯π∗ := Φ( ¯f∗/

√

1

k (covariance function), x∗ test input
2 K ˜S
eq. (3.60) using eq. (3.71)

B = In + ˜S

1
2

1

o
o

eq. (3.61) using eq. (3.72)
eq. (3.63)

8: return: ¯π∗ (predictive class probability (for class 1))
Algorithm 3.6: Predictions for expectation propagation. The natural site parameters
˜ν and ˜τ of the posterior (which can be computed using algorithm 3.5) are input. For
multiple test inputs lines 4-7 are applied to each test input. Computational complexity
is n3/6 + n2 operations once (line 2 and 3) plus n2 operations per test case (line
5), although the Cholesky decomposition in line 2 could be avoided by storing it in
Algorithm 3.5. Note the close similarity to Algorithm 3.2 on page 47.

3.5. There is no formal guarantee of convergence, but several authors have
reported that EP for Gaussian process models works relatively well.16

For the predictive distribution, we get the mean from eq. (3.60) which is

evaluated using
Eq[f∗|X, y, x∗] = k>

∗ (K + ˜S−1)−1 ˜S−1 ˜ν = k>
= k>

∗ (I − ˜S
and the predictive variance from eq. (3.61) similarly by

∗(cid:0)I − (K + ˜S−1)−1K(cid:1)˜ν

1

2 B−1 ˜S

1

2 K)˜ν,

Vq[f∗|X, y, x∗] = k(x∗, x∗) − k>
∗ (K + ˜S−1)−1k∗
= k(x∗, x∗) − k>
∗ ˜S
2 k∗.

2 B−1 ˜S

1

1

(3.71)

(3.72)

Pseudocode for making predictions using EP is given in Algorithm 3.6.

Finally, we need to evaluate the approximate log marginal likelihood from
eq. (3.65). There are several terms which need careful consideration, principally
due to the fact the ˜τi values may be arbitrarily small (and cannot safely be
inverted). We start with the fourth and ﬁrst terms of eq. (3.65)
X
2 log | ˜S−1(I + ˜ST −1)| − 1

2 log |T −1+ ˜S−1| − 1

log(1+˜τiτ−1−i ) −X

2 log |K + ˜Σ| = 1
= 1
2

2 log | ˜S−1B|
log Lii,

(3.73)

1

i

i

where T is a diagonal matrix of cavity precisions Tii = τ−i = σ−2−i and L is the
Cholesky factorization of B. In eq. (3.73) we have factored out the matrix ˜S−1
from both determinants, and the terms cancel. Continuing with the part of the

16It has been conjectured (but not proven) by L. Csat´o (personal communication) that EP

is guaranteed to converge if the likelihood is log concave.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

60

Classiﬁcation

ﬁfth term from eq. (3.65) which is quadratic in ˜µ together with the second term

1

2 ˜µ>(T −1 + ˜S−1)−1 ˜µ − 1

2 ˜µ>(K + ˜Σ)−1 ˜µ

2 ˜ν> ˜S−1(cid:0)(T −1 + ˜S−1)−1 − (K + ˜S−1)−1(cid:1) ˜S−1 ˜ν
2 ˜ν>(cid:0)(K−1 + ˜S)−1 − (T + ˜S)−1(cid:1)˜ν
2 ˜ν>(cid:0)K − K ˜S

2 K − (T + ˜S)−1(cid:1)˜ν,

2 B−1 ˜S

1

1

= 1
= 1
= 1

(3.74)

where in eq. (3.74) we apply the matrix inversion lemma eq. (A.9) to both
parenthesis to be inverted. The remainder of the ﬁfth term in eq. (3.65) is
evaluated using the identity

1

2 µ>

−i(T −1 + ˜S−1)−1(µ−i − 2˜µ) = 1

2 µ>

−iT ( ˜S + T )−1( ˜Sµ−i − 2˜ν),

(3.75)

where µ−i is the vector of cavity means µ−i. The third term in eq. (3.65)
requires in no special treatment and can be evaluated as written.

3.7 Experiments

In this section we present the results of applying the algorithms for GP clas-
siﬁcation discussed in the previous sections to several data sets. The purpose
is ﬁrstly to illustrate the behaviour of the methods and secondly to gain some
insights into how good the performance is compared to some other commonly-
used machine learning methods for classiﬁcation.

Section 3.7.1 illustrates the action of a GP classiﬁer on a toy binary pre-
diction problem with a 2-d input space, and shows the eﬀect of varying the
length-scale ‘ in the SE covariance function. In section 3.7.2 we illustrate and
compare the behaviour of the two approximate GP methods on a simple one-
dimensional binary task. In section 3.7.3 we present results for a binary GP
classiﬁer on a handwritten digit classiﬁcation task, and study the eﬀect of vary-
ing the kernel parameters. In section 3.7.4 we carry out a similar study using
a multi-class GP classiﬁer to classify digits from all ten classes 0-9. In section
3.8 we discuss the methods from both experimental and theoretical viewpoints.

3.7.1 A Toy Problem

Figure 3.5 illustrates the operation of a Gaussian process classiﬁer on a binary
problem using the squared exponential kernel with a variable length-scale and
the logistic response function. The Laplace approximation was used to make
the plots. The data points lie within the square [0, 1]2, as shown in panel (a).
Notice in particular the lone white point amongst the black points in the NE
corner, and the lone black point amongst the white points in the SW corner.

In panel (b) the length-scale is ‘ = 0.1, a relatively short value. In this case
the latent function is free to vary relatively quickly and so the classiﬁcations

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.7 Experiments

61

(a)

(b)

(c)

(d)

Figure 3.5: Panel (a) shows the location of the data points in the two-dimensional
space [0, 1]2. The two classes are labelled as open circles (+1) and closed circles (-
1). Panels (b)-(d) show contour plots of the predictive probability Eq[π(x∗)|y] for
signal variance σ2
f = 9 and length-scales ‘ of 0.1, 0.2 and 0.3 respectively. The de-
cision boundaries between the two classes are shown by the thicker black lines. The
maximum value attained is 0.84, and the minimum is 0.19.

provided by thresholding the predictive probability Eq[π(x∗)|y] at 0.5 agrees
with the training labels at all data points. In contrast, in panel (d) the length-
scale is set to ‘ = 0.3. Now the latent function must vary more smoothly, and
so the two lone points are misclassiﬁed. Panel (c) was obtained with ‘ = 0.2.
As would be expected, the decision boundaries are more complex for shorter
length-scales. Methods for setting the hyperparameters based on the data are
discussed in chapter 5.

(cid:176)(cid:176)(cid:176)•(cid:176)(cid:176)(cid:176)(cid:176)(cid:176)•(cid:176)••••••(cid:176)••0.250.50.50.50.750.250.30.50.70.30.50.7C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

62

Classiﬁcation

(a)

(b)

Figure 3.6: One-dimensional toy classiﬁcation dataset: Panel (a) shows the dataset,
where points from class +1 have been plotted at π = 1 and class −1 at π = 0, together
with the predictive probability for Laplace’s method and the EP approximation. Also
shown is the probability p(y = +1|x) of the data generating process. Panel (b) shows
the corresponding distribution of the latent function f (x), showing curves for the
mean, and ±2 standard deviations, corresponding to 95% conﬁdence regions.

3.7.2 One-dimensional Example

Although Laplace’s method and the EP approximation often give similar re-
sults, we here present a simple one-dimensional problem which highlights some
of the diﬀerences between the methods. The data, shown in Figure 3.6(a),
consists of 60 data points in three groups, generated from a mixture of three
Gaussians, centered on −6 (20 points), 0 (30 points) and 2 (10 points), where
the middle component has label −1 and the two other components label +1; all
components have standard deviation 0.8; thus the two left-most components
are well separated, whereas the two right-most components overlap.

Both approximation methods are shown with the same value of the hyperpa-
rameters, ‘ = 2.6 and σf = 7.0, chosen to maximize the approximate marginal
likelihood for Laplace’s method. Notice in Figure 3.6 that there is a consid-
erable diﬀerence in the value of the predictive probability for negative inputs.
The Laplace approximation seems overly cautious, given the very clear separa-
tion of the data. This eﬀect can be explained as a consequence of the intuition
that the inﬂuence of “well-explained data points” is eﬀectively reduced, see the
discussion around eq. (3.19). Because the points in the left hand cluster are
relatively well-explained by the model, they don’t contribute as strongly to the
posterior, and thus the predictive probability never gets very close to 1. Notice
in Figure 3.6(b) the 95% conﬁdence region for the latent function for Laplace’s
method actually includes functions that are negative at x = −6, which does
not seem appropriate. For the positive examples centered around x = 2 on the
right-hand side of Figure 3.6(b), this eﬀect is not visible, because the points
around the transition between the classes at x = 1 are not so “well-explained”;
this is because the points near the boundary are competing against the points
from the other class, attempting to pull the latent function in opposite di-
rections. Consequently, the datapoints in this region all contribute strongly.

−8−6−4−202400.20.40.60.81input, xpredictive probability, π*Class +1Class −1LaplaceEPp(y|x)−8−6−4−2024−10−5051015input, xlatent function, f(x)LaplaceEPC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.7 Experiments

63

Another sign of this eﬀect is that the uncertainty in the latent function, which
is closely related to the “eﬀective” local density of the data, is very small in
the region around x = 1; the small uncertainty reveals a high eﬀective density,
which is caused by all data points in the region contributing with full weight. It
should be emphasized that the example was artiﬁcially constructed speciﬁcally
to highlight this eﬀect.

Finally, Figure 3.6 also shows clearly the eﬀects of uncertainty in the latent
function on Eq[π∗|y]. In the region between x = 2 to x = 4, the latent mean
in panel (b) increases slightly, but the predictive probability decreases in this
region in panel (a). This is caused by the increase in uncertainty for the latent
function; when the widely varying functions are squashed through the non-
linearity it is possible for both classes to get high probability, and the average
prediction becomes less extreme.

3.7.3 Binary Handwritten Digit Classiﬁcation Example

Handwritten digit and character recognition are popular real-world tasks for
testing and benchmarking classiﬁers, with obvious application e.g. in postal
services. In this section we consider the discrimination of images of the digit
3 from images of the digit 5 as an example of binary classiﬁcation; the speciﬁc
choice was guided by the experience that this is probably one of the most
diﬃcult binary subtasks. 10-class classiﬁcation of the digits 0-9 is described in
the following section.

We use the US Postal Service (USPS) database of handwritten digits which
consists of 9298 segmented 16 × 16 greyscale images normalized so that the
intensity of the pixels lies in [−1, 1]. The data was originally split into a training
set of 7291 cases and a testset of the remaining 2007 cases, and has often been
used in this conﬁguration. Unfortunately, the data in the two partitions was
collected in slightly diﬀerent ways, such that the data in the two sets did not
stem from the same distribution.17 Since the basic underlying assumption for
most machine learning algorithms is that the distribution of the training and
test data should be identical, the original data partitions are not really suitable
as a test bed for learning algorithms, the interpretation of the results being
hampered by the change in distribution. Secondly, the original test set was
rather small, sometimes making it diﬃcult to diﬀerentiate the performance of
diﬀerent algorithms. To overcome these two problems, we decided to pool the
two partitions and randomly split the data into two identically sized partitions
of 4649 cases each. A side-eﬀect is that it is not trivial to compare to results
obtained using the original partitions. All experiments reported here use the
repartitioned data. The binary 3s vs. 5s data has 767 training cases, divided
406/361 on 3s vs. 5s, while the test set has 773 cases split 418/355.

USPS dataset

USPS repartitioned

We present results of both Laplace’s method and EP using identical ex-
perimental setups. The squared exponential covariance function k(x, x0) =

squared exponential
covariance function

17It is well known e.g. that the original test partition had more diﬃcult cases than the

training set.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

64

Classiﬁcation

(a)

(b)

(c)

(d)

Figure 3.7: Binary Laplace approximation: 3s vs. 5s discrimination using the USPS
data. Panel (a) shows a contour plot of the log marginal likelihood as a function of
log(‘) and log(σf ). The marginal likelihood has an optimum at log(‘) = 2.85 and
log(σf ) = 2.35, with an optimum value of log p(y|X, θ) = −99. Panel (b) shows a
contour plot of the amount of information (in excess of a simple base-line model, see
text) about the test cases in bits as a function of the same variables. The statistical
uncertainty (because of the ﬁnite number of test cases) is about ±0.03 bits (95%
conﬁdence interval). Panel (c) shows a histogram of the latent means for the training
and test sets respectively at the values of the hyperparameters with optimal marginal
likelihood (from panel (a)). Panel (d) shows the number of test errors (out of 773)
when predicting using the sign of the latent mean.

f exp(−|x − x0|2/2‘2) was used, so there are two free parameters, namely σf
σ2
(the process standard deviation, which controls its vertical scaling), and the
length-scale ‘ (which controls the input length-scale). Let θ = (log(‘), log(σf ))
denote the vector of hyperparameters. We ﬁrst present the results of Laplace’s
method in Figure 3.7 and discuss these at some length. We then brieﬂy compare
these with the results of the EP method in Figure 3.8.

hyperparameters

2345012345log lengthscale, log(l)log magnitude, log(σf)Log marginal likelihood−100−105−115−115−130−150−200−2002345012345log lengthscale, log(l)log magnitude, log(σf)Information about test targets in bits0.250.250.50.50.70.70.80.80.84−50501020latent means, ffrequencyTraining set latent means−50501020latent means, ffrequencyTest set latent means2345012345log lengthscale, log(l)log magnitude, log(σf)21191919191919191918181819191919191919191919192220181819191817171717171818181818181818181818232321181818171616161515161616161616161616161529262220181717161616161717171717171717171717173329262423191817151616161616161615151515151515343430282625232320191817171717171717171818181835343430302927242322212019181818181818181919193635343432303027262322222221212021202020202020393636343532323130292725242423242322222222222341393736353632323130302625252526262626252424244240393836353632323131292627252526272828282828454240393836363632323131292726252528282829292951454240393836363632323131292726262830293030306051454240393836363632333131292728272830293030896051454240393836373632333131282828293030293088605145424039383637363233313128292826303029886051454240393836373632333131282928293030Number of test misclassificationsC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.7 Experiments

65

(a)

(b)

(c)

(d)

Figure 3.8: The EP algorithm on 3s vs. 5s digit discrimination task from the USPS
data. Panel (a) shows a contour plot of the log marginal likelihood as a function of
the hyperparameters log(‘) and log(σf ). The marginal likelihood has an optimum
at log(‘) = 2.6 at the maximum value of log(σf ), but the log marginal likelihood is
essentially ﬂat as a function of log(σf ) in this region, so a good point is at log(σf ) =
4.1, where the log marginal likelihood has a value of −90. Panel (b) shows a contour
plot of the amount of information (in excess of the baseline model) about the test cases
in bits as a function of the same variables. Zero bits corresponds to no information
and one bit to perfect binary generalization. The 773 test cases allows the information
to be determined within ±0.035 bits. Panel (c) shows a histogram of the latent means
for the training and test sets respectively at the values of the hyperparameters with
optimal marginal likelihood (from panel a). Panel (d) shows the number of test errors
(out of 773) when predicting using the sign of the latent mean.

In Figure 3.7(a) we show a contour plot of the approximate log marginal
likelihood (LML) log q(y|X, θ) as a function of log(‘) and log(σf ), obtained
from runs on a grid of 17 evenly-spaced values of log(‘) and 23 evenly-spaced
values of log(σf ). Notice that there is a maximum of the marginal likelihood

Laplace results

2345012345log lengthscale, log(l)log magnitude, log(σf)Log marginal likelihood−92−95−100−105−105−115−130−160−160−200−2002345012345log lengthscale, log(l)log magnitude, log(σf)Information about test targets in bits0.250.50.70.70.80.80.840.840.860.880.89−100−5005001020latent means, ffrequencyTraining set latent means−100−5005001020latent means, ffrequencyTest set latent means2345012345log lengthscale, log(l)log magnitude, log(σf)21201919191919191919191919191919191919191919192220191819191919191919191919191919191919191919242321191817171717171717171717171717171717171729262322201818181818181818181818181818181818183330252523211917171617181818181818181818181818343530292625242120191919181818181818181818181835343431292927262423232120202020212121212121213635343432313131302523232324242424242525252525393636343432323230302724232625252626262626262641393736353632323230292924242626272727272727274240393736353632323131292926232627272727272727454240393836363632333131292826242526282828282751454240393836363632333131292826252828282827286051454240393836363632333131292827272829282727896051454240393836363632333131292827272929282788605145424039383636363233313129282727292828876051454240393836363632333131292828272928Number of test misclassificationsC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

66

Classiﬁcation

test log predictive
probability

base-line method

interpretation of
information score

error rate

near log(‘) = 2.85 and log(σf ) = 2.35. As will be explained in chapter 5, we
would expect that hyperparameters that yield a high marginal likelihood would
give rise to good predictions. Notice that an increase of 1 unit on the log scale
means that the probability is 2.7 times larger, so the marginal likelihood in
Figure 3.7(a) is fairly well peaked.

There are at least two ways we can measure the quality of predictions at the
test points. The ﬁrst is the test log predictive probability log2 p(y∗|x∗,D, θ).
In Figure 3.7(b) we plot the average over the test set of the test log predictive
probability for the same range of hyperparameters. We express this as the
amount of information in bits about the targets, by using log to the base 2.
Further, we oﬀ-set the value by subtracting the amount of information that a
simple base-line method would achieve. As a base-line model we use the best
possible model which does not use the inputs; in this case, this model would
just produce a predictive distribution reﬂecting the frequency of the two classes
in the training set, i.e.

− 418/773 log2(406/767) − 355/773 log2(361/767) = 0.9956 bits,

(3.76)

essentially 1 bit. (If the classes had been perfectly balanced, and the training
and test partitions also exactly balanced, we would arrive at exactly 1 bit.)
Thus, our scaled information score used in Figure 3.7(b) would be zero for a
method that did random guessing and 1 bit for a method which did perfect
classiﬁcation (with complete conﬁdence). The information score measures how
much information the model was able to extract from the inputs about the
identity of the output. Note that this is not the mutual information between
the model output and the test targets, but rather the Kullback-Leibler (KL)
divergence between them. Figure 3.7 shows that there is a good qualitative
agreement between the marginal likelihood and the test information, compare
panels (a) and (b).

The second (and perhaps most commonly used) method for measuring the
quality of the predictions is to compute the number of test errors made when
using the predictions. This is done by computing Eq[π∗|y] (see eq. (3.25)) for
each test point, thresholding at 1/2 to get “hard” predictions and counting the
number of errors. Figure 3.7(d) shows the number of errors produced for each
entry in the 17 × 23 grid of values for the hyperparameters. The general trend
in this table is that the number of errors is lowest in the top left-hand corner
and increases as one moves right and downwards. The number of errors rises
dramatically in the far bottom righthand corner. However, note in general that
the number of errors is quite small (there are 773 cases in the test set).

The qualitative diﬀerences between the two evaluation criteria depicted in
Figure 3.7 panels (b) and (d) may at ﬁrst sight seem alarming. And although
panels (a) and (b) show similar trends, one may worry about using (a) to select
the hyperparameters, if one is interested in minimizing the test misclassiﬁcation
rate. Indeed a full understanding of all aspects of these plots is quite involved,
but as the following discussion suggests, we can explain the major trends.

First, bear in mind that the eﬀect of increasing ‘ is to make the kernel
function broader, so we might expect to observe eﬀects like those in Figure 3.5

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.7 Experiments

67

where large widths give rise to a lack of ﬂexibility. Keeping ‘ constant, the
eﬀect of increasing σf is to increase the magnitude of the values obtained for
ˆf. By itself this would lead to “harder” predictions (i.e. predictive probabilities
closer to 0 or 1), but we have to bear in mind that the variances associated
will also increase and this increased uncertainty for the latent variables tends
to “soften” the predictive probabilities, i.e. move them closer to 1/2.

The most marked diﬀerence between Figure 3.7(b) and (d) is the behaviour
in the the top left corner, where classiﬁcation error rate remains small, but
the test information and marginal likelihood are both poor. In the left hand
side of the plots, the length scale ‘ is very short. This causes most points to
be deemed “far away” from most other points. In this regime the prediction
is dominated by the class-label of the nearest neighbours, and for the task at
hand, this happens to give a low misclassiﬁcation rate. In this parameter region
the test latent variables f∗ are very close to zero, corresponding to probabilities
very close to 1/2. Consequently, the predictive probabilities carry almost no
information about the targets. In the top left corner, the predictive probabilities
for all 773 test cases lie in the interval [0.48, 0.53]. Notice that a large amount
of information implies a high degree of correct classiﬁcation, but not vice versa.
At the optimal marginal likelihood values of the hyperparameters, there are 21
misclassiﬁcations, which is slightly higher that the minimum number attained
which is 15 errors.

In exercise 3.10.6 readers are encouraged to investigate further the behaviour
of ˆf and the predictive probabilities etc. as functions of log(‘) and log(σf ) for
themselves.

In Figure 3.8 we show the results on the same experiment, using the EP
method. The ﬁndings are qualitatively similar, but there are signiﬁcant dif-
ferences. In panel (a) the approximate log marginal likelihood has a diﬀerent
shape than for Laplace’s method, and the maximum of the log marginal likeli-
hood is about 9 units on a natural log scale larger (i.e. the marginal probability
is exp(9) ’ 8000 times higher). Also note that the marginal likelihood has a
ridge (for log ‘ = 2.6) that extends into large values of log σf . For these very
large latent amplitudes (see also panel (c)) the probit likelihood function is well
approximated by a step function (since it transitions from low to high values
in the domain [−3, 3]). Once we are in this regime, it is of course irrelevant
exactly how large the magnitude is, thus the ridge. Notice, however, that this
does not imply that the prediction will always be “hard”, since the variance of
the latent function also grows.

Figure 3.8 shows a good qualitative agreement between the approximate
log marginal likelihood and the test information, compare panels (a) and (b).
The best value of the test information is signiﬁcantly higher for EP than for
Laplace’s method. The classiﬁcation error rates in panel (d) show a fairly
similar behaviour to that of Laplace’s method. In Figure 3.8(c) we show the
latent means for training and test cases. These show a clear separation on
the training set, and much larger magnitudes than for Laplace’s method. The
absolute values of the entries in f∗ are quite large, often well in excess of 50,
which may suggest very “hard” predictions (probabilities close to zero or one),

EP results

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

68

Classiﬁcation

(a)

(b)

Figure 3.9: MAP vs. averaged predictions for the EP algorithm for the 3’s vs. 5’s
digit discrimination using the USPS data. The optimal values of the hyperparameters
from Figure 3.8(a) log(‘) = 2.6 and log(σf ) = 4.1 are used. The MAP predictions
σ(Eq[f∗|y]) are “hard”, mostly being very close to zero or one. On the other hand,
the averaged predictions Eq[π∗|y] from eq. (3.25) are a lot less extreme. In panel (a)
the 21 cases that were misclassiﬁed are indicated by crosses (correctly classiﬁed cases
are shown by points). Note that only 4 of the 21 misclassiﬁed points have conﬁdent
predictions (i.e. outside [0.1, 0.9]). Notice that all points fall in the triangles below
and above the horizontal line, conﬁrming that averaging does not change the “most
probable” class, and that it always makes the probabilities less extreme (i.e. closer to
1/2). Panel (b) shows histograms of averaged and MAP predictions, where we have
truncated values over 30.

since the sigmoid saturates for smaller arguments. However, when taking the
uncertainties in the latent variables into account, and computing the predictions
using averaging as in eq. (3.25) the predictive probabilities are “softened”. In
Figure 3.9 we can verify that the averaged predictive probabilities are much less
extreme than the MAP predictions.

In order to evaluate the performance of the two approximate methods for
GP classiﬁcation, we compared to a linear probit model, a support vector ma-
chine, a least-squares classiﬁer and a nearest neighbour approach, all of which
are commonly used in the machine learning community. In Figure 3.10 we show
error-reject curves for both misclassiﬁcation rate and the test information mea-
sure. The error-reject curve shows how the performance develops as a function
of the fraction of test cases that is being rejected. To compute these, we ﬁrst
modify the methods that do not naturally produce probabilistic predictions to
do so, as described below. Based on the predictive probabilities, we reject test
cases for which the maximum predictive probability is smaller than a threshold.
Varying the threshold produces the error-reject curve.

The GP classiﬁers applied in Figure 3.10 used the hyperparameters which
optimized the approximate marginal likelihood for each of the two methods.
For the GP classiﬁers there were two free parameters σf and ‘. The linear pro-
bit model (linear logistic models are probably more common, but we chose the
probit here, since the other likelihood based methods all used probit) can be

error-reject curve

linear probit model

00.20.40.60.8100.20.40.60.81π* MAPπ* averaged00.20.40.60.810510152025π* MAPfrequency00.20.40.60.810510152025π* averagedfrequencyC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.7 Experiments

69

(a)

(b)

Figure 3.10: Panel (a) shows the error-reject curve and panel (b) the amount of
information about the test cases as a function of the rejection rate. The probabilistic
one nearest neighbour (P1NN) method has much worse performance than the other
methods. Gaussian processes with EP behaves similarly to SVM’s although the clas-
siﬁcation rate for SVM for low rejection rates seems to be a little better. Laplace’s
method is worse than EP and SVM. The GP least squares classiﬁer (LSC) described
in section 6.5 performs the best.

implemented as GP model using Laplace’s method, which is equivalent to (al-
though not computationally as eﬃcient as) iteratively reweighted least squares
(IRLS). The covariance function k(x, x0) = θ2x>x0 has a single hyperparam-
eter, θ, which was set by maximizing the log marginal likelihood. This gives
log p(y|X, θ) = −105, at θ = 2.0, thus the marginal likelihood for the linear
covariance function is about 6 units on a natural log scale lower than the max-
imum log marginal likelihood for the Laplace approximation using the squared
exponential covariance function.

The support vector machine (SVM) classiﬁer (see section 6.4 for further de-
tails on the SVM) used the same SE kernel as the GP classiﬁers. For the SVM
the rˆole of ‘ is identical, and the trade-oﬀ parameter C in the SVM formulation
f . We carried out 5-fold cross validation
(see eq. (6.37)) plays a similar rˆole to σ2
on a grid in parameter space to identify the best combination of parameters
w.r.t. the error rate; this turned out to be at C = 1, ‘ = 10. Our experiments
were conducted using the SVMTorch software [Collobert and Bengio, 2001].
In order to compute probabilistic predictions, we squashed the test-activities
through a cumulative Gaussian, using the methods proposed by Platt [2000]:
we made a parameterized linear transformation of the test-activities and fed
this through the cumulative Gaussian.18 The parameters of the linear trans-
formation were chosen to maximize the log predictive probability, evaluated on
the hold-out sets of the 5-fold cross validation.

The probabilistic one nearest neighbour (P1NN) method is a simple nat-
ural extension to the classical one nearest neighbour method which provides
probabilistic predictions.
It computes the leave-one-out (LOO) one nearest
neighbour prediction on the training set, and records the fraction of cases π
where the LOO predictions were correct. On test cases, the method then pre-

18Platt [2000] used a logistic whereas we use a cumulative Gaussian.

support vector machine

probabilistic
one nearest neighbour

00.10.20.300.010.020.03rejection ratemisclassification rateEPLaplaceSVMP1NNLSClin probit00.20.40.60.810.850.90.951rejection ratetest information, bitsEPLaplaceSVMP1NNLSClin probitC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

70

Classiﬁcation

dicts the one nearest neighbour class with probability π, and the other class
with probability 1− π. Rejections are based on thresholding on the distance to
the nearest neighbour.

The least-squares classiﬁer (LSC) is described in section 6.5. In order to
produce probabilistic predictions, the method of Platt [2000] was used (as de-
scribed above for the SVM) using the predictive means only (the predictive
variances were ignored19), except that instead of the 5-fold cross validation,
leave-one-out cross-validation (LOO-CV) was used, and the kernel parameters
were also set using LOO-CV.

Figure 3.10 shows that the three best methods are the EP approximation for
GPC, the SVM and the least-squares classiﬁer (LSC). Presenting both the error
rates and the test information helps to highlight diﬀerences which may not be
apparent from a single plot alone. For example, Laplace’s method and EP seem
very similar on error rates, but quite diﬀerent in test information. Notice also,
that the error-reject curve itself reveals interesting diﬀerences, e.g. notice that
although the P1NN method has an error rate comparable to other methods at
zero rejections, things don’t improve very much when rejections are allowed.
Refer to section 3.8 for more discussion of the results.

3.7.4

10-class Handwritten Digit Classiﬁcation Example

We apply the multi-class Laplace approximation developed in section 3.5 to the
10-class handwritten digit classiﬁcation problem from the (repartitioned) USPS
dataset, having n = 4649 training cases and n∗ = 4649 cases for testing, see
page 63. We used a squared exponential covariance function with two hyper-
parameters: a single signal amplitude σf , common to all 10 latent functions,
and a single length-scale parameter ‘, common to all 10 latent functions and
common to all 256 input dimensions.

The behaviour of the method was investigated on a grid of values for the
hyperparameters, see Figure 3.11. Note that the correspondence between the
log marginal likelihood and the test information is not as close as for Laplace’s
method for binary classiﬁcation in Figure 3.7 on page 64. The maximum value
of the log marginal likelihood attained is -1018, and for the hyperparameters
corresponding to this point the error rate is 3.1% and the test information
2.67 bits. As with the binary classiﬁcation problem, the test information is
standardized by subtracting oﬀ the negative entropy (information) of the targets
which is −3.27 bits. The classiﬁcation error rate in Figure 3.11(c) shows a clear
minimum, and this is also attained at a shorter length-scale than where the
marginal likelihood and test information have their maxima. This eﬀect was
also seen in the experiments on binary classiﬁcation.

To gain some insight into the level of performance we compared these re-
sults with those obtained with the probabilistic one nearest neighbour method
P1NN, a multiple logistic regression model and a SVM. The P1NN ﬁrst uses an

19Of course, one could also have tried a variant where the full latent predictive distribution

was averaged over, but we did not do that here.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.7 Experiments

71

(a)

(b)

(c)

Figure 3.11: 10-way digit classiﬁcation using the Laplace approximation. Panel
(a) shows the approximate log marginal likelihood, reaching a maximum value of
log p(y|X, θ) = −1018 at log ‘ = 2.35 and log σf = 2.6.
In panel (b) information
about the test cases is shown. The maximum possible amount of information about
the test targets, corresponding to perfect classiﬁcation, would be 3.27 bits (the entropy
of the targets). At the point of maximum marginal likelihood, the test information is
2.67 bits. In panel (c) the test set misclassiﬁcation rate is shown in percent. At the
point of maximum marginal likelihood the test error rate is 3.1%.

internal leave-one-out assessment on the training set to estimate its probabil-
ity of being correct, π. For the test set it then predicts the nearest neighbour
with probability π and all other classes with equal probability (1 − π)/9. We
obtained π = 0.967, a test information of 2.98 bits and a test set classiﬁcation
error rate of 3.0%.

We also compare to multiple linear logistic regression. One way to imple-
ment this method is to view it as a Gaussian process with a linear covariance

2345012345log lengthscale, log(l)log magnitude, log(σf)Log marginal likelihood−1050−1100−1200−1300−1500−2000−3000−3000−30002345012345log lengthscale, log(l)log magnitude, log(σf)Information about the test targets in bits11222.52.52.82.82.952.992345012345log lengthscale, log(l)log magnitude, log(σf)Test set misclassification percentage2.62.72.833.3451010C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

72

Classiﬁcation

function, although it is equivalent and computationally more eﬃcient to do the
Laplace approximation over the “weights” of the linear model. In our case there
are 10×257 weights (256 inputs and one bias), whereas there are 10×4696 latent
function values in the GP. The linear covariance function k(x, x0) = θ2x>x0 has
a single hyperparameter θ (used for all 10 latent functions). Optimizing the log
marginal likelihood w.r.t. θ gives log p(y|X, θ) = −1339 at θ = 1.45. Using this
value for the hyperparameter, the test information is 2.95 bits and the test set
error rate is 5.7%.

Finally, a support vector machine (SVM) classiﬁer was trained using the
same SE kernel as the Gaussian process classiﬁers. (See section 6.4 for further
details on the SVM.) As in the binary SVM case there were two free parameters
‘ (the length-scale of the kernel), and the trade-oﬀ parameter C (see eq. (6.37)),
f . We carried out 5-fold cross-validation on a grid
which plays a similar rˆole to σ2
in parameter space to identify the best combination of parameters w.r.t. the
error rate; this turned out to be at C = 1, ‘ = 5. Our experiments were
conducted using the SVMTorch software [Collobert and Bengio, 2001], which
implements multi-class SVM classiﬁcation using the one-versus-rest method de-
scribed in section 6.5. The test set error rate for the SVM is 2.2%; we did not
attempt to evaluate the test information for the multi-class SVM.

3.8 Discussion

In the previous section we presented several sets of experiments comparing the
two approximate methods for inference in GPC models, and comparing them to
other commonly-used supervised learning methods. In this section we discuss
the results and attempt to relate them to the properties of the models.

For the binary examples from Figures 3.7 and 3.8, we saw that the two ap-
proximations showed quite diﬀerent qualitative behaviour of the approximated
log marginal likelihood, although the exact marginal likelihood is of course iden-
tical. The EP approximation gave a higher maximum value of the log marginal
likelihood (by about 9 units on the log scale) and the test information was
somewhat better than for Laplace’s method, although the test set error rates
were comparable. However, although this experiment seems to favour the EP
approximation, it is interesting to know how close these approximations are to
the exact (analytically intractable) solutions. In Figure 3.12 we show the results
of running a sophisticated Markov chain Monte Carlo method called Annealed
Importance Sampling [Neal, 2001] carried out by Kuss and Rasmussen [2005].
The USPS dataset for these experiments was identical to the one used in Fig-
ures 3.7 and 3.8, so the results are directly comparable.
It is seen that the
MCMC results indicate that the EP method achieves a very high level of accu-
racy, i.e. that the diﬀerence between EP and Laplace’s method is caused almost
exclusively by approximation errors in Laplace’s method.

The main reason for the inaccuracy of Laplace’s method is that the high
dimensional posterior is skew, and that the symmetric approximation centered
on the mode is not characterizing the posterior volume very well. The posterior

Monte Carlo results

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.8 Discussion

73

(a)

(b)

Figure 3.12: The log marginal likelihood, panel (a), and test information, panel
(b), for the USPS 3’s vs. 5’s binary classiﬁcation task computed using Markov chain
Monte Carlo (MCMC). Comparing this to the Laplace approximation Figure 3.7 and
Figure 3.8 shows that the EP approximation is surprisingly accurate. The slight
wiggliness of the contour lines are caused by ﬁnite sample eﬀects in the MCMC runs.

is a combination of the (correlated) Gaussian prior centered on the origin and
the likelihood terms which (softly) cut oﬀ half-spaces which do not agree with
the training set labels. Therefore the posterior looks like a correlated Gaussian
restricted to the orthant which agrees with the labels. Its mode will be located
close to the origin in that orthant, and it will decrease rapidly in the direction
towards the origin due to conﬂicts from the likelihood terms, and decrease only
slowly in the opposite direction (because of the prior). Seen in this light it is
not surprising that the Laplace approximation is somewhat inaccurate. This
explanation is corroborated further by Kuss and Rasmussen [2005].

It should be noted that all the methods compared on the binary digits clas-
siﬁcation task except for the linear probit model are using the squared distance
between the digitized digit images measured directly in the image space as the
sole input to the algorithm. This distance measure is not very well suited for
the digit discrimination task—for example, two similar images that are slight
translations of each other may have a huge squared distance, although of course
identical labels. One of the strengths of the GP formalism is that one can use
prior distributions over (latent, in this case) functions, and do inference based
on these. If however, the prior over functions depends only on one particular as-
pect of the data (the squared distance in image space) which is not so well suited
for discrimination, then the prior used is also not very appropriate. It would be
more interesting to design covariance functions (parameterized by hyperparame-
ters) which are more appropriate for the digit discrimination task, e.g. reﬂecting
on the known invariances in the images, such as the “tangent-distance” ideas
from Simard et al. [1992]; see also Sch¨olkopf and Smola [2002, ch. 11] and section
9.10. The results shown here follow the common approach of using a generic

suitablility of the
covariance function

2345012345log lengthscale, log(l)log magnitude, log(σf)Log marginal likelihood−92−95−100−105−105−115−130−160−160−200−2002345012345log lengthscale, log(l)log magnitude, log(σf)Information about test targets in bits0.250.50.70.70.80.80.840.840.860.880.89C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

74

Classiﬁcation

covariance function with a minimum of hyperparameters, but this doesn’t allow
us to incorporate much prior information about the problem. For an example
in the GP framework for doing inference about multiple hyperparameters with
more complex covariance functions which provide clearly interpretable infor-
mation about the data, see the carbon dioxide modelling problem discussed on
page 118.

∗

3.9 Appendix: Moment Derivations

Consider the integral of a cumulative Gaussian, Φ, with respect to a Gaussian

Z ∞

−∞

Z =

Zv>0 =

or in matrix notation

Zv>0 =

=

initially for the special case v >0. Writing out in full, substituting z = y − x +
µ − m and w = x − µ and interchanging the order of the integrals

Z x

−∞

N (y) dy,

(3.77)

(cid:1) dy dx
− (x − µ)2
(cid:1) dw dz,
2σ2
(cid:21)(cid:20) w

2σ2

1
v2
1
v2

z

(3.78)

(cid:21)(cid:1) dw dz

dw dz,

(3.79)

=

v

1

1

−∞

−∞

2v2

2πσv

Φ(cid:0) x − m
(cid:1)N (x|µ, σ2) dx, where Φ(x) =
Z ∞
Z x
exp(cid:0)− (y − m)2
Z ∞
Z µ−m
exp(cid:0)− (z + w)2
2v2 − w2
(cid:21)>(cid:20) 1
(cid:20) w
Z µ−m
Z ∞
exp(cid:0)− 1
Z µ−m
Z ∞
i(cid:12)(cid:12)(cid:12) 0,
N(cid:16)h w
h σ2
Z µ−m

−σ2
v2 + σ2

v2 + 1
σ2

i(cid:17)

−σ2

2πσv

2πσv

−∞

−∞

−∞

2

z

−∞

−∞

−∞

1
v2

1

z

(cid:16) −

(cid:17)

dz = Φ(cid:0) µ − m√

(cid:1),

v2 + σ2

i.e. an (incomplete) integral over a joint Gaussian. The inner integral corre-
sponds to marginalizing over w (see eq. (A.6)), yielding

(3.80)
which assumed v > 0. If v is negative, we can substitute the symmetry Φ(−z) =
1 − Φ(z) into eq. (3.77) to get

z2

−∞

exp

Zv>0 =

2(v2 + σ2)

1p2π(v2 + σ2)
(cid:1) = Φ(cid:0)− µ − m√
Zv<0 = 1 − Φ(cid:0) µ − m√
(cid:1)N (x|µ, σ2) dx = Φ(z), where z =
(cid:1)N (x|µ, σ2),
q(x) = Z−1Φ(cid:0) x − m

v2 + σ2
Collecting the two cases, eq. (3.80) and eq. (3.81) we arrive at
√

Z =
for general v 6= 0. We wish to compute the moments of

Φ(cid:0) x − m

v2 + σ2

Z

v

v

(cid:1).

(3.81)

, (3.82)

(3.83)

µ − m
1 + σ2/v2

v

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.10 Exercises

75

where Z is given in eq. (3.82). Perhaps the easiest way to do this is to diﬀer-
entiate w.r.t. µ on both sides of eq. (3.82)

Z x − µ
σ2 Φ(cid:0) x − m
xΦ(cid:0) x − m

v

(cid:1)N (x|µ, σ2) dx = ∂

v

(cid:1)N (x|µ, σ2) dx − µZ

σ2 =

∂Z
∂µ

=

Z

1
σ2

Φ(z) ⇐⇒
N (z)
1 + σ2/v2

∂µ
√

v

(3.84)

,

where we have used ∂Φ(z)/∂µ = N (z)∂z/∂µ. We recognize the ﬁrst term in
the integral in the top line of eq. (3.84) as Z/σ2 times the ﬁrst moment of q
which we are seeking. Multiplying through by σ2/Z and rearranging we obtain

ﬁrst moment

Eq[x] = µ +

σ2N (z)
√

Φ(z)v

1 + σ2/v2

.

(3.85)

Similarly, the second moment can be obtained by diﬀerentiating eq. (3.82) twice

Z h x2
σ4 − 2µx
⇐⇒ Eq[x2] = 2µEq[x] − µ2 + σ2 − σ4zN (z)

Φ(cid:0) x − m

i

σ4 + µ2

σ4 − 1

σ2

v

(cid:1)N (x|µ, σ2) dx = − zN (z)

v2 + σ2

∂2Z
∂µ2 =

(3.86)

Φ(z)(v2 + σ2) ,

second moment

where the ﬁrst and second terms of the integral in the top line of eq. (3.86) are
multiples of the ﬁrst and second moments. The second central moment after
reintroducing eq. (3.85) into eq. (3.86) and simplifying is given by

(cid:2)(x−Eq[x])2(cid:3) = Eq[x2]−Eq[x]2 = σ2−

Eq

(cid:16)

(cid:17)

σ4N (z)

(v2 + σ2)Φ(z)

z +

N (z)
Φ(z)

. (3.87)

3.10 Exercises

1. For binary GPC, show the equivalence of using a noise-free latent process
combined with a probit likelihood and a latent process with Gaussian
noise combined with a step-function likelihood. Hint: introduce explicitly
additional noisy latent variables ˜fi, which diﬀer from fi by Gaussian noise.
Write down the step function likelihood for a single case as a function of
˜fi, integrate out the noisy variable, to arrive at the probit likelihood as a
function of the noise-free process.

2. Consider a multinomial random variable y having C states, with yc = 1 if
the variable is in state c, and 0 otherwise. State c occurs with probability
πc. Show that cov(y) = E[(y − π)(y − π)>] = diag(π) − ππ>. Ob-
serve that cov(y), being a covariance matrix, must necessarily be positive
semideﬁnite. Using this fact show that the matrix W = diag(π) − ΠΠ>
from eq. (3.38) is positive semideﬁnite. By showing that the vector of all
ones is an eigenvector of cov(y) with eigenvalue zero, verify that the ma-
trix is indeed positive semideﬁnite, and not positive deﬁnite. (See section
4.1 for deﬁnitions of positive semideﬁnite and positive deﬁnite matrices.)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

76

Classiﬁcation

Figure 3.13: The decision regions for the three-class softmax function in z2-z3 space.

3. Consider the 3-class softmax function

p(Cc) =

exp(fc)

exp(f1) + exp(f2) + exp(f3) ,

where c = 1, 2, 3 and f1, f2, f3 are the corresponding activations. To
more easily visualize the decision boundaries, let z2 = f2 − f1 and z3 =
f3 − f1. Thus

p(C1) =

1

1 + exp(z2) + exp(z3) ,

(3.88)

and similarly for the other classes. The decision boundary relating to
p(C1) > 1/3 is the curve exp(z2) + exp(z3) = 2. The decision regions for
the three classes are illustrated in Figure 3.13. Let f = (f1, f2, f3)> have
a Gaussian distribution centered on the origin, and let π(f) = softmax(f).

We now consider the eﬀect of this distribution on ¯π =R π(f)p(f) df. For

a Gaussian with given covariance structure this integral is easily approxi-
mated by drawing samples from p(f). Show that the classiﬁcation can be
made to fall into any of the three categories depending on the covariance
matrix. Thus, by considering displacements of the mean of the Gaussian
by  from the origin into each of the three regions we have shown that
overall classiﬁcation depends not only on the mean of the Gaussian but
also on its covariance. Show that this conclusion is still valid when it is
recalled that z is derived from f as z = T f where

(cid:18) 1

0

(cid:19)

,

0 −1
1 −1

T =

so that cov(z) = T cov(f)T >.

4. Consider the update equation for f new given by eq. (3.18) when some of
the training points are well-explained under f so that ti ’ πi and Wii ’ 0

R1R2R3−303−303z2z3C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

3.10 Exercises

77

for these points. Break f into two subvectors, f1 that corresponds to
points that are not well-explained, and f2 to those that are. Re-write
(K−1 + W )−1 from eq. (3.18) as K(I + W K)−1 and let K be partitioned
as K11, K12, K21, K22 and similarly for the other matrices. Using the
partitioned matrix inverse equations (see section A.3) show that

= K11(I11 + W11K11)−1(cid:0)W11f1 + ∇ log p(y1|f1)(cid:1),

(3.89)

f new
1
f new
2

11 f new

1

= K21K−1

.

See section 3.4.1 for the consequences of this result.

5. Show that the expressions in eq. (3.56) for the cavity mean µ−i and vari-
ance σ2−i do not depend on the approximate likelihood terms ˜µi and ˜σ2
i
for the corresponding case, despite the appearance of eq. (3.56).

6. Consider the USPS 3s vs. 5s prediction problem discussed in section 3.7.3.
Use the implementation of the Laplace binary GPC provided to investi-
gate how ˆf and the predictive probabilities etc. vary as functions of log(‘)
and log(σf ).

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 4

Covariance Functions

We have seen that a covariance function is the crucial ingredient in a Gaussian
process predictor, as it encodes our assumptions about the function which we
wish to learn. From a slightly diﬀerent viewpoint it is clear that in supervised
learning the notion of similarity between data points is crucial; it is a basic
assumption that points with inputs x which are close are likely to have similar
target values y, and thus training points that are near to a test point should
be informative about the prediction at that point. Under the Gaussian process
view it is the covariance function that deﬁnes nearness or similarity.

An arbitrary function of input pairs x and x0 will not, in general, be a valid
covariance function.1 The purpose of this chapter is to give examples of some
commonly-used covariance functions and to examine their properties. Section
4.1 deﬁnes a number of basic terms relating to covariance functions. Section 4.2
gives examples of stationary, dot-product, and other non-stationary covariance
functions, and also gives some ways to make new ones from old. Section 4.3
introduces the important topic of eigenfunction analysis of covariance functions,
and states Mercer’s theorem which allows us to express the covariance function
(under certain conditions) in terms of its eigenfunctions and eigenvalues. The
covariance functions given in section 4.2 are valid when the input domain X is
a subset of RD. In section 4.4 we describe ways to deﬁne covariance functions
when the input domain is over structured objects such as strings and trees.

4.1 Preliminaries
A stationary covariance function is a function of x − x0. Thus it is invariant
to translations in the input space.2 For example the squared exponential co-

1To be a valid covariance function it must be positive semideﬁnite, see eq. (4.2).
2In stochastic process theory a process which has constant mean and whose covariance
function is invariant to translations is called weakly stationary. A process is strictly sta-
tionary if all of its ﬁnite dimensional distributions are invariant to translations [Papoulis,
1991, sec. 10.1].

similarity

valid covariance
functions

stationarity

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

80

isotropy

dot product covariance

kernel

Gram matrix
covariance matrix

positive semideﬁnite

Covariance Functions

variance function given in equation 2.16 is stationary. If further the covariance
function is a function only of |x − x0| then it is called isotropic; it is thus in-
variant to all rigid motions. For example the squared exponential covariance
function given in equation 2.16 is isotropic. As k is now only a function of
r = |x − x0| these are also known as radial basis functions (RBFs).

If a covariance function depends only on x and x0 through x · x0 we call it
a dot product covariance function. A simple example is the covariance function
0 + x · x0 which can be obtained from linear regression by putting
k(x, x0) = σ2
N (0, 1) priors on the coeﬃcients of xd (d = 1, . . . , D) and a prior of N (0, σ2
0)
on the bias (or constant function) 1, see eq. (2.15). Another important example
0 + x · x0)p where p is a
is the inhomogeneous polynomial kernel k(x, x0) = (σ2
positive integer. Dot product covariance functions are invariant to a rotation
of the coordinates about the origin, but not translations.

A general name for a function k of two arguments mapping a pair of inputs
x ∈ X , x0 ∈ X into R is a kernel. This term arises in the theory of integral
operators, where the operator Tk is deﬁned as

(Tkf)(x) =

k(x, x0)f(x0) dµ(x0),

(4.1)

Z

X

where µ denotes a measure; see section A.7 for further explanation of this point.3
A real kernel is said to be symmetric if k(x, x0) = k(x0, x); clearly covariance
functions must be symmetric from the deﬁnition.

Given a set of input points {xi|i = 1, . . . , n} we can compute the Gram
matrix K whose entries are Kij = k(xi, xj). If k is a covariance function we
call the matrix K the covariance matrix.

A real n × n matrix K which satisﬁes Q(v) = v>Kv ≥ 0 for all vectors
v ∈ Rn is called positive semideﬁnite (PSD). If Q(v) = 0 only when v = 0
the matrix is positive deﬁnite. Q(v) is called a quadratic form. A symmetric
matrix is PSD if and only if all of its eigenvalues are non-negative. A Gram
matrix corresponding to a general kernel function need not be PSD, but the
Gram matrix corresponding to a covariance function is PSD.

A kernel is said to be positive semideﬁnite if

k(x, x0)f(x)f(x0) dµ(x) dµ(x0) ≥ 0,

(4.2)

Z

for all f ∈ L2(X , µ). Equivalently a kernel function which gives rise to PSD
Gram matrices for any choice of n ∈ N and D is positive semideﬁnite. To
see this let f be the weighted sum of delta functions at each xi. Since such
functions are limits of functions in L2(X , µ) eq. (4.2) implies that the Gram
matrix corresponding to any D is PSD.

For a one-dimensional Gaussian process one way to understand the charac-
teristic length-scale of the process (if this exists) is in terms of the number of
upcrossings of a level u. Adler [1981, Theorem 4.1.1] states that the expected

3Informally speaking, readers will usually be able to substitute dx or p(x)dx for dµ(x).

upcrossing rate

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.2 Examples of Covariance Functions

81

number of upcrossings E[Nu] of the level u on the unit interval by a zero-mean,
stationary, almost surely continuous Gaussian process is given by

s−k00(0)

k(0)

(cid:16)− u2

2k(0)

(cid:17)

E[Nu] =

1
2π

exp

.

(4.3)

If k00(0) does not exist (so that the process is not mean square diﬀerentiable)
then if such a process has a zero at x0 then it will almost surely have an inﬁnite
number of zeros in the arbitrarily small interval (x0, x0 + δ) [Blake and Lindsey,
1973, p. 303].

4.1.1 Mean Square Continuity and Diﬀerentiability

∗

We now describe mean square continuity and diﬀerentiability of stochastic pro-
cesses, following Adler [1981, sec. 2.2]. Let x1, x2, . . . be a sequence of points
and x∗ be a ﬁxed point in RD such that |xk − x∗| → 0 as k → ∞. Then a
process f(x) is continuous in mean square at x∗ if E[|f(xk) − f(x∗)|2] → 0 as mean square continuity
k → ∞. If this holds for all x∗ ∈ A where A is a subset of RD then f(x) is said
to be continuous in mean square (MS) over A. A random ﬁeld is continuous in
mean square at x∗ if and only if its covariance function k(x, x0) is continuous
at the point x = x0 = x∗. For stationary covariance functions this reduces
to checking continuity at k(0). Note that MS continuity does not necessarily
imply sample function continuity; for a discussion of sample function continuity
and diﬀerentiability see Adler [1981, ch. 3].

The mean square derivative of f(x) in the ith direction is deﬁned as

mean square
diﬀerentiability

∂f(x)
∂xi

= l. i. m
h→0

f(x + hei) − f(x)

h

,

(4.4)

when the limit exists, where l.i.m denotes the limit in mean square and ei
is the unit vector in the ith direction. The covariance function of ∂f(x)/∂xi
is given by ∂2k(x, x0)/∂xi∂x0
i. These deﬁnitions can be extended to higher
order derivatives. For stationary processes, if the 2kth-order partial derivative
∂2kk(x)/∂2xi1 . . . ∂2xik exists and is ﬁnite at x = 0 then the kth order partial
derivative ∂kf(x)/∂xi1 . . . xik exists for all x ∈ RD as a mean square limit.
Notice that it is the properties of the kernel k around 0 that determine the
smoothness properties (MS diﬀerentiability) of a stationary process.

4.2 Examples of Covariance Functions
In this section we consider covariance functions where the input domain X is
a subset of the vector space RD. More general input spaces are considered in
section 4.4. We start in section 4.2.1 with stationary covariance functions, then
consider dot-product covariance functions in section 4.2.2 and other varieties
of non-stationary covariance functions in section 4.2.3. We give an overview
of some commonly used covariance functions in Table 4.1 and in section 4.2.4

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

82

Covariance Functions

we describe general methods for constructing new kernels from old. There
exist several other good overviews of covariance functions, see e.g. Abrahamsen
[1997].

4.2.1 Stationary Covariance Functions

In this section (and section 4.3) it will be convenient to allow kernels to be a map
from x ∈ X , x0 ∈ X into C (rather than R). If a zero-mean process f is complex-
valued, then the covariance function is deﬁned as k(x, x0) = E[f(x)f∗(x0)],
where ∗ denotes complex conjugation.

A stationary covariance function is a function of τ = x − x0. Sometimes in

this case we will write k as a function of a single argument, i.e. k(τ ).

The covariance function of a stationary process can be represented as the

Fourier transform of a positive ﬁnite measure.

Bochner’s theorem

Theorem 4.1 (Bochner’s theorem) A complex-valued function k on RD is the
covariance function of a weakly stationary mean square continuous complex-
valued random process on RD if and only if it can be represented as

where µ is a positive ﬁnite measure.

k(τ ) =

RD

e2πis·τ dµ(s)

(4.5)

(cid:3)

Z

spectral density
power spectrum

The statement of Bochner’s theorem is quoted from Stein [1999, p. 24]; a proof
can be found in Gihman and Skorohod [1974, p. 208]. If µ has a density S(s)
then S is known as the spectral density or power spectrum corresponding to k.
The construction given by eq. (4.5) puts non-negative power into each fre-
quency s; this is analogous to the requirement that the prior covariance matrix
Σp on the weights in equation 2.4 be non-negative deﬁnite.

Z

Z

In the case that the spectral density S(s) exists, the covariance function and
the spectral density are Fourier duals of each other as shown in eq. (4.6);4 this
is known as the Wiener-Khintchine theorem, see, e.g. Chatﬁeld [1989]

k(τ ) =

Notice that the variance of the process is k(0) =R S(s) ds so the power spectrum

S(s) =

k(τ )e−2πis·τ dτ .

S(s)e2πis·τ ds,

(4.6)

must be integrable to deﬁne a valid Gaussian process.

To gain some intuition for the deﬁnition of the power spectrum given in
eq. (4.6) it is important to realize that the complex exponentials e2πis·x are
eigenfunctions of a stationary kernel with respect to Lebesgue measure (see
section 4.3 for further details). Thus S(s) is, loosely speaking, the amount of
power allocated on average to the eigenfunction e2πis·x with frequency s. S(s)
must eventually decay suﬃciently fast as |s| → ∞ so that it is integrable; the

4See Appendix A.8 for details of Fourier transforms.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.2 Examples of Covariance Functions

83

rate of this decay of the power spectrum gives important information about
the smoothness of the associated stochastic process. For example it can deter-
mine the mean-square diﬀerentiability of the process (see section 4.3 for further
details).

If the covariance function is isotropic (so that it is a function of r, where
r = |τ|) then it can be shown that S(s) is a function of s , |s| only [Adler,
1981, Theorem 2.5.2]. In this case the integrals in eq. (4.6) can be simpliﬁed
by changing to spherical polar coordinates and integrating out the angular
variables (see e.g. Bracewell, 1986, ch. 12) to obtain

Z ∞
Z ∞

0

0

k(r) =

S(s) =

2π

rD/2−1

2π

sD/2−1

S(s)JD/2−1(2πrs)sD/2 ds,

k(r)JD/2−1(2πrs)rD/2 dr,

(4.7)

(4.8)

where JD/2−1 is a Bessel function of order D/2−1. Note that the dependence on
the dimensionality D in equation 4.7 means that the same isotropic functional
form of the spectral density can give rise to diﬀerent isotropic covariance func-
tions in diﬀerent dimensions. Similarly, if we start with a particular isotropic
covariance function k(r) the form of spectral density will in general depend on
D (see, e.g. the Mat´ern class spectral density given in eq. (4.15)) and in fact
k(r) may not be valid for all D. A necessary condition for the spectral density

to exist is thatR rD−1|k(r)| dr < ∞; see Stein [1999, sec. 2.10] for more details.

We now give some examples of commonly-used isotropic covariance func-
tions. The covariance functions are given in a normalized form where k(0) = 1;
we can multiply k by a (positive) constant σ2
f to get any desired process vari-
ance.

Squared Exponential Covariance Function

The squared exponential (SE) covariance function has already been introduced
in chapter 2, eq. (2.16) and has the form

kSE(r) = exp

,

(4.9)

with parameter ‘ deﬁning the characteristic length-scale. Using eq. (4.3) we
see that the mean number of level-zero upcrossings for a SE process in 1-
d is (2π‘)−1, which conﬁrms the rˆole of ‘ as a length-scale. This covari-
ance function is inﬁnitely diﬀerentiable, which means that the GP with this
covariance function has mean square derivatives of all orders, and is thus
very smooth. The spectral density of the SE covariance function is S(s) =
(2π‘2)D/2 exp(−2π2‘2s2). Stein [1999] argues that such strong smoothness
assumptions are unrealistic for modelling many physical processes, and rec-
ommends the Mat´ern class (see below). However, the squared exponential is
probably the most widely-used kernel within the kernel machines ﬁeld.

(cid:17)

(cid:16)− r2

2‘2

squared exponential

characteristic
length-scale

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

84

Covariance Functions

inﬁnitely divisible

The SE kernel is inﬁnitely divisible in that (k(r))t is a valid kernel for all

t > 0; the eﬀect of raising k to the power of t is simply to rescale ‘.

inﬁnite network
construction for SE
covariance function

Mat´ern class

We now digress brieﬂy, to show that the squared exponential covariance
function can also be obtained by expanding the input x into a feature space
deﬁned by Gaussian-shaped basis functions centered densely in x-space. For
simplicity of exposition we consider scalar inputs with basis functions

φc(x) = exp(cid:0)− (x − c)2

(cid:1),

2‘2

(4.10)

where c denotes the centre of the basis function. From sections 2.1 and 2.2 we
recall that with a Gaussian prior on the weights w ∼ N (0, σ2
pI), this gives rise
to a GP with covariance function

k(xp, xq) = σ2
p

φc(xp)φc(xq).

(4.11)

Now, allowing an inﬁnite number of basis functions centered everywhere on an
interval (and scaling down the variance of the prior on the weights with the
number of basis functions) we obtain the limit

NX

c=1

Z cmax

cmin

NX

c=1

lim
N→∞

σ2
p
N

φc(xp)φc(xq) = σ2
p

φc(xp)φc(xq)dc.

(4.12)

Plugging in the Gaussian-shaped basis functions eq. (4.10) and letting the in-
tegration limits go to inﬁnity we obtain

Z ∞
exp(cid:0)− (xp − c)2
p exp(cid:0)− (xp − xq)2

2‘2
√
2(

2‘)2

−∞

π‘σ2

(cid:1)dc

(cid:1) exp(cid:0)− (xq − c)2
(cid:1),

2‘2

k(xp, xq) = σ2
p
√

=

√
which we recognize as a squared exponential covariance function with a
2
times longer length-scale. The derivation is adapted from MacKay [1998]. It
is straightforward to generalize this construction to multivariate x. See also
eq. (4.30) for a similar construction where the centres of the basis functions are
sampled from a Gaussian distribution; the constructions are equivalent when
the variance of this Gaussian tends to inﬁnity.

(4.13)

The Mat´ern Class of Covariance Functions

The Mat´ern class of covariance functions is given by

kMatern(r) =

21−ν
Γ(ν)

2νr
‘

Kν

(cid:16)√

(cid:17)ν

(cid:16)√

(cid:17)

,

2νr
‘

(4.14)

with positive parameters ν and ‘, where Kν is a modiﬁed Bessel function
[Abramowitz and Stegun, 1965, sec. 9.6]. This covariance function has a spectral
density

(cid:16)2ν
‘2 + 4π2s2(cid:17)−(ν+D/2)

(4.15)

S(s) =

2DπD/2Γ(ν + D/2)(2ν)ν

Γ(ν)‘2ν

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.2 Examples of Covariance Functions

85

(a)

(b)

Figure 4.1: Panel (a): covariance functions, and (b): random functions drawn from
Gaussian processes with Mat´ern covariance functions, eq. (4.14), for diﬀerent values of
ν, with ‘ = 1. The sample functions on the right were obtained using a discretization
of the x-axis of 2000 equally-spaced points.

in D dimensions. Note that the scaling is chosen so that for ν → ∞ we obtain
the SE covariance function e−r2/2‘2, see eq. (A.25). Stein [1999] named this the
Mat´ern class after the work of Mat´ern [1960]. For the Mat´ern class the process
f(x) is k-times MS diﬀerentiable if and only if ν > k. The Mat´ern covariance
functions become especially simple when ν is half-integer: ν = p + 1/2, where
p is a non-negative integer. In this case the covariance function is a product
of an exponential and a polynomial of order p, the general expression can be
derived from [Abramowitz and Stegun, 1965, eq. 10.2.15], giving

(cid:16)−

√

(cid:17) Γ(p + 1)

pX

Γ(2p + 1)

i=0

2νr
‘

(cid:16)√

(cid:17)p−i

(p + i)!
i!(p − i)!

8νr
‘

.

(4.16)

kν=p+1/2(r) = exp

It is possible that the most interesting cases for machine learning are ν = 3/2
and ν = 5/2, for which

(cid:16)
(cid:16)

(cid:17)

√

3r
√
‘
5r
‘

exp

+

5r2
3‘2

(cid:16)−
(cid:17)

√

(cid:17)
(cid:16)−

3r
‘

exp

kν=3/2(r) =

kν=5/2(r) =

1 +

1 +

(cid:17)

,

(4.17)

,

√

5r
‘

since for ν = 1/2 the process becomes very rough (see below), and for ν ≥ 7/2,
in the absence of explicit prior knowledge about the existence of higher order
derivatives, it is probably very hard from ﬁnite noisy training examples to
distinguish between values of ν ≥ 7/2 (or even to distinguish between ﬁnite
values of ν and ν → ∞, the smooth squared exponential, in this case). For
example a value of ν = 5/2 was used in [Cornford et al., 2002].

Ornstein-Uhlenbeck Process and Exponential Covariance Function

The special case obtained by setting ν = 1/2 in the Mat´ern class gives the
exponential covariance function k(r) = exp(−r/‘). The corresponding process

exponential

012300.20.40.60.81input distance, rcovariance, k(r)ν=1/2ν=2ν→∞−505−202input, xoutput, f(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

86

Covariance Functions

(a)

(b)

Figure 4.2: Panel (a) covariance functions, and (b) random functions drawn from
Gaussian processes with the γ-exponential covariance function eq. (4.18), for diﬀerent
values of γ, with ‘ = 1. The sample functions are only diﬀerentiable when γ = 2 (the
SE case). The sample functions on the right were obtained using a discretization of
the x-axis of 2000 equally-spaced points.

is MS continuous but not MS diﬀerentiable. In D = 1 this is the covariance
function of the Ornstein-Uhlenbeck (OU) process. The OU process [Uhlenbeck
and Ornstein, 1930] was introduced as a mathematical model of the velocity
of a particle undergoing Brownian motion. More generally in D = 1 setting
ν + 1/2 = p for integer p gives rise to a particular form of a continuous-time
AR(p) Gaussian process; for further details see section B.2.1. The form of the
Mat´ern covariance function and samples drawn from it for ν = 1/2, ν = 2 and
ν → ∞ are illustrated in Figure 4.1.

The γ-exponential Covariance Function

The γ-exponential family of covariance functions, which includes both the ex-
ponential and squared exponential, is given by

k(r) = exp(cid:0) − (r/‘)γ(cid:1) for 0 < γ ≤ 2.

(4.18)

Although this function has a similar number of parameters to the Mat´ern class,
it is (as Stein [1999] notes) in a sense less ﬂexible. This is because the corre-
sponding process is not MS diﬀerentiable except when γ = 2 (when it is in-
ﬁnitely MS diﬀerentiable). The covariance function and random samples from
the process are shown in Figure 4.2. A proof of the positive deﬁniteness of this
covariance function can be found in Schoenberg [1938].

Rational Quadratic Covariance Function

The rational quadratic (RQ) covariance function

(cid:16)

(cid:17)−α

kRQ(r) =

1 + r2
2α‘2

(4.19)

Ornstein-Uhlenbeck
process

γ-exponential

rational quadratic

012300.20.40.60.81input distancecovarianceγ=1γ=1.5γ=2−505−3−2−10123input, xoutput, f(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.2 Examples of Covariance Functions

87

(a)

(b)

Figure 4.3: Panel (a) covariance functions, and (b) random functions drawn from
Gaussian processes with rational quadratic covariance functions, eq. (4.20), for diﬀer-
ent values of α with ‘ = 1. The sample functions on the right were obtained using a
discretization of the x-axis of 2000 equally-spaced points.

with α, ‘ > 0 can be seen as a scale mixture (an inﬁnite sum) of squared
exponential (SE) covariance functions with diﬀerent characteristic length-scales
(sums of covariance functions are also a valid covariance, see section 4.2.4).
Parameterizing now in terms of inverse squared length scales, τ = ‘−2, and
putting a gamma distribution on p(τ|α, β) ∝ τ α−1 exp(−ατ /β),5 we can add
up the contributions through the following integral

p(τ|α, β)kSE(r|τ) dτ

(cid:17)

(cid:16)− ατ

β

(cid:16)− τ r2

2

(cid:17)

dτ ∝ (cid:16)

1 + r2
2α‘2

(cid:17)−α

,

(4.20)

exp

Z
Z

kRQ(r) =

∝

τ α−1 exp

scale mixture

where we have set β−1 = ‘2. The rational quadratic is also discussed by Mat´ern
[1960, p. 17] using a slightly diﬀerent parameterization; in our notation the limit
of the RQ covariance for α → ∞ (see eq. (A.25)) is the SE covariance function
with characteristic length-scale ‘, eq. (4.9). Figure 4.3 illustrates the behaviour
for diﬀerent values of α; note that the process is inﬁnitely MS diﬀerentiable for
every α in contrast to the Mat´ern covariance function in Figure 4.1.

The previous example is a special case of kernels which can be written as
superpositions of SE kernels with a distribution p(‘) of length-scales ‘, k(r) =

R exp(−r2/2‘2)p(‘) d‘. This is in fact the most general representation for an

isotropic kernel which deﬁnes a valid covariance function in any dimension D,
see [Stein, 1999, sec. 2.10].

Piecewise Polynomial Covariance Functions with Compact Support

A family of piecewise polynomial functions with compact support provide an-
other interesting class of covariance functions. Compact support means that

5 Note that there are several common ways to parameterize the Gamma distribution—our

choice is convenient here: α is the “shape” and β is the mean.

piecewise polynomial
covariance functions
with compact support

012300.20.40.60.81input distancecovarianceα=1/2α=2α→∞−505−3−2−10123input, xoutput, f(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

88

Covariance Functions

(a)

(b)

Figure 4.4: Panel (a): covariance functions, and (b): random functions drawn from
Gaussian processes with piecewise polynomial covariance functions with compact sup-
port from eq. (4.21), with speciﬁed parameters.

positive deﬁniteness

restricted dimension

the covariance between points become exactly zero when their distance exceeds
a certain threshold. This means that the covariance matrix will become sparse
by construction, leading to the possibility of computational advantages.6 The
challenge in designing these functions is how to guarantee positive deﬁnite-
ness. Multiple algorithms for deriving such covariance functions are discussed
by Wendland [2005, ch. 9]. These functions are usually not positive deﬁnite
for all input dimensions, but their validity is restricted up to some maximum
dimension D. Below we give examples of covariance functions kppD,q(r) which
are positive deﬁnite in RD

kppD,0(r) = (1 − r)j
+,
kppD,1(r) = (1 − r)j+1
kppD,2(r) = (1 − r)j+2
kppD,3(r) = (1 − r)j+3

+

+

+

2 c + q + 1,

where j = b D

(cid:0)(j + 1)r + 1(cid:1),
(cid:0)(j2 + 4j + 3)r2 + (3j + 6)r + 3(cid:1)/3,
(cid:0)(j3 + 9j2 + 23j + 15)r3+
(6j2 + 36j + 45)r2 + (15j + 45)r + 15(cid:1)/15.

(4.21)

The properties of three of these covariance functions are illustrated in Fig-
ure 4.4. These covariance functions are 2q-times continuously diﬀerentiable,
and thus the corresponding processes are q-times mean-square diﬀerentiable,
see section 4.1.1.
It is interesting to ask to what extent one could use the
compactly-supported covariance functions described above in place of the other
covariance functions mentioned in this section, while obtaining inferences that
are similar. One advantage of the compact support is that it gives rise to spar-
sity of the Gram matrix which could be exploited, for example, when using
iterative solutions to GPR problem, see section 8.3.6.

6If the product of the inverse covariance matrix with a vector (needed e.g. for prediction)
is computed using a conjugate gradient algorithm, then products of the covariance matrix
with vectors are the basic computational unit, and these can obviously be carried out much
faster if the matrix is sparse.

00.20.40.60.8100.20.40.60.81input distance, rcovariance, k(r)D=1, q=1D=3, q=1D=1, q=2−2−1012−202input, xoutput, f(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.2 Examples of Covariance Functions

89

Further Properties of Stationary Covariance Functions

The covariance functions given above decay monotonically with r and are always
positive. However, this is not a necessary condition for a covariance function.
For example Yaglom [1987] shows that k(r) = c(αr)−νJν(αr) is a valid covari-
ance function for ν ≥ (D − 2)/2 and α > 0; this function has the form of a
damped oscillation.

Anisotropic versions of these isotropic covariance functions can be created
by setting r2(x, x0) = (x − x0)>M(x − x0) for some positive semideﬁnite M.
If M is diagonal this implements the use of diﬀerent length-scales on diﬀerent
dimensions—for further discussion of automatic relevance determination see
section 5.1. General M’s have been considered by Mat´ern [1960, p. 19], Poggio
and Girosi [1990] and also in Vivarelli and Williams [1999]; in the latter work a
low-rank M was used to implement a linear dimensionality reduction step from
the input space to lower-dimensional feature space. More generally, one could
assume the form

(4.22)
where Λ is a D × k matrix whose columns deﬁne k directions of high relevance,
and Ψ is a diagonal matrix (with positive entries), capturing the (usual) axis-
aligned relevances, see also Figure 5.1 on page 107. Thus M has a factor analysis
form. For appropriate choices of k this may represent a good trade-oﬀ between
ﬂexibility and required number of parameters.

M = ΛΛ> + Ψ

k(x), the kernel kT(x) =P

Stationary kernels can also be deﬁned on a periodic domain, and can be
readily constructed from stationary kernels on R. Given a stationary kernel
m∈Z k(x + ml) is periodic with period l, as shown in

section B.2.2 and Sch¨olkopf and Smola [2002, eq. 4.42].

anisotropy

factor analysis distance

periodization

If σ2

4.2.2 Dot Product Covariance Functions
0 + x · x0 can
As we have already mentioned above the kernel k(x, x0) = σ2
0 = 0 we call this the homogeneous
be obtained from linear regression.
linear kernel, otherwise it is inhomogeneous. Of course this can be generalized
0 + x>Σpx0 by using a general covariance matrix Σp on the
to k(x, x0) = σ2
components of x, as described in eq. (2.4).7 It is also the case that k(x, x0) =
0 + x>Σpx0)p is a valid covariance function for positive integer p, because of
(σ2
the general result that a positive-integer power of a given covariance function is
also a valid covariance function, as described in section 4.2.4. However, it is also
interesting to show an explicit feature space construction for the polynomial
covariance function. We consider the homogeneous polynomial case as the
inhomogeneous case can simply be obtained by considering x to be extended

7Indeed the bias term could also be included in the general expression.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

90

Covariance Functions

by concatenating a constant. We write

(cid:16) DX

d=1

(cid:17)p

(cid:16) DX

d1=1

=

(cid:17)···(cid:16) DX

dp=1

(cid:17)

xdpx0

dp

xd1x0

d1

xdx0

d

(xd1 ··· xdp)(x0

d1 ··· x0

dp

) , φ(x) · φ(x0).

(4.23)

k(x, x0) = (x · x0)p =

DX

··· DX

d1=1

dp=1

=

d appears in the monomial, under the constraint that PD

Notice that this sum apparently contains Dp terms but in fact it is less than this
as the order of the indices in the monomial xd1 ··· xdp is unimportant, e.g. for
p = 2, x1x2 and x2x1 are the same monomial. We can remove the redundancy
by deﬁning a vector m whose entry md speciﬁes the number of times index
i=1 mi = p. Thus
φm(x), the feature corresponding to vector m is proportional to the monomial
m1!...mD! (where as usual we deﬁne
xm1
1
0! = 1), giving the feature map

D . The degeneracy of φm(x) is

. . . xmD

p!

r

φm(x) =

p!

m1!··· mD! xm1

1

··· xmD
D .

(4.24)

√

2x1x2)>. Dot-
For example, for p = 2 in D = 2, we have φ(x) = (x2
product kernels are sometimes used in a normalized form given by eq. (4.35).
For regression problems the polynomial kernel is a rather strange choice as
the prior variance grows rapidly with |x| for |x| > 1. However, such kernels
have proved eﬀective in high-dimensional classiﬁcation problems (e.g. take x
to be a vectorized binary image) where the input data are binary or greyscale
normalized to [−1, 1] on each dimension [Sch¨olkopf and Smola, 2002, sec. 7.8].

1, x2
2,

4.2.3 Other Non-stationary Covariance Functions

Above we have seen examples of non-stationary dot product kernels. However,
there are also other interesting kernels which are not of this form. In this section
we ﬁrst describe the covariance function belonging to a particular type of neural
network; this construction is due to Neal [1996].

Consider a network which takes an input x, has one hidden layer with NH
units and then linearly combines the outputs of the hidden units with a bias b
to obtain f(x). The mapping can be written

f(x) = b +

vjh(x; uj),

(4.25)

j=1

where the vjs are the hidden-to-output weights and h(x; u) is the hidden unit
transfer function (which we shall assume is bounded) which depends on the
input-to-hidden weights u. For example, we could choose h(x; u) = tanh(x· u).
This architecture is important because it has been shown by Hornik [1993] that
networks with one hidden layer are universal approximators as the number of

NHX

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.2 Examples of Covariance Functions

91

hidden units tends to inﬁnity, for a wide class of transfer functions (but exclud-
ing polynomials). Let b and the v’s have independent zero-mean distributions
v, respectively, and let the weights uj for each hidden unit
of variance σ2
be independently and identically distributed. Denoting all weights by w, we
obtain (following Neal [1996])

b and σ2

Ew[f(x)] = 0
Ew[f(x)f(x0)] = σ2

b +X

Eu[h(x; uj)h(x0; uj)]

σ2
v

j

= σ2

b + NH σ2

v

Eu[h(x; u)h(x0; u)],

(4.26)
(4.27)

(4.28)

where eq. (4.28) follows because all of the hidden units are identically dis-
tributed. The ﬁnal term in equation 4.28 becomes ω2Eu[h(x; u)h(x0; u)] by
letting σ2

v scale as ω2/NH.

The sum in eq. (4.27) is over NH identically and independently distributed
random variables. As the transfer function is bounded, all moments of the
distribution will be bounded and hence the central limit theorem can be applied,
showing that the stochastic process will converge to a Gaussian process in the
limit as NH → ∞.

πR z

By evaluating Eu[h(x; u)h(x0; u)] we can obtain the covariance function of
the neural network. For example if we choose the error function h(z) = erf(z) =
√
j=1ujxj) and
2/
choose u ∼ N (0, Σ) then we obtain [Williams, 1998]
2˜x>Σ˜x0

dt as the transfer function, let h(x; u) = erf(u0 +PD
(cid:17)

0 e−t2

p(1 + 2˜x>Σ˜x)(1 + 2˜x0>Σ˜x0)

,

sin−1(cid:16)

2
π

kNN(x, x0) =

(4.29)

where ˜x = (1, x1, . . . , xd)> is an augmented input vector. This is a true “neural
network” covariance function. The “sigmoid” kernel k(x, x0) = tanh(a + bx· x0)
has sometimes been proposed, but in fact this kernel is never positive deﬁ-
nite and is thus not a valid covariance function, see, e.g. Sch¨olkopf and Smola
[2002, p. 113]. Figure 4.5 shows a plot of the neural network covariance function
and samples from the prior. We have set Σ = diag(σ2
0, σ2). Samples from a GP
with this covariance function can be viewed as superpositions of the functions
erf(u0 +ux), where σ2
0 controls the variance of u0 (and thus the amount of oﬀset
of these functions from the origin), and σ2 controls u and thus the scaling on
the x-axis. In Figure 4.5(b) we observe that the sample functions with larger σ
vary more quickly. Notice that the samples display the non-stationarity of the
covariance function in that for large values of +x or −x they should tend to a
constant value, consistent with the construction as a superposition of sigmoid
functions.

Another interesting construction is to set h(x; u) = exp(−|x − u|2/2σ2
g),
where σg sets the scale of this Gaussian basis function. With u ∼ N (0, σ2
uI)

neural network
covariance function

modulated squared
exponential

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

92

Covariance Functions

(a), covariance

(b), sample functions

Figure 4.5: Panel (a): a plot of the covariance function kNN(x, x0) for σ0 = 10, σ = 10.
Panel (b): samples drawn from the neural network covariance function with σ0 = 2
and σ as shown in the legend. The samples were obtained using a discretization of
the x-axis of 500 equally-spaced points.

(4.30)

,

we obtain
kG(x, x0) =

Z
(cid:16)− x>x

(cid:16)− |x − u|2
(cid:17)

2σ2
g

exp

exp

− |x0 − u|2
(cid:16)− |x − x0|2
(cid:17)
2σ2
g

(cid:17)
− u>u
(cid:16)− x0>x0
2σ2
u

du

(cid:17)

exp

2σ2
m
s = 2σ2

2σ2
s
u and σ2

2σ2
m
u + σ2

1
(2πσ2
u)d/2

(cid:16) σe

(cid:17)d

exp

=

σu
e = 2/σ2

g/σ2

u, σ2

g + σ4

g + 1/σ2

m = 2σ2
where 1/σ2
g. This is
u → ∞ (while scaling
in general a non-stationary covariance function, but if σ2
ω2 appropriately) we recover the squared exponential kG(x, x0) ∝ exp(−|x −
x0|2/4σ2
u, kG(x, x0) comprises a squared exponen-
tial covariance function modulated by the Gaussian decay envelope function
exp(−x>x/2σ2
m), cf. the vertical rescaling construction de-
scribed in section 4.2.4.

g). For a ﬁnite value of σ2

m) exp(−x0>x0/2σ2

One way to introduce non-stationarity is to introduce an arbitrary non-linear
mapping (or warping) u(x) of the input x and then use a stationary covariance
function in u-space. Note that x and u need not have the same dimensionality as
each other. This approach was used by Sampson and Guttorp [1992] to model
patterns of solar radiation in southwestern British Columbia using Gaussian
processes.

Another interesting example of this warping construction is given in MacKay

[1998] where the one-dimensional input variable x is mapped to the two-dimensional
u(x) = (cos(x), sin(x)) to give rise to a periodic random function of x. If we
use the squared exponential kernel in u-space, then

(cid:16)− 2 sin2(cid:0) x−x0

2

(cid:1)

(cid:17)

‘2

k(x, x0) = exp

as (cos(x) − cos(x0))2 + (sin(x) − sin(x0))2 = 4 sin2( x−x0

2

(4.31)

,

).

warping

periodic random
function

−404−404input, xinput, x’−0.5−0.5000.50.50.950.95−404−101input, xoutput, f(x)σ = 10σ = 3σ = 1C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.2 Examples of Covariance Functions

93

(a)

(b)

Figure 4.6: Panel (a) shows the chosen length-scale function ‘(x). Panel (b) shows
three samples from the GP prior using Gibbs’ covariance function eq. (4.32). This
ﬁgure is based on Fig. 3.9 in Gibbs [1997].

We have described above how to make an anisotropic covariance function
by scaling diﬀerent dimensions diﬀerently. However, we are not free to make
these length-scales ‘d be functions of x, as this will not in general produce a
valid covariance function. Gibbs [1997] derived the covariance function

varying length-scale

k(x, x0) =

DY

(cid:16) 2‘d(x)‘d(x0)

(cid:17)1/2

d(x) + ‘2
‘2

d(x0)

d=1

(cid:16)− DX

d=1

exp

(cid:17)

(xd − x0
d(x) + ‘2
‘2

d)2
d(x0)

,

(4.32)

where each ‘i(x) is an arbitrary positive function of x. Note that k(x, x) = 1
for all x. This covariance function is obtained by considering a grid of N
Gaussian basis functions with centres cj and a corresponding length-scale on
input dimension d which varies as a positive function ‘d(cj). Taking the limit
as N → ∞ the sum turns into an integral and after some algebra eq. (4.32) is
obtained.

An example of a variable length-scale function and samples from the prior
corresponding to eq. (4.32) are shown in Figure 4.6. Notice that as the length-
scale gets shorter the sample functions vary more rapidly as one would expect.
The large length-scale regions on either side of the short length-scale region can
be quite strongly correlated. If one tries the converse experiment by creating
a length-scale function ‘(x) which has a longer length-scale region between
two shorter ones then the behaviour may not be quite what is expected; on
initially transitioning into the long length-scale region the covariance drops oﬀ
quite sharply due to the prefactor in eq. (4.32), before stabilizing to a slower
variation. See Gibbs [1997, sec. 3.10.3] for further details. Exercises 4.5.4 and
4.5.5 invite you to investigate this further.

Paciorek and Schervish [2004] have generalized Gibbs’ construction to obtain
non-stationary versions of arbitrary isotropic covariance functions. Let kS be a

0123400.511.5lengthscale l(x)input, x01234−101input, xoutput, f(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

94

Covariance Functions

covariance function
constant
linear
polynomial
squared exponential

Mat´ern
exponential
γ-exponential
rational quadratic
neural network

d

expression
σ2
0

PD

d=1 σ2

1

dxdx0
(x · x0 + σ2
0)p
exp(− r2
2‘2 )

(cid:16)√
‘ )γ(cid:1)
exp(cid:0) − ( r
sin−1(cid:0)

2α‘2 )−α
(1 + r2
√

2ν−1Γ(ν)
exp(− r
‘ )

(cid:17)ν

(cid:17)

(cid:16)√

2ν
‘ r

Kν

2ν
‘ r

2˜x>Σ˜x0

(1+2˜x>Σ˜x)(1+2˜x0>Σ˜x0)

S ND
√

√ √
√ √
√ √
√ √
√ √
√

(cid:1)

Table 4.1: Summary of several commonly-used covariance functions. The covariances
are written either as a function of x and x0, or as a function of r = |x − x0|. Two
columns marked ‘S’ and ‘ND’ indicate whether the covariance functions are stationary
and nondegenerate respectively. Degenerate covariance functions have ﬁnite rank, see
section 4.3 for more discussion of this issue.

stationary, isotropic covariance function that is valid in every Euclidean space
RD for D = 1, 2, . . .. Let Σ(x) be a D × D matrix-valued function which
is positive deﬁnite for all x, and let Σi , Σ(xi).
(The set of Gibbs’ ‘i(x)
functions deﬁne a diagonal Σ(x).) Then deﬁne the quadratic form

Qij = (xi − xj)>((Σi + Σj)/2)−1(xi − xj).

Paciorek and Schervish [2004] show that

kNS(xi, xj) = 2D/2|Σi|1/4|Σj|1/4|Σi + Σj|−1/2kS(pQij),

(4.33)

(4.34)

Wiener process

is a valid non-stationary covariance function.

In chapter 2 we described the linear regression model in feature space f(x) =
φ(x)>w. O’Hagan [1978] suggested making w a function of x to allow for
diﬀerent values of w to be appropriate in diﬀerent regions. Thus he put a
Gaussian process prior on w of the form cov(w(x), w(x0)) = W0kw(x, x0) for
some positive deﬁnite matrix W0, giving rise to a prior on f(x) with covariance
kf (x, x0) = φ(x)>W0φ(x0)kw(x, x0).

Finally we note that the Wiener process with covariance function k(x, x0) =
min(x, x0) is a fundamental non-stationary process. See section B.2.1 and texts
such as Grimmett and Stirzaker [1992, ch. 13] for further details.

4.2.4 Making New Kernels from Old

In the previous sections we have developed many covariance functions some of
which are summarized in Table 4.1. In this section we show how to combine or
modify existing covariance functions to make new ones.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

95

sum

product

vertical rescaling

convolution

direct sum
tensor product

additive model

functional ANOVA

4.2 Examples of Covariance Functions

The sum of two kernels is a kernel. Proof: consider the random process
f(x) = f1(x) + f2(x), where f1(x) and f2(x) are independent. Then k(x, x0) =
k1(x, x0) + k2(x, x0). This construction can be used e.g. to add together kernels
with diﬀerent characteristic length-scales.

The product of two kernels is a kernel. Proof: consider the random process
f(x) = f1(x)f2(x), where f1(x) and f2(x) are independent. Then k(x, x0) =
k1(x, x0)k2(x, x0).8 A simple extension of this argument means that kp(x, x0) is
a valid covariance function for p ∈ N.

Let a(x) be a given deterministic function and consider g(x) = a(x)f(x)
where f(x) is a random process. Then cov(g(x), g(x0)) = a(x)k(x, x0)a(x0).
Such a construction can be used to normalize kernels by choosing a(x) =
k−1/2(x, x) (assuming k(x, x) > 0 ∀x), so that

˜k(x, x0) =

pk(x, x)pk(x0, x0)

k(x, x0)

.

(4.35)

This ensures that ˜k(x, x) = 1 for all x.

We can also obtain a new process by convolution (or blurring). Consider

an arbitrary ﬁxed kernel h(x, z) and the map g(x) = R h(x, z)f(z) dz. Then
clearly cov(g(x), g(x0)) =R h(x, z)k(z, z0)h(x0, z0) dz dz0.

i=1fi(xi),

If k(x1, x0

1) + k2(x2, x0

i=1fi(xi) +P

shirani, 1990] has the form f(x) = c +PD
f(x) = c +PD
form k(x, x0) =PD

2) are covariance functions over diﬀerent spaces X1
1) and k(x2, x0
and X2, then the direct sum k(x, x0) = k1(x1, x0
2) and the tensor
1)k2(x2, x0
product k(x, x0) = k1(x1, x0
2) are also covariance functions (deﬁned
on the product space X1×X2), by virtue of the sum and product constructions.
The direct sum construction can be further generalized. Consider a func-
tion f(x), where x is D-dimensional. An additive model [Hastie and Tib-
i.e. a linear combina-
tion of functions of one variable.
If the individual fi’s are taken to be in-
dependent stochastic processes, then the covariance function of f will have the
form of a direct sum. If we now admit interactions of two variables, so that
ij,j<i fij(xi, xj) and the various fi’s and fij’s are
independent stochastic processes, then the covariance function will have the
j). Indeed this pro-
cess can be extended further to provide a functional ANOVA9 decomposition,
ranging from a simple additive model up to full interaction of all D input vari-
ables. (The sum can also be truncated at some stage.) Wahba [1990, ch. 10]
and Stitson et al. [1999] suggest using tensor products for kernels with inter-
actions so that in the example above kij(xi, xj; x0
j) would have the form
ki(xi; x0
j). Note that if D is large then the large number of pairwise
(or higher-order) terms may be problematic; Plate [1999] has investigated using
a combination of additive GP models plus a general covariance function that
permits full interactions.

Pi−1
j=1 kij(xi, xj; x0

i) +PD

i=1ki(xi, x0

i=2

i)kj(xj; x0

i, x0

i, x0

8If f1 and f2 are Gaussian processes then the product f will not in general be a Gaussian

process, but there exists a GP with this covariance function.

9ANOVA stands for analysis of variance, a statistical technique that analyzes the interac-

tions between various attributes.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

96

Covariance Functions

4.3 Eigenfunction Analysis of Kernels

We ﬁrst deﬁne eigenvalues and eigenfunctions and discuss Mercer’s theorem
which allows us to express the kernel (under certain conditions) in terms of these
quantities. Section 4.3.1 gives the analytical solution of the eigenproblem for the
SE kernel under a Gaussian measure. Section 4.3.2 discusses how to compute
approximate eigenfunctions numerically for cases where the exact solution is
not known.

It turns out that Gaussian process regression can be viewed as Bayesian
linear regression with a possibly inﬁnite number of basis functions, as discussed
in chapter 2. One possible basis set is the eigenfunctions of the covariance
function. A function φ(·) that obeys the integral equation

k(x, x0)φ(x) dµ(x) = λφ(x0),

(4.36)

Z

eigenvalue,
eigenfunction

Mercer’s theorem

is called an eigenfunction of kernel k with eigenvalue λ with respect to measure10
µ. The two measures of particular interest to us will be (i) Lebesgue measure
over a compact subset C of RD, or (ii) when there is a density p(x) so that
dµ(x) can be written p(x)dx.

In general there are an inﬁnite number of eigenfunctions, which we label
φ1(x), φ2(x), . . . We assume the ordering is chosen such that λ1 ≥ λ2 ≥ . . ..
The eigenfunctions are orthogonal with respect to µ and can be chosen to be

normalized so thatR φi(x)φj(x) dµ(x) = δij where δij is the Kronecker delta.

Mercer’s theorem (see, e.g. K¨onig, 1986) allows us to express the kernel k

in terms of the eigenvalues and eigenfunctions.
Theorem 4.2 (Mercer’s theorem). Let (X , µ) be a ﬁnite measure space and
k ∈ L∞(X 2, µ2) be a kernel such that Tk : L2(X , µ) → L2(X , µ) is positive
deﬁnite (see eq. (4.2)). Let φi ∈ L2(X , µ) be the normalized eigenfunctions of
Tk associated with the eigenvalues λi > 0. Then:

1. the eigenvalues {λi}∞
2.

i=1 are absolutely summable

∞X

k(x, x0) =

λiφi(x)φ∗

i (x0),

(4.37)

holds µ2 almost everywhere, where the series converges absolutely and
(cid:3)
uniformly µ2 almost everywhere.

i=1

This decomposition is just the inﬁnite-dimensional analogue of the diagonaliza-
tion of a Hermitian matrix. Note that the sum may terminate at some value
N ∈ N (i.e. the eigenvalues beyond N are zero), or the sum may be inﬁnite.
We have the following deﬁnition [Press et al., 1992, p. 794]

10For further explanation of measure see Appendix A.7.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.3 Eigenfunction Analysis of Kernels

97

Deﬁnition 4.1 A degenerate kernel has only a ﬁnite number of non-zero eigen-
(cid:3)
values.

A degenerate kernel is also said to have ﬁnite rank. If a kernel is not degenerate
it is said to be nondegenerate. As an example a N-dimensional linear regression
model in feature space (see eq. (2.10)) gives rise to a degenerate kernel with at
most N non-zero eigenvalues. (Of course if the measure only puts weight on a
ﬁnite number of points n in x-space then the eigendecomposition is simply that
of a n × n matrix, even if the kernel is nondegenerate.)

degenerate,
nondegenerate
kernel

The statement of Mercer’s theorem above referred to a ﬁnite measure µ.
If we replace this with Lebesgue measure and consider a stationary covariance
function, then directly from Bochner’s theorem eq. (4.5) we obtain

k(x − x0) =

e2πis·(x−x0) dµ(s) =

dµ(s).

(4.38)

Z

RD

e2πis·x(cid:16)

e2πis·x0(cid:17)∗

Z

RD

The complex exponentials e2πis·x are the eigenfunctions of a stationary kernel
w.r.t. Lebesgue measure. Note the similarity to eq. (4.37) except that the
summation has been replaced by an integral.

The rate of decay of the eigenvalues gives important information about the
smoothness of the kernel. For example Ritter et al. [1995] showed that in 1-d
with µ uniform on [0, 1], processes which are r-times mean-square diﬀerentiable
have λi ∝ i−(2r+2) asymptotically. This makes sense as “rougher” processes
have more power at high frequencies, and so their eigenvalue spectrum decays
more slowly. The same phenomenon can be read oﬀ from the power spectrum
of the Mat´ern class as given in eq. (4.15).

Hawkins [1989] gives the exact eigenvalue spectrum for the OU process on
[0, 1]. Widom [1963; 1964] gives an asymptotic analysis of the eigenvalues of
stationary kernels taking into account the eﬀect of the density dµ(x) = p(x)dx;
Bach and Jordan [2002, Table 3] use these results to show the eﬀect of varying
p(x) for the SE kernel. An exact eigenanalysis of the SE kernel under the
Gaussian density is given in the next section.

4.3.1 An Analytic Example

∗

For the case that p(x) is a Gaussian and for the squared-exponential kernel
k(x, x0) = exp(−(x−x0)2/2‘2), there are analytic results for the eigenvalues and
eigenfunctions, as given by Zhu et al. [1998, sec. 4]. Putting p(x) = N (x|0, σ2)
we ﬁnd that the eigenvalues λk and eigenfunctions φk (for convenience let k =
0, 1, . . . ) are given by

r2a

A

λk =

φk(x) = exp(cid:0)− (c − a)x2(cid:1)Hk

Bk,

(cid:0)√

2cx(cid:1),

(4.39)

(4.40)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

98

Covariance Functions

Figure 4.7: The ﬁrst 3 eigenfunctions of the squared exponential kernel w.r.t. a
Gaussian density. The value of k = 0, 1, 2 is equal to the number of zero-crossings
of the function. The dashed line is proportional to the density p(x).

where Hk(x) = (−1)k exp(x2) dk
(see Gradshteyn and Ryzhik [1980, sec. 8.95]), a−1 = 4σ2, b−1 = 2‘2 and

dxk exp(−x2) is the kth order Hermite polynomial

a2 + 2ab,

A = a + b + c,

B = b/A.

(4.41)

Hints on the proof of this result are given in exercise 4.5.9. A plot of the ﬁrst
three eigenfunctions for a = 1 and b = 3 is shown in Figure 4.7.

The result for the eigenvalues and eigenfunctions is readily generalized to
the multivariate case when the kernel and Gaussian density are products of
the univariate expressions, as the eigenfunctions and eigenvalues will simply
be products too. For the case that a and b are equal on all D dimensions,
the degeneracy of the eigenvalue ( 2a

(cid:1) which is O(kD−1). As
(cid:1)’th eigenvalue has a value given by

(cid:1) we see that the(cid:0)k+D

(cid:1) =(cid:0)k+D

A )D/2Bk is(cid:0)k+D−1

D−1

Pk

(cid:0)j+D−1

D−1

A )D/2Bk, and this can be used to determine the rate of decay of the spectrum.
( 2a

j=0

D

D

4.3.2 Numerical Approximation of Eigenfunctions

The standard numerical method for approximating the eigenfunctions and eigen-
values of eq. (4.36) is to use a numerical routine to approximate the integral
(see, e.g. Baker [1977, ch. 3]). For example letting dµ(x) = p(x)dx in eq. (4.36)
one could use the approximation

c =p

Z

λiφi(x0) =

k(x, x0)p(x)φi(x) dx ’ 1
n

k(xl, x0)φi(xl),

(4.42)

nX

l=1

−202−0.200.20.4C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.4 Kernels for Non-vectorial Inputs

99

where the xl’s are sampled from p(x). Plugging in x0 = xl for l = 1, . . . , n into
eq. (4.42) we obtain the matrix eigenproblem

Kui = λmat

i ui,

(4.43)

i

√

n(ui)j where the

where K is the n× n Gram matrix with entries Kij = k(xi, xj), λmat
is the ith
i ui = 1). We have φi(xj) ∼ √
matrix eigenvalue and ui is the corresponding eigenvector (normalized so that
u>
n factor arises from the
diﬀering normalizations of the eigenvector and eigenfunction. Thus 1
is
an obvious estimator for λi for i = 1, . . . , n. For ﬁxed n one would expect that
the larger eigenvalues would be better estimated than the smaller ones. The
theory of the numerical solution of eigenvalue problems shows that for a ﬁxed i,
will converge to λi in the limit that n → ∞ [Baker, 1977, Theorem 3.4].
1
n λmat
It is also possible to study the convergence further; for example it is quite
easy using the properties of principal components analysis (PCA) in feature
space to show that for any l, 1 ≤ l ≤ n, En[ 1
i=1λi and
En[ 1
i=l+1λi, where En denotes expectation with respect to
samples of size n drawn from p(x). For further details see Shawe-Taylor and
Williams [2003].

] ≥ Pl

] ≤PN

Pn

i=l+1λmat

i

Pl

n λmat

i

i=1λmat

i

n

i

n

Nystr¨om method

kernel PCA

The Nystr¨om method for approximating the ith eigenfunction (see Baker

[1977] and Press et al. [1992, section 18.1]) is given by

φi(x0) ’

k(x0)>ui,

(4.44)

√

n
λmat

i

where k(x0)> = (k(x1, x0), . . . , k(xn, x0)), which is obtained from eq. (4.42) by
dividing both sides by λi. Equation 4.44 extends the approximation φi(xj) ’
√
n(ui)j from the sample points x1, . . . , xn to all x.

There is an interesting relationship between the kernel PCA method of
Sch¨olkopf et al. [1998] and the eigenfunction expansion discussed above. The
eigenfunction expansion has (at least potentially) an inﬁnite number of non-
zero eigenvalues. In contrast, the kernel PCA algorithm operates on the n × n
matrix K and yields n eigenvalues and eigenvectors. Eq. (4.42) clariﬁes the
relationship between the two. However, note that eq. (4.44) is identical (up to
scaling factors) to Sch¨olkopf et al. [1998, eq. 4.1] which describes the projection
of a new point x0 onto the ith eigenvector in the kernel PCA feature space.

4.4 Kernels for Non-vectorial Inputs

So far in this chapter we have assumed that the input x is a vector, measuring
the values of a number of attributes (or features). However, for some learning
problems the inputs are not vectors, but structured objects such as strings,
trees or general graphs. For example, we may have a biological problem where
we want to classify proteins (represented as strings of amino acid symbols).11

11Proteins are initially made up of 20 diﬀerent amino acids, of which a few may later be

modiﬁed bringing the total number up to 26 or 30.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

100

Covariance Functions

Or our input may be parse-trees derived from a linguistic analysis. Or we may
wish to represent chemical compounds as labelled graphs, with vertices denoting
atoms and edges denoting bonds.

To follow the discriminative approach we need to extract some features from
the input objects and build a predictor using these features. (For a classiﬁcation
problem, the alternative generative approach would construct class-conditional
models over the objects themselves.) Below we describe two approaches to
this feature extraction problem and the eﬃcient computation of kernels from
them: in section 4.4.1 we cover string kernels, and in section 4.4.2 we describe
Fisher kernels. There exist other proposals for constructing kernels for strings,
for example Watkins [2000] describes the use of pair hidden Markov models
(HMMs that generate output symbols for two strings conditional on the hidden
state) for this purpose.

4.4.1 String Kernels
We start by deﬁning some notation for strings. Let A be a ﬁnite alphabet of
characters. The concatenation of strings x and y is written xy and |x| denotes
the length of string x. The string s is a substring of x if we can write x = usv
for some (possibly empty) u, s and v.

Let φs(x) denote the number of times that substring s appears in string x.

Then we deﬁne the kernel between two strings x and x0 as

k(x, x0) = X

s∈A∗

wsφs(x)φs(x0),

(4.45)

where ws is a non-negative weight for substring s. For example, we could set
ws = λ|s|, where 0 < λ < 1, so that shorter substrings get more weight than
longer ones.

A number of interesting special cases are contained in the deﬁnition 4.45:
• Setting ws = 0 for |s| > 1 gives the bag-of-characters kernel. This takes
the feature vector for a string x to be the number of times that each
character in A appears in x.

• In text analysis we may wish to consider the frequencies of word occur-
rence. If we require s to be bordered by whitespace then a “bag-of-words”
representation is obtained. Although this is a very simple model of text
(which ignores word order) it can be surprisingly eﬀective for document
classiﬁcation and retrieval tasks, see e.g. Hand et al. [2001, sec. 14.3].
The weights can be set diﬀerently for diﬀerent words, e.g. using the “term
frequency inverse document frequency” (TF-IDF) weighting scheme de-
veloped in the information retrieval area [Salton and Buckley, 1988].

• If we only consider substrings of length k, then we obtain the k-spectrum

kernel [Leslie et al., 2003].

bag-of-characters

bag-of-words

k-spectrum kernel

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

4.4 Kernels for Non-vectorial Inputs

101

Importantly, there are eﬃcient methods using suﬃx trees that can compute
a string kernel k(x, x0) in time linear in |x| +|x0| (with some restrictions on the
weights {ws}) [Leslie et al., 2003, Vishwanathan and Smola, 2003].

Work on string kernels was started by Watkins [1999] and Haussler [1999].
There are many further developments of the methods we have described above;
for example Lodhi et al. [2001] go beyond substrings to consider subsequences
of x which are not necessarily contiguous, and Leslie et al. [2003] describe
mismatch string kernels which allow substrings s and s0 of x and x0 respectively
to match if there are at most m mismatches between them. We expect further
developments in this area, tailoring (or engineering) the string kernels to have
properties that make sense in a particular domain.

The idea of string kernels, where we consider matches of substrings, can
easily be extended to trees, e.g. by looking at matches of subtrees [Collins and
Duﬀy, 2002].

Leslie et al. [2003] have applied string kernels to the classiﬁcation of protein
domains into SCOP12 superfamilies. The results obtained were signiﬁcantly
better than methods based on either PSI-BLAST13 searches or a generative
hidden Markov model classiﬁer. Similar results were obtained by Jaakkola et al.
[2000] using a Fisher kernel (described in the next section). Saunders et al.
[2003] have also described the use of string kernels on the problem of classifying
natural language newswire stories from the Reuters-2157814 database into ten
classes.

4.4.2 Fisher Kernels

score vector

As explained above, our problem is that the input x is a structured object of
arbitrary size e.g. a string, and we wish to extract features from it. The Fisher
kernel (introduced by Jaakkola et al., 2000) does this by taking a generative
model p(x|θ), where θ is a vector of parameters, and computing the feature
vector φθ(x) = ∇θ log p(x|θ). φθ(x) is sometimes called the score vector.

in string x. Then a Markov model gives p(x|θ) = p(x1|π)Q|x|−1

Take, for example, a Markov model for strings. Let xk be the kth symbol
i=1 p(xi+1|xi, A),
where θ = (π, A). Here (π)j gives the probability that x1 will be the jth symbol
in the alphabet A, and A is a |A| × |A| stochastic matrix, with ajk giving the
probability that p(xi+1 = k|xi = j). Given such a model it is straightforward
to compute the score vector for a given x.

It is also possible to consider other generative models p(x|θ). For example
we might try a kth-order Markov model where xi is predicted by the preceding
k symbols. See Leslie et al. [2003] and Saunders et al. [2003] for an interesting
discussion of the similarities of the features used in the k-spectrum kernel and
the score vector derived from an order k − 1 Markov model; see also exercise
12Structural classiﬁcation of proteins database, http://scop.mrc-lmb.cam.ac.uk/scop/.
13Position-Speciﬁc Iterative Basic Local Alignment Search Tool, see

http://www.ncbi.nlm.nih.gov/Education/BLASTinfo/psi1.html.

14http://www.daviddlewis.com/resources/testcollections/reuters21578/.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

102

Covariance Functions

Fisher information
matrix

Fisher kernel

TOP kernel

4.5.12. Another interesting choice is to use a hidden Markov model (HMM) as
the generative model, as discussed by Jaakkola et al. [2000]. See also exercise
4.5.11 for a linear kernel derived from an isotropic Gaussian model for x ∈ RD.
We deﬁne a kernel k(x, x0) based on the score vectors for x and x0. One

simple choice is to set

k(x, x0) = φ

>
θ (x)M−1φθ(x0),

(4.46)

where M is a strictly positive deﬁnite matrix. Alternatively we might use the
squared exponential kernel k(x, x0) = exp(−α|φθ(x)−φθ(x0)|2) for some α > 0.
The structure of p(x|θ) as θ varies has been studied extensively in informa-
tion geometry (see, e.g. Amari, 1985). It can be shown that the manifold of
log p(x|θ) is Riemannian with a metric tensor which is the inverse of the Fisher
information matrix F , where

F = Ex[φθ(x)φ

>
θ (x)].

(4.47)

Setting M = F in eq. (4.46) gives the Fisher kernel . If F is diﬃcult to compute
then one might resort to setting M = I. The advantage of using the Fisher
information matrix is that it makes arc length on the manifold invariant to
reparameterizations of θ.

The Fisher kernel uses a class-independent model p(x|θ). Tsuda et al.
[2002] have developed the tangent of posterior odds (TOP) kernel based on
∇θ(log p(y = +1|x, θ)−log p(y = −1|x, θ)), which makes use of class-conditional
distributions for the C+ and C− classes.

4.5 Exercises

1. The OU process with covariance function k(x − x0) = exp(−|x − x0|/‘)
is the unique stationary ﬁrst-order Markovian Gaussian process (see Ap-
pendix B for further details). Consider training inputs x1 < x2 . . . <
xn−1 < xn on R with corresponding function values f = (f(x1), . . . , f(xn))>.
Let xl denote the nearest training input to the left of a test point x∗, and
similarly let xu denote the nearest training input to the right of x∗. Then
the Markovian property means that p(f(x∗)|f) = p(f(x∗)|f(xl), f(xu)).
Demonstrate this by choosing some x-points on the line and computing
the predictive distribution p(f(x∗)|f) using eq. (2.19), and observing that
non-zero contributions only arise from xl and xu. Note that this only
occurs in the noise-free case; if one allows the training points to be cor-
rupted by noise (equations 2.23 and 2.24) then all points will contribute
in general.

2. Computer exercise: write code to draw samples from the neural network
covariance function, eq. (4.29) in 1-d and 2-d. Consider the cases when
var(u0) is either 0 or non-zero. Explain the form of the plots obtained
when var(u0) = 0.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

103

4.5 Exercises

3. Consider the random process f(x) = erf(u0 +PD

i=1ujxj), where u ∼
N (0, Σ). Show that this non-linear transform of a process with an inho-
mogeneous linear covariance function has the same covariance function as
the erf neural network. However, note that this process is not a Gaussian
process. Draw samples from the given process and compare them to your
results from exercise 4.5.2.

4. Derive Gibbs’ non-stationary covariance function, eq. (4.32).

5. Computer exercise: write code to draw samples from Gibbs’ non-stationary
covariance function eq. (4.32) in 1-d and 2-d. Investigate various forms of
length-scale function ‘(x).

6. Show that the SE process is inﬁnitely MS diﬀerentiable and that the OU

process is not MS diﬀerentiable.

7. Prove that the eigenfunctions of a symmetric kernel are orthogonal w.r.t. the

measure µ.

8. Let ˜k(x, x0) = p1/2(x)k(x, x0)p1/2(x0), and assume p(x) > 0 for all x.
˜φi(x0) has the same

Show that the eigenproblem R ˜k(x, x0) ˜φi(x)dx = ˜λi
eigenvalues asR k(x, x0)p(x)φi(x)dx = λiφi(x0), and that the eigenfunc-

tions are related by ˜φi(x) = p1/2(x)φi(x). Also give the matrix version
of this problem (Hint: introduce a diagonal matrix P to take the rˆole of
p(x)). The signiﬁcance of this connection is that it can be easier to ﬁnd
eigenvalues of symmetric matrices than general matrices.

9. Apply the construction in the previous exercise to the eigenproblem for
the SE kernel and Gaussian density given in section 4.3.1, with p(x) =
exp(−ax2) exp(−b(x−x0)2) exp(−a(x0)2). Using equation 7.374.8 in Grad-
shteyn and Ryzhik [1980]:

p2a/π exp(−2ax2). Thus consider the modiﬁed kernel given by ˜k(x, x0) =
Z ∞
(cid:17)

exp(cid:0)− (x − y)2(cid:1)Hn(αx) dx =

π(1 − α2)n/2Hn

(cid:16)

√

αy

(1 − α2)1/2

,

−∞

√
verify that ˜φk(x) = exp(−cx2)Hk(
and 4.40.

2cx), and thus conﬁrm equations 4.39

10. Computer exercise: The analytic form of the eigenvalues and eigenfunc-
tions for the SE kernel and Gaussian density are given in section 4.3.1.
Compare these exact results to those obtained by the Nystr¨om approxi-
mation for various values of n and choice of samples.

11. Let x ∼ N (µ, σ2I). Consider the Fisher kernel derived from this model
with respect to variation of µ (i.e. regard σ2 as a constant). Show that:

(cid:12)(cid:12)(cid:12)(cid:12)µ=0

∂ log p(x|µ)

∂µ

=

x
σ2

and that F = σ−2I. Thus the Fisher kernel for this model with µ = 0 is
the linear kernel k(x, x0) = 1

σ2 x · x0.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

104

Covariance Functions

12. Consider a k − 1 order Markov model for strings on a ﬁnite alphabet. Let
this model have parameters θt|s1,...,sk−1 denoting the probability p(xi =
t|xi−1 = s1, . . . , xk−1 = sk−1). Of course as these are probabilities they
t0 θt0|s1,...,sk−1 = 1. Enforcing this constraint

obey the constraint that P

can be achieved automatically by setting

θt|s1,...,sk−1 =

P

θt,s1,...,sk−1
t0 θt0,s1,...,sk−1

,

where the θt,s1,...,sk−1 parameters are now independent, as suggested in
[Jaakkola et al., 2000]. The current parameter values are denoted θ0.
Let the current values of θ0
t0,s1,...,sk−1 = 1,
i.e. that θ0

Show that log p(x|θ) =P nt,s1,...,sk−1 log θt|s1,...,sk−1 where nt,s1,...,sk−1 is

t,s1,...,sk−1 be set so that P

the number of instances of the substring sk−1 . . . s1t in x. Thus, following
Leslie et al. [2003], show that

t0θ0

t,s1,...,sk−1 = θ0

t|s1,...,sk−1

.

(cid:12)(cid:12)(cid:12)(cid:12)θ=θ0

∂ log p(x|θ)
∂θt,s1,...,sk−1

=

nt,s1,...,sk−1
θ0
t|s1,...,sk−1

− ns1,...,sk−1,

t|s1,...,sk−1

where ns1,...,sk−1 is the number of instances of the substring sk−1 . . . s1 in
x. As ns1,...,sk−1θ0
is the expected number of occurrences of the
string sk−1 . . . s1t given the count ns1,...,sk−1, the Fisher score captures the
degree to which this string is over- or under-represented relative to the
model. For the k-spectrum kernel the relevant feature is φsk−1...,s1,t(x) =
nt,s1,...,sk−1.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 5

Model Selection and
Adaptation of
Hyperparameters

In chapters 2 and 3 we have seen how to do regression and classiﬁcation using
a Gaussian process with a given ﬁxed covariance function. However, in many
practical applications, it may not be easy to specify all aspects of the covari-
ance function with conﬁdence. While some properties such as stationarity of
the covariance function may be easy to determine from the context, we typically
have only rather vague information about other properties, such as the value
of free (hyper-) parameters, e.g. length-scales. In chapter 4 several examples
of covariance functions were presented, many of which have large numbers of
parameters.
In addition, the exact form and possible free parameters of the
likelihood function may also not be known in advance. Thus in order to turn
Gaussian processes into powerful practical tools it is essential to develop meth-
ods that address the model selection problem. We interpret the model selection
problem rather broadly, to include all aspects of the model including the dis-
crete choice of the functional form for the covariance function as well as values
for any hyperparameters.

In section 5.1 we outline the model selection problem. In the following sec-
tions diﬀerent methodologies are presented: in section 5.2 Bayesian principles
are covered, and in section 5.3 cross-validation is discussed, in particular the
leave-one-out estimator. In the remaining two sections the diﬀerent methodolo-
gies are applied speciﬁcally to learning in GP models, for regression in section
5.4 and classiﬁcation in section 5.5.

model selection

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

106

Model Selection and Adaptation of Hyperparameters

5.1 The Model Selection Problem

In order for a model to be a practical tool in an application, one needs to make
decisions about the details of its speciﬁcation. Some properties may be easy to
specify, while we typically have only vague information available about other
aspects. We use the term model selection to cover both discrete choices and the
setting of continuous (hyper-) parameters of the covariance functions. In fact,
model selection can help both to reﬁne the predictions of the model, and give
a valuable interpretation to the user about the properties of the data, e.g. that
a non-stationary covariance function may be preferred over a stationary one.

A multitude of possible families of covariance functions exists, including
squared exponential, polynomial, neural network, etc., see section 4.2 for an
overview. Each of these families typically have a number of free hyperparameters
whose values also need to be determined. Choosing a covariance function for a
particular application thus comprises both setting of hyperparameters within a
family, and comparing across diﬀerent families. Both of these problems will be
treated by the same methods, so there is no need to distinguish between them,
and we will use the term “model selection” to cover both meanings. We will
refer to the selection of a covariance function and its parameters as training of
a Gaussian process.1 In the following paragraphs we give example choices of
parameterizations of distance measures for stationary covariance functions.

enable interpretation

hyperparameters

training

Covariance functions such as the squared exponential can be parameterized

in terms of hyperparameters. For example

k(xp, xq) = σ2

(5.1)
where θ = ({M}, σ2
n)> is a vector containing all the hyperparameters,2 and
{M} denotes the parameters in the symmetric matrix M. Possible choices for
the matrix M include

f , σ2

nδpq,

f exp(cid:0)− 1

2

(xp − xq)>M(xp − xq)(cid:1) + σ2

characteristic
length-scale
automatic relevance
determination

M1 = ‘−2I,

M2 = diag(‘)−2,

M3 = ΛΛ> + diag(‘)−2,

(5.2)
where ‘ is a vector of positive values, and Λ is a D × k matrix, k < D. The
properties of functions with these covariance functions depend on the values of
the hyperparameters. For many covariance functions it is easy to interpret the
meaning of the hyperparameters, which is of great importance when trying to
understand your data. For the squared exponential covariance function eq. (5.1)
with distance measure M2 from eq. (5.2), the ‘1, . . . , ‘D hyperparameters play
the rˆole of characteristic length-scales; loosely speaking, how far do you need
to move (along a particular axis) in input space for the function values to be-
come uncorrelated. Such a covariance function implements automatic relevance
determination (ARD) [Neal, 1996], since the inverse of the length-scale deter-
mines how relevant an input is: if the length-scale has a very large value, the

1This contrasts the use of the word in the SVM literature, where “training” usually refers

to ﬁnding the support vectors for a ﬁxed kernel.

2Sometimes the noise level parameter, σ2

n is not considered a hyperparameter; however it
plays an analogous role and is treated in the same way, so we simply consider it a hyperpa-
rameter.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.1 The Model Selection Problem

107

(a)

(b)

(c)

Figure 5.1: Functions with two dimensional input drawn at random from noise free
squared exponential covariance function Gaussian processes, corresponding to the
three diﬀerent distance measures in eq. (5.2) respectively. The parameters were: (a)
‘ = 1, (b) ‘ = (1, 3)>, and (c) Λ = (1,−1)>, ‘ = (6, 6)>. In panel (a) the two inputs
are equally important, while in (b) the function varies less rapidly as a function of x2
than x1. In (c) the Λ column gives the direction of most rapid variation .

covariance will become almost independent of that input, eﬀectively removing
it from the inference. ARD has been used successfully for removing irrelevant
input by several authors, e.g. Williams and Rasmussen [1996]. We call the pa-
rameterization of M3 in eq. (5.2) the factor analysis distance due to the analogy
with the (unsupervised) factor analysis model which seeks to explain the data
through a low rank plus diagonal decomposition. For high dimensional datasets
the k columns of the Λ matrix could identify a few directions in the input space
with specially high “relevance”, and their lengths give the inverse characteristic
length-scale for those directions.

In Figure 5.1 we show functions drawn at random from squared exponential
covariance function Gaussian processes, for diﬀerent choices of M.
In panel
(a) we get an isotropic behaviour. In panel (b) the characteristic length-scale
is diﬀerent along the two input axes; the function varies rapidly as a function
of x1, but less rapidly as a function of x2. In panel (c) the direction of most
rapid variation is perpendicular to the direction (1, 1). As this ﬁgure illustrates,

factor analysis distance

−202−202−2−1012input x1input x2output y−202−202−2−1012input x1input x2output y−202−202−2−1012input x1input x2output yC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

108

Model Selection and Adaptation of Hyperparameters

there is plenty of scope for variation even inside a single family of covariance
functions. Our task is, based on a set of training data, to make inferences about
the form and parameters of the covariance function, or equivalently, about the
relationships in the data.

It should be clear from the above example that model selection is essentially
open ended. Even for the squared exponential covariance function, there is a
huge variety of possible distance measures. However, this should not be a cause
for despair, rather seen as a possibility to learn. It requires, however, a sys-
tematic and practical approach to model selection. In a nutshell we need to be
able to compare two (or more) methods diﬀering in values of particular param-
eters, or the shape of the covariance function, or compare a Gaussian process
model to any other kind of model. Although there are endless variations in the
suggestions for model selection in the literature three general principles cover
most: (1) compute the probability of the model given the data, (2) estimate
the generalization error and (3) bound the generalization error. We use the
term generalization error to mean the average error on unseen test examples
(from the same distribution as the training cases). Note that the training error
is usually a poor proxy for the generalization error, since the model may ﬁt
the noise in the training set (over-ﬁt), leading to low training error but poor
generalization performance.

In the next section we describe the Bayesian view on model selection, which
involves the computation of the probability of the model given the data, based
on the marginal likelihood.
In section 5.3 we cover cross-validation, which
estimates the generalization performance. These two paradigms are applied
to Gaussian process models in the remainder of this chapter. The probably
approximately correct (PAC) framework is an example of a bound on the gen-
eralization error, and is covered in section 7.4.2.

5.2 Bayesian Model Selection

In this section we give a short outline description of the main ideas in Bayesian
model selection. The discussion will be general, but focusses on issues which will
be relevant for the speciﬁc treatment of Gaussian process models for regression
in section 5.4 and classiﬁcation in section 5.5.

It is common to use a hierarchical speciﬁcation of models. At the lowest level
are the parameters, w. For example, the parameters could be the parameters
in a linear model, or the weights in a neural network model. At the second level
are hyperparameters θ which control the distribution of the parameters at the
bottom level. For example the “weight decay” term in a neural network, or the
“ridge” term in ridge regression are hyperparameters. At the top level we may
have a (discrete) set of possible model structures, Hi, under consideration.

We will ﬁrst give a “mechanistic” description of the computations needed
for Bayesian inference, and continue with a discussion providing the intuition
about what is going on. Inference takes place one level at a time, by applying

hierarchical models

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.2 Bayesian Model Selection

the rules of probability theory, see e.g. MacKay [1992b] for this framework and
MacKay [1992a] for the context of neural networks. At the bottom level, the
posterior over the parameters is given by Bayes’ rule

p(w|y, X, θ,Hi) = p(y|X, w,Hi)p(w|θ,Hi)

p(y|X, θ,Hi)

,

(5.3)

109

level 1 inference

where p(y|X, w,Hi) is the likelihood and p(w|θ,Hi) is the parameter prior.
The prior encodes as a probability distribution our knowledge about the pa-
rameters prior to seeing the data.
If we have only vague prior information
about the parameters, then the prior distribution is chosen to be broad to
reﬂect this. The posterior combines the information from the prior and the
data (through the likelihood). The normalizing constant in the denominator of
eq. (5.3) p(y|X, θ,Hi) is independent of the parameters, and called the marginal
likelihood (or evidence), and is given by

p(y|X, θ,Hi) =

p(y|X, w,Hi)p(w|θ,Hi) dw.

(5.4)

Z

Z

At the next level, we analogously express the posterior over the hyperparam-
eters, where the marginal likelihood from the ﬁrst level plays the rˆole of the
likelihood

p(θ|y, X,Hi) = p(y|X, θ,Hi)p(θ|Hi)

(5.5)
where p(θ|Hi) is the hyper-prior (the prior for the hyperparameters). The
normalizing constant is given by

p(y|X,Hi)

,

p(y|X,Hi) =

p(y|X, θ,Hi)p(θ|Hi)dθ.

(5.6)

level 2 inference

At the top level, we compute the posterior for the model

level 3 inference

,

(5.7)

p(y|X)

where p(y|X) = P

p(Hi|y, X) = p(y|X,Hi)p(Hi)
i p(y|X,Hi)p(Hi). We note that the implementation of
Bayesian inference calls for the evaluation of several integrals. Depending on the
details of the models, these integrals may or may not be analytically tractable
and in general one may have to resort to analytical approximations or Markov
chain Monte Carlo (MCMC) methods. In practice, especially the evaluation
of the integral in eq. (5.6) may be diﬃcult, and as an approximation one may
shy away from using the hyperparameter posterior in eq. (5.5), and instead
maximize the marginal likelihood in eq. (5.4) w.r.t. the hyperparameters, θ.
This approximation is known as type II maximum likelihood (ML-II). Of course,
one should be careful with such an optimization step, since it opens up the
possibility of overﬁtting, especially if there are many hyperparameters. The
integral in eq. (5.6) can then be approximated using a local expansion around
the maximum (the Laplace approximation). This approximation will be good
if the posterior for θ is fairly well peaked, which is more often the case for the

ML-II

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

110

Model Selection and Adaptation of Hyperparameters

Figure 5.2: The marginal likelihood p(y|X,Hi) is the probability of the data, given
the model. The number of data points n and the inputs X are ﬁxed, and not shown.
The horizontal axis is an idealized representation of all possible vectors of targets y.
The marginal likelihood for models of three diﬀerent complexities are shown. Note,
that since the marginal likelihood is a probability distribution, it must normalize
to unity. For a particular dataset indicated by y and a dotted line, the marginal
likelihood prefers a model of intermediate complexity over too simple or too complex
alternatives.

hyperparameters than for the parameters themselves, see MacKay [1999] for an
illuminating discussion. The prior over models Hi in eq. (5.7) is often taken to
be ﬂat, so that a priori we do not favour one model over another. In this case,
the probability for the model is proportional to the expression from eq. (5.6).
It is primarily the marginal likelihood from eq. (5.4) involving the integral
over the parameter space which distinguishes the Bayesian scheme of inference
from other schemes based on optimization.
It is a property of the marginal
likelihood that it automatically incorporates a trade-oﬀ between model ﬁt and
model complexity. This is the reason why the marginal likelihood is valuable
in solving the model selection problem.

In Figure 5.2 we show a schematic of the behaviour of the marginal likelihood
for three diﬀerent model complexities. Let the number of data points n and
the inputs X be ﬁxed; the horizontal axis is an idealized representation of all
possible vectors of targets y, and the vertical axis plots the marginal likelihood
p(y|X,Hi). A simple model can only account for a limited range of possible sets
of target values, but since the marginal likelihood is a probability distribution
over y it must normalize to unity, and therefore the data sets which the model
does account for have a large value of the marginal likelihood. Conversely for
a complex model:
it is capable of accounting for a wider range of data sets,
and consequently the marginal likelihood doesn’t attain such large values as
for the simple model. For example, the simple model could be a linear model,
and the complex model a large neural network. The ﬁgure illustrates why the
marginal likelihood doesn’t simply favour the models that ﬁt the training data
the best. This eﬀect is called Occam’s razor after William of Occam 1285-1349,
whose principle: “plurality should not be assumed without necessity” he used
to encourage simplicity in explanations. See also Rasmussen and Ghahramani
[2001] for an investigation into Occam’s razor in statistical models.

Occam’s razor

ymarginal likelihood, p(y|X,Hi)all possible data setssimpleintermediatecomplexC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.3 Cross-validation

Notice that the trade-oﬀ between data-ﬁt and model complexity is automatic;
there is no need to set a parameter externally to ﬁx the trade-oﬀ. Do not confuse
the automatic Occam’s razor principle with the use of priors in the Bayesian
method. Even if the priors are “ﬂat” over complexity, the marginal likelihood
will still tend to favour the least complex model able to explain the data. Thus,
a model complexity which is well suited to the data can be selected using the
marginal likelihood.

In the preceding paragraphs we have thought of the speciﬁcation of a model
as the model structure as well as the parameters of the priors, etc.
If it is
unclear how to set some of the parameters of the prior, one can treat these as
hyperparameters, and do model selection to determine how to set them. At
the same time it should be emphasized that the priors correspond to (proba-
bilistic) assumptions about the data. If the priors are grossly at odds with the
distribution of the data, inference will still take place under the assumptions
encoded by the prior, see the step-function example in section 5.4.3. To avoid
this situation, one should be careful not to employ priors which are too narrow,
ruling out reasonable explanations of the data.3

5.3 Cross-validation

In this section we consider how to use methods of cross-validation (CV) for
model selection. The basic idea is to split the training set into two disjoint sets,
one which is actually used for training, and the other, the validation set, which
is used to monitor performance. The performance on the validation set is used
as a proxy for the generalization error and model selection is carried out using
this measure.

In practice a drawback of hold-out method is that only a fraction of the
full data set can be used for training, and that if the validation set it small,
the performance estimate obtained may have large variance. To minimize these
problems, CV is almost always used in the k-fold cross-validation setting: the
data is split into k disjoint, equally sized subsets; validation is done on a single
subset and training is done using the union of the remaining k − 1 subsets, the
entire procedure being repeated k times, each time with a diﬀerent subset for
validation. Thus, a large fraction of the data can be used for training, and all
cases appear as validation cases. The price is that k models must be trained
instead of one. Typical values for k are in the range 3 to 10.

An extreme case of k-fold cross-validation is obtained for k = n, the number
of training cases, also known as leave-one-out cross-validation (LOO-CV). Of-
ten the computational cost of LOO-CV (“training” n models) is prohibitive, but
in certain cases, such as Gaussian process regression, there are computational
shortcuts.

3This is known as Cromwell’s dictum [Lindley, 1985] after Oliver Cromwell who on August
5th, 1650 wrote to the synod of the Church of Scotland: “I beseech you, in the bowels of
Christ, consider it possible that you are mistaken.”

111

automatic trade-oﬀ

cross-validation

k-fold cross-validation

leave-one-out
cross-validation
(LOO-CV)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

112

Model Selection and Adaptation of Hyperparameters

other loss functions

model parameters

Cross-validation can be used with any loss function. Although the squared
error loss is by far the most common for regression, there is no reason not to
allow other loss functions. For probabilistic models such as Gaussian processes
it is natural to consider also cross-validation using the negative log probabil-
ity loss. Craven and Wahba [1979] describe a variant of cross-validation using
squared error known as generalized cross-validation which gives diﬀerent weight-
ings to diﬀerent datapoints so as to achieve certain invariance properites. See
Wahba [1990, sec. 4.3] for further details.

5.4 Model Selection for GP Regression

We apply Bayesian inference in section 5.4.1 and cross-validation in section 5.4.2
to Gaussian process regression with Gaussian noise. We conclude in section
5.4.3 with some more detailed examples of how one can use the model selection
principles to tailor covariance functions.

5.4.1 Marginal Likelihood

Bayesian principles provide a persuasive and consistent framework for inference.
Unfortunately, for most interesting models for machine learning, the required
computations (integrals over parameter space) are analytically intractable, and
good approximations are not easily derived. Gaussian process regression mod-
els with Gaussian noise are a rare exception: integrals over the parameters are
analytically tractable and at the same time the models are very ﬂexible. In this
section we ﬁrst apply the general Bayesian inference principles from section
5.2 to the speciﬁc Gaussian process model, in the simpliﬁed form where hy-
perparameters are optimized over. We derive the expressions for the marginal
likelihood and interpret these.

Since a Gaussian process model is a non-parametric model, it may not be
immediately obvious what the parameters of the model are. Generally, one
may regard the noise-free latent function values at the training inputs f as the
parameters. The more training cases there are, the more parameters. Using
the weight-space view, developed in section 2.1, one may equivalently think
of the parameters as being the weights of the linear model which uses the
basis-functions φ, which can be chosen as the eigenfunctions of the covariance
function. Of course, we have seen that this view is inconvenient for nondegen-
erate covariance functions, since these would then have an inﬁnite number of
weights.

We proceed by applying eq. (5.3) and eq. (5.4) for the 1st level of inference—
which we ﬁnd that we have already done back in chapter 2! The predictive dis-
tribution from eq. (5.3) is given for the weight-space view in eq. (2.11) and
eq. (2.12) and equivalently for the function-space view in eq. (2.22). The
marginal likelihood (or evidence) from eq. (5.4) was computed in eq. (2.30),

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.4 Model Selection for GP Regression

113

(a)

(b)

Figure 5.3: Panel (a) shows a decomposition of the log marginal likelihood into
its constituents: data-ﬁt and complexity penalty, as a function of the characteristic
length-scale. The training data is drawn from a Gaussian process with SE covariance
function and parameters (‘, σf , σn) = (1, 1, 0.1), the same as in Figure 2.5, and we are
ﬁtting only the length-scale parameter ‘ (the two other parameters have been set in
accordance with the generating process). Panel (b) shows the log marginal likelihood
as a function of the characteristic length-scale for diﬀerent sizes of training sets. Also
shown, are the 95% conﬁdence intervals for the posterior length-scales.

and we re-state the result here

log p(y|X, θ) = −1
2

y>K−1

y y − 1
2

log |Ky| − n
2

log 2π,

(5.8)

where Ky = Kf + σ2
nI is the covariance matrix for the noisy targets y (and Kf
is the covariance matrix for the noise-free latent f), and we now explicitly write
the marginal likelihood conditioned on the hyperparameters (the parameters of
the covariance function) θ. From this perspective it becomes clear why we call
eq. (5.8) the log marginal likelihood, since it is obtained through marginaliza-
tion over the latent function. Otherwise, if one thinks entirely in terms of the
function-space view, the term “marginal” may appear a bit mysterious, and
similarly the “hyper” from the θ parameters of the covariance function.4

The three terms of the marginal likelihood in eq. (5.8) have readily inter-
pretable rˆoles: the only term involving the observed targets is the data-ﬁt
−y>K−1
y y/2; log |Ky|/2 is the complexity penalty depending only on the co-
variance function and the inputs and n log(2π)/2 is a normalization constant.
In Figure 5.3(a) we illustrate this breakdown of the log marginal likelihood.
The data-ﬁt decreases monotonically with the length-scale, since the model be-
comes less and less ﬂexible. The negative complexity penalty increases with the
length-scale, because the model gets less complex with growing length-scale.
The marginal likelihood itself peaks at a value close to 1. For length-scales
somewhat longer than 1, the marginal likelihood decreases rapidly (note the

4Another reason that we like to stick to the term “marginal likelihood” is that it is the
likelihood of a non-parametric model, i.e. a model which requires access to all the training
data when making predictions; this contrasts the situation for a parametric model, which
“absorbs” the information from the training data into its (posterior) parameter (distribution).
This diﬀerence makes the two “likelihoods” behave quite diﬀerently as a function of θ.

marginal likelihood

interpretation

100−100−80−60−40−2002040log probabilitycharacteristic lengthscaleminus complexity penaltydata fitmarginal likelihood100−100−80−60−40−20020Characteristic lengthscalelog marginal likelihood95% conf int  82155C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

114

Model Selection and Adaptation of Hyperparameters

Figure 5.4: Contour plot showing the log marginal likelihood as a function of the
characteristic length-scale and the noise level, for the same data as in Figure 2.5 and
Figure 5.3. The signal variance hyperparameter was set to σ2
f = 1. The optimum is
close to the parameters used when generating the data. Note, the two ridges, one
for small noise and length-scale ‘ = 0.4 and another for long length-scale and noise
σ2

n = 1. The contour lines spaced 2 units apart in log probability density.

log scale!), due to the poor ability of the model to explain the data, compare to
Figure 2.5(c). For smaller length-scales the marginal likelihood decreases some-
what more slowly, corresponding to models that do accommodate the data,
but waste predictive mass at regions far away from the underlying function,
compare to Figure 2.5(b).

In Figure 5.3(b) the dependence of the log marginal likelihood on the charac-
teristic length-scale is shown for diﬀerent numbers of training cases. Generally,
the more data, the more peaked the marginal likelihood. For very small numbers
of training data points the slope of the log marginal likelihood is very shallow
as when only a little data has been observed, both very short and intermediate
values of the length-scale are consistent with the data. With more data, the
complexity term gets more severe, and discourages too short length-scales.

marginal likelihood
gradient

To set the hyperparameters by maximizing the marginal likelihood, we seek
the partial derivatives of the marginal likelihood w.r.t. the hyperparameters.
Using eq. (5.8) and eq. (A.14-A.15) we obtain
K−1y − 1
2
(αα> − K−1) ∂K
∂θj

tr(cid:0)K−1 ∂K
(cid:17)

where α = K−1y.

log p(y|X, θ) =

y>K−1 ∂K
∂θj

(cid:16)

(cid:1)

∂θj

(5.9)

∂
∂θj

1
2
1
2

=

tr

The complexity of computing the marginal likelihood in eq. (5.8) is dominated
by the need to invert the K matrix (the log determinant of K is easily com-
puted as a by-product of the inverse). Standard methods for matrix inversion of
positive deﬁnite symmetric matrices require time O(n3) for inversion of an n by
n matrix. Once K−1 is known, the computation of the derivatives in eq. (5.9)
requires only time O(n2) per hyperparameter.5 Thus, the computational over-
5Note that matrix-by-matrix products in eq. (5.9) should not be computed directly: in the
ﬁrst term, do the vector-by-matrix multiplications ﬁrst; in the trace term, compute only the
diagonal terms of the product.

10010110−1100characteristic lengthscalenoise standard deviationC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.4 Model Selection for GP Regression

115

head of computing derivatives is small, so using a gradient based optimizer is
advantageous.

Estimation of θ by optimzation of the marginal likelihood has a long history
in spatial statistics, see e.g. Mardia and Marshall [1984]. As n increases, one
would hope that the data becomes increasingly informative about θ. However,
it is necessary to contrast what Stein [1999, sec. 3.3] calls ﬁxed-domain asymp-
totics (where one gets increasingly dense observations within some region) with
increasing-domain asymptotics (where the size of the observation region grows
with n). Increasing-domain asymptotics are a natural choice in a time-series
context but ﬁxed-domain asymptotics seem more natural in spatial (and ma-
chine learning) settings. For further discussion see Stein [1999, sec. 6.4].

Figure 5.4 shows an example of the log marginal likelihood as a function
of the characteristic length-scale and the noise standard deviation hyperpa-
rameters for the squared exponential covariance function, see eq. (5.1). The
signal variance σ2
f was set to 1.0. The marginal likelihood has a clear maximum
around the hyperparameter values which were used in the Gaussian process
from which the data was generated. Note that for long length-scales and a
noise level of σ2
n = 1, the marginal likelihood becomes almost independent of
the length-scale; this is caused by the model explaining everything as noise,
and no longer needing the signal covariance. Similarly, for small noise and a
length-scale of ‘ = 0.4, the marginal likelihood becomes almost independent of
the noise level; this is caused by the ability of the model to exactly interpolate
the data at this short length-scale. We note that although the model in this
hyperparameter region explains all the data-points exactly, this model is still
disfavoured by the marginal likelihood, see Figure 5.2.

There is no guarantee that the marginal likelihood does not suﬀer from mul-
tiple local optima. Practical experience with simple covariance functions seem
to indicate that local maxima are not a devastating problem, but certainly they
do exist. In fact, every local maximum corresponds to a particular interpre-
tation of the data. In Figure 5.5 an example with two local optima is shown,
together with the corresponding (noise free) predictions of the model at each
of the two local optima. One optimum corresponds to a relatively complicated
model with low noise, whereas the other corresponds to a much simpler model
with more noise. With only 7 data points, it is not possible for the model to
conﬁdently reject either of the two possibilities. The numerical value of the
marginal likelihood for the more complex model is about 60% higher than for
the simple model. According to the Bayesian formalism, one ought to weight
predictions from alternative explanations according to their posterior probabil-
ities. In practice, with data sets of much larger sizes, one often ﬁnds that one
local optimum is orders of magnitude more probable than other local optima,
so averaging together alternative explanations may not be necessary. However,
care should be taken that one doesn’t end up in a bad local optimum.

Above we have described how to adapt the parameters of the covariance
function given one dataset. However, it may happen that we are given several
datasets all of which are assumed to share the same hyperparameters; this
is known as multi-task learning, see e.g. Caruana [1997]. In this case one can

multiple local maxima

multi-task learning

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

116

Model Selection and Adaptation of Hyperparameters

(a)

(b)

(c)

n (noise standard deviation), where σ2

Figure 5.5: Panel (a) shows the marginal likelihood as a function of the hyperparame-
ters ‘ (length-scale) and σ2
f = 1 (signal standard
deviation) for a data set of 7 observations (seen in panels (b) and (c)). There are
two local optima, indicated with ’+’: the global optimum has low noise and a short
length-scale; the local optimum has a high noise and a long length scale. In (b) and (c)
the inferred underlying functions (and 95% conﬁdence intervals) are shown for each
of the two solutions. In fact, the data points were generated by a Gaussian process
with (‘, σ2

f , σ2

n) = (1, 1, 0.1) in eq. (5.1).

simply sum the log marginal likelihoods of the individual problems and optimize
this sum w.r.t. the hyperparameters [Minka and Picard, 1999].

5.4.2 Cross-validation

The predictive log probability when leaving out training case i is

log p(yi|X, y−i, θ) = −1
2

log σ2

i − (yi − µi)2

2σ2
i

− 1
2

log 2π,

(5.10)

negative log validation
density loss

where the notation y−i means all targets except number i, and µi and σ2
i are
computed according to eq. (2.23) and (2.24) respectively, in which the training
sets are taken to be (X−i, y−i). Accordingly, the LOO log predictive probability
is

LLOO(X, y, θ) =

log p(yi|X, y−i, θ),

(5.11)

nX

i=1

10010110−1100characteristic lengthscalenoise standard deviation−505−2−1012input, xoutput, y−505−2−1012input, xoutput, yC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.4 Model Selection for GP Regression

117

pseudo-likelihood

see [Geisser and Eddy, 1979] for a discussion of this and related approaches.
LLOO in eq. (5.11) is sometimes called the log pseudo-likelihood. Notice, that
in each of the n LOO-CV rotations, inference in the Gaussian process model
(with ﬁxed hyperparameters) essentially consists of computing the inverse co-
variance matrix, to allow predictive mean and variance in eq. (2.23) and (2.24)
to be evaluated (i.e. there is no parameter-ﬁtting, such as there would be in a
parametric model). The key insight is that when repeatedly applying the pre-
diction eq. (2.23) and (2.24), the expressions are almost identical: we need the
inverses of covariance matrices with a single column and row removed in turn.
This can be computed eﬃciently from the inverse of the complete covariance
matrix using inversion by partitioning, see eq. (A.11-A.12). A similar insight
has also been used for spline models, see e.g. Wahba [1990, sec. 4.2]. The ap-
proach was used for hyperparameter selection in Gaussian process models in
Sundararajan and Keerthi [2001]. The expressions for the LOO-CV predictive
mean and variance are

µi = yi − [K−1y]i/[K−1]ii,

and

i = 1/[K−1]ii,
σ2

(5.12)

where careful inspection reveals that the mean µi is in fact independent of yi as
indeed it should be. The computational expense of computing these quantities
is O(n3) once for computing the inverse of K plus O(n2) for the entire LOO-
CV procedure (when K−1 is known). Thus, the computational overhead for
the LOO-CV quantities is negligible. Plugging these expressions into eq. (5.10)
and (5.11) produces a performance estimator which we can optimize w.r.t. hy-
perparameters to do model selection. In particular, we can compute the partial
derivatives of LLOO w.r.t. the hyperparameters (using eq. (A.14)) and use con-
jugate gradient optimization. To this end, we need the partial derivatives of
the LOO-CV predictive mean and variances from eq. (5.12) w.r.t. the hyperpa-
rameters

− αi[ZjK−1]ii

,

∂µi
∂θj

=

[Zjα]i
[K−1]ii

[K−1]2
where α = K−1y and Zj = K−1 ∂K
obtained by using the chain-rule and eq. (5.13) to give

∂θj

ii

∂σ2
i
∂θj

=

[ZjK−1]ii
[K−1]2

ii

,

(5.13)

. The partial derivatives of eq. (5.11) are

∂LLOO

∂θj

=

=

nX
nX

i=1

i=1

(cid:16)

∂ log p(yi|X, y−i, θ)

(cid:16)

∂µi
∂θj
1 + α2

i

+ ∂ log p(yi|X, y−i, θ)
(cid:17)

∂σ2
i
∂θj
/[K−1]ii.

[ZjK−1]ii

(cid:17)

∂σ2
i

[K−1]ii

∂µi

αi[Zjα]i − 1
2

(5.14)

The computational complexity is O(n3) for computing the inverse of K, and
O(n3) per hyperparameter 6 for the derivative eq. (5.14). Thus, the computa-
tional burden of the derivatives is greater for the LOO-CV method than for the
method based on marginal likelihood, eq. (5.9).

6Computation of the matrix-by-matrix product K−1 ∂K
∂θj

for each hyperparameter is un-

avoidable.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

118

Model Selection and Adaptation of Hyperparameters

LOO-CV with squared
error loss

In eq. (5.10) we have used the log of the validation density as a cross-
validation measure of ﬁt (or equivalently, the negative log validation density as
a loss function). One could also envisage using other loss functions, such as the
commonly used squared error. However, this loss function is only a function
of the predicted mean and ignores the validation set variances. Further, since
the mean prediction eq. (2.23) is independent of the scale of the covariances
(i.e. you can multiply the covariance of the signal and noise by an arbitrary
positive constant without changing the mean predictions), one degree of freedom
is left undetermined7 by a LOO-CV procedure based on squared error loss (or
any other loss function which depends only on the mean predictions). But, of
course, the full predictive distribution does depend on the scale of the covariance
function. Also, computation of the derivatives based on the squared error loss
has similar computational complexity as the negative log validation density loss.
In conclusion, it seems unattractive to use LOO-CV based on squared error loss
for hyperparameter selection.

Comparing the pseudo-likelihood for the LOO-CV methodology with the
marginal likelihood from the previous section, it is interesting to ask under
which circumstances each method might be preferable. Their computational
demands are roughly identical. This issue has not been studied much empir-
ically. However, it is interesting to note that the marginal likelihood tells us
the probability of the observations given the assumptions of the model. This
contrasts with the frequentist LOO-CV value, which gives an estimate for the
(log) predictive probability, whether or not the assumptions of the model may
be fulﬁlled. Thus Wahba [1990, sec. 4.8] has argued that CV procedures should
be more robust against model mis-speciﬁcation.

5.4.3 Examples and Discussion

In the following we give three examples of model selection for regression models.
We ﬁrst describe a 1-d modelling task which illustrates how special covariance
functions can be designed to achieve various useful eﬀects, and can be evaluated
using the marginal likelihood. Secondly, we make a short reference to the model
selection carried out for the robot arm problem discussed in chapter 2 and again
in chapter 8. Finally, we discuss an example where we deliberately choose a
covariance function that is not well-suited for the problem; this is the so-called
mis-speciﬁed model scenario.

Mauna Loa Atmospheric Carbon Dioxide

We will use a modelling problem concerning the concentration of CO2 in the
atmosphere to illustrate how the marginal likelihood can be used to set multiple
hyperparameters in hierarchical Gaussian process models. A complex covari-
ance function is derived by combining several diﬀerent kinds of simple covariance
functions, and the resulting model provides an excellent ﬁt to the data as well

7In the special case where we know either the signal or the noise variance there is no

indeterminancy.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.4 Model Selection for GP Regression

119

Figure 5.6: The 545 observations of monthly averages of the atmospheric concentra-
tion of CO2 made between 1958 and the end of 2003, together with 95% predictive
conﬁdence region for a Gaussian process regression model, 20 years into the future.
Rising trend and seasonal variations are clearly visible. Note also that the conﬁdence
interval gets wider the further the predictions are extrapolated.

as insights into its properties by interpretation of the adapted hyperparame-
ters. Although the data is one-dimensional, and therefore easy to visualize, a
total of 11 hyperparameters are used, which in practice rules out the use of
cross-validation for setting parameters, except for the gradient-based LOO-CV
procedure from the previous section.

The data [Keeling and Whorf, 2004] consists of monthly average atmospheric
CO2 concentrations (in parts per million by volume (ppmv)) derived from in situ
air samples collected at the Mauna Loa Observatory, Hawaii, between 1958 and
2003 (with some missing values).8 The data is shown in Figure 5.6. Our goal is
the model the CO2 concentration as a function of time x. Several features are
immediately apparent: a long term rising trend, a pronounced seasonal variation
and some smaller irregularities. In the following we suggest contributions to a
combined covariance function which takes care of these individual properties.
This is meant primarily to illustrate the power and ﬂexibility of the Gaussian
process framework—it is possible that other choices would be more appropriate
for this data set.

To model the long term smooth rising trend we use a squared exponential
(SE) covariance term, with two hyperparameters controlling the amplitude θ1
and characteristic length-scale θ2

smooth trend

(cid:16)− (x − x0)2

(cid:17)

k1(x, x0) = θ2

1 exp

.

(5.15)

2θ2
2

Note that we just use a smooth trend; actually enforcing the trend a priori to
be increasing is probably not so simple and (hopefully) not desirable. We can
use the periodic covariance function from eq. (4.31) with a period of one year to
model the seasonal variation. However, it is not clear that the seasonal trend is

8The data is available from http://cdiac.esd.ornl.gov/ftp/trends/co2/maunaloa.co2.

seasonal component

1960197019801990200020102020320340360380400420yearCO2 concentration, ppmC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

120

Model Selection and Adaptation of Hyperparameters

(b)

(a)
Figure 5.7: Panel (a):
long term trend, dashed, left hand scale, predicted by the
squared exponential contribution; superimposed is the medium term trend, full line,
right hand scale, predicted by the rational quadratic contribution; the vertical dash-
dotted line indicates the upper limit of the training data. Panel (b) shows the seasonal
variation over the year for three diﬀerent years. The concentration peaks in mid May
and has a low in the beginning of October. The seasonal variation is smooth, but
not of exactly sinusoidal shape. The peak-to-peak amplitude increases from about 5.5
ppm in 1958 to about 7 ppm in 2003, but the shape does not change very much. The
characteristic decay length of the periodic component is inferred to be 90 years, so
the seasonal trend changes rather slowly, as also suggested by the gradual progression
between the three years shown.

exactly periodic, so we modify eq. (4.31) by taking the product with a squared
exponential component (using the product construction from section 4.2.4), to
allow a decay away from exact periodicity

(cid:16)− (x − x0)2

2θ2
4

(cid:17)

− 2 sin2(π(x − x0))

θ2
5

,

(5.16)

k2(x, x0) = θ2

3 exp

where θ3 gives the magnitude, θ4 the decay-time for the periodic component,
and θ5 the smoothness of the periodic component; the period has been ﬁxed
to one (year). The seasonal component in the data is caused primarily by
diﬀerent rates of CO2 uptake for plants depending on the season, and it is
probably reasonable to assume that this pattern may itself change slowly over
time, partially due to the elevation of the CO2 level itself; if this eﬀect turns
out not to be relevant, then it can be eﬀectively removed at the ﬁtting stage by
allowing θ4 to become very large.

To model the (small) medium term irregularities a rational quadratic term

(cid:16)

(cid:17)−θ8

k3(x, x0) = θ2

6

1 +

(x − x0)2
2θ8θ2
7

,

(5.17)

medium term
irregularities

is used, eq. (4.19)

where θ6 is the magnitude, θ7 is the typical length-scale and θ8 is the shape pa-
rameter determining diﬀuseness of the length-scales, see the discussion on page
87. One could also have used a squared exponential form for this component,
but it turns out that the rational quadratic works better (gives higher marginal
likelihood), probably because it can accommodate several length-scales.

1960197019801990200020102020320340360380400CO2 concentration, ppmyear−1−0.500.51CO2 concentration, ppmJFMAMJJASOND−3−2−10123CO2 concentration, ppmmonth195819702003C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.4 Model Selection for GP Regression

121

Figure 5.8: The time course of the seasonal eﬀect, plotted in a months vs. year plot
(with wrap-around continuity between the edges). The labels on the contours are in
ppmv of CO2. The training period extends up to the dashed line. Note the slow
development: the height of the May peak may have started to recede, but the low in
October may currently (2005) be deepening further. The seasonal eﬀects from three
particular years were also plotted in Figure 5.7(b).

Finally we specify a noise model as the sum of a squared exponential con-

tribution and an independent component

(cid:16)− (xp − xq)2

(cid:17)

2θ2
10

k4(xp, xq) = θ2

9 exp

+ θ2

11δpq,

(5.18)

where θ9 is the magnitude of the correlated noise component, θ10 is its length-
scale and θ11 is the magnitude of the independent noise component. Noise in
the series could be caused by measurement inaccuracies, and by local short-term
weather phenomena, so it is probably reasonable to assume at least a modest
amount of correlation in time. Notice that the correlated noise component, the
ﬁrst term of eq. (5.18), has an identical expression to the long term component
in eq. (5.15). When optimizing the hyperparameters, we will see that one of
these components becomes large with a long length-scale (the long term trend),
while the other remains small with a short length-scale (noise). The fact that
we have chosen to call one of these components ‘signal’ and the other one ‘noise’
is only a question of interpretation. Presumably we are less interested in very
short-term eﬀect, and thus call it noise; if on the other hand we were interested
in this eﬀect, we would call it signal.

The ﬁnal covariance function is

k(x, x0) = k1(x, x0) + k2(x, x0) + k3(x, x0) + k4(x, x0),

(5.19)
with hyperparameters θ = (θ1, . . . , θ11)>. We ﬁrst subtract the empirical mean
of the data (341 ppm), and then ﬁt the hyperparameters by optimizing the
marginal likelihood using a conjugate gradient optimizer. To avoid bad local
minima (e.g. caused by swapping rˆoles of the rational quadratic and squared
exponential terms) a few random restarts are tried, picking the run with the
best marginal likelihood, which was log p(y|X, θ) = −108.5.

noise terms

parameter estimation

JFMAMJJASOND1960197019801990200020102020MonthYear−3.6−3.3−2.8−2.8−2−2−1−10011222.833.1C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

122

Model Selection and Adaptation of Hyperparameters

We now examine and interpret the hyperparameters which optimize the
marginal likelihood. The long term trend has a magnitude of θ1 = 66 ppm
and a length scale of θ2 = 67 years. The mean predictions inside the range
of the training data and extending for 20 years into the future are depicted in
Figure 5.7 (a). In the same plot (with right hand axis) we also show the medium
term eﬀects modelled by the rational quadratic component with magnitude
θ6 = 0.66 ppm, typical length θ7 = 1.2 years and shape θ8 = 0.78. The very
small shape value allows for covariance at many diﬀerent length-scales, which
is also evident in Figure 5.7 (a). Notice that beyond the edge of the training
data the mean of this contribution smoothly decays to zero, but of course it
still has a contribution to the uncertainty, see Figure 5.6.

The hyperparameter values for the decaying periodic contribution are: mag-
nitude θ3 = 2.4 ppm, decay-time θ4 = 90 years, and the smoothness of the
periodic component is θ5 = 1.3. The quite long decay-time shows that the
data have a very close to periodic component in the short term. In Figure 5.7
(b) we show the mean periodic contribution for three years corresponding to
the beginning, middle and end of the training data. This component is not
exactly sinusoidal, and it changes its shape slowly over time, most notably the
amplitude is increasing, see Figure 5.8.

√

For the noise components, we get the amplitude for the correlated compo-
nent θ9 = 0.18 ppm, a length-scale of θ10 = 1.6 months and an independent
noise magnitude of θ11 = 0.19 ppm. Thus, the correlation length for the noise
component is indeed inferred to be short, and the total magnitude of the noise
11 = 0.26 ppm, indicating that the data can be explained very
is just
well by the model. Note also in Figure 5.6 that the model makes relatively
conﬁdent predictions, the 95% conﬁdence region being 16 ppm wide at a 20
year prediction horizon.

9 + θ2
θ2

In conclusion, we have seen an example of how non-trivial structure can be
inferred by using composite covariance functions, and that the ability to leave
hyperparameters to be determined by the data is useful in practice. Of course
a serious treatment of such data would probably require modelling of other
eﬀects, such as demographic and economic indicators too. Finally, one may
want to use a real time-series approach (not just a regression from time to CO2
level as we have done here), to accommodate causality, etc. Nevertheless, the
ability of the Gaussian process to avoid simple parametric assumptions and still
build in a lot of structure makes it, as we have seen, a very attractive model in
many application domains.

Robot Arm Inverse Dynamics

We have discussed the use of GPR for the SARCOS robot arm inverse dynamics
problem in section 2.5. This example is also further studied in section 8.3.7
where a variety of approximation methods are compared, because the size of
the training set (44, 484 examples) precludes the use of simple GPR due to its
O(n2) storage and O(n3) time complexity.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.4 Model Selection for GP Regression

123

(a)

(b)

Figure 5.9: Mis-speciﬁcation example. Fit to 64 datapoints drawn from a step func-
tion with Gaussian noise with standard deviation σn = 0.1. The Gaussian process
models are using a squared exponential covariance function. Panel (a) shows the mean
and 95% conﬁdence interval for the noisy signal in grey, when the hyperparameters are
chosen to maximize the marginal likelihood. Panel (b) shows the resulting model when
the hyperparameters are chosen using leave-one-out cross-validation (LOO-CV). Note
that the marginal likelihood chooses a high noise level and long length-scale, whereas
LOO-CV chooses a smaller noise level and shorter length-scale. It is not immediately
obvious which ﬁt it worse.

One of the techniques considered in section 8.3.7 is the subset of datapoints
(SD) method, where we simply discard some of the data and only make use
of m < n training examples. Given a subset of the training data of size m
selected at random, we adjusted the hyperparameters by optimizing either the
marginal likelihood or LLOO. As ARD was used, this involved adjusting D +
2 = 23 hyperparameters. This process was repeated 10 times with diﬀerent
random subsets of the data selected for both m = 1024 and m = 2048. The
results show that the predictive accuracy obtained from the two optimization
methods is very similar on both standardized mean squared error (SMSE) and
mean standardized log loss (MSLL) criteria, but that the marginal likelihood
optimization is much quicker.

Step function example illustrating mis-speciﬁcation

In this section we discuss the mis-speciﬁed model scenario, where we attempt
to learn the hyperparameters for a covariance function which is not very well
suited to the data. The mis-speciﬁcation arises because the data comes from a
function which has either zero or very low probability under the GP prior. One
could ask why it is interesting to discuss this scenario, since one should surely
simply avoid choosing such a model in practice. While this is true in theory,
for practical reasons such as the convenience of using standard forms for the
covariance function or because vague prior information, one inevitably ends up
in a situation which resembles some level of mis-speciﬁcation.

As an example, we use data from a noisy step function and ﬁt a GP model
with a squared exponential covariance function, Figure 5.9. There is mis-
speciﬁcation because it would be very unlikely that samples drawn from a GP

−1−0.500.51−2−1012output, yinput, x−1−0.500.51−2−1012output, yinput, xC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

124

Model Selection and Adaptation of Hyperparameters

(a)

(b)

Figure 5.10: Same data as in Figure 5.9. Panel (a) shows the result of using a
covariance function which is the sum of two squared-exponential terms. Although this
is still a stationary covariance function, it gives rise to a higher marginal likelihood
than for the squared-exponential covariance function in Figure 5.9(a), and probably
also a better ﬁt. In panel (b) the neural network covariance function eq. (4.29) was
used, providing a much larger marginal likelihood and a very good ﬁt.

with the stationary SE covariance function would look like a step function. For
short length-scales samples can vary quite quickly, but they would tend to vary
rapidly all over, not just near the step. Conversely a stationary SE covariance
function with a long length-scale could model the ﬂat parts of the step function
but not the rapid transition. Note that Gibbs’ covariance function eq. (4.32)
would be one way to achieve the desired eﬀect. It is interesting to note the dif-
ferences between the model optimized with marginal likelihood in Figure 5.9(a),
and one optimized with LOO-CV in panel (b) of the same ﬁgure. See exercise
5.6.2 for more on how these two criteria weight the inﬂuence of the prior.

For comparison, we show the predictive distribution for two other covari-
ance functions in Figure 5.10. In panel (a) a sum of two squared exponential
terms were used in the covariance. Notice that this covariance function is still
stationary, but it is more ﬂexible than a single squared exponential, since it has
two magnitude and two length-scale parameters. The predictive distribution
looks a little bit better, and the value of the log marginal likelihood improves
from −37.7 in Figure 5.9(a) to −26.1 in Figure 5.10(a). We also tried the neural
network covariance function from eq. (4.29), which is ideally suited to this case,
since it allows saturation at diﬀerent values in the positive and negative direc-
tions of x. As shown in Figure 5.10(b) the predictions are also near perfect,
and the log marginal likelihood is much larger at 50.2.

5.5 Model Selection for GP Classiﬁcation

In this section we compute the derivatives of the approximate marginal likeli-
hood for the Laplace and EP methods for binary classiﬁcation which are needed
for training. We also give the detailed algorithms for these, and brieﬂy discuss
the possible use of cross-validation and other methods for training binary GP

−1−0.500.51−2−1012output, yinput, x−1−0.500.51−2−1012output, yinput, xC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.5 Model Selection for GP Classiﬁcation

125

classiﬁers.

5.5.1 Derivatives of the Marginal Likelihood for Laplace’s ∗

Approximation

Recall from section 3.4.4 that the approximate log marginal likelihood was given
in eq. (3.32) as

log q(y|X, θ) = −1
2

ˆf>K−1ˆf + log p(y|ˆf) − 1
2

log |B|,

(5.20)

1

1
2 KW

2 and ˆf is the maximum of the posterior eq. (3.12)
where B = I + W
found by Newton’s method in Algorithm 3.1, and W is the diagonal matrix
W = −∇∇ log p(y|ˆf). We can now optimize the approximate marginal likeli-
hood q(y|X, θ) w.r.t. the hyperparameters, θ. To this end we seek the partial
derivatives of ∂q(y|X, θ)/∂θj. The covariance matrix K is a function of the hy-
perparameters, but ˆf and therefore W are also implicitly functions of θ, since
when θ changes, the optimum of the posterior ˆf also changes. Thus
∂ ˆfi
∂θj

= ∂ log q(y|X, θ)

∂ log q(y|X, θ)

∂ log q(y|X, θ)

(cid:12)(cid:12)(cid:12)(cid:12)explicit

nX

(5.21)

∂ ˆfi

∂θj

∂θj

+

i=1

by the chain rule. Using eq. (A.14) and eq. (A.15) the explicit term is given by

=

1
2

ˆf>K−1 ∂K
∂θj

K−1ˆf− 1
2

tr

(W −1+K)−1 ∂K
∂θj

. (5.22)

(cid:12)(cid:12)(cid:12)(cid:12)explicit

∂ log q(y|X, θ)

∂θj

When evaluating the remaining term from eq. (5.21), we utilize the fact that
ˆf is the maximum of the posterior, so that ∂Ψ(f)/∂f = 0 at f = ˆf, where the
(un-normalized) log posterior Ψ(f) is deﬁned in eq. (3.12); thus the implicit
derivatives of the two ﬁrst terms of eq. (5.20) vanish, leaving only

∂ log q(y|X, θ)

∂ ˆfi

= −1
2
= −1
2

∂ log |B|

= −1
2

∂ ˆfi

(cid:2)(K−1 + W )−1(cid:3)

tr

(K−1 + W )−1 ∂W
∂ ˆfi

log p(y|ˆf).

∂3
∂f 3
i

ii

(5.23)

= ∂K
∂θj

In order to evaluate the derivative ∂ˆf /∂θj, we diﬀerentiate the self-consistent
eq. (3.17) ˆf = K∇ log p(y|ˆf) to obtain
∂ˆf
∇ log p(y|ˆf),
∂θj
(5.24)
where we have used the chain rule ∂/∂θj = ∂ˆf /∂θj · ∂/∂ˆf and the identity
∂∇ log p(y|ˆf)/∂ˆf = −W . The desired derivatives are obtained by plugging
eq. (5.22-5.24) into eq. (5.21).

= (I +KW )−1 ∂K
∂θj

∇ log p(y|ˆf)+K

∂∇ log p(y|ˆf)

∂ˆf
∂θj

∂ˆf

(cid:16)

(cid:16)

,

(cid:17)

(cid:17)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

126

Model Selection and Adaptation of Hyperparameters

(f , a) := mode(cid:0)K, y, p(y|f)(cid:1)

input: X (inputs), y (±1 targets), θ (hypers), p(y|f) (likelihood function)
compute covariance matrix from X and θ
locate posterior mode using Algorithm 3.1

2: compute K
4: W := −∇∇ log p(y|f)
L := cholesky(I + W
6: log Z := − 1
2 L>\(L\W

1

1

8: C := L\(W

R := W
s2 := − 1

1

2 )

1
2 KW

2 a>f + log p(y|f) −P log(diag(L))
2 diag(cid:0) diag(K) − diag(C>C)(cid:1)∇3 log p(y|f)

R = W

2 K)

2 )

1

solve LL> = B = I + W

1
2 KW

1
2

1

2 (I + W

1
2 KW

1

eq. (5.20)
2 )−1W
eq. (5.23)

1
2

o

o

eq. (5.24)
eq. (5.21)

10: for j := 1 . . . dim(θ) do

12:

14:

C := ∂K/∂θj
2 a>Ca − 1
s1 := 1
b := C∇ log p(y|f)
s3 := b − KRb
∇j log Z := s1 + s>
2 s3

2 tr(RC)

compute derivative matrix from X and θ
eq. (5.22)

16: end for

return: log Z (log marginal likelihood), ∇ log Z (partial derivatives)

Algorithm 5.1: Compute the approximate log marginal likelihood and its derivatives
w.r.t. the hyperparameters for binary Laplace GPC for use by an optimization routine,
such as conjugate gradient optimization. In line 3 Algorithm 3.1 on page 46 is called
to locate the posterior mode.
In line 12 only the diagonal elements of the matrix
product should be computed. In line 15 the notation ∇j means the partial derivative
w.r.t. the j’th hyperparameter. An actual implementation may also return the value
of f to be used as an initial guess for the subsequent call (as an alternative the zero
initialization in line 2 of Algorithm 3.1).

Details of the Implementation

The implementation of the log marginal likelihood and its partial derivatives
w.r.t. the hyperparameters is shown in Algorithm 5.1. It is advantageous to re-
write the equations from the previous section in terms of well-conditioned sym-
metric positive deﬁnite matrices, whose solutions can be obtained by Cholesky
factorization, combining numerical stability with computational speed.

In detail, the matrix of central importance turns out to be
2 )−1W

R = (W −1 + K)−1 = W

2 (I + W

1
2 KW

1

1

1
2 ,

(5.25)

where the right hand side is suitable for numerical evaluation as in line 7 of
Algorithm 5.1, reusing the Cholesky factor L from the Newton scheme above.
Remember that W is diagonal so eq. (5.25) does not require any real matrix-by-
matrix products. Rewriting eq. (5.22-5.23) is straightforward, and for eq. (5.24)
we apply the matrix inversion lemma (eq. (A.9)) to (I + KW )−1 to obtain
I − KR, which is used in the implementation.

The computational complexity is dominated by the Cholesky factorization
in line 5 which takes n3/6 operations per iteration of the Newton scheme. In
addition the computation of R in line 7 is also O(n3), all other computations
being at most O(n2) per hyperparameter.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

5.5 Model Selection for GP Classiﬁcation

127

input: X (inputs), y (±1 targets), θ (hyperparameters)

(˜ν, ˜τ , log ZEP) := EP(cid:0)K, y(cid:1)

2: compute K

2 K ˜S

4: L := cholesky(I + ˜S
2 L\(L>\ ˜S

b := ˜ν − ˜S

6: R := bb> − ˜S

2 L>\(L\ ˜S
for j := 1 . . . dim(θ) do

2 )
2 K ˜ν)
2 )

1

1

1

1

1

1

compute covariance matrix from X and θ
run the EP Algorithm 3.5
2 K ˜S
b from under eq. (5.27)
R = bb> − ˜S
2 B−1 ˜S

solve LL> = B = I + ˜S

1
2

1
2

1

1

8:

2 tr(RC)

10: end for

C := ∂K/∂θj
∇j log ZEP := 1

compute derivative matrix from X and θ
eq. (5.27)
return: log ZEP (log marginal likelihood), ∇ log ZEP (partial derivatives)
Algorithm 5.2: Compute the log marginal likelihood and its derivatives w.r.t. the
hyperparameters for EP binary GP classiﬁcation for use by an optimization routine,
such as conjugate gradient optimization. ˜S is a diagonal precision matrix with entries
˜Sii = ˜τi. In line 3 Algorithm 3.5 on page 58 is called to compute parameters of the EP
approximation. In line 9 only the diagonal of the matrix product should be computed
and the notation ∇j means the partial derivative w.r.t. the j’th hyperparameter. The
computational complexity is dominated by the Cholesky factorization in line 4 and
the solution in line 6, both of which are O(n3).

5.5.2 Derivatives of the Marginal Likelihood for EP

∗

Optimization of the EP approximation to the marginal likelihood w.r.t. the
hyperparameters of the covariance function requires evaluation of the partial
derivatives from eq. (3.65). Luckily, it turns out that implicit terms in the
derivatives caused by the solution of EP being a function of the hyperparam-
eters is exactly zero. We will not present the proof here, see Seeger [2005].
Consequently, we only have to take account of the explicit dependencies

(cid:0) − 1

log |K + ˜Σ|(cid:1)

∂ log ZEP

∂θj

˜µ>(K + ˜Σ)−1 ˜µ − 1
2

= ∂
∂θj
1
˜µ>(K + ˜S−1)−1 ∂K
2
∂θj

=

2

(K + ˜S−1)−1 ˜µ − 1
2

(5.26)

(cid:1).

tr(cid:0)(K + ˜S−1)−1 ∂K
(cid:17)
2(cid:1) ∂K

∂θj

1

,

(5.27)

∂θj

(cid:16)(cid:0)bb> − ˜S

1

2 B−1S

In Algorithm 5.2 the derivatives from eq. (5.26) are implemented using

∂ log ZEP

=

1
2

tr

where b = (I − ˜S

∂θj
2 B−1 ˜S

1

1

2 K)˜ν.

5.5.3 Cross-validation

Whereas the LOO-CV estimates were easily computed for regression through
the use of rank-one updates, it is not so obvious how to generalize this to
classiﬁcation. Opper and Winther [2000, sec. 5] use the cavity distributions
of their mean-ﬁeld approach as LOO-CV estimates, and one could similarly
use the cavity distributions from the closely-related EP algorithm discussed in

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

128

Model Selection and Adaptation of Hyperparameters

section 3.6. Although technically the cavity distribution for site i could depend
on the label yi (because the algorithm uses all cases when converging to its
ﬁxed point), this eﬀect is probably very small and indeed Opper and Winther
[2000, sec. 8] report very high precision for these LOO-CV estimates. As an
alternative k-fold CV could be used explicitly for some moderate value of k.

Other Methods for Setting Hyperparameters

alignment

Above we have considered setting hyperparameters by optimizing the marginal
likelihood or cross-validation criteria. However, some other criteria have been
proposed in the literature. For example Cristianini et al. [2002] deﬁne the
alignment between a Gram matrix K and the corresponding +1/− 1 vector of
targets y as

y>Ky
nkKkF

A(K, y) =

trices Ki so that K =P

(5.28)
where kKkF denotes the Frobenius norm of the matrix K, as deﬁned in eq. (A.16).
Lanckriet et al. [2004] show that if K is a convex combination of Gram ma-
i νiKi with νi ≥ 0 for all i then the optimization of
the alignment score w.r.t. the νi’s can be achieved by solving a semideﬁnite
programming problem.

,

5.5.4 Example

For an example of model selection, refer to section 3.7. Although the experi-
ments there were done by exhaustively evaluating the marginal likelihood for a
whole grid of hyperparameter values, the techniques described in this chapter
could be used to locate the same solutions more eﬃciently.

5.6 Exercises

1. The optimization of the marginal likelihood w.r.t. the hyperparameters
is generally not possible in closed form. Consider, however, the situation
where one hyperparameter, θ0 gives the overall scale of the covariance

ky(x, x0) = θ0

˜ky(x, x0),

(5.29)
where ky is the covariance function for the noisy targets (i.e. including
noise contributions) and ˜ky(x, x0) may depend on further hyperparam-
eters, θ1, θ2, . . .. Show that the marginal likelihood can be optimized
w.r.t. θ0 in closed form.

P
given by P
2. Consider the diﬀerence between the log marginal likelihood given by:
i log p(yi|{yj, j < i}), and the LOO-CV using log probability which is
i log p(yi|{yj, j 6= i}). From the viewpoint of the marginal
likelihood the LOO-CV conditions too much on the data. Show that the
expected LOO-CV loss is greater than the expected marginal likelihood.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 6

Relationships between GPs
and Other Models

In this chapter we discuss a number of concepts and models that are related to
Gaussian process prediction. In section 6.1 we cover reproducing kernel Hilbert
spaces (RKHSs), which deﬁne a Hilbert space of suﬃciently-smooth functions
corresponding to a given positive semideﬁnite kernel k.

As we discussed in chapter 1, there are many functions that are consistent
with a given dataset D. We have seen how the GP approach puts a prior
over functions in order to deal with this issue. A related viewpoint is provided
by regularization theory (described in section 6.2) where one seeks a trade-oﬀ
between data-ﬁt and the RKHS norm of function. This is closely related to the
MAP estimator in GP prediction, and thus omits uncertainty in predictions
and also the marginal likelihood. In section 6.3 we discuss splines, a special
case of regularization which is obtained when the RKHS is deﬁned in terms of
diﬀerential operators of a given order.

There are a number of other families of kernel machines that are related
to Gaussian process prediction. In section 6.4 we describe support vector ma-
chines, in section 6.5 we discuss least-squares classiﬁcation (LSC), and in section
6.6 we cover relevance vector machines (RVMs).

6.1 Reproducing Kernel Hilbert Spaces

Here we present a brief introduction to reproducing kernel Hilbert spaces. The
theory was developed by Aronszajn [1950]; a more recent treatise is Saitoh
[1988]. Information can also be found in Wahba [1990], Sch¨olkopf and Smola
[2002] and Wegman [1982]. The collection of papers edited by Weinert [1982]
provides an overview of the uses of RKHSs in statistical signal processing.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

130

Relationships between GPs and Other Models

We start with a formal deﬁnition of a RKHS, and then describe two speciﬁc
bases for a RKHS, ﬁrstly through Mercer’s theorem and the eigenfunctions of
k, and secondly through the reproducing kernel map.
Deﬁnition 6.1 (Reproducing kernel Hilbert space). Let H be a Hilbert space
of real functions f deﬁned on an index set X . Then H is called a reproducing
kernel Hilbert space endowed with an inner product h·,·iH (and norm kfkH =

phf, fiH) if there exists a function k : X ×X → R with the following properties:

1. for every x, k(x, x0) as a function of x0 belongs to H, and
2. k has the reproducing property hf(·), k(·, x)iH = f(x).

(cid:3)

See e.g. Sch¨olkopf and Smola [2002] and Wegman [1982]. Note also that as
k(x,·) and k(x0,·) are in H we have that hk(x,·), k(x0,·)iH = k(x, x0).

reproducing property

The RKHS uniquely determines k, and vice versa, as stated in the following

theorem:
Theorem 6.1 (Moore-Aronszajn theorem, Aronszajn [1950]). Let X be an in-
dex set. Then for every positive deﬁnite function k(·,·) on X × X there exists
(cid:3)
a unique RKHS, and vice versa.

The Hilbert space L2 (which has the dot product hf, giL2 =R f(x)g(x)dx)
function is the representer of evaluation, i.e. f(x) =R f(x0)δ(x−x0)dx0. Kernels

contains many non-smooth functions. In L2 (which is not a RKHS) the delta

are the analogues of delta functions within the smoother RKHS. Note that the
delta function is not itself in L2; in contrast for a RKHS the kernel k is the
representer of evaluation and is itself in the RKHS.

inner product
hf, giH

The above description is perhaps rather abstract. For our purposes the key
intuition behind the RKHS formalism is that the squared norm kfk2H can be
thought of as a generalization to functions of the n-dimensional quadratic form
f>K−1f we have seen in earlier chapters.

Consider a real positive semideﬁnite kernel k(x, x0) with an eigenfunction
i=1λiφi(x)φi(x0) relative to a measure µ. Recall from
Mercer’s theorem that the eigenfunctions are orthonormal w.r.t. µ, i.e. we have

expansion k(x, x0) =PN
R φi(x)φj(x) dµ(x) = δij. We now consider a Hilbert space comprised of linear
combinations of the eigenfunctions, i.e. f(x) =PN
functions f(x) and g(x) =PN

i /λi <
∞. We assert that the inner product hf, giH in the Hilbert space between

i=1fiφi(x) withPN

i=1giφi(x) is deﬁned as

i=1f 2

PN
Thus this Hilbert space is equipped with a norm kfkH where kfk2H = hf, fiH =
i /λi. Note that for kfkH to be ﬁnite the sequence of coeﬃcients {fi}
must decay quickly; eﬀectively this imposes a smoothness condition on the
space.

i=1f 2

i=1

NX

figi
λi

hf, giH =

.

(6.1)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.1 Reproducing Kernel Hilbert Spaces

131

We now need to show that this Hilbert space is the RKHS corresponding to
the kernel k, i.e. that it has the reproducing property. This is easily achieved
as

hf(·), k(·, x)iH =

= f(x).

(6.2)

Similarly

NX

fiλiφi(x)

λi

i=1

NX

λiφi(x)λiφi(x0)

hk(x,·), k(x0,·)iH =

= k(x, x0).

(6.3)

i=1

λi

Notice also that k(x,·) is in the RKHS as it has normPN
linear combinations of the eigenfunctions with the restrictionPN

i=1(λiφi(x))2/λi =
k(x, x) < ∞. We have now demonstrated that the Hilbert space comprised of
i /λi < ∞
fulﬁls the two conditions given in Deﬁnition 6.1. As there is a unique RKHS
associated with k(·,·), this Hilbert space must be that RKHS.

i=1f 2

The advantage of the abstract formulation of the RKHS is that the eigenbasis
will change as we use diﬀerent measures µ in Mercer’s theorem. However, the
RKHS norm is in fact solely a property of the kernel and is invariant under
this change of measure. This can be seen from the fact that the proof of the
RKHS properties above is not dependent on the measure; see also Kailath
[1971, sec. II.B]. A ﬁnite-dimensional example of this measure invariance is
explored in exercise 6.7.1.

Notice the analogy between the RKHS norm kfk2H = hf, fiH =PN
If we sample the coeﬃcients fi in the eigenexpansion f(x) =PN

i /λi
and the quadratic form f>K−1f; if we express K and f in terms of the eigen-
vectors of K we obtain exactly the same form (but the sum has only n terms if
f has length n).

i=1f 2

i=1fiφi(x)

from N (0, λi) then

E[kfk2H] =

NX

i=1

E[f 2
i ]
λi

=

NX

i=1

1.

(6.4)

Thus if N is inﬁnite the sample functions are not in H (with probability 1)
as the expected value of the RKHS norm is inﬁnite; see Wahba [1990, p. 5]
and Kailath [1971, sec. II.B] for further details. However, note that although
sample functions of this Gaussian process are not in H, the posterior mean after
observing some data will lie in the RKHS, due to the smoothing properties of
averaging.

Another view of the RKHS can be obtained from the reproducing kernel

map construction. We consider the space of functions f deﬁned as

n

f(x) =

nX

i=1

αik(x, xi) : n ∈ N, xi ∈ X , αi ∈ Ro

.

(6.5)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

132

regularizer

(kernel) ridge regression

representer theorem

Now let g(x) =Pn0

Relationships between GPs and Other Models

j=1α0

jk(x, x0

j). Then we deﬁne the inner product

hf, giH =

αiα0

jk(xi, x0
j).

(6.6)

nX

n0X

i=1

j=1

nX

Clearly condition 1 of Deﬁnition 6.1 is fulﬁlled under the reproducing kernel
map construction. We can also demonstrate the reproducing property, as

hk(·, x), f(·)iH =

αik(x, xi) = f(x).

(6.7)

i=1

6.2 Regularization

The problem of inferring an underlying function f(x) from a ﬁnite (and possibly
noisy) dataset without any additional assumptions is clearly “ill posed”. For
example, in the noise-free case, any function that passes through the given data
points is acceptable. Under a Bayesian approach our assumptions are charac-
terized by a prior over functions, and given some data, we obtain a posterior
over functions. The problem of bringing prior assumptions to bear has also
been addressed under the regularization viewpoint, where these assumptions
are encoded in terms of the smoothness of f.

We consider the functional

J[f] = λ
2

kfk2H + Q(y, f),

(6.8)

where y is the vector of targets we are predicting and f = (f(x1), . . . , f(xn))>
is the corresponding vector of function values, and λ is a scaling parameter that
trades oﬀ the two terms. The ﬁrst term is called the regularizer and represents
smoothness assumptions on f as encoded by a suitable RKHS, and the second
term is a data-ﬁt term assessing the quality of the prediction f(xi) for the
observed datum yi, e.g. the negative log likelihood.

Indeed, recalling that kfk2H = PN

Ridge regression (described in section 2.1) can be seen as a particular case
i /λi where fi is the
of regularization.
coeﬃcient of eigenfunction φi(x), we see that we are penalizing the weighted
squared coeﬃcients. This is taking place in feature space, rather than simply in
input space, as per the standard formulation of ridge regression (see eq. (2.4)),
so it corresponds to kernel ridge regression.

The representer theorem shows that each minimizer f ∈ H of J[f] has the
i=1 αik(x, xi).1 The representer theorem was ﬁrst stated by
Kimeldorf and Wahba [1971] for the case of squared error.2 O’Sullivan et al.
[1986] showed that the representer theorem could be extended to likelihood

form f(x) = Pn

i=1f 2

1If the RKHS contains a null space of unpenalized functions then the given form is correct

modulo a term that lies in this null space. This is explained further in section 6.3.

2Schoenberg [1964] proved the representer theorem for the special case of cubic splines and
squared error. This was result extended to general RKHSs in Kimeldorf and Wahba [1971].

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.2 Regularization

133

functions arising from generalized linear models. The representer theorem can
be generalized still further, see e.g. Sch¨olkopf and Smola [2002, sec. 4.2]. If the
data-ﬁt term is convex (see section A.9) then there will be a unique minimizer
ˆf of J[f].

For Gaussian process prediction with likelihoods that involve the values of
f at the n training points only (so that Q(y, f) is the negative log likelihood
up to some terms not involving f), the analogue of the representer theorem is
obvious. This is because the predictive distribution of f(x∗) , f∗ at test point

x∗ given the data y is p(f∗|y) =R p(f∗|f)p(f|y) df. As derived in eq. (3.22) we
Thus E[f∗|y] =Pn

(6.9)
due to the formulae for the conditional distribution of a multivariate Gaussian.

i=1αik(x∗, xi), where α = K−1E[f|y].

E[f∗|y] = k(x∗)>K−1E[f|y]

have

The regularization approach has a long tradition in inverse problems, dat-
ing back at least as far as Tikhonov [1963]; see also Tikhonov and Arsenin
[1977]. For the application of this approach in the machine learning literature
see e.g. Poggio and Girosi [1990].

In section 6.2.1 we consider RKHSs deﬁned in terms of diﬀerential operators.
In section 6.2.2 we demonstrate how to solve the regularization problem in the
speciﬁc case of squared error, and in section 6.2.3 we compare and contrast the
regularization approach with the Gaussian process viewpoint.

∗

null space

6.2.1 Regularization Deﬁned by Diﬀerential Operators
For x ∈ RD deﬁne

Z X
(cid:16) ∂2f
(cid:17)2

j1+...+jD=m

(cid:16) ∂mf(x)
(cid:16) ∂2f
(cid:17)2

∂xj1

(cid:17)2
(cid:17)2i

1 . . . xjD

D

kOmfk2 =

Z h(cid:16) ∂2f

For example for m = 2 and D = 2

dx.

(6.10)

kO2fk2 =

Now set kP fk2 =PM

+ 2

∂x2
1

(6.11)
m=0 amkOmfk2 with non-negative coeﬃcients am. Notice

dx1 dx2.

∂x1∂x2

∂x2
2

+

that kP fk2 is translation and rotation invariant.

In this section we assume that a0 > 0; if this is not the case and ak is
the ﬁrst non-zero coeﬃcient, then there is a null space of functions that are
unpenalized. For example if k = 2 then constant and linear functions are in the
null space. This case is dealt with in section 6.3.

kP fk2 penalizes f in terms of the variability of its function values and
derivatives up to order M. How does this correspond to the RKHS formulation
of section 6.1? The key is to recognize that the complex exponentials exp(2πis·
x) are eigenfunctions of the diﬀerential operator if X = RD. In this case

kP fk2 =

am(4π2s · s)m| ˜f(s)|2ds,

(6.12)

Z MX

m=0

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

134

Relationships between GPs and Other Models

where ˜f(s) is the Fourier transform of f(x). Comparing eq. (6.12) with eq. (6.1)
we see that the kernel has the power spectrum

S(s) =

,

(6.13)

1

PM
m=0 am(4π2s · s)m
PM
m=0 am(4π2s · s)m

e2πis·x

Z

and thus by Fourier inversion we obtain the stationary kernel

k(x) =

ds.

(6.14)

A slightly diﬀerent approach to obtaining the kernel is to use calculus of
variations to minimize J[f] with respect to f. The Euler-Lagrange equation
leads to

nX

f(x) =

αiG(x − xi),

with

MX

i=1

(−1)mam∇2mG = δ(x − x0),

(6.15)

(6.16)

Green’s function
≡ kernel

m=0

diﬀerential operatorPM

where G(x, x0) is known as a Green’s function. Notice that the Green’s func-
tion also depends on the boundary conditions. For the case of X = RD by
Fourier transforming eq. (6.16) we recognize that G is in fact the kernel k. The
m=0(−1)mam∇2m and the integral operator k(·,·) are in
fact inverses, as shown by eq. (6.16). See Poggio and Girosi [1990] for further
details. Arfken [1985] provides an introduction to calculus of variations and
Green’s functions. RKHSs for regularizers deﬁned by diﬀerential operators are
Sobolev spaces; see e.g. Adams [1975] for further details on Sobolev spaces.

We now give two speciﬁc examples of kernels derived from diﬀerential oper-

ators.
Example 1. Set a0 = α2, a1 = 1 and am = 0 for m ≥ 2 in D = 1. Using
the Fourier pair e−α|x| ↔ 2α/(α2 + 4π2s2) we obtain k(x − x0) = 1
2α e−α|x−x0|.
Note that this is the covariance function of the Ornstein-Uhlenbeck process, see
section 4.2.1.
Example 2. By setting am = σ2m
we obtain

m!2m and using the power series ey =P∞

k=0 yk/k!

k(x − x0) =

exp(2πis · (x − x0)) exp(− σ2
2

(4π2s · s))ds

=

1

(2πσ2)D/2

exp(− 1

2σ2 (x − x0)>(x − x0)),

(6.17)

(6.18)

Z

as shown by Yuille and Grzywacz [1989]. This is the squared exponential co-
variance function that we have seen earlier.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.2 Regularization

135

6.2.2 Obtaining the Regularized Solution

The representer theorem tells us the general form of the solution to eq. (6.8).
We now consider a speciﬁc functional

J[f] =

kfk2H +

1
2

1
2σ2
n

(yi − f(xi))2,

(6.19)

nX

i=1

which uses a squared error data-ﬁt term (corresponding to the negative log
likelihood of a Gaussian noise model with variance σ2
n). Substituting f(x) =

Pn
i=1αik(x, xi) and using hk(·, xi), k(·, xj)iH = k(xi, xj) we obtain

J[α] =

=

1
2 α>Kα +
1
2 α>(K +

1
|y − Kα|2
2σ2
n
K 2)α − 1
1
σ2
σ2
n
n

y>Kα +

(6.20)

y>y.

1
2σ2
n

Minimizing J by diﬀerentiating w.r.t. the vector of coeﬃcients α we obtain
nI)−1y, so that the prediction for a test point x∗ is ˆf(x∗) =
ˆα = (K + σ2
k(x∗)>(K + σ2
nI)−1y. This should look very familiar—it is exactly the form of
the predictive mean obtained in eq. (2.23). In the next section we compare and
contrast the regularization and GP views of the problem.

The solution f(x) =Pn

regularization network in Poggio and Girosi [1990].

i=1αik(x, xi) that minimizes eq. (6.19) was called a

regularization network

6.2.3 The Relationship of the Regularization View to Gaus-

sian Process Prediction

The regularization method returns ˆf = argminf J[f]. For a Gaussian process
predictor we obtain a posterior distribution over functions. Can we make a
connection between these two views? In fact we shall see in this section that ˆf
can be viewed as the maximum a posteriori (MAP) function under the posterior.

Following Szeliski [1987] and Poggio and Girosi [1990] we consider

exp (−J[f]) = exp(cid:0) − λ

kP fk2(cid:1) × exp (−Q(y, f)) .

2

(6.21)

The ﬁrst term on the RHS is a Gaussian process prior on f, and the second
is proportional to the likelihood. As ˆf is the minimizer of J[f], it is the MAP
function.

f. Thus we obtain kP fk2 ’ PM

To get some intuition for the Gaussian process prior, imagine f(x) being
represented on a grid in x-space, so that f is now an (inﬁnite dimensional) vector
mDm)f
where Dm is an appropriate ﬁnite-diﬀerence approximation of the diﬀerential
operator Om. Observe that this prior term is a quadratic form in f.

m=0 am(Dmf)>(Dmf) = f>(P

m amD>

To go into more detail concerning the MAP relationship we consider three
cases: (i) when Q(y, f) is quadratic (corresponding to a Gaussian likelihood);

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

136

Relationships between GPs and Other Models

(ii) when Q(y, f) is not quadratic but convex and (iii) when Q(y, f) is not
convex.

In case (i) we have seen in chapter 2 that the posterior mean function can
be obtained exactly, and the posterior is Gaussian. As the mean of a Gaussian
is also its mode this is the MAP solution. The correspondence between the GP
posterior mean and the solution of the regularization problem ˆf was made in
Kimeldorf and Wahba [1970].

In case (ii) we have seen in chapter 3 for classiﬁcation problems using the
logistic, probit or softmax response functions that Q(y, f) is convex. Here the
MAP solution can be found by ﬁnding ˆf (the MAP solution to the n-dimensional
problem deﬁned at the training points) and then extending it to other x-values
through the posterior mean conditioned on ˆf.

In case (iii) there will be more than one local minimum of J[f] under the
regularization approach. One could check these minima to ﬁnd the deepest one.
However, in this case the argument for MAP is rather weak (especially if there
are multiple optima of similar depth) and suggests the need for a fully Bayesian
treatment.

While the regularization solution gives a part of the Gaussian process solu-

tion, there are the following limitations:

1. It does not characterize the uncertainty in the predictions, nor does it

handle well multimodality in the posterior.

2. The analysis is focussed at approximating the ﬁrst level of Bayesian infer-
ence, concerning predictions for f. It is not usually extended to the next
level, e.g. to the computation of the marginal likelihood. The marginal
likelihood is very useful for setting any parameters of the covariance func-
tion, and for model comparison (see chapter 5).

In addition, we ﬁnd the speciﬁcation of smoothness via the penalties on deriva-
tives to be not very intuitive. The regularization viewpoint can be thought of
as directly specifying the inverse covariance rather than the covariance. As
marginalization is achieved for a Gaussian distribution directly from the covari-
ance (and not the inverse covariance) it seems more natural to us to specify
the covariance function. Also, while non-stationary covariance functions can
be obtained from the regularization viewpoint, e.g. by replacing the Lebesgue
measure in eq. (6.10) with a non-uniform measure µ(x), calculation of the cor-
responding covariance function can then be very diﬃcult.

6.3 Spline Models

In section 6.2 we discussed regularizers which had a0 > 0 in eq. (6.12). We now
consider the case when a0 = 0; in particular we consider the regularizer to be
of the form kOmfk2, as deﬁned in eq. (6.10). In this case polynomials of degree

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.3 Spline Models

137

up to m − 1 are in the null space of the regularization operator, in that they
are not penalized at all.

In the case that X = RD we can again use Fourier techniques to ob-
tain the Green’s function G corresponding to the Euler-Lagrange equation
(−1)m∇2mG(x) = δ(x). The result, as shown by Duchon [1977] and Meinguet
[1979] is

(cid:26)cm,D|x − x0|2m−D log |x − x0|

cm,D|x − x0|2m−D

G(x−x0) =

if 2m > D and D even
otherwise,

(6.22)

where cm,D is a constant (Wahba [1990, p. 31] gives the explicit form). Note that
the constraint 2m > D has to be imposed to avoid having a Green’s function
that is singular at the origin. Explicit calculation of the Green’s function for
other domains X is sometimes possible; for example see Wahba [1990, sec. 2.2]
for splines on the sphere.

Because of the null space, a minimizer of the regularization functional has

the form

nX

f(x) =

kX

αiG(x, xi) +

βjhj(x),

(6.23)

i=1

j=1

where h1(x), . . . , hk(x) are polynomials that span the null space. The exact
values of the coeﬃcients α and β for a speciﬁc problem can be obtained in
an analogous manner to the derivation in section 6.2.2; in fact the solution is
equivalent to that given in eq. (2.42).

To gain some more insight into the form of the Green’s function we consider
the equation (−1)m∇2mG(x) = δ(x) in Fourier space, leading to ˜G(s) = (4π2s·
s)−m. ˜G(s) plays a rˆole like that of the power spectrum in eq. (6.13), but notice

thatR ˜G(s)ds is inﬁnite, which would imply that the corresponding process has

inﬁnite variance. The problem is of course that the null space is unpenalized; for
example any arbitrary constant function can be added to f without changing
the regularizer.

tions of f(x) of the form g(x) =Pk

Because of the null space we have seen that one cannot obtain a simple
connection between the spline solution and a corresponding Gaussian process
problem. However, by introducing the notion of an intrinsic random function
(IRF) one can deﬁne a generalized covariance; see Cressie [1993, sec. 5.4] and
Stein [1999, section 2.9] for details. The basic idea is to consider linear combina-
i=1 aif(x+δi) for which g(x) is second-order
stationary and where (hj(δ1), . . . , hj(δk))a = 0 for j = 1, . . . , k. A careful de-
scription of the equivalence of spline and IRF prediction is given in Kent and
Mardia [1994].

The power-law form of ˜G(s) = (4π2s·s)−m means that there is no character-
istic length-scale for random functions drawn from this (improper) prior. Thus
we obtain the self-similar property characteristic of fractals; for further details
see Szeliski [1987] and Mandelbrot [1982]. Some authors argue that the lack
of a characteristic length-scale is appealing. This may sometimes be the case,
but if we believe there is an appropriate length-scale (or set of length-scales)

IRF

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

138

Relationships between GPs and Other Models

for a given problem but this is unknown in advance, we would argue that a
hierarchical Bayesian formulation of the problem (as described in chapter 5)
would be more appropriate.

Splines were originally introduced for one-dimensional interpolation and
smoothing problems, and then generalized to the multivariate setting. Schoen-
berg [1964] considered the problem of ﬁnding the function that minimizes

spline interpolation

natural polynomial
spline

smoothing spline

Z b

a

(f (m)(x))2 dx,

(6.24)

where f (m) denotes the m’th derivative of f, subject to the interpolation con-
straints f(xi) = fi, xi ∈ (a, b) for i = 1, . . . , n and for f in an appropriate
Sobolev space. He showed that the solution is the natural polynomial spline,
which is a piecewise polynomial of order 2m − 1 in each interval [xi, xi+1],
i = 1, . . . , n − 1, and of order m − 1 in the two outermost intervals. The pieces
are joined so that the solution has 2m − 2 continuous derivatives. Schoen-
berg also proved that the solution to the univariate smoothing problem (see
eq. (6.19)) is a natural polynomial spline. A common choice is m = 2, leading
to the cubic spline. One possible way of writing this solution is

1X

nX

f(x) =

βjxj +

j=0

i=1

αi(x − xi)3

+, where (x)+ =

(cid:26) x if x > 0

0 otherwise.

(6.25)

It turns out that the coeﬃcients α and β can be computed in time O(n) using
an algorithm due to Reinsch; see Green and Silverman [1994, sec. 2.3.3] for
details.

Splines were ﬁrst used in regression problems. However, by using general-
ized linear modelling [McCullagh and Nelder, 1983] they can be extended to
classiﬁcation problems and other non-Gaussian likelihoods, as we did for GP
classiﬁcation in section 3.3. Early references in this direction include Silverman
[1978] and O’Sullivan et al. [1986].

There is a vast literature in relation to splines in both the statistics and
numerical analysis literatures; for entry points see citations in Wahba [1990]
and Green and Silverman [1994].

∗

6.3.1 A 1-d Gaussian Process Spline Construction

In this section we will further clarify the relationship between splines and Gaus-
sian processes by giving a GP construction for the solution of the univariate
cubic spline smoothing problem whose cost functional is

nX

(cid:0)f(xi) − yi

(cid:1)2 + λ

Z 1

(cid:0)f00(x)(cid:1)2

dx,

(6.26)

i=1

0

where the observed data are {(xi, yi)|i = 1, . . . , n, 0 < x1 < ··· < xn < 1} and
λ is a smoothing parameter controlling the trade-oﬀ between the ﬁrst term, the

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.3 Spline Models

139

data-ﬁt, and the second term, the regularizer, or complexity penalty. Recall
that the solution is a piecewise polynomial as in eq. (6.25).

Following Wahba [1978], we consider the random function

1X

j=0

g(x) =

βjxj + f(x)

(6.27)

where β ∼ N (0, σ2
where

ksp(x, x0) ,

and v = min(x, x0).

0

Z 1

β I) and f(x) is a Gaussian process with covariance σ2

f ksp(x, x0),

(x − u)+(x0 − u)+ du =

|x − x0|v2

2

+ v3
3 ,

(6.28)

To complete the analogue of the regularizer in eq. (6.26), we need to remove
any penalty on polynomial terms in the null space by making the prior vague,
β → ∞. Notice that the covariance has the form of
i.e. by taking the limit σ2
contributions from explicit basis functions, h(x) = (1, x)> and a regular covari-
ance function ksp(x, x0), a problem which we have already studied in section 2.7.
β → ∞,
Indeed we have computed the limit where the prior becomes vague σ2
the result is given in eq. (2.42).

Plugging into the mean equation from eq. (2.42), we get the predictive mean

¯f(x∗) = k(x∗)>K−1

y (y − H> ¯β) + h(x∗)> ¯β,

(6.29)

nδij eval-
where Ky is the covariance matrix corresponding to σ2
uated at the training points, H is the matrix that collects the h(xi) vectors at
all training points, and ¯β = (HK−1
y y is given below eq. (2.42).
It is not diﬃcult to show that this predictive mean function is a piecewise cu-
bic polynomial, since the elements of k(x∗) are piecewise3 cubic polynomials.
Showing that the mean function is a ﬁrst order polynomial in the outer intervals
[0, x1] and [xn, 1] is left as exercise 6.7.3.

y H>)−1HK−1

f ksp(xi, xj) + σ2

So far ksp has been produced rather mysteriously “from the hat”; we now
provide some explanation. Shepp [1966] deﬁned the l-fold integrated Wiener
process as

l!

+

Z(u)du,

Wl(x) =

l = 0, 1, . . .

(6.30)
where Z(u) denotes the Gaussian white noise process with covariance δ(u− u0).
Note that W0 is the standard Wiener process. It is easy to show that ksp(x, x0)
is the covariance of the once-integrated Wiener process by writing W1(x) and
W1(x0) using eq. (6.30) and taking the expectation using the covariance of the
white noise process. Note that Wl is the solution to the stochastic diﬀerential
equation (SDE) X (l+1) = Z; see Appendix B for further details on SDEs. Thus
3The pieces are joined at the datapoints, the points where the min(x, x0) from the covari-

Z 1

0

(x − u)l

ance function is non-diﬀerentiable.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

140

Relationships between GPs and Other Models

(a), spline covariance

(b), squared exponential cov.

Figure 6.1: Panel (a) shows the application of the spline covariance to a simple
dataset. The full line shows the predictive mean, which is a piecewise cubic polyno-
mial, and the grey area indicates the 95% conﬁdence area. The two thin dashed and
dash-dotted lines are samples from the posterior. Note that the posterior samples
are not as smooth as the mean. For comparison a GP using the squared exponential
covariance function is shown in panel (b). The hyperparameters in both cases were
optimized using the marginal likelihood.

the regularizerR (f00(x))2dx.

for the cubic spline we set l = 1 to obtain the SDE X00 = Z, corresponding to

We can also give an explicit basis-function construction for the covariance

function ksp. Consider the family of random functions given by

fN (x) =

1√
N

γi(x − i
N

)+,

(6.31)

N−1X

i=0

N−1X

i=0

where γ is a vector of parameters with γ ∼ N (0, I). Note that the sum has
the form of evenly spaced “ramps” whose magnitudes are given by the entries
in the γ vector. Thus

E[fN (x)fN (x0)] =

1
N

(x − i
N

)+(x0 − i
N

)+.

(6.32)

Taking the limit N → ∞, we obtain eq. (6.28), a derivation which is also found
in [Vapnik, 1998, sec. 11.6].

Notice that the covariance function ksp given in eq. (6.28) corresponds to a
Gaussian process which is MS continuous but only once MS diﬀerentiable. Thus
samples from the prior will be quite “rough”, although (as noted in section 6.1)
the posterior mean, eq. (6.25), is smoother.

The constructions above can be generalized to the regularizerR (f (m)(x))2 dx

by replacing (x − u)+ with (x − u)m−1
eq. (6.32), and setting h(x) = (1, x, . . . , xm−1)>.

+ /(m − 1)! in eq. (6.28) and similarly in

Thus, we can use a Gaussian process formulation as an alternative to the
usual spline ﬁtting procedure. Note that the trade-oﬀ parameter λ from eq. (6.26)

−505−4−3−2−1012input, xoutput, y−505−4−3−2−1012input, xoutput, yC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.4 Support Vector Machines

141

(a)

(b)

Figure 6.2: Panel (a) shows a linearly separable binary classiﬁcation problem, and a
separating hyperplane. Panel (b) shows the maximum margin hyperplane.

n/σ2

f and σ2

f . The hyperparameters σ2

n can be set
is now given as the ratio σ2
using the techniques from section 5.4.1 by optimizing the marginal likelihood
given in eq. (2.45). Kohn and Ansley [1987] give details of an O(n) algorithm
(based on Kalman ﬁltering) for the computation of the spline and the marginal
likelihood. In addition to the predictive mean the GP treatment also yields an
explicit estimate of the noise level and predictive error bars. Figure 6.1 shows
a simple example. Notice that whereas the mean function is a piecewise cubic
polynomial, samples from the posterior are not smooth. In contrast, for the
squared exponential covariance functions shown in panel (b), both the mean
and functions drawn from the posterior are inﬁnitely diﬀerentiable.

6.4 Support Vector Machines

∗

Since the mid 1990’s there has been an explosion of interest in kernel machines,
and in particular the support vector machine (SVM). The aim of this section
is to provide a brief introduction to SVMs and in particular to compare them
to Gaussian process predictors. We consider SVMs for classiﬁcation and re-
gression problems in sections 6.4.1 and 6.4.2 respectively. More comprehensive
treatments can be found in Vapnik [1995], Cristianini and Shawe-Taylor [2000]
and Sch¨olkopf and Smola [2002].

6.4.1 Support Vector Classiﬁcation

For support vector classiﬁers, the key notion that we need to introduce is that
of the maximum margin hyperplane for a linear classiﬁer. Then by using the
“kernel trick” this can be lifted into feature space. We consider ﬁrst the sep-
arable case and then the non-separable case. We conclude this section with a
comparison between GP classiﬁers and SVMs.

xixj     w·x+w0<0w·x+w0>0.     wmarginxixj.C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

142

Relationships between GPs and Other Models

The Separable Case

Figure 6.2(a) illustrates the case where the data is linearly separable. For a
linear classiﬁer with weight vector w and oﬀset w0, let the decision boundary
be deﬁned by w · x + w0 = 0, and let ˜w = (w, w0). Clearly, there is a whole
version space of weight vectors that give rise to the same classiﬁcation of the
training points. The SVM algorithm chooses a particular weight vector, that
gives rise to the “maximum margin” of separation.

functional margin

geometrical margin

Let the training set be pairs of the form (xi, yi) for i = 1, . . . , n, where yi =
±1. For a given weight vector we can compute the quantity ˜γi = yi(w· x + w0),
which is known as the functional margin. Notice that ˜γi > 0 if a training point
is correctly classiﬁed.

If the equation f(x) = w · x + w0 deﬁnes a discriminant function (so that
the output is sgn(f(x))), then the hyperplane cw · x + cw0 deﬁnes the same
discriminant function for any c > 0. Thus we have the freedom to choose the
scaling of ˜w so that mini ˜γi = 1, and in this case ˜w is known as the canonical
form of the hyperplane.

The geometrical margin is deﬁned as γi = ˜γi/|w|. For a training point xi
that is correctly classiﬁed this is simply the distance from xi to the hyperplane.
To see this, let c = 1/|w| so that ˆw = w/|w| is a unit vector in the direction
of w, and ˆw0 is the corresponding oﬀset. Then ˆw · x computes the length
of the projection of x onto the direction orthogonal to the hyperplane and
ˆw·x+ ˆw0 computes the distance to the hyperplane. For training points that are
misclassiﬁed the geometrical margin is the negative distance to the hyperplane.
The geometrical margin for a dataset D is deﬁned as γD = mini γi. Thus
for a canonical separating hyperplane the margin is 1/|w|. We wish to ﬁnd the
maximum margin hyperplane, i.e. the one that maximizes γD.

optimization problem

By considering canonical hyperplanes, we are thus led to the following op-

timization problem to determine the maximum margin hyperplane:

|w|2

1
2

minimize
subject to yi(w · xi + w0) ≥ 1

over w, w0

for all i = 1, . . . , n.

(6.33)

It is clear by considering the geometry that for the maximum margin solution
there will be at least one data point in each class for which yi(w·xi+w0) = 1, see
Figure 6.2(b). Let the hyperplanes that pass through these points be denoted
H+ and H− respectively.

This constrained optimization problem can be set up using Lagrange multi-
pliers, and solved using numerical methods for quadratic programming4 (QP)
problems. The form of the solution is

w = X

4A quadratic programming problem is an optimization problem where the objective func-

tion is quadratic and the constraints are linear in the unknowns.

i

λiyixi,

(6.34)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.4 Support Vector Machines

143

support vectors

kernel trick

soft margin

where the λi’s are non-negative Lagrange multipliers. Notice that the solution
is a linear combination of the xi’s.

The key feature of equation 6.34 is that λi is zero for every xi except those
which lie on the hyperplanes H+ or H−; these points are called the support
vectors. The fact that not all of the training points contribute to the ﬁnal
solution is referred to as the sparsity of the solution. The support vectors
lie closest to the decision boundary. Note that if all of the other training
points were removed (or moved around, but not crossing H+ or H−) the same
maximum margin hyperplane would be found. The quadratic programming
problem for ﬁnding the λi’s is convex, i.e. there are no local minima. Notice
the similarity of this to the convexity of the optimization problem for Gaussian
process classiﬁers, as described in section 3.4.

To make predictions for a new input x∗ we compute

sgn(w · x∗ + w0) = sgn

λiyi(xi · x∗) + w0

(cid:16) nX

(cid:17)

.

(6.35)

i=1

In the QP problem and in eq. (6.35) the training points {xi} and the test point
x∗ enter the computations only in terms of inner products. Thus by using the
kernel trick we can replace occurrences of the inner product by the kernel to
obtain the equivalent result in feature space.

The Non-Separable Case

For linear classiﬁers in the original x space there will be some datasets that
are not linearly separable. One way to generalize the SVM problem in this
case is to allow violations of the constraint yi(w · xi + w0) ≥ 1 but to impose a
penalty when this occurs. This leads to the soft margin support vector machine
problem, the minimization of

nX

i=1

|w|2 + C

1
2

(1 − yifi)+

(6.36)

with respect to w and w0, where fi = f(xi) = w · xi + w0 and (z)+ = z if
z > 0 and 0 otherwise. Here C > 0 is a parameter that speciﬁes the relative
importance of the two terms. This convex optimization problem can again be
solved using QP methods and yields a solution of the form given in eq. (6.34). In
this case the support vectors (those with λi 6= 0) are not only those data points
which lie on the separating hyperplanes, but also those that incur penalties.
This can occur in two ways (i) the data point falls in between H+ and H− but
on the correct side of the decision surface, or (ii) the data point falls on the
wrong side of the decision surface.

In a feature space of dimension N, if N > n then there will always be
separating hyperplane. However, this hyperplane may not give rise to good
generalization performance, especially if some of the labels are incorrect, and
thus the soft margin SVM formulation is often used in practice.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

144

Relationships between GPs and Other Models

(a)

(b)

Figure 6.3: (a) A comparison of the hinge error, gλ and gΦ. (b) The -insensitive
error function used in SVR.

For both the hard and soft margin SVM QP problems a wide variety of
algorithms have been developed for their solution; see Sch¨olkopf and Smola
[2002, ch. 10] for details. Basic interior point methods involve inversions of n×n
matrices and thus scale as O(n3), as with Gaussian process prediction. However,
there are other algorithms, such as the sequential minimal optimization (SMO)
algorithm due to Platt [1999], which often have better scaling in practice.

Above we have described SVMs for the two-class (binary) classiﬁcation prob-
lem. There are many ways of generalizing SVMs to the multi-class problem,
see Sch¨olkopf and Smola [2002, sec. 7.6] for further details.

Comparing Support Vector and Gaussian Process Classiﬁers

For the soft margin classiﬁer we obtain a solution of the form w = P
(with αi = λiyi) and thus |w|2 =P

i αixi
i,j αiαj(xi · xj). Kernelizing this we obtain
|w|2 = α>Kα = f>K−1f, as5 Kα = f. Thus the soft margin objective
nX
function can be written as

f>K−1f + C

(1 − yifi)+.

(6.37)

1
2

1
2

i=1

f>K−1f − nX

i=1

For the binary GP classiﬁer, to obtain the MAP value ˆf of p(f|y) we minimize
the quantity

log p(yi|fi),

(6.38)

cf. eq. (3.12). (The ﬁnal two terms in eq. (3.12) are constant if the kernel is
ﬁxed.)

For log-concave likelihoods (such as those derived from the logistic or pro-
bit response functions) there is a strong similarity between the two optimiza-
tion problems in that they are both convex. Let gλ(z) , log(1 + e−z), gΦ =
5Here the oﬀset w0 has been absorbed into the kernel so it is not an explicit extra param-

eter.

−2014012log(1 + exp(−z))−log F(z)max(1−z, 0)zg(z)−0−.C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.4 Support Vector Machines

145

hinge error function

− log Φ(z), and ghinge(z) , (1 − z)+ where z = yifi. We refer to ghinge as the
hinge error function, due to its shape. As shown in Figure 6.3(a) all three data
ﬁt terms are monotonically decreasing functions of z. All three functions tend
to inﬁnity as z → −∞ and decay to zero as z → ∞. The key diﬀerence is that
the hinge function takes on the value 0 for z ≥ 1, while the other two just decay
slowly. It is this ﬂat part of the hinge function that gives rise to the sparsity of
the SVM solution.

Thus there is a close correspondence between the MAP solution of the GP
classiﬁer and the SVM solution. Can this correspondence be made closer by
considering the hinge function as a negative log likelihood? The answer to this
is no [Seeger, 2000, Sollich, 2002]. If Cghinge(z) deﬁned a negative log likelihood,
then exp(−Cghinge(f)) + exp(−Cghinge(−f)) should be a constant independent
of f, but this is not the case. To see this, consider the quantity

ν(f; C) = κ(C)[exp(−C(1 − f)+) + exp(−C(1 + f)+)].

(6.39)

κ(C) cannot be chosen so as to make ν(f; C) = 1 independent of the value
of f for C > 0. By comparison, for the logistic and probit likelihoods the
analogous expression is equal to 1. Sollich [2002] suggests choosing κ(C) =
1/(1 + exp(−2C)) which ensures that ν(f, C) ≤ 1 (with equality only when
f = ±1). He also gives an ingenious interpretation (involving a “don’t know”
class to soak up the unassigned probability mass) that does yield the SVM
solution as the MAP solution to a certain Bayesian problem, although we ﬁnd
this construction rather contrived. Exercise 6.7.2 invites you to plot ν(f; C) as
a function of f for various values of C.

One attraction of the GP classiﬁer is that it produces an output with a
clear probabilistic interpretation, a prediction for p(y = +1|x). One can try
to interpret the function value f(x) output by the SVM probabilistically, and
Platt [2000] suggested that probabilistic predictions can be generated from the
SVM by computing σ(af(x) + b) for some constants a, b that are ﬁtted using
some “unbiased version” of the training set (e.g. using cross-validation). One
disadvantage of this rather ad hoc procedure is that unlike the GP classiﬁers
it does not take into account the predictive variance of f(x) (cf. eq. (3.25)).
Seeger [2003, sec. 4.7.2] shows that better error-reject curves can be obtained
on an experiment using the MNIST digit classiﬁcation problem when the eﬀect
of this uncertainty is taken into account.

6.4.2 Support Vector Regression

The SVM was originally introduced for the classiﬁcation problem, then extended
to deal with the regression case. The key concept is that of the -insensitive
error function. This is deﬁned as

(6.40)

(cid:26) |z| − 

0

g(z) =

if |z| ≥ ,
otherwise.

This function is plotted in Figure 6.3(b). As in eq. (6.21) we can interpret
exp(−g(z)) as a likelihood model for the regression residuals (c.f. the squared

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

146

Relationships between GPs and Other Models

error function corresponding to a Gaussian model). However, we note that
this is quite an unusual choice of model for the distribution of residuals and
is basically motivated by the desire to obtain a sparse solution (see below)
as in support vector classiﬁer.
If  = 0 then the error model is a Laplacian
distribution, which corresponds to least absolute values regression (Edgeworth
[1887], cited in Rousseeuw [1984]); this is a heavier-tailed distribution than the
Gaussian and provides some protection against outliers. Girosi [1991] showed
that the Laplacian distribution can be viewed as a continuous mixture of zero-
mean Gaussians with a certain distribution over their variances. Pontil et al.
[1998] extended this result by allowing the means to uniformly shift in [−, ]
in order to obtain a probabilistic model corresponding to the -insensitive error
function. See also section 9.3 for work on robustiﬁcation of the GP regression
problem.

For the linear regression case with an -insensitive error function and a

Gaussian prior on w, the MAP value of w is obtained by minimizing

g(yi − fi)

(6.41)

nX
w.r.t. w. The solution6 is f(x∗) =Pn
solution f(x∗) =Pn

i=1 αik(xi, x∗).

i=1

|w|2 + C

1
2

i=1 αixi · x∗ where the coeﬃcients α are
obtained from a QP problem. The problem can also be kernelized to give the

As for support vector classiﬁcation, many of the coeﬃcients αi are zero. The
data points which lie inside the -“tube” have αi = 0, while those on the edge
or outside have non-zero αi.

∗

6.5 Least-squares Classiﬁcation

In chapter 3 we have argued that the use of logistic or probit likelihoods pro-
vides the natural route to develop a GP classiﬁer, and that it is attractive in
that the outputs can be interpreted probabilistically. However, there is an even
simpler approach which treats classiﬁcation as a regression problem.

Our starting point is binary classiﬁcation using the linear predictor f(x) =
w>x. This is trained using linear regression with a target y+ for patterns that
have label +1, and target y− for patterns that have label −1. (Targets y+, y−
give slightly more ﬂexibility than just using targets of ±1.) As shown in Duda
and Hart [1973, section 5.8], choosing y+, y− appropriately allows us to obtain
the same solution as Fisher’s linear discriminant using the decision criterion
f(x) ≷ 0. Also, they show that using targets y+ = +1, y− = −1 with the
least-squares error function gives a minimum squared-error approximation to
the Bayes discriminant function p(C+|x)− p(C−|x) as n → ∞. Following Rifkin
and Klautau [2004] we call such methods least-squares classiﬁcation (LSC). Note
that under a probabilistic interpretation the squared-error criterion is rather an

6Here we have assumed that the constant 1 is included in the input vector x.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.5 Least-squares Classiﬁcation

147

odd choice as it implies a Gaussian noise model, yet only two values of the
target (y+ and y−) are observed.

It is natural to extend the least-squares classiﬁer using the kernel trick.
This has been suggested by a number of authors including Poggio and Girosi
[1990] and Suykens and Vanderwalle [1999]. Experimental results reported in
Rifkin and Klautau [2004] indicate that performance comparable to SVMs can
be obtained using kernel LSC (or as they call it the regularized least-squares
classiﬁer, RLSC).

Consider a single random variable y which takes on the value +1 with proba-
bility p and value −1 with probability 1−p. Then the value of f which minimizes
the squared error function E = p(f − 1)2 + (1 − p)(f + 1)2 is ˆf = 2p − 1, which
is a linear rescaling of p to the interval [−1, 1]. (Equivalently if the targets are
1 and 0, we obtain ˆf = p.) Hence we observe that LSC will estimate p correctly
in the large data limit. If we now consider not just a single random variable,
but wish to estimate p(C+|x) (or a linear rescaling of it), then as long as the
approximating function f(x) is suﬃciently ﬂexible, we would expect that in the
limit n → ∞ it would converge to p(C+|x). (For more technical detail on this
issue, see section 7.2.1 on consistency.) Hence LSC is quite a sensible procedure
for classiﬁcation, although note that there is no guarantee that f(x) will be
constrained to lie in the interval [y−, y+].
If we wish to guarantee a proba-
bilistic interpretation, we could “squash” the predictions through a sigmoid, as
suggested for SVMs by Platt [2000] and described on page 145.

When generalizing from the binary to multi-class situation there is some
freedom as to how to set the problem up. Sch¨olkopf and Smola [2002, sec. 7.6]
identify four methods, namely one-versus-rest (where C binary classiﬁers are
trained to classify each class against all the rest), all pairs (where C(C − 1)/2
binary classiﬁers are trained), error-correcting output coding (where each class
is assigned a binary codeword, and binary classiﬁers are trained on each bit
separately), and multi-class objective functions (where the aim is to train C
classiﬁers simultaneously rather than creating a number of binary classiﬁcation
problems). One also needs to specify how the outputs of the various classiﬁers
that are trained are combined so as to produce an overall answer. For the
one-versus-rest7 method one simple criterion is to choose the classiﬁer which
produces the most positive output. Rifkin and Klautau [2004] performed ex-
tensive experiments and came to the conclusion that the one-versus-rest scheme
using either SVMs or RLSC is as accurate as any other method overall, and
has the merit of being conceptually simple and straightforward to implement.

6.5.1 Probabilistic Least-squares Classiﬁcation

The LSC algorithm discussed above is attractive from a computational point
of view, but to guarantee a valid probabilistic interpretation one may need
to use a separate post-processing stage to “squash” the predictions through a
sigmoid. However, it is not so easy to enforce a probabilistic interpretation

7This method is also sometimes called one-versus-all.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

148

Relationships between GPs and Other Models

during the training stage. One possible solution is to combine the ideas of
training using leave-one-out cross-validation, covered in section 5.4.2, with the
use of a (parameterized) sigmoid function, as in Platt [2000]. We will call this
method the probabilistic least-squares classiﬁer (PLSC).

In section 5.4.2 we saw how to compute the Gaussian leave-one-out (LOO)
predictive probabilities, and that training of hyperparameters can be based
on the sum of the log LOO probabilities. Using this idea, we express the LOO
probability by squashing a linear function of the Gaussian predictive probability
through a cumulative Gaussian
p(yi|X, y−i, θ) =

Φ(cid:0)yi(αfi + β)(cid:1)N (fi|µi, σ2
(cid:16) yi(αµi + β)

(6.42)

i ) dfi

(cid:17)

Z

= Φ

√

,

1 + α2σ2
i

where the integral is given in eq. (3.82) and the leave-one-out predictive mean µi
and variance σ2
i are given in eq. (5.12). The objective function is the sum of the
log LOO probabilities, eq. (5.11) which can be used to set the hyperparameters
as well as the two additional parameters of the linear transformation, α and β in
eq. (6.42). Introducing the likelihood in eq. (6.42) into the objective eq. (5.11)
and taking derivatives we obtain

∂ log p(yi|X, y−i, θ)

∂µi
yiα√
1 + α2σ2
i

N (ri)
Φ(yiri)
√

∂µi
∂θj

(cid:16) ∂µi

∂θj

+ ∂ log p(yi|X, y−i, θ)
(cid:17)

∂σ2
i
− α(αµi + β)
2(1 + α2σ2
i )

∂σ2
i
∂θj

,

∂σ2
i
∂θj

(6.43)

1 + α2σ2
where ri = (αµi + β)/
LOO parameters ∂µi/∂θj and ∂σ2
linear transformation parameters we have

i and the partial derivatives of the Gaussian
i /∂θj are given in eq. (5.13). Finally, for the

∂LLOO

∂θj

=

=

nX
nX

i=1

i=1

nX
nX

i=1

i=1

∂LLOO

∂α

∂LLOO

∂β

=

=

N (ri)
Φ(yiri)
N (ri)
Φ(yiri)

yi√
1 + α2σ2
i

yip1 + α2σ2

i

µi − βασ2
i
1 + α2σ2
i

,

.

(6.44)

These partial derivatives can be used to train the parameters of the GP. There
are several options on how to do predictions, but the most natural would seem
to be to compute predictive mean and variance and squash it through the
sigmoid, parallelling eq. (6.42). Applying this model to the USPS 3s vs. 5s
binary classiﬁcation task discussed in section 3.7.3, we get a test set error rate
of 12/773 = 0.0155%, which compares favourably with the results reported for
other methods in Figure 3.10. However, the test set information is only 0.77
bits,8 which is very poor.

8The test information is dominated by a single test case, which is predicted conﬁdently
to belong to the wrong class. Visual inspection of the digit reveals that indeed it looks as
though the testset label is wrong for this case. This observation highlights the danger of not
explicitly allowing for data mislabelling in the model for this kind of data.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

6.6 Relevance Vector Machines

149

6.6 Relevance Vector Machines

∗

Although usually not presented as such, the relevance vector machine (RVM)
introduced by Tipping [2001] is actually a special case of a Gaussian process.
The covariance function has the form

NX

j=1

k(x, x0) =

φj(x)φj(x0),

1
αj

(6.45)

where αj are hyperparameters and the N basis functions φj(x) are usually, but
not necessarily taken to be Gaussian-shaped basis functions centered on each
of the n training data points

(cid:16)− |x − xj|2

(cid:17)

2‘2

φj(x) = exp

,

(6.46)

where ‘ is a length-scale hyperparameter controlling the width of the basis
function. Notice that this is simply the construction for the covariance function
corresponding to an N-dimensional set of basis functions given in section 2.1.2,
with Σp = diag(α−1

1 , . . . , α−1
N ).

The covariance function in eq. (6.45) has two interesting properties: ﬁrstly,
it is clear that the feature space corresponding to the covariance function is
ﬁnite dimensional, i.e. the covariance function is degenerate, and secondly the
covariance function has the odd property that it depends on the training data.
This dependency means that the prior over functions depends on the data, a
property which is at odds with a strict Bayesian interpretation. Although the
usual treatment of the model is still possible, this dependency of the prior on
the data may lead to some surprising eﬀects, as discussed below.

Training the RVM is analogous to other GP models: optimize the marginal
likelihood w.r.t. the hyperparameters. This optimization often leads to a sig-
niﬁcant number of the αj hyperparameters tending towards inﬁnity, eﬀectively
removing, or pruning, the corresponding basis function from the covariance
function in eq. (6.45). The basic idea is that basis functions that are not sig-
niﬁcantly contributing to explaining the data should be removed, resulting in
a sparse model. The basis functions that survive are called relevance vectors.
Empirically it is often observed that the number of relevance vectors is smaller
than the number of support vectors on the same problem [Tipping, 2001].

The original RVM algorithm [Tipping, 2001] was not able to exploit the
sparsity very eﬀectively during model ﬁtting as it was initialized with all of the
αis set to ﬁnite values, meaning that all of the basis functions contributed to
the model. However, careful analysis of the RVM marginal likelihood by Faul
and Tipping [2002] showed that one can carry out optimization w.r.t. a single
αi analytically. This has led to the accelerated training algorithm described
in Tipping and Faul [2003] which starts with an empty model (i.e. all αis set
to inﬁnity) and adds basis functions sequentially. As the number of relevance
vectors is (usually much) less than the number of training cases it will often
be much faster to train and make predictions using a RVM than a non-sparse

relevance vectors

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

150

Relationships between GPs and Other Models

GP. Also note that the basis functions can include additional hyperparameters,
e.g. one could use an automatic relevance determination (ARD) form of basis
function by using diﬀerent length-scales on diﬀerent dimensions in eq. (6.46).
These additional hyperparameters could also be set by optimizing the marginal
likelihood.

The use of a degenerate covariance function which depends on the data
Imagine a test point, x∗, which lies far away
has some undesirable eﬀects.
from the relevance vectors. At x∗ all basis functions will have values close to
zero, and since no basis function can give any appreciable signal, the predictive
distribution will be a Gaussian with a mean close to zero and variance close
to zero (or to the inferred noise level). This behaviour is undesirable, and
could lead to dangerously false conclusions. If the x∗ is far from the relevance
vectors, then the model shouldn’t be able to draw strong conclusions about
the output (we are extrapolating), but the predictive uncertainty becomes very
small—this is the opposite behaviour of what we would expect from a reasonable
model. Here, we have argued that for localized basis functions, the RVM has
undesirable properties, but as argued in Rasmussen and Qui˜nonero-Candela
[2005] it is actually the degeneracy of the covariance function which is the
core of the problem. Although the work of Rasmussen and Qui˜nonero-Candela
[2005] goes some way towards ﬁxing the problem, there is an inherent conﬂict:
degeneracy of the covariance function is good for computational reasons, but
bad for modelling reasons.

6.7 Exercises

sis vectors f = Pn
Pn

1. We motivate the fact that the RKHS norm does not depend on the den-
sity p(x) using a ﬁnite-dimensional analogue. Consider the n-dimensional
vector f, and let the n× n matrix Φ be comprised of non-colinear columns
φ1, . . . , φn. Then f can be expressed as a linear combination of these ba-
i=1 ciφi = Φc for some coeﬃcients {ci}. Let the φs
be eigenvectors of the covariance matrix K w.r.t. a diagonal matrix P
with non-negative entries, so that KP Φ = ΦΛ, where Λ is a diagonal
matrix containing the eigenvalues. Note that Φ>P Φ = In. Show that
i /λi = c>Λ−1c = f>K−1f, and thus observe that f>K−1f can be
expressed as c>Λ−1c for any valid P and corresponding Φ. Hint: you
may ﬁnd it useful to set ˜Φ = P 1/2Φ, ˜K = P 1/2KP 1/2 etc.

i=1 c2

2. Plot eq. (6.39) as a function of f for diﬀerent values of C. Show that
there is no value of C and κ(C) which makes ν(f; C) equal to 1 for all
values of f. Try setting κ(C) = 1/(1 + exp(−2C)) as suggested in Sollich
[2002] and observe what eﬀect this has.

3. Show that the predictive mean for the spline covariance GP in eq. (6.29)
is a linear function of x∗ when x∗ is located either to the left or to the
right of all training points. Hint: consider the eigenvectors corresponding
to the two largest eigenvalues of the training set covariance matrix from
eq. (2.40) in the vague limit.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 7

Theoretical Perspectives

This chapter covers a number of more theoretical issues relating to Gaussian
processes. In section 2.6 we saw how GPR carries out a linear smoothing of the
datapoints using the weight function. The form of the weight function can be
understood in terms of the equivalent kernel, which is discussed in section 7.1.
As one gets more and more data, one would hope that the GP predictions
would converge to the true underlying predictive distribution. This question
of consistency is reviewed in section 7.2, where we also discuss the concepts of
equivalence and orthogonality of GPs.

When the generating process for the data is assumed to be a GP it is particu-
larly easy to obtain results for learning curves which describe how the accuracy
of the predictor increases as a function of n, as described in section 7.3. An
alternative approach to the analysis of generalization error is provided by the
PAC-Bayesian analysis discussed in section 7.4. Here we seek to relate (with
high probability) the error observed on the training set to the generalization
error of the GP predictor.

Gaussian processes are just one of the many methods that have been devel-
oped for supervised learning problems. In section 7.5 we compare and contrast
GP predictors with other supervised learning methods.

7.1 The Equivalent Kernel

In this section we consider regression problems. We have seen in section 6.2
that the posterior mean for GP regression can be obtained as the function which
minimizes the functional

(cid:0)yi − f(xi)(cid:1)2

,

(7.1)

J[f] =

kfk2H +

1
2

1
2σ2
n

nX

i=1

where kfkH is the RKHS norm corresponding to kernel k. Our goal is now to
understand the behaviour of this solution as n → ∞.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

152

Theoretical Perspectives

Let µ(x, y) be the probability measure from which the data pairs (xi, yi) are

generated. Observe that

Eh nX

(cid:0)yi − f(xi)(cid:1)2i

Z (cid:0)y − f(x)(cid:1)2

= n

dµ(x, y).

(7.2)

i=1

Let η(x) = E[y|x] be the regression function corresponding to the probability
Then writing y − f = (y − η) + (η − f) we obtain

measure µ. The variance around η(x) is denoted σ2(x) =R (y − η(x))2dµ(y|x).
Z (cid:0)y − f(x)(cid:1)2

Z (cid:0)η(x) − f(x)(cid:1)2

σ2(x) dµ(x),

dµ(x, y) =

dµ(x) +

(7.3)

Z

as the cross term vanishes due to the deﬁnition of η(x).

As the second term on the right hand side of eq. (7.3) is independent of f,
an idealization of the regression problem consists of minimizing the functional

Z (cid:0)η(x) − f(x)(cid:1)2

Jµ[f] = n
2σ2
n

dµ(x) +

kfk2H.

1
2

(7.4)

The form of the minimizing solution is most easily understood in terms of the

eigenfunctions {φi(x)} of the kernel k w.r.t. to µ(x), whereR φi(x)φj(x)dµ(x) =
form a complete orthonormal basis, we write f(x) =P∞
i=1 ηiφi(x), where ηi =R η(x)φi(x)dµ(x). Thus
η(x) =P∞
∞X

δij, see section 4.3. Assuming that the kernel is nondegenerate so that the φs
i=1 fiφi(x). Similarly,

∞X

Jµ[f] = n
2σ2
n

i=1

(ηi − fi)2 +

1
2

i=1

f 2
i
λi

.

(7.5)

This is readily minimized by diﬀerentiation w.r.t. each fi to obtain

fi =

λi
λi + σ2

n/n

ηi.

(7.6)

the generalized Fourier seriesP∞

n/n → 0 as n → ∞ so that in this limit we would
Notice that the term σ2
expect that f(x) will converge to η(x). There are two caveats: (1) we have
assumed that η(x) is suﬃciently well-behaved so that it can be represented by
i=1 ηiφi(x), and (2) we assumed that the kernel
is nondegenerate. If the kernel is degenerate (e.g. a polynomial kernel) then f
should converge to the best µ-weighted L2 approximation to η within the span
of the φ’s. In section 7.2.1 we will say more about rates of convergence of f to
η; clearly in general this will depend on the smoothness of η, the kernel k and
the measure µ(x, y).

From a Bayesian perspective what is happening is that the prior on f is
being overwhelmed by the data as n → ∞. Looking at eq. (7.6) we also see
n (cid:29) nλi then fi is eﬀectively zero. This means that we cannot ﬁnd
that if σ2
out about the coeﬃcients of eigenfunctions with small eigenvalues until we get
suﬃcient amounts of data. Ferrari Trecate et al. [1999] demonstrated this by

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.1 The Equivalent Kernel

153

showing that regression performance of a certain nondegenerate GP could be
approximated by taking the ﬁrst m eigenfunctions, where m was chosen so that
λm ’ σ2

Using the fact that ηi = R η(x0)φi(x0)dµ(x0) and deﬁning σ2

n/n. Of course as more data is obtained then m has to be increased.

, σ2

n/n we

eﬀ

obtain

∞X

i=1

Z h ∞X

i=1

i

λiφi(x)φi(x0)

λi + σ2
eﬀ

Z

f(x) =

λiηi
λi + σ2
eﬀ

φi(x) =

η(x0) dµ(x0).

(7.7)

with ¯f(x0) = R hn(x, x0)y(x)dµ(x). Notice that in the limit n → ∞ (so that

The term in square brackets in eq. (7.7) is the equivalent kernel for the smooth-
ing problem; we denote it by hn(x, x0). Notice the similarity to the vector-valued
weight function h(x) deﬁned in section 2.6. The diﬀerence is that there the pre-
diction was obtained as a linear combination of a ﬁnite number of observations
yi with weights given by hi(x) while here we have a noisy function y(x) instead,
eﬀ → 0) the equivalent kernel tends towards the delta function.
σ2
The form of the equivalent kernel given in eq. (7.7) is not very useful in
practice as it requires knowledge of the eigenvalues/functions for the combina-
tion of k and µ. However, in the case of stationary kernels we can use Fourier
methods to compute the equivalent kernel. Consider the functional

Jρ[f] = ρ
2σ2
n

(y(x) − f(x))2 dx +

kfk2H,

1
2

(7.8)

where ρ has dimensions of the number of observations per unit of x-space
(length/area/volume etc. as appropriate). Using a derivation similar to eq. (7.6)
we obtain

˜h(s) =

Sf (s)
Sf (s) + σ2

n/ρ

=

1
1 + S−1

f (s)σ2

n/ρ

,

(7.9)

where Sf (s) is the power spectrum of the kernel k. The term σ2
n/ρ corresponds
to the power spectrum of a white noise process, as the delta function covari-
ance function of white noise corresponds to a constant in the Fourier domain.
This analysis is known as Wiener ﬁltering; see, e.g. Papoulis [1991, sec. 14-1].
Equation (7.9) is the same as eq. (7.6) except that the discrete eigenspectrum
has been replaced by a continuous one.

As can be observed in Figure 2.6, the equivalent kernel essentially gives a
weighting to the observations locally around x. Thus identifying ρ with np(x)
we can obtain an approximation to the equivalent kernel for stationary kernels
when the width of the kernel is smaller than the length-scale of variations in
p(x). This form of analysis was used by Silverman [1984] for splines in one
dimension.

7.1.1 Some Speciﬁc Examples of Equivalent Kernels
We ﬁrst consider the OU process in 1-d. This has k(r) = exp(−α|r|) (setting
α = 1/‘ relative to our previous notation and r = x − x0), and power spectrum

equivalent kernel

Wiener ﬁltering

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

154

Theoretical Perspectives

S(s) = 2α/(4π2s2 + α2). Let vn , σ2

n/ρ. Using eq. (7.9) we obtain

˜h(s) =

2α

vn(4π2s2 + β2) ,

(7.10)

where β2 = α2 + 2α/vn. This again has the form of Fourier transform of an
vnβ e−β|r|. In
OU covariance function1 and can be inverted to obtain h(r) = α
particular notice that as n increases (and thus vn decreases) the inverse length-
scale β of h(r) increases; asymptotically β ∼ n1/2 for large n. This shows that
the width of equivalent kernel for the OU covariance function will scale as n−1/2
asymptotically. Similarly the width will scale as p(x)−1/2 asymptotically.

A similar analysis can be carried out for the AR(2) Gaussian process in 1-d
(see section B.2) which has a power spectrum ∝ (4π2s2 + α2)−2 (i.e. it is in
the Mat´ern class with ν = 3/2). In this case we can show (using the Fourier
relationships given by Papoulis [1991, p. 326]) that the width of the equivalent
kernel scales as n−1/4 asymptotically.

analyzes end-eﬀects if the domain of interest is a bounded open interval. For

Analysis of the equivalent kernel has also been carried out for spline models.
Silverman [1984] gives the explicit form of the equivalent kernel in the case
of a one-dimensional cubic spline (corresponding to the regularizer kP fk2 =
00)2dx). Thomas-Agnan [1996] gives a general expression for the equivalent

R (f
kernel for the spline regularizer kP fk2 =R (f (m))2dx in one dimension and also
the regularizer kP fk2 =R (∇2f)2dx in two dimensions, the equivalent kernel is
sponding to a roughness penalty of R (f (m))2 dx) the width of the equivalent

Silverman [1984] has also shown that for splines of order m in 1-d (corre-
kernel will scale as n−1/2m asymptotically. In fact it can be shown that this is
true for splines in D > 1 dimensions too, see exercise 7.7.1.

given in terms of the Kelvin function kei (Poggio et al. 1985, Stein 1991).

Another interesting case to consider is the squared exponential kernel, where

S(s) = (2π‘2)D/2 exp(−2π2‘2|s|2). Thus

˜hSE(s) =

1

1 + b exp(2π2‘2|s|2) ,

(7.11)

where b = σ2
n/ρ(2π‘2)D/2. We are unaware of an exact result in this case, but
the following approximation due to Sollich and Williams [2005] is simple but
eﬀective. For large ρ (i.e. large n) b will be small. Thus for small s = |s| we
have that ˜hSE ’ 1, but for large s it is approximately 0. The change takes
place around the point sc where b exp(2π2‘2s2
c = log(1/b)/2π2‘2.
As exp(2π2‘2s2) grows quickly with s, the transition of ˜hSE between 1 and 0
can be expected to be rapid, and thus be well-approximated by a step function.
By using the standard result for the Fourier transform of the step function we
obtain

c) = 1, i.e. s2

hSE(x) = 2scsinc(2πscx)

(7.12)

1The fact that ˜h(s) has the same form as Sf (s) is particular to the OU covariance function

and is not generally the case.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.2 Asymptotic Analysis

155

for D = 1, where sinc(z) = sin(z)/z. A similar calculation in D > 1 using
eq. (4.7) gives

(cid:16) sc

(cid:17)D/2

hSE(r) =

r

JD/2(2πscr).

(7.13)

Notice that sc scales as (log(n))1/2 so that the width of the equivalent kernel
will decay very slowly as n increases. Notice that the plots in Figure 2.6 show
the sinc-type shape, although the sidelobes are not quite as large as would be
predicted by the sinc curve (because the transition is smoother than a step
function in Fourier space so there is less “ringing”).

7.2 Asymptotic Analysis

∗

In this section we consider two asymptotic properties of Gaussian processes,
consistency and equivalence/orthogonality.

7.2.1 Consistency

In section 7.1 we have analyzed the asymptotics of GP regression and have
seen how the minimizer of the functional eq. (7.4) converges to the regression
function as n → ∞. We now broaden the focus by considering loss functions
other than squared loss, and the case where we work directly with eq. (7.1)
rather than the smoothed version eq. (7.4).

The set up is as follows: Let L(·,·) be a pointwise loss function. Consider
a procedure that takes training data D and this loss function, and returns a
function fD(x). For a measurable function f, the risk (expected loss) is deﬁned
as

Z

RL(f) =

L(y, f(x)) dµ(x, y).

(7.14)

L denote the function that minimizes this risk. For squared loss f∗

Let f∗
L(x) =
E[y|x]. For 0/1 loss with classiﬁcation problems, we choose f∗
L(x) to be the
class c at x such that p(Cc|x) > p(Cj|x) for all j 6= c (breaking ties arbitrarily).

Deﬁnition 7.1 We will say that a procedure that returns fD is consistent for
a given measure µ(x, y) and loss function L if

consistency

RL(fD) → RL(f∗
L)

as n → ∞,

(7.15)

where convergence is assessed in a suitable manner, e.g. in probability. If fD(x)
is consistent for all Borel probability measures µ(x, y) then it is said to be uni-
(cid:3)
versally consistent.

ing ˆf(x∗) =Pn

A simple example of a consistent procedure is the kernel regression method.
As described in section 2.6 one obtains a prediction at test point x∗ by comput-
j=1κj (the Nadaraya-Watson estima-
tor). Let h be the width of the kernel κ and D be the dimension of the input

i=1 wiyi where wi = κi/Pn

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

156

Theoretical Perspectives

space. It can be shown that under suitable regularity conditions if h → 0 and
nhD → ∞ as n → ∞ then the procedure is consistent; see e.g. [Gy¨orﬁ et al.,
2002, Theorem 5.1] for the regression case with squared loss and Devroye et al.
[1996, Theorem 10.1] for the classiﬁcation case using 0/1 loss. An intuitive
understanding of this result can be obtained by noting that h → 0 means that
only datapoints very close to x∗ will contribute to the prediction (eliminating
bias), while the condition nhD → ∞ means that a large number of datapoints
will contribute to the prediction (eliminating noise/variance).

combination of eigenfunctionsP∞

It will ﬁrst be useful to consider why we might hope that GPR and GPC
should be universally consistent. As discussed in section 7.1, the key property
is that a non-degenerate kernel will have an inﬁnite number of eigenfunctions
forming an orthonormal set. Thus from generalized Fourier analysis a linear
i=1 ciφi(x) should be able to represent a suf-
ﬁciently well-behaved target function f∗
L. However, we have to estimate the
inﬁnite number of coeﬃcients {ci} from the noisy observations. This makes it
clear that we are playing a game involving inﬁnities which needs to be played
with care, and there are some results [Diaconis and Freedman, 1986, Freedman,
1999, Gr¨unwald and Langford, 2004] which show that in certain circumstances
Bayesian inference in inﬁnite-dimensional objects can be inconsistent.

However, there are some positive recent results on the consistency of GPR
and GPC. Choudhuri et al. [2005] show that for the binary classiﬁcation case
under certain assumptions GPC is consistent. The assumptions include smooth-
ness on the mean and covariance function of the GP, smoothness on E[y|x] and
an assumption that the domain is a bounded subset of RD. Their result holds
for the class of response functions which are c.d.f.s of a unimodal symmetric
density; this includes the probit and logistic functions.

For GPR, Choi and Schervish [2004] show that for a one-dimensional input
space of ﬁnite length under certain assumptions consistency holds. Here the
assumptions again include smoothness of the mean and covariance function of
the GP and smoothness of E[y|x]. An additional assumption is that the noise
has a normal or Laplacian distribution (with an unknown variance which is
inferred).

There are also some consistency results relating to the functional

Jλn[f] = λn
2

kfk2H +

1
n

(7.16)

L(cid:0)yi, f(xi)(cid:1),

nX

i=1

m =Pm

where λn → 0 as n → ∞. Note that to agree with our previous formulations
we would set λn = 1/n, but other decay rates on λn are often considered.

In the splines literature, Cox [1984] showed that for regression problems us-
ing the regularizer kfk2
k=0 kOkfk2 (using the deﬁnitions in eq. (6.10))
consistency can be obtained under certain technical conditions. Cox and O’Sulli-
van [1990] considered a wide range of problems (including regression problems
with squared loss and classiﬁcation using logistic loss) where the solution is
obtained by minimizing the regularized risk using a spline smoothness term.
L ∈ H (where H is the RKHS corresponding to the spline
They showed that if f∗

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.2 Asymptotic Analysis

157

regularizer) then as n → ∞ and λn → 0 at an appropriate rate, one gets
convergence of fD to f∗
L.

More recently, Zhang [2004, Theorem 4.4] has shown that for the classiﬁca-
tion problem with a number of diﬀerent loss functions (including logistic loss,
hinge loss and quadratic loss) and for general RKHSs with a nondegenerate
kernel, that if λn → 0, λnn → ∞ and µ(x, y) is suﬃciently regular then the
classiﬁcation error of fD will converge to the Bayes optimal error in probability
as n → ∞. Similar results have also been obtained by Steinwart [2005] with
various rates on the decay of λn depending on the smoothness of the kernel.
Bartlett et al. [2003] have characterized the loss functions that lead to universal
consistency.

Above we have focussed on regression and classiﬁcation problems. However,
similar analyses can also be given for other problems such as density estimation
and deconvolution; see Wahba [1990, chs. 8, 9] for references. Also we have
discussed consistency using a ﬁxed decay rate for λn. However, it is also possible
to analyze the asymptotics of methods where λn is set in a data-dependent way,
e.g. by cross-validation;2 see Wahba [1990, sec. 4.5] and references therein for
further details.

Consistency is evidently a desirable property of supervised learning proce-
dures. However, it is an asymptotic property that does not say very much about
how a given prediction procedure will perform on a particular problem with a
given dataset. For instance, note that we only required rather general prop-
erties of the kernel function (e.g. non-degeneracy) for some of the consistency
results. However, the choice of the kernel can make a huge diﬀerence to how a
procedure performs in practice. Some analyses related to this issue are given in
section 7.3.

7.2.2 Equivalence and Orthogonality

The presentation in this section is based mainly on Stein [1999, ch. 4]. For
two probability measures µ0 and µ1 deﬁned on a measurable space (Ω,F),3
µ0 is said to be absolutely continuous w.r.t. µ1 if for all A ∈ F, µ1(A) = 0
implies µ0(A) = 0. If µ0 is absolutely continuous w.r.t. µ1 and µ1 is absolutely
continuous w.r.t. µ0 the two measures are said to be equivalent, written µ0 ≡ µ1.
µ0 and µ1 are said to be orthogonal, written µ0 ⊥ µ1, if there exists an A ∈ F
such that µ0(A) = 1 and µ1(A) = 0. (Note that in this case we have µ0(Ac) = 0
and µ1(Ac) = 1, where Ac is the complement of A.) The dichotomy theorem for
Gaussian processes (due to Hajek [1958] and, independently, Feldman [1958])
states that two Gaussian processes are either equivalent or orthogonal.

Equivalence and orthogonality for Gaussian measures µ0, µ1 with corre-
sponding probability densities p0, p1, can be characterized in terms of the

2Cross validation is discussed in section 5.3.
3See section A.7 for background on measurable spaces.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

158

Theoretical Perspectives

Z

symmetrized Kullback-Leibler divergence KLsym between them, given by

KLsym(p0, p1) =

(7.17)
The measures are equivalent if KLsym < ∞ and orthogonal otherwise. For two
ﬁnite-dimensional Gaussian distributions N (µ0, K0) and N (µ1, K1) we have
[Kullback, 1959, sec. 9.1]

p1(f) df .

(p0(f) − p1(f)) log p0(f)

KLsym = 1
+ 1

2 tr(K0 − K1)(K−1
2 tr(K−1

1 + K−1

1 − K−1
0 )

0 )(µ0 − µ1)(µ0 − µ1)>.

(7.18)

This expression can be simpliﬁed considerably by simultaneously diagonalizing
K0 and K1. Two ﬁnite-dimensional Gaussian distributions are equivalent if the
null spaces of their covariance matrices coincide, and are orthogonal otherwise.
Things can get more interesting if we consider inﬁnite-dimensional distribu-
tions, i.e. Gaussian processes. Consider some closed subset R ∈ RD. Choose
some ﬁnite number n of x-points in R and let f = (f1, . . . , fn)> denote the
values corresponding to these inputs. We consider the KLsym-divergence as
above, but in the limit n → ∞. KLsym can now diverge if the rates of decay of
the eigenvalues of the two processes are not the same. For example, consider
zero-mean periodic processes with period 1 where the eigenvalue λi
j indicates
the amount of power in the sin/cos terms of frequency 2πj for process i = 0, 1.
Then using eq. (7.18) we have

KLsym =

(λ0

0 − λ1
0)2
0λ1
λ0
0

+ 2

(λ0

j − λ1
j)2
λ0
j λ1
j

(7.19)

∞X

j=1

(see also [Stein, 1999, p. 119]). Some corresponding results for the equiva-
lence or orthogonality of non-periodic Gaussian processes are given in Stein
[1999, pp. 119-122]. Stein (p. 109) gives an example of two equivalent Gaussian
processes on R, those with covariance functions exp(−r) and 1/2 exp(−2r). (It
is easy to check that for large s these have the same power spectrum.)

We now turn to the consequences of equivalence for the model selection
problem. Suppose that we know that either GP 0 or GP 1 is the correct model.
Then if GP 0 ≡ GP 1 then it is not possible to determine which model is correct
with probability 1. However, under a Bayesian setting all this means is if we
have prior probabilities π0 and π1 = 1− π0 on these two hypotheses, then after
observing some data D the posterior probabilities p(GP i|D) (for i = 0, 1) will
not be 0 or 1, but could be heavily skewed to one model or the other.

The other important observation is to consider the predictions made by GP 0
or GP 1. Consider the case where GP 0 is the correct model and GP 1 ≡ GP 0.
Then Stein [1999, sec. 4.3] shows that the predictions of GP 1 are asymptotically
optimal, in the sense that the expected relative prediction error between GP 1
and GP 0 tends to 0 as n → ∞ under some technical conditions. Stein’s Corol-
lary 9 (p. 132) shows that this conclusion remains true under additive noise if
the un-noisy GPs are equivalent. One caveat about equivalence is although the
predictions of GP 1 are asymptotically optimal when GP 0 is the correct model
and GP 0 ≡ GP 1, one would see diﬀering predictions for ﬁnite n.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.3 Average-case Learning Curves

159

7.3 Average-case Learning Curves

∗

In section 7.2 we have discussed the asymptotic properties of Gaussian process
predictors and related methods.
In this section we will say more about the
speed of convergence under certain speciﬁc assumptions. Our goal will be to
obtain a learning curve describing the generalization error as a function of the
training set size n. This is an average-case analysis, averaging over the choice
of target functions (drawn from a GP) and over the x locations of the training
points.

In more detail, we ﬁrst consider a target function f drawn from a Gaussian
process. n locations are chosen to make observations at, giving rise to the train-
ing set D = (X, y). The yis are (possibly) noisy observations of the underlying
function f. Given a loss function L(·,·) which measures the diﬀerence between
the prediction for f and f itself, we obtain an estimator fD for f. Below we
will use the squared loss, so that the posterior mean ¯fD(x) is the estimator.
Then the generalization error (given f and D) is given by

EgD(f) =

L(f(x∗), ¯fD(x∗))p(x∗) dx∗.

(7.20)

generalization error

Z

Z

As this is an expected loss it is technically a risk, but the term generalization
error is commonly used.

EgD(f) depends on both the choice of f and on X. (Note that y depends on
the choice of f, and also on the noise, if present.) The ﬁrst level of averaging
we consider is over functions f drawn from a GP prior, to obtain

Eg(X) =

EgD(f)p(f) df.

(7.21)

It will turn out that for regression problems with Gaussian process priors and
predictors this average can be readily calculated. The second level of averaging
assumes that the x-locations of the training set are drawn i.i.d. from p(x) to
give

Z

Eg(n) =

Eg(X)p(x1) . . . p(xn) dx1 . . . dxn.

(7.22)

A plot of Eg(n) against n is known as a learning curve.

learning curve

Rather than averaging over X, an alternative is to minimize Eg(X) w.r.t. X.
This gives rise to the optimal experimental design problem. We will not say
more about this problem here, but it has been subject to a large amount of
investigation. An early paper on this subject is by Ylvisaker [1975]. These
questions have been addressed both in the statistical literature and in theoretical
numerical analysis; for the latter area the book by Ritter [2000] provides a useful
overview.

We now proceed to develop the average-case analysis further for the speciﬁc
case of GP predictors and GP priors for the regression case using squared loss.
Let f be drawn from a zero-mean GP with covariance function k0 and noise
level σ2
0. Similarly the predictor assumes a zero-mean process, but covariance

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

160

Theoretical Perspectives

1. At a particular test location x∗, averaging over

function k1 and noise level σ2
f we have
E[(f(x∗) − k1(x∗)>K−1

1,yy)2]

= E[f 2(x∗)] − 2k1(x∗)>K−1
= k0(x∗, x∗) − 2k1(x∗)>K−1

E[f(x∗)y] + k1(x∗)>K−1
1,yk0(x∗) + k1(x∗)>K−1

1,y

1,y

E[yy>]K−1
1,yk1(x∗)

1,y K0,yK−1

(7.23)
1,yk1(x∗)

where Ki,y = Ki,f + σ2
assumed noise.
the above expression reduces to k0(x∗, x∗)− k0(x∗)>K−1
variance of the GP.

i for i = 0, 1, i.e. the covariance matrix including the
If k1 = k0 so that the predictor is correctly speciﬁed then
0,yk0(x∗), the predictive

Z
Z

Averaging the error over p(x∗) we obtain

Eg(X) =

=

E[(f(x∗) − k1(x∗)>K−1
k0(x∗, x∗)p(x∗) dx∗ − 2 tr
K−1
1,y K0,yK−1

Z

1,y

(cid:16)

(cid:16)

+ tr

1,yy)2]p(x∗) dx∗

Z

k1(x∗)k1(x)>p(x∗) dx∗

.

K−1

1,y

k0(x∗)k1(x∗)>p(x∗) dx∗

(cid:17)

(7.24)

(cid:17)

For some choices of p(x∗) and covariance functions these integrals will be an-
alytically tractable, reducing the computation of Eg(X) to a n × n matrix
computation.

To obtain Eg(n) we need to perform a ﬁnal level of averaging over X. In
general this is diﬃcult even if Eg(X) can be computed exactly, but it is some-
times possible, e.g. for the noise-free OU process on the real line, see section
7.6.

k1 we use the deﬁnition k(x, x0) =P

The form of Eg(X) can be simpliﬁed considerably if we express the covari-
ance functions in terms of their eigenfunction expansions. In the case that k0 =
λiφi(x0). Let Λ be a diagonal matrix of the eigenvalues and Φ be the N × n
design matrix, as deﬁned in section 2.1.2. Then from eq. (7.24) we obtain

i λiφi(x)φi(x0) andR k(x, x0)φi(x)p(x) dx =

Eg(X) = tr(Λ) − tr((σ2
= tr(Λ−1 + σ−2

nI + Φ>ΛΦ)−1Φ>Λ2Φ)
n ΦΦ>)−1,

(7.25)

where the second line follows through the use of the matrix inversion lemma
eq. (A.9) (or directly if we use eq. (2.11)), as shown in Sollich [1999] or Opper
and Vivarelli [1999]. Using the fact that EX[ΦΦ>] = nI, a na¨ıve approximation
would replace ΦΦ> inside the trace with its expectation; in fact Opper and
Vivarelli [1999] showed that this gives a lower bound, so that

Eg(n) ≥ tr(Λ−1 + nσ−2

n I)−1 = σ2

.

(7.26)

NX

λi

n + nλi
σ2

i=1

Examining the asymptotics of eq. (7.26), we see that for each eigenvalue where
λi (cid:29) σ2
n/n onto the bound on the generalization error. As we saw

n/n we add σ2

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.4 PAC-Bayesian Analysis

161

P∞

in section 7.1, more eigenfunctions “come into play” as n increases, so the rate
of decay of Eg(n) is slower than 1/n. Sollich [1999] derives a number of more
accurate approximations to the learning curve than eq. (7.26).

For the noiseless case with k1 = k0, there is a simple lower bound Eg(n) ≥
i=n+1 λi due to Micchelli and Wahba [1981]. This bound is obtained by
demonstrating that the optimal n pieces of information are the projections of the
random function f onto the ﬁrst n eigenfunctions. As observations which simply
consist of function evaluations will not in general provide such information this
is a lower bound. Plaskota [1996] generalized this result to give a bound on the
learning curve if the observations are noisy.

Some asymptotic results for the learning curves are known. For example, in
Ritter [2000, sec. V.2] covariance functions obeying Sacks-Ylvisaker conditions4
of order r in 1-d are considered. He shows that for an optimal sampling of the
input space the generalization error goes as O(n−(2r+1)/(2r+2)) for the noisy
problem. Similar rates can also be found in Sollich [2002] for random designs.
For the noise-free case Ritter [2000, p. 103] gives the rate as O(n−(2r+1)).

One can examine the learning curve not only asymptotically but also for
small n, where typically the curve has a roughly linear decrease with n. Williams
and Vivarelli [2000] explained this behaviour by observing that the introduction
of a datapoint x1 reduces the variance locally around x1 (assuming a stationary
covariance function). The addition of another datapoint at x2 will also create
a “hole” there, and so on. With only a small number of datapoints it is likely
that these holes will be far apart so their contributions will add, thus explaining
the initial linear trend.

Sollich [2002] has also investigated the mismatched case where k0 6= k1.
This can give rise to a rich variety of behaviours in the learning curves, includ-
ing plateaux. Stein [1999, chs. 3, 4] has also carried out some analysis of the
mismatched case.

Although we have focused on GP regression with squared loss, we note that
Malzahn and Opper [2002] have developed more general techniques that can be
used to analyze learning curves for other situations such as GP classiﬁcation.

7.4 PAC-Bayesian Analysis

∗

In section 7.3 we gave an average-case analysis of generalization, taking the
average with respect to a GP prior over functions. In this section we present
a diﬀerent kind of analysis within the probably approximately correct (PAC)
framework due to Valiant [1984]. Seeger [2002; 2003] has presented a PAC-
Bayesian analysis of generalization in Gaussian process classiﬁers and we get
to this in a number of stages; we ﬁrst present an introduction to the PAC
framework (section 7.4.1), then describe the PAC-Bayesian approach (section

4Roughly speaking, a stochastic process which possesses r MS derivatives but not r + 1
is said to satisfy Sacks-Ylvisaker conditions of order r; in 1-d this gives rise to a spectrum
λi ∝ i−(2r+2) asymptotically. The OU process obeys Sacks-Ylvisaker conditions of order 0.

PAC

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

162

Theoretical Perspectives

7.4.2) and then ﬁnally the application to GP classiﬁcation (section 7.4.3). Our
presentation is based mainly on Seeger [2003].

7.4.1 The PAC Framework
Consider a ﬁxed measure µ(x, y). Given a loss function L there exists a function
η(x) which minimizes the expected risk. By running a learning algorithm on
a data set D of size n drawn i.i.d. from µ(x, y) we obtain an estimate fD of η
P
which attains an expected risk RL(fD). We are not able to evaluate RL(fD) as
P
we do not know µ. However, we do have access to the empirical distribution of
i δ(x−xi)δ(y−yi) and can compute the empirical
the training set ˆµ(x, y) = 1
n
i L(yi, fD(xi)). Because the training set had been used to
risk ˆRL(fD) = 1
compute fD we would expect ˆRL(fD) to underestimate RL(fD),5 and the aim
of the PAC analysis is to provide a bound on RL(fD) based on ˆRL(fD).

n

A PAC bound has the following format

pD{RL(fD) ≤ ˆRL(fD) + gap(fD,D, δ)} ≥ 1 − δ,

(7.27)

where pD denotes the probability distribution of datasets drawn i.i.d. from
µ(x, y), and δ ∈ (0, 1) is called the conﬁdence parameter. The bound states
that, averaged over draws of the dataset D from µ(x, y), RL(fD) does not
exceed the sum of ˆRL(fD) and the gap term with probability of at least 1 − δ.
The δ accounts for the “probably” in PAC, and the “approximately” derives
from the fact that the gap term is positive for all n. It is important to note that
PAC analyses are distribution-free, i.e. eq. (7.27) must hold for any measure µ.
There are two kinds of PAC bounds, depending on whether gap(fD,D, δ)
actually depends on the particular sample D (rather than on simple statistics
like n). Bounds that do depend on D are called data dependent, and those that
do not are called data independent. The PAC-Bayesian bounds given below are
data dependent.

has mean m. An estimate of m is given by the sample mean ¯x = P

It is important to understand the interpretation of a PAC bound and to
clarify this we ﬁrst consider a simpler case of statistical inference. We are
given a dataset D = {x1, . . . , xn} drawn i.i.d. from a distribution µ(x) that
i xi/n.
Under certain assumptions we can obtain (or put bounds on) the sampling
distribution p(¯x|m) which relates to the choice of dataset D. However, if we
wish to perform probabilistic inference for m we need to combine p(¯x|m) with
a prior distribution p(m) and use Bayes’ theorem to obtain the posterior.6
The situation is similar (although somewhat more complex) for PAC bounds as
these concern the sampling distribution of the expected and empirical risks of
fD w.r.t. D.

5It is also possible to consider PAC analyses of other empirical quantities such as the

cross-validation error (see section 5.3) which do not have this bias.

6In introductory treatments of frequentist statistics the logical hiatus of going from the

sampling distribution to inference on the parameter of interest is often not well explained.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.4 PAC-Bayesian Analysis

163

We might wish to make a conditional statement like

pD{RL(fD) ≤ r + gap(fD,D, δ)| ˆRL(fD) = r} ≥ 1 − δ,

(7.28)
where r is a small value, but such a statement cannot be inferred directly from
the PAC bound. This is because the gap might be heavily anti-correlated with
ˆRL(fD) so that the gap is large when the empirical risk is small.

PAC bounds are sometimes used to carry out model selection—given a learn-
ing machine which depends on a (discrete or continuous) parameter vector θ,
one can seek to minimize the generalization bound as a function of θ. However,
this procedure may not be well-justiﬁed if the generalization bounds are loose.
Let the slack denote the diﬀerence between the value of the bound and the
generalization error. The danger of choosing θ to minimize the bound is that
if the slack depends on θ then the value of θ that minimizes the bound may be
very diﬀerent from the value of θ that minimizes the generalization error. See
Seeger [2003, sec. 2.2.4] for further discussion.

7.4.2 PAC-Bayesian Analysis

We now consider a Bayesian set up, with a prior distribution p(w) over the pa-
rameters w, and a “posterior” distribution q(w). (Strictly speaking the analysis
does not require q(w) to be the posterior distribution, just some other distribu-
tion, but in practice we will consider q to be an (approximate) posterior distri-
bution.) We also limit our discussion to binary classiﬁcation with labels {−1, 1},
although more general cases can be considered, see Seeger [2003, sec. 3.2.2].

R q(f∗|w, x∗)q(w)dw, and the predictive classiﬁer outputs sgn(q(f∗|x∗)− 1/2).

The predictive distribution for f∗ at a test point x∗ given q(w) is q(f∗|x∗) =

The Gibbs classiﬁer has also been studied in learning theory; given a test point
x∗ one draws a sample ˜w from q(w) and predicts the label using sgn(f(x∗; ˜w)).
The main reason for introducing the Gibbs classiﬁer here is that the PAC-
Bayesian theorems given below apply to Gibbs classiﬁers.

For a given parameter vector w giving rise to a classiﬁer c(x; w), the ex-

pected risk and empirical risk are given by

RL(w) =

L(y, c(x; w)) dµ(x, y),

ˆRL(w) =

L(yi, c(xi; w)). (7.29)

As the Gibbs classiﬁer draws samples from q(w) we consider the averaged risks

RL(q) =

RL(w)q(w) dw,

ˆRL(q) =

ˆRL(w)q(w) dw.

(7.30)

nX

i=1

1
n

Z

Z

Z

Theorem 7.1 (McAllester’s PAC-Bayesian theorem) For any probability mea-
sures p and q over w and for any bounded loss function L for which L(y, c(x)) ∈
[0, 1] for any classiﬁer c and input x we have

n

s

pD

RL(q) ≤ ˆRL(q) +

KL(q||p) + log 1
2n − 1

δ + log n + 2

∀ q

o ≥ 1 − δ.

(7.31)
(cid:3)

predictive classiﬁer
Gibbs classiﬁer

McAllester’s
PAC-Bayesian theorem

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

164

Theoretical Perspectives

The proof can be found in McAllester [2003]. The Kullback-Leibler (KL) diver-
gence KL(q||p) is deﬁned in section A.5. An example of a loss function which
obeys the conditions of the theorem is the 0/1 loss.

For the special case of 0/1 loss, Seeger [2002] gives the following tighter

Seeger’s PAC-
Bayesian theorem

n

bound.
Theorem 7.2 (Seeger’s PAC-Bayesian theorem) For any distribution over X ×
{−1, +1} and for any probability measures p and q over w the following bound
holds for i.i.d. samples drawn from the data distribution
(KL(q||p) + log n + 1

(7.32)
(cid:3)
Here KLBer(·||·) is the KL divergence between two Bernoulli distributions (de-
ﬁned in eq. (A.22)). Thus the theorem bounds (with high probability) the KL
divergence between ˆRL(q) and RL(q).

o ≥ 1 − δ.

pD

KLBer( ˆRL(q)||RL(q)) ≤ 1
n

) ∀ q

δ

The PAC-Bayesian theorems above refer to a Gibbs classiﬁer.

If we are
interested in the predictive classiﬁer sgn(q(f∗|x∗) − 1/2) then Seeger [2002]
shows that if q(f∗|x∗) is symmetric about its mean then the expected risk
of the predictive classiﬁer is less than twice the expected risk of the Gibbs
classiﬁer. However, this result is based on a simple bounding argument and in
practice one would expect that the predictive classiﬁer will usually give better
performance than the Gibbs classiﬁer. Recent work by Meir and Zhang [2003]
provides some PAC bounds directly for Bayesian algorithms (like the predictive
classiﬁer) whose predictions are made on the basis of a data-dependent posterior
distribution.

7.4.3 PAC-Bayesian Analysis of GP Classiﬁcation

To apply this bound to the Gaussian process case we need to compute the
KL divergence KL(q||p) between the posterior distribution q(w) and the prior
distribution p(w). Although this could be considered w.r.t. the weight vector
w in the eigenfunction expansion, in fact it turns out to be more convenient
to consider the latent function value f(x) at every possible point in the input
space X as the parameter. We divide this (possibly inﬁnite) vector into two
parts, (1) the values corresponding to the training points x1, . . . , xn, denoted
f, and (2) those at the remaining points in x-space (the test points) f∗.

The key observation is that all methods we have described for dealing with
GP classiﬁcation problems produce a posterior approximation q(f|y) which is
deﬁned at the training points. (This is an approximation for Laplace’s method
and for EP; MCMC methods sample from the exact posterior.) This posterior
over f is then extended to the test points by setting q(f , f∗|y) = q(f|y)p(f∗|f).
Of course for the prior distribution we have a similar decomposition p(f , f∗) =

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.5 Comparison with Other Supervised Learning Methods

165

p(f)p(f∗|f). Thus the KL divergence is given by

Z
Z

KL(q||p) =

=

q(f|y)p(f∗|f) log q(f|y)p(f∗|f)
q(f|y) log q(f|y)

p(f)p(f∗|f) df df∗

p(f) df ,

(7.33)

as shown e.g. in Seeger [2002]. Notice that this has reduced a rather scary
inﬁnite-dimensional integration to a more manageable n-dimensional integra-
tion; in the case that q(f|y) is Gaussian (as for the Laplace and EP approxima-
tions), this KL divergence can be computed using eq. (A.23). For the Laplace
approximation with p(f) = N (0, K) and q(f|y) = N (ˆf , A−1) this gives
KL(q||p) = 1

2 tr(cid:0)A−1(K−1 − A)(cid:1) + 1

ˆf>K−1ˆf . (7.34)

2

2 log |K| + 1

2 log |A| + 1

Seeger [2002] has evaluated the quality of the bound produced by the PAC-
Bayesian method for a Laplace GPC on the task of discriminating handwritten
2s and 3s from the MNIST handwritten digits database.7 He reserved a test set
of 1000 examples and used training sets of size 500, 1000, 2000, 5000 and 9000.
The classiﬁcations were replicated ten times using draws of the training sets
from a pool of 12089 examples. We quote example results for n = 5000 where
the training error was 0.0187 ± 0.0016, the test error was 0.0195 ± 0.0011 and
the PAC-Bayesian bound on the generalization error (evaluated for δ = 0.01)
was 0.076 ± 0.002.
(The ± ﬁgures denote a 95% conﬁdence interval.) The
classiﬁcation results are for the Gibbs classiﬁer; for the predictive classiﬁer the
test error rate was 0.0171± 0.0016. Thus the generalization error is around 2%,
while the PAC bound is 7.6%. Many PAC bounds struggle to predict error rates
below 100%(!), so this is an impressive and highly non-trivial result. Further
details and experiments can be found in Seeger [2002].

7.5 Comparison with Other Supervised Learn-

ing Methods

The focus of this book is on Gaussian process methods for supervised learning.
However, there are many other techniques available for supervised learning such
as linear regression, logistic regression, decision trees, neural networks, support
vector machines, kernel smoothers, k-nearest neighbour classiﬁers, etc., and we
need to consider the relative strengths and weaknesses of these approaches.

Supervised learning is an inductive process—given a ﬁnite training set we
wish to infer a function f that makes predictions for all possible input values.
The additional assumptions made by the learning algorithm are known as its
inductive bias (see e.g. Mitchell [1997, p. 43]). Sometimes these assumptions
are explicit, but for other algorithms (e.g. for decision tree induction) they can
be rather more implicit.

7See http://yann.lecun.com/exdb/mnist.

inductive bias

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

166

Theoretical Perspectives

However, for all their variety, supervised learning algorithms are based on
the idea that similar input patterns will usually give rise to similar outputs (or
output distributions), and it is the precise notion of similarity that diﬀerentiates
the algorithms. For example some algorithms may do feature selection and
decide that there are input dimensions that are irrelevant to the predictive task.
Some algorithms may construct new features out of those provided and measure
similarity in this derived space. As we have seen, many regression techniques
can be seen as linear smoothers (see section 2.6) and these techniques vary in
the deﬁnition of the weight function that is used.

One important distinction between diﬀerent learning algorithms is how they
relate to the question of universal consistency (see section 7.2.1). For example
a linear regression model will be inconsistent if the function that minimizes the
risk cannot be represented by a linear function of the inputs. In general a model
with a ﬁnite-dimensional parameter vector will not be universally consistent.
Examples of such models are linear regression and logistic regression with a
ﬁnite-dimensional feature vector, and neural networks with a ﬁxed number of
hidden units. In contrast to these parametric models we have non-parametric
models (such as k-nearest neighbour classiﬁers, kernel smoothers and Gaussian
processes and SVMs with nondegenerate kernels) which do not compress the
training data into a ﬁnite-dimensional parameter vector. An intermediate po-
sition is taken by semi-parametric models such as neural networks where the
number of hidden units k is allowed to increase as n increases. In this case uni-
versal consistency results can be obtained [Devroye et al., 1996, ch. 30] under
certain technical conditions and growth rates on k.

Although universal consistency is a “good thing”, it does not necessarily
mean that we should only consider procedures that have this property; for
example if on a speciﬁc problem we knew that a linear regression model was
consistent for that problem then it would be very natural to use it.

In the 1980’s there was a large surge in interest in artiﬁcial neural networks
(ANNs), which are feedforward networks consisting of an input layer, followed
by one or more layers of non-linear transformations of weighted combinations of
the activity from previous layers, and an output layer. One reason for this surge
of interest was the use of the backpropagation algorithm for training ANNs.
Initial excitement centered around that fact that training non-linear networks
was possible, but later the focus came onto the generalization performance of
ANNs, and how to deal with questions such as how many layers of hidden
units to use, how many units there should be in each layer, and what type of
non-linearities should be used, etc.

For a particular ANN the search for a good set of weights for a given training
set is complicated by the fact that there can be local optima in the optimization
problem; this can cause signiﬁcant diﬃculties in practice. In contrast for Gaus-
sian process regression and classiﬁcation the posterior for the latent variables
is convex.

neural networks

Bayesian neural
networks

One approach to the problems raised above was to put ANNs in a Bayesian
framework, as developed by MacKay [1992a] and Neal [1996]. This gives rise

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.5 Comparison with Other Supervised Learning Methods

167

to posterior distributions over weights for a given architecture, and the use of
the marginal likelihood (see section 5.2) for model comparison and selection.
In contrast to Gaussian process regression the marginal likelihood for a given
ANN model is not analytically tractable, and thus approximation techniques
such as the Laplace approximation [MacKay, 1992a] and Markov chain Monte
Carlo methods [Neal, 1996] have to be used. Neal’s observation [1996] that
certain ANNs with one hidden layer converge to a Gaussian process prior over
functions (see section 4.2.3) led us to consider GPs as alternatives to ANNs.

MacKay [2003, sec. 45.7] raises an interesting question whether in moving
from neural networks to Gaussian processes we have “thrown the baby out with
the bathwater?”. This question arises from his statements that “neural networks
were meant to be intelligent models that discovered features and patterns in
data”, while “Gaussian processes are simply smoothing devices”. Our answer
to this question is that GPs give us a computationally attractive method for
dealing with the smoothing problem for a given kernel, and that issues of feature
discovery etc. can be addressed through methods to select the kernel function
(see chapter 5 for more details on how to do this). Note that using a distance
function r2(x, x0) = (x − x0)>M(x − x0) with M having a low-rank form M =
ΛΛ> + Ψ as in eq. (4.22), features are described by the columns of Λ. However,
some of the non-convexity of the neural network optimization problem now
returns, as optimizing the marginal likelihood in terms of the parameters of M
may well have local optima.

As we have seen from chapters 2 and 3 linear regression and logistic regres-
sion with Gaussian priors on the parameters are a natural starting point for
the development of Gaussian process regression and Gaussian process classiﬁ-
cation. However, we need to enhance the ﬂexibility of these models, and the
use of non-degenerate kernels opens up the possibility of universal consistency.
Kernel smoothers and classiﬁers have been described in sections 2.6 and
7.2.1. At a high level there are similarities between GP prediction and these
methods as a kernel is placed on every training example and the prediction is
obtained through a weighted sum of the kernel functions, but the details of
the prediction and the underlying logic diﬀer. Note that the GP prediction
view gives us much more, e.g. error bars on the predictions and the use of the
marginal likelihood to set parameters in the kernel (see section 5.2). On the
other hand the computational problem that needs to be solved to carry out GP
prediction is more demanding than that for simple kernel-based methods.

Kernel smoothers and classiﬁers are non-parametric methods, and consis-
tency can often be obtained under conditions where the width h of the kernel
tends to zero while nhD → ∞. The equivalent kernel analysis of GP regression
(section 7.1) shows that there are quite close connections between the kernel
regression method and GPR, but note that the equivalent kernel automatically
reduces its width as n grows; in contrast the decay of h has to be imposed for
kernel regression. Also, for some kernel smoothing and classiﬁcation algorithms
the width of the kernel is increased in areas of low observation density; for ex-
ample this would occur in algorithms that consider the k nearest neighbours of
a test point. Again notice from the equivalent kernel analysis that the width

linear and logistic
regression

kernel smoothers and
classiﬁers

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

168

Theoretical Perspectives

regularization networks,
splines, SVMs and
RVMs

∗

of the equivalent kernel is larger in regions of low density, although the exact
dependence on the density will depend on the kernel used.

The similarities and diﬀerences between GP prediction and regularization

networks, splines, SVMs and RVMs have been discussed in chapter 6.

7.6 Appendix: Learning Curve for the Ornstein-

Uhlenbeck Process

We now consider the calculation of the learning curve for the OU covariance
function k(r) = exp(−α|r|) on the interval [0, 1], assuming that the training x’s
are drawn from the uniform distribution U(0, 1). Our treatment is based on
Williams and Vivarelli [2000].8 We ﬁrst calculate Eg(X) for a ﬁxed design, and
then integrate over possible designs to obtain Eg(n).

In the absence of noise the OU process is Markovian (as discussed in Ap-
pendix B and exercise 4.5.1). We consider the interval [0, 1] with points x1 <
x2 . . . < xn−1 < xn placed on this interval. Also let x0 = 0 and xn+1 = 1. Due
to the Markovian nature of the process the prediction at a test point x depends
only on the function values of the training points immediately to the left and
right of x. Thus in the i-th interval (counting from 0) the bounding points are
xi and xi+1. Let this interval have length δi.

Using eq. (7.24) we have

Z 1

0

Z xi+1

nX

i=0

xi

Eg(X) =

f (x) dx =
σ2

f (x) dx,
σ2

(7.35)

where σ2
we have in interval i (for i = 1, . . . , n − 1) that σ2
where K is the 2 × 2 Gram matrix

f (x) is the predictive variance at input x. Using the Markovian property
f (x) = k(0) − k(x)>K−1k(x)
(cid:19)
(cid:18) k(0)
(cid:18) k(0) −k(δi)

and k(x) is the corresponding vector of length 2. Thus

k(δi)
k(0)

(7.36)

k(δi)

K =

(cid:19)

,

(7.37)

1
∆i

−k(δi)

k(0)

K−1 =
where ∆i = k2(0) − k2(δi) and
f (x) = k(0)− 1
σ2
∆i
Z xi+1

Thus

[k(0)(k2(xi+1−x)+k2(x−xi))−2k(δi)k(x−xi)k(xi+1−x)].
(7.38)

f (x)dx = δik(0) − 2
σ2
∆i

xi

(I1(δi) − I2(δi))

(7.39)

8CW thanks Manfred Opper for pointing out that the upper bound developed in Williams

and Vivarelli [2000] is exact for the noise-free OU process.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

7.7 Exercises

where

I1(δ) = k(0)

Z δ

0

k2(z)dz,

I2(δ) = k(δ)

Z δ

0

k(z)k(δ − z)dz.

(7.40)

169

For k(r) = exp(−α|r|) these equations reduce to I1(δ) = (1 − e−2αδ)/(2α),

I2(δ) = δe−2αδ and ∆ = 1 − e−2αδ. Thus

f (x)dx = δi − 1
σ2

α

2δie−2αδi
1 − e−2αδi

.

+

(7.41)

This calculation is not correct in the ﬁrst and last intervals where only x1
f (x) =

and xn are relevant (respectively). For the 0th interval we have that σ2
k(0) − k2(x1 − x)/k(0) and thus

Z x1

f (x) = δ0k(0) − 1
σ2
k(0)
(1 − e−2αδ0),

= δ0 − 1
2α

0

k2(x1 − x)dx

Z xi+1

xi

Z x1

0

(7.42)

(7.43)

(7.44)

and a similar result holds forR 1

f (x).
σ2
Putting this all together we obtain

xn

Eg(X) = 1 − n
α

+

1
2α

(e−2αδ0 + e−2αδn) +

n−1X

i=1

2δie−2αδi
1 − e−2αδi

.

Choosing a regular grid so that δ0 = δn = 1/2n and δi = 1/n for i =
1, . . . , n − 1 it is straightforward to show (see exercise 7.7.4) that Eg scales as
O(n−1), in agreement with the general Sacks-Ylvisaker result [Ritter, 2000, p.
103] when it is recalled that the OU process obeys Sacks-Ylvisaker conditions
of order 0. A similar calculation is given in Plaskota [1996, sec. 3.8.2] for the
Wiener process on [0, 1] (note that this is also Markovian, but non-stationary).
We have now worked out the generalization error for a ﬁxed design X.
However to compute Eg(n) we need to average Eg(X) over draws of X from the
uniform distribution. The theory of order statistics David [1970, eq. 2.3.4] tells
us that p(δ) = n(1− δ)n−1 for all the δi, i = 0, . . . , n. Taking the expectation of
Eg(X) then turns into the problem of evaluating the one-dimensional integrals

R e−2αδp(δ)dδ and R δe−2αδ(1 − e−2αδ)−1p(δ)dδ. Exercise 7.7.5 asks you to

compute these integrals numerically.

7.7 Exercises

1. Consider a spline regularizer with Sf (s) = c−1|s|−2m. (As we noted in
section 6.3 this is not strictly a power spectrum as the spline is an im-
proper prior, but it can be used as a power spectrum in eq. (7.9) for the

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

170

Theoretical Perspectives

purposes of this analysis.) The equivalent kernel corresponding to this
spline is given by

Z exp(2πis · x)

h(x) =

(7.45)
n/ρ. By changing variables in the integration to |t| =

1 + γ|s|2m ds,

where γ = cσ2
γ1/2m|s| show that the width of h(x) scales as n−1/2m.

2. Equation 7.45 gives the form of the equivalent kernel for a spline regular-
izer. Show that h(0) is only ﬁnite if 2m > D. (Hint: transform the inte-
gration to polar coordinates.) This observation was made by P. Whittle
in the discussion of Silverman [1985], and shows the need for the condition
2m > D for spline smoothing.

3. Computer exercise: Space n + 1 points out evenly along the interval
(−1/2, 1/2). (Take n to be even so that one of the sample points falls at 0.)
Calculate the weight function (see section 2.6) corresponding to Gaussian
process regression with a particular covariance function and noise level,
and plot this for the point x = 0. Now compute the equivalent kernel cor-
responding to the covariance function (see, e.g. the examples in section
7.1.1), plot this on the same axes and compare results. Hint 1: Recall
that the equivalent kernel is deﬁned in terms of integration (see eq. (7.7))
so that there will be a scaling factor of 1/(n + 1). Hint 2: If you wish to
use large n (say > 1000), use the ngrid method described in section 2.6.

4. Consider Eg(X) as given in eq. (7.44) and choose a regular grid design X
so that δ0 = δn = 1/2n and δi = 1/n for i = 1, . . . , n−1. Show that Eg(X)
scales as O(n−1) asymptotically. Hint: when expanding 1 − exp(−2αδi),
be sure to extend the expansion to suﬃcient order.

5. Compute numerically the expectation of Eg(X) eq. (7.44) over random
designs for the OU process example discussed in section 7.6. Make use
of the fact [David, 1970, eq. 2.3.4] that p(δ) = n(1 − δ)n−1 for all the δi,
i = 0, . . . , n. Investigate the scaling behaviour of Eg(n) w.r.t. n.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 8

Approximation Methods for
Large Datasets

As we have seen in the preceding chapters a signiﬁcant problem with Gaus-
sian process prediction is that it typically scales as O(n3). For large problems
(e.g. n > 10, 000) both storing the Gram matrix and solving the associated
linear systems are prohibitive on modern workstations (although this boundary
can be pushed further by using high-performance computers).

An extensive range of proposals have been suggested to deal with this prob-
lem. Below we divide these into ﬁve parts: in section 8.1 we consider reduced-
rank approximations to the Gram matrix; in section 8.2 a general strategy for
greedy approximations is described; in section 8.3 we discuss various methods
for approximating the GP regression problem for ﬁxed hyperparameters; in sec-
tion 8.4 we describe various methods for approximating the GP classiﬁcation
problem for ﬁxed hyperparameters; and in section 8.5 we describe methods to
approximate the marginal likelihood and its derivatives. Many (although not
all) of these methods use a subset of size m < n of the training examples.

8.1 Reduced-rank Approximations of the Gram

Matrix

In the GP regression problem we need to invert the matrix K + σ2
nI (or at least
to solve a linear system (K + σ2
nI)v = y for v). If the matrix K has rank q (so
that it can be represented in the form K = QQ> where Q is an n × q matrix)
then this matrix inversion can be speeded up using the matrix inversion lemma
eq. (A.9) as (QQ> + σ2
nIq + Q>Q)−1Q>. Notice that
the inversion of an n × n matrix has now been transformed to the inversion of
a q × q matrix.1

nIn)−1 = σ−2

n In − σ−2

n Q(σ2

1For numerical reasons this is not the best way to solve such a linear system but it does

illustrate the savings that can be obtained with reduced-rank representations.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

172

Approximation Methods for Large Datasets

In the case that the kernel is derived from an explicit feature expansion with
N features, then the Gram matrix will have rank min(n, N) so that exploitation
of this structure will be beneﬁcial if n > N. Even if the kernel is non-degenerate
it may happen that it has a fast-decaying eigenspectrum (see e.g. section 4.3.1)
so that a reduced-rank approximation will be accurate.

If K is not of rank < n, we can still consider reduced-rank approximations to
K. The optimal reduced-rank approximation of K w.r.t. the Frobenius norm
(see eq. (A.16)) is UqΛqU>
q , where Λq is the diagonal matrix of the leading
q eigenvalues of K and Uq is the matrix of the corresponding orthonormal
eigenvectors [Golub and Van Loan, 1989, Theorem 8.1.9]. Unfortunately, this
is of limited interest in practice as computing the eigendecomposition is an
O(n3) operation. However, it does suggest that if we can more cheaply obtain
an approximate eigendecomposition then this may give rise to a useful reduced-
rank approximation to K.

(cid:18) Kmm

We now consider selecting a subset I of the n datapoints; set I has size
m < n. The remaining n − m datapoints form the set R. (As a mnemonic, I is
for the included datapoints and R is for the remaining points.) We sometimes
call the included set the active set. Without loss of generality we assume that
the datapoints are ordered so that set I comes ﬁrst. Thus K can be partitioned
as

.

K =

K(n−m)m K(n−m)(n−m)

(8.1)
The top m × n block will also be referred to as Kmn and its transpose as Knm.
In section 4.3.2 we saw how to approximate the eigenfunctions of a kernel
using the Nystr¨om method. We can now apply the same idea to approximating
the eigenvalues/vectors of K. We compute the eigenvectors and eigenvalues of
}m
Kmm and denote them {λ(m)
i=1. These are extended to all n
points using eq. (4.44) to give

i=1 and {u(m)
}m

i

i

(cid:19)

Km(n−m)

λ(m)
i

,

, n
m

r m

1

˜λ(n)

i

,

˜u(n)

i

i = 1, . . . , m

i = 1, . . . , m

(8.2)

(8.3)

Knmu(m)

,

i

n

λ(m)
i
has been chosen so that |˜u(n)

| ’ 1. In general we have
where the scaling of ˜u(n)
a choice of how many of the approximate eigenvalues/vectors to include in our
)>.

approximation of K; choosing the ﬁrst p we get ˜K = Pp

(˜u(n)

i

i

˜λ(n)
i ˜u(n)

i

i

i=1

Below we will set p = m to obtain

Nystr¨om approximation

˜K = KnmK−1

mmKmn

(8.4)

using equations 8.2 and 8.3, which we call the Nystr¨om approximation to K.
Computation of ˜K takes time O(m2n) as the eigendecomposition of Kmm is
O(m3) and the computation of each ˜u(n)
is O(mn). Fowlkes et al. [2001] have
applied the Nystr¨om method to approximate the top few eigenvectors in a
computer vision problem where the matrices in question are larger than 106×106
in size.

i

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.1 Reduced-rank Approximations of the Gram Matrix

173

√

The Nystr¨om approximation has been applied above to approximate the
elements of K. However, using the approximation for the ith eigenfunction
, where km(x) = (k(x, x1), . . . , k(x, xm))> (a
˜φi(x) = (
restatement of eq. (4.44) using the current notation) and λi ’ λ(m)
/m it is
easy to see that in general we obtain an approximation for the kernel k(x, x0) =

)km(x)>u(m)

m/λ(m)

i

i

i

PN
i=1 λiφi(x)φi(x0) as
˜k(x, x0) =

mX
mX

i=1

λ(m)
i
m

˜φi(x) ˜φi(x0)

=

λ(m)
i
m

m
(λ(m)
mmkm(x0).
= km(x)>K−1

)2

i=1

i

km(x)>u(m)

i

(u(m)

i

)>km(x0)

(8.5)

(8.6)

(8.7)

Clearly eq. (8.4) is obtained by evaluating eq. (8.7) for all pairs of datapoints
in the training set.

By multiplying out eq. (8.4) using Kmn = [KmmKm(n−m)] it is easy to
show that Kmm = ˜Kmm, Km(n−m) = ˜Km(n−m), K(n−m)m = ˜K(n−m)m, but
that ˜K(n−m)(n−m) = K(n−m)mK−1
K(n−m)(n−m) − ˜K(n−m)(n−m) is in fact the Schur complement of Kmm [Golub
and Van Loan, 1989, p. 103]. It is easy to see that K(n−m)(n−m)− ˜K(n−m)(n−m)
is positive semi-deﬁnite; if a vector f is partitioned as f> = (f>
n−m) and f
has a Gaussian distribution with zero mean and covariance K then fn−m|fm
has the Schur complement as its covariance matrix, see eq. (A.6).

mmKm(n−m). The diﬀerence

m, f>

The Nystr¨om approximation was derived in the above fashion by Williams
and Seeger [2001] for application to kernel machines. An alternative view which
gives rise to the same approximation is due to Smola and Sch¨olkopf [2000] (and
also Sch¨olkopf and Smola [2002, sec. 10.2]). Here the starting point is that we
wish to approximate the kernel centered on point xi as a linear combination of
kernels from the active set, so that

cijk(xj, x) , ˆk(xi, x)

(8.8)

k(xi, x) ’X

j∈I

for some coeﬃcients {cij} that are to be determined so as to optimize the
approximation. A reasonable criterion to minimize is
kk(xi, x) − ˆk(xi, x)k2H

nX

E(C) =

(8.9)

i=1

= tr K − 2 tr(CKmn) + tr(CKmmC>),

(8.10)
where the coeﬃcients are arranged into a n × m matrix C. Minimizing E(C)
w.r.t. C gives Copt = KnmK−1
mm; thus we obtain the approximation ˆK =
KnmK−1
mmKmn in agreement with eq. (8.4). Also, it can be shown that E(Copt) =
tr(K − ˆK).

Smola and Sch¨olkopf [2000] suggest a greedy algorithm to choose points to
include into the active set so as to minimize the error criterion. As it takes

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

174

Approximation Methods for Large Datasets

O(mn) operations to evaluate the change in E due to including one new dat-
apoint (see exercise 8.7.2) it is infeasible to consider all members of set R for
inclusion on each iteration; instead Smola and Sch¨olkopf [2000] suggest ﬁnd-
ing the best point to include from a randomly chosen subset of set R on each
iteration.

Recent work by Drineas and Mahoney [2005] analyzes a similar algorithm
to the Nystr¨om approximation, except that they use biased sampling with re-
placement (choosing column i of K with probability ∝ k2
ii) and a pseudoinverse
of the inner m × m matrix. For this algorithm they are able to provide prob-
abilistic bounds on the quality of the approximation. Earlier work by Frieze
et al. [1998] had developed an approximation to the singular value decomposi-
tion (SVD) of a rectangular matrix using a weighted random subsampling of its
rows and columns, and probabilistic error bounds. However, this is rather diﬀer-
ent from the Nystr¨om approximation; see Drineas and Mahoney [2005, sec. 5.2]
for details.

Fine and Scheinberg [2002] suggest an alternative low-rank approximation
to K using the incomplete Cholesky factorization (see Golub and Van Loan
[1989, sec. 10.3.2]). The idea here is that when computing the Cholesky de-
composition of K pivots below a certain threshold are skipped.2 If the number
of pivots greater than the threshold is k the incomplete Cholesky factorization
takes time O(nk2).

8.2 Greedy Approximation

Many of the methods described below use an active set of training points of size
m selected from the training set of size n > m. We assume that it is impossible
to search for the optimal subset of size m due to combinatorics. The points
in the active set could be selected randomly, but in general we might expect
better performance if the points are selected greedily w.r.t. some criterion. In
the statistics literature greedy approaches are also known as forward selection
strategies.

A general recipe for greedy approximation is given in Algorithm 8.1. The
algorithm starts with the active set I being empty, and the set R containing the
indices of all training examples. On each iteration one index is selected from R
and added to I. This is achieved by evaluating some criterion ∆ and selecting
the data point that optimizes this criterion. For some algorithms it can be too
expensive to evaluate ∆ on all points in R, so some working set J ⊂ R can be
chosen instead, usually at random from R.

Greedy selection methods have been used with the subset of regressors (SR),
subset of datapoints (SD) and the projected process (PP) methods described
below.

2As a technical detail, symmetric permutations of the rows and columns are required to

stabilize the computations.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.3 Approximations for GPR with Fixed Hyperparameters

175

input: m, desired size of active set
2: Initialization I = ∅, R = {1, . . . , n}

for j := 1 . . . m do

Create working set J ⊆ R
Compute ∆j for all j ∈ J
i = argmaxj∈J∆j
Update model to include data from example i
I ← I ∪ {i}, R ← R\{i}

4:

6:

8:

end for

10: return: I
Algorithm 8.1: General framework for greedy subset selection. ∆j is the criterion
function evaluated on data point j.

8.3 Approximations for GPR with Fixed Hy-

perparameters

We present six approximation schemes for GPR below, namely the subset of
regressors (SR), the Nystr¨om method, the subset of datapoints (SD), the pro-
jected process (PP) approximation, the Bayesian committee machine (BCM)
and the iterative solution of linear systems. Section 8.3.7 provides a summary
of these methods and a comparison of their performance on the SARCOS data
which was introduced in section 2.5.

8.3.1 Subset of Regressors

Pn
Silverman [1985, sec. 6.1] showed that the mean GP predictor can be ob-
tained from a ﬁnite-dimensional generalized linear regression model f(x∗) =
i=1 αik(x∗, xi) with a prior α ∼ N (0, K−1). To see this we use the mean
prediction for linear regression model in feature space given by eq. (2.11),
i.e. ¯f(x∗) = σ−2
n ΦΦ>. Setting φ(x∗) =
k(x∗), Φ = Φ> = K and Σ−1
¯f(x∗) = σ−2

n φ(x∗)>A−1Φy with A = Σ−1

p + σ−2

p = K we obtain
n k>(x∗)[σ−2
= k>(x∗)(K + σ2

n K(K + σ2
nI)−1y,

nI)]−1Ky

(8.11)
(8.12)

in agreement with eq. (2.25). Note, however, that the predictive (co)variance
of this model is diﬀerent from full GPR.

A simple approximation to this model is to consider only a subset of regres-

sors, so that

mX

i=1

fSR(x∗) =

αik(x∗, xi),

with

αm ∼ N (0, K−1

mm).

(8.13)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

176

Approximation Methods for Large Datasets

Again using eq. (2.11) we obtain

¯fSR(x∗) = km(x∗)>(KmnKnm + σ2

nKmm)−1Kmny,

V[fSR(x∗)] = σ2

nkm(x∗)>(KmnKnm + σ2

nKmm)−1km(x∗).

(8.14)
(8.15)

SR marginal likelihood

nKmm)−1Kmny.

Thus the posterior mean for αm is given by
¯αm = (KmnKnm + σ2

(8.16)
This method has been proposed, for example, in Wahba [1990, chapter 7], and
in Poggio and Girosi [1990, eq. 25] via the regularization framework. The name
“subset of regressors” (SR) was suggested to us by G. Wahba. The computa-
tions for equations 8.14 and 8.15 take time O(m2n) to carry out the necessary
matrix computations. After this the prediction of the mean for a new test point
takes time O(m), and the predictive variance takes O(m2).

Under the subset of regressors model we have f ∼ N (0, ˜K) where ˜K is

y>( ˜K + σ2

log | ˜K + σ2

nIn| − 1
2

deﬁned as in eq. (8.4). Thus the log marginal likelihood under this model is
log pSR(y|X) = −1
2
Notice that the covariance function deﬁned by the SR model has the form
˜k(x, x0) = k(x)>K−1
mmk(x0), which is exactly the same as that from the Nystr¨om
approximation for the covariance function eq. (8.7). In fact if the covariance
function k(x, x0) in the predictive mean and variance equations 2.25 and 2.26
is replaced systematically with ˜k(x, x0) we obtain equations 8.14 and 8.15, as
shown in Appendix 8.6.

nIn)−1y − n
2

log(2π). (8.17)

If the kernel function decays to zero for |x| → ∞ for ﬁxed x0, then ˜k(x, x)
will be near zero when x is distant from points in the set I. This will be the case
even when the kernel is stationary so that k(x, x) is independent of x. Thus
we might expect that using the approximate kernel will give poor predictions,
especially underestimates of the predictive variance, when x is far from points
in the set I.

ySR∗(x∗) = Pm

An interesting idea suggested by Rasmussen and Qui˜nonero-Candela [2005]
to mitigate this problem is to deﬁne the SR model with m + 1 basis func-
tions, where the extra basis function is centered on the test point x∗, so that
i=1 αik(x∗, xi) + α∗k(x∗, x∗). This model can then be used to
make predictions, and it can be implemented eﬃciently using the partitioned
matrix inverse equations A.11 and A.12. The eﬀect of the extra basis function
centered on x∗ is to maintain predictive variance at the test point.

So far we have not said how the subset I should be chosen. One sim-
ple method is to choose it randomly from X, another is to run clustering on
{xi}n
i=1 to obtain centres. Alternatively, a number of greedy forward selection
algorithms for I have been proposed. Luo and Wahba [1997] choose the next
kernel so as to minimize the residual sum of squares (RSS) |y− Knmαm|2 after
optimizing αm. Smola and Bartlett [2001] take a similar approach, but choose
as their criterion the quadratic form

|y − Knm ¯αm|2 + ¯α>

mKmm ¯αm = y>( ˜K + σ2

nIn)−1y,

(8.18)

1
σ2
n

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.3 Approximations for GPR with Fixed Hyperparameters

177

comparison with RVM

where the right hand side follows using eq. (8.16) and the matrix inversion
lemma. Alternatively, Qui˜nonero-Candela [2004] suggests using the approxi-
mate log marginal likelihood log pSR(y|X) (see eq. (8.17)) as the selection cri-
terion. In fact the quadratic term from eq. (8.18) is one of the terms comprising
log pSR(y|X).

For all these suggestions the complexity of evaluating the criterion on a new
example is O(mn), by making use of partitioned matrix equations. Thus it is
likely to be too expensive to consider all points in R on each iteration, and we
are likely to want to consider a smaller working set, as described in Algorithm
8.1.

Note that the SR model is obtained by selecting some subset of the data-
points of size m in a random or greedy manner. The relevance vector machine
(RVM) described in section 6.6 has a similar ﬂavour in that it automatically
selects (in a greedy fashion) which datapoints to use in its expansion. However,
note one important diﬀerence which is that the RVM uses a diagonal prior on
the α’s, while for the SR method we have αm ∼ N (0, K−1

mm).

8.3.2 The Nystr¨om Method

Williams and Seeger [2001] suggested approximating the GPR equations by
replacing the matrix K by ˜K in the mean and variance prediction equations
2.25 and 2.26, and called this the Nystr¨om method for approximate GPR. Notice
that in this proposal the covariance function k is not systematically replaced
by ˜k, it is only occurrences of the matrix K that are replaced. As for the
SR model the time complexity is O(m2n) to carry out the necessary matrix
computations, and then O(n) for the predictive mean of a test point and O(mn)
for the predictive variance.

Experimental evidence in Williams et al. [2002] suggests that for large m
the SR and Nystr¨om methods have similar performance, but for small m the
Nystr¨om method can be quite poor. Also the fact that k is not systematically
replaced by ˜k means that embarrassments can occur like the approximated
predictive variance being negative. For these reasons we do not recommend the
Nystr¨om method over the SR method. However, the Nystr¨om method can be
eﬀective when λm+1, the (m + 1)th eigenvalue of K, is much smaller than σ2
n.

8.3.3 Subset of Datapoints

The subset of regressors method described above approximated the form of the
predictive distribution, and particularly the predictive mean. Another simple
approximation to the full-sample GP predictor is to keep the GP predictor,
but only on a smaller subset of size m of the data. Although this is clearly
wasteful of data, it can make sense if the predictions obtained with m points
are suﬃciently accurate for our needs.

Clearly it can make sense to select which points are taken into the active set
I, and typically this is achieved by greedy algorithms. However, one has to be

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

178

Approximation Methods for Large Datasets

wary of the amount of computation that is needed, especially if one considers
each member of R at each iteration.

Lawrence et al. [2003] suggest choosing as the next point (or site) for in-
clusion into the active set the one that maximizes the diﬀerential entropy score
∆j , H[p(fj)] − H[pnew(fj)], where H[p(fj)] is the
entropy of the Gaus-
sian at site j ∈ R (which is a function of the variance at site j as the poste-
rior is Gaussian, see eq. (A.20)), and H[pnew(fj)] is the entropy at this site
once the observation at site j has been included. Let the posterior variance
of fj before inclusion be vj. As p(fj|yI , yj) ∝ p(fj|yI)N (yj|fj, σ2) we have
j + σ−2. Using the fact that the entropy of a Gaussian with
(vnew
variance v is log(2πev)/2 we obtain

)−1 = v−1

j

IVM

∆j = 1

2 log(1 + vj/σ2).

(8.19)

∆j is a monotonic function of vj so that it is maximized by choosing the site with
the largest variance. Lawrence et al. [2003] call their method the informative
vector machine (IVM)

If coded na¨ıvely the complexity of computing the variance at all sites in R
on a single iteration is O(m3 + (n− m)m2) as we need to evaluate eq. (2.26) at
nI can be done once in O(m3)
each site (and the matrix inversion of Kmm + σ2
then stored). However, as we are incrementally growing the matrices Kmm
and Km(n−m) in fact the cost is O(mn) per inclusion, leading to an overall
complexity of O(m2n) when using a subset of size m. For example, once a site
has been chosen for inclusion the matrix Kmm + σ2
nI is grown by including an
extra row and column. The inverse of this expanded matrix can be found using
eq. (A.12) although it would be better practice numerically to use a Cholesky
decomposition approach as described in Lawrence et al. [2003]. The scheme
evaluates ∆j over all j ∈ R at each step to choose the inclusion site. This
makes sense when m is small, but as it gets larger it can make sense to select
candidate inclusion sites from a subset of R. Lawrence et al. [2003] call this the
randomized greedy selection method and give further ideas on how to choose
the subset.

The diﬀerential entropy score ∆j is not the only criterion that can be used for
site selection. For example the information gain criterion KL(pnew(fj)||p(fj))
can also be used (see Seeger et al., 2003). The use of greedy selection heuristics
here is similar to the problem of active learning, see e.g. MacKay [1992c].

8.3.4 Projected Process Approximation

The SR method has the unattractive feature that it is based on a degenerate
GP, the ﬁnite-dimensional model given in eq. (8.13). The SD method is a non-
degenerate process model but it only makes use of m datapoints. The projected
process (PP) approximation is also a non-degenerate process model but it can
make use of all n datapoints. We call it a projected process approximation
as it represents only m < n latent function values, but computes a likelihood
involving all n datapoints by projecting up the m latent points to n dimensions.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.3 Approximations for GPR with Fixed Hyperparameters

179

One problem with the basic GPR algorithm is the fact that the likelihood
term requires us to have f-values for the n training points. However, say we only
represent m of these values explicitly, and denote these as fm. Then the remain-
ing f-values in R denoted fn−m have a conditional distribution p(fn−m|fm), the
mean of which is given by E[fn−m|fm] = K(n−m)mK−1
mmfm.3 Say we replace the
true likelihood term for the points in R by N (yn−m|E[fn−m|fm], σ2
nI). Including
also the likelihood contribution of the points in set I we have

q(y|fm) = N (y|KnmK−1

nI),
(8.20)
mmfm, σ2
which can also be written as q(y|fm) = N (y|E[f|fm], σ2
nI). The key feature here
is that we have absorbed the information in all n points of D into the m points
in I.

The form of q(y|fm) in eq. (8.20) might seem rather arbitrary, but in fact
it can be shown that if we consider minimizing KL(q(f|y)||p(f|y)), the KL-
divergence between the approximating distribution q(f|y) and the true posterior
p(f|y) over all q distributions of the form q(f|y) ∝ p(f)R(fm) where R is positive
and depends on fm only, this is the form we obtain. See Seeger [2003, Lemma 4.1
and sec. C.2.1] for detailed derivations, and also Csat´o [2002, sec. 3.3].

To make predictions we ﬁrst have to compute the posterior distribution
mmKmn so that E[f|fm] = P >fm. Then

q(fm|y). Deﬁne the shorthand P = K−1
we have

q(y|fm) ∝ exp(cid:0) − 1

(y − P >fm)>(y − P >fm)(cid:1).

2σ2
n

q(fm|y) ∝ exp(cid:0) − 1

Combining this with the prior p(fm) ∝ exp(−f>

mK−1
P P >)fm +
which can be recognized as a Gaussian N (µ, A) with
A−1 = σ−2
µ = σ−2

n (σ2
n AP y = Kmm(σ2

mm + P P >) = σ−2

f>
m(K−1

nK−1

nKmm + KmnKnm)−1Kmny.

mm +

1
σ2
n

2

mmfm/2) we obtain

y>P >fm

1
σ2
n

(cid:1),

n K−1

mm(σ2

nKmm + KmnKnm)K−1
mm,

(8.21)

(8.22)

(8.23)
(8.24)

Thus the predictive mean is given by
Eq[f(x∗)] = km(x∗)>K−1
= km(x∗)>(σ2

(8.25)
(8.26)
which turns out to be just the same as the predictive mean under the SR
model, as given in eq. (8.14). However, the predictive variance is diﬀerent. The
argument is the same as in eq. (3.23) and yields

mmµ
nKmm + KmnKnm)−1Kmny,

Vq[f(x∗)] = k(x∗, x∗) − km(x∗)>K−1

+ km(x∗)>K−1

mmkm(x∗)
mmcov(fm|y)K−1

mmkm(x∗)

= k(x∗, x∗) − km(x∗)>K−1

+ σ2

nkm(x∗)>(σ2

mmkm(x∗)
nKmm + KmnKnm)−1km(x∗).

(8.27)

3There is no a priori reason why the m points chosen have to be a subset of the n points
in D—they could be disjoint from the training set. However, for our derivations below we
will consider them to be a subset.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

180

Approximation Methods for Large Datasets

Notice that predictive variance is the sum of the predictive variance under the
SR model (last term in eq. (8.27)) plus k(x∗, x∗)− km(x∗)>K−1
mmkm(x∗) which
is the predictive variance at x∗ given fm. Thus eq. (8.27) is never smaller than
the SR predictive variance and will become close to k(x∗, x∗) when x∗ is far
away from the points in set I.

As for the SR model it takes time O(m2n) to carry out the necessary matrix
computations. After this the prediction of the mean for a new test point takes
time O(m), and the predictive variance takes O(m2).

We have q(y|fm) = N (y|P >fm, σ2

nI) and p(fm) = N (0, Kmm). By integrat-
ing out fm we ﬁnd that y ∼ N (0, ˜K + σ2
nIn). Thus the marginal likelihood
for the projected process approximation is the same as that for the SR model
eq. (8.17).

Again the question of how to choose which points go into the set I arises.
Csat´o and Opper [2002] present a method in which the training examples are
presented sequentially (in an “on-line” fashion). Given the current active set I
one can compute the novelty of a new input point; if this is large, then this point
is added to I, otherwise the point is added to R. To be precise, the novelty of
an input x is computed as k(x, x)− km(x)>K−1
mmk(x), which can be recognized
as the predictive variance at x given non-noisy observations at the points in I.
If the active set gets larger than some preset maximum size, then points can
be deleted from I, as speciﬁed in section 3.3 of Csat´o and Opper [2002]. Later
work by Csat´o et al. [2002] replaced the dependence of the algorithm described
above on the input sequence by an expectation-propagation type algorithm (see
section 3.6).

As an alternative method for selecting the active set, Seeger et al. [2003]
suggest using a greedy subset selection method as per Algorithm 8.1. Com-
putation of the information gain criterion after incorporating a new site takes
O(mn) and is thus too expensive to use as a selection criterion. However, an ap-
proximation to the information gain can be computed cheaply (see Seeger et al.
[2003, eq. 3] and Seeger [2003, sec. C.4.2] for further details) and this allows the
greedy subset algorithm to be run on all points in R on each iteration.

8.3.5 Bayesian Committee Machine

Tresp [2000] introduced the Bayesian committee machine (BCM) as a way of
speeding up Gaussian process regression. Let f∗ be the vector of function val-
ues at the test locations. Under GPR we obtain a predictive Gaussian distri-
bution for p(f∗|D). For the BCM we split the dataset into p parts D1, . . . ,Dp
Qp
where Di = (Xi, yi) and make the approximation that p(y1, . . . , yp|f∗, X) ’
Qp
i=1 p(yi|f∗, Xi). Under this approximation we have
i=1 p(f∗|Di)
p(yi|f∗, Xi) = c
pp−1(f∗)

q(f∗|D1, . . . ,Dp) ∝ p(f∗)

pY

i=1

,

(8.28)

where c is a normalization constant. Using the fact that the terms in the
numerator and denomination are all Gaussian distributions over f∗ it is easy

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.3 Approximations for GPR with Fixed Hyperparameters

181

to show (see exercise 8.7.1) that the predictive mean and covariance for f∗ are
given by

Eq[f∗|D] = [covq(f∗|D)]

[cov(f∗|Di)]−1E[f∗|Di],

pX

pX

(8.29)

(8.30)

[covq(f∗|D)]−1 = −(p − 1)K−1∗∗ +

i=1

[cov(f∗|Di)]−1,

i=1

where K∗∗ is the covariance matrix evaluated at the test points. Here E[f∗|Di]
and cov(f∗|Di) are the mean and covariance of the predictions for f∗ given Di,
as given in eqs. (2.23) and (2.24). Note that eq. (8.29) has an interesting form
in that the predictions from each part of the dataset are weighted by the inverse
predictive covariance.

We are free to choose how to partition the dataset D. This has two aspects,
the number of partitions and the assignment of data points to the partitions.
If we wish each partition to have size m, then p = n/m. Tresp [2000] used
a random assignment of data points to partitions but Schwaighofer and Tresp
[2003] recommend that clustering the data (e.g. with p-means clustering) can
lead to improved performance. However, note that compared to the greedy
schemes used above clustering does not make use of the target y values, only
the inputs x.

Although it is possible to make predictions for any number of test points
n∗, this slows the method down as it involves the inversion of n∗ × n∗ matrices.
Schwaighofer and Tresp [2003] recommend making test predictions on blocks of
size m so that all matrices are of the same size. In this case the computational
complexity of BCM is O(pm3) = O(m2n) for predicting m test points, or
O(mn) per test point.

The BCM approach is transductive [Vapnik, 1995] rather than inductive, in
the sense that the method computes a test-set dependent model making use
of the test set input locations. Note also that if we wish to make a prediction
at just one test point, it would be necessary to “hallucinate” some extra test
points as eq. (8.28) generally becomes a better approximation as the number of
test points increases.

8.3.6

Iterative Solution of Linear Systems

One straightforward method to speed up GP regression is to note that the lin-
ear system (K + σ2
nI)v = y can be solved by an iterative method, for example
conjugate gradients (CG). (See Golub and Van Loan [1989, sec. 10.2] for fur-
ther details on the CG method.) Conjugate gradients gives the exact solution
(ignoring round-oﬀ errors) if run for n iterations, but it will give an approxi-
mate solution if terminated earlier, say after k iterations, with time complexity
O(kn2). This method has been suggested by Wahba et al. [1995] (in the context
of numerical weather prediction) and by Gibbs and MacKay [1997] (in the con-
text of general GP regression). CG methods have also been used in the context

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

182

Approximation Methods for Large Datasets

Method m
SD

SR

PP

BCM

SMSE
0.0813 ± 0.0198
0.0532 ± 0.0046
0.0398 ± 0.0036
0.0290 ± 0.0013
0.0200 ± 0.0008
0.0351 ± 0.0036
0.0259 ± 0.0014
0.0193 ± 0.0008
0.0150 ± 0.0005
0.0110 ± 0.0004
0.0351 ± 0.0036
0.0259 ± 0.0014
0.0193 ± 0.0008
0.0150 ± 0.0005
0.0110 ± 0.0004
0.0314 ± 0.0046
0.0281 ± 0.0055
0.0180 ± 0.0010
0.0136 ± 0.0007

MSLL
-1.4291 ± 0.0558
-1.5834 ± 0.0319
-1.7149 ± 0.0293
-1.8611 ± 0.0204
-2.0241 ± 0.0151
-1.6088 ± 0.0984
-1.8185 ± 0.0357
-1.9728 ± 0.0207
-2.1126 ± 0.0185
-2.2474 ± 0.0204
-1.6940 ± 0.0528
-1.8423 ± 0.0286
-1.9823 ± 0.0233
-2.1125 ± 0.0202
-2.2399 ± 0.0160
-1.7066 ± 0.0550
-1.7807 ± 0.0820
-2.0081 ± 0.0321
-2.1364 ± 0.0266

mean runtime (s)
0.8
2.1
6.5
25.0
100.7
11.0
27.0
79.5
284.8
927.6
17.3
41.4
95.1
354.2
964.5
506.4
660.5
1043.2
1920.7

256
512
1024
2048
4096
256
512
1024
2048
4096
256
512
1024
2048
4096
256
512
1024
2048

Table 8.1: Test results on the inverse dynamics problem for a number of diﬀerent
methods. Ten repetitions were used, the mean loss is shown ± one standard deviation.

of Laplace GPC, where linear systems are solved repeatedly to obtain the MAP
solution ˜f (see sections 3.4 and 3.5 for details).

One way that the CG method can be speeded up is by using an approximate
rather than exact matrix-vector multiplication. For example, recent work by
Yang et al. [2005] uses the improved fast Gauss transform for this purpose.

8.3.7 Comparison of Approximate GPR Methods

Above we have presented six approximation methods for GPR. Of these, we
retain only those methods which scale linearly with n, so the iterative solu-
tion of linear systems must be discounted. Also we discount the Nystr¨om ap-
proximation in preference to the SR method, leaving four alternatives: subset
of regressors (SR), subset of data (SD), projected process (PP) and Bayesian
committee machine (BCM).

Table 8.1 shows results of the four methods on the robot arm inverse dy-
namics problem described in section 2.5 which has D = 21 input variables,
44,484 training examples and 4,449 test examples. As in section 2.5 we used
the squared exponential covariance function with a separate length-scale pa-
rameter for each of the 21 input dimensions.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.3 Approximations for GPR with Fixed Hyperparameters

183

Method
SD
SR
PP
BCM

Storage
O(m2) O(m3)
O(mn) O(m2n)
O(mn) O(m2n)
O(mn)

Variance
Initialization Mean
O(m2)
O(m)
O(m2)
O(m)
O(m2)
O(m)
O(mn) O(mn)

Table 8.2: A comparison of the space and time complexity of the four methods
using random selection of subsets. Initialization gives the time needed to carry out
preliminary matrix computations before the test point x∗ is known. Mean (resp.
variance) refers to the time needed to compute the predictive mean (variance) at x∗.

For the SD method a subset of the training data of size m was selected at
random, and the hyperparameters were set by optimizing the marginal likeli-
hood on this subset. As ARD was used, this involved the optimization of D + 2
hyperparameters. This process was repeated 10 times, giving rise to the mean
and standard deviation recorded in Table 8.1. For the SR, PP and BCM meth-
ods, the same subsets of the data and hyperparameter vectors were used as had
been obtained from the SD experiments.4 Note that the m = 4096 result is not
available for BCM as this gave an out-of-memory error.

These experiments were conducted on a 2.0 GHz twin processor machine
with 3.74 GB of RAM. The code for all four methods was written in Matlab.5
A summary of the time complexities for the four methods are given in Table
8.2. Thus for a test set of size n∗ and using full (mean and variance) predictions
we ﬁnd that the SD method has time complexity O(m3) + O(m2n∗), for the
SR and PP methods it is O(m2n) + O(m2n∗), and for the BCM method it
is O(mnn∗). Assuming that n∗ ≥ m these reduce to O(m2n∗), O(m2n) and
O(mnn∗) respectively. These complexities are in broad agreement with the
timings in Table 8.1.

The results from Table 8.1 are plotted in Figure 8.1. As we would expect,
the general trend is that as m increases the SMSE and MSLL scores decrease.
Notice that it is well worth doing runs with small m so as to obtain a learning
curve with respect to m; this helps in getting a feeling of how useful runs at
large m will be. Both in terms of SMSE and MSLL we see (not surprisingly)
that SD is inferior to the other methods, all of which have similar performance.
These results were obtained using a random selection of the active set. Some
experiments were also carried out using active selection for the SD method
(IVM) and for the SR method but these did not lead to signiﬁcant improve-
ments in performance. For BCM we also experimented with the use of p-means
clustering instead of random assignment to partitions; again this did not lead
to signiﬁcant improvements in performance. Overall on this dataset our con-

4In the BCM case it was only the hyperparameters that were re-used; the data was parti-

tioned randomly into blocks of size m.

5We thank Anton Schwaighofer for making his BCM code available to us.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

184

Approximation Methods for Large Datasets

(a)

(b)

Figure 8.1: Panel(a): plot of SMSE against m. Panel(b) shows the MSLL for the four
methods. The error bars denote one standard deviation. For clarity in both panels
the BCM results are slightly displaced horizontally w.r.t. the SR results.

clusion is that for ﬁxed m SR or PP are the methods of choice, as BCM has
longer running times for similar performance. However, notice that if we com-
pare on runtime, then SD for m = 4096 is competitive with the SR, PP and
BCM results for m = 1024 on both time and performance.

In the above experiments the hyperparameters for all methods were set by
optimizing the marginal likelihood of the SD model of size m. This means that
we get a direct comparison of the diﬀerent methods using the same hyperparam-
eters and subsets. However, one could alternatively optimize the (approximate)
marginal likelihood for each method (see section 8.5) and then compare results.
Notice that the hyperparameters which optimize the approximate marginal like-
lihood may depend on the method. For example Figure 5.3(b) shows that
the maximum in the marginal likelihood occurs at shorter length-scales as the
amount of data increases. This eﬀect has also been observed by V. Tresp and
A. Schwaighofer (pers. comm., 2004) when comparing the SD marginal likeli-
hood eq. (8.31) with the full marginal likelihood computed on all n datapoints
eq. (5.8).

Schwaighofer and Tresp [2003] report some experimental comparisons be-
tween the BCM method and some other approximation methods for a number
of synthetic regression problems. In these experiments they optimized the ker-
nel hyperparameters for each method separately. Their results are that for ﬁxed
m BCM performs as well as or better than the other methods. However, these
results depend on factors such as the noise level in the data generating pro-
cess; they report (pers. comm., 2005) that for relatively large noise levels BCM
no longer displays an advantage. Based on the evidence currently available
we are unable to provide ﬁrm recommendations for one approximation method
over another; further research is required to understand the factors that aﬀect
performance.

25651210242048409600.050.1SMSEmSDSR and PPBCM256512102420484096−2.2−1.8−1.4MSLLmSDPPSRBCMC. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.4 Approximations for GPC with Fixed Hyperparameters

185

8.4 Approximations for GPC with Fixed Hy-

perparameters

The approximation methods for GPC are similar to those for GPR, but need
to deal with the non-Gaussian likelihood as well, either by using the Laplace
approximation, see section 3.4, or expectation propagation (EP), see section
3.6.
In this section we focus mainly on binary classiﬁcation tasks, although
some of the methods can also be extended to the multi-class case.

Pm
For the subset of regressors (SR) method we again use the model fSR(x∗) =
i=1 αik(x∗, xi) with αm ∼ N (0, K−1
mm). The likelihood is non-Gaussian but
the optimization problem to ﬁnd the MAP value of αm is convex and can be
obtained using a Newton iteration. Using the MAP value ˆαm and the Hessian
at this point we obtain a predictive mean and variance for f(x∗) which can be
fed through the sigmoid function to yield probabilistic predictions. As usual
the question of how to choose a subset of points arises; Lin et al. [2000] select
these using a clustering method, while Zhu and Hastie [2002] propose a forward
selection strategy.

The subset of datapoints (SD) method for GPC was proposed in Lawrence
et al. [2003], using an EP-style approximation of the posterior, and the diﬀer-
ential entropy score (see section 8.3.3) to select new sites for inclusion. Note
that the EP approximation lends itself very naturally to sparsiﬁcation: a sparse
model results when some site precisions (see eq. (3.51)) are zero, making the cor-
responding likelihood term vanish. A computational gain can thus be achieved
by ignoring likelihood terms whose site precisions are very small.

The projected process (PP) approximation can also be used with non-
Gaussian likelihoods. Csat´o and Opper [2002] present an “online” method
where the examples are processed sequentially, while Csat´o et al. [2002] give
an expectation-propagation type algorithm where multiple sweeps through the
training data are permitted.

The Bayesian committee machine (BCM) has also been generalized to deal
with non-Gaussian likelihoods in Tresp [2000]. As in the GPR case the dataset
is broken up into blocks, but now approximate inference is carried out using the
Laplace approximation in each block to yield an approximate predictive mean
Eq[f∗|Di] and approximate predictive covariance covq(f∗|Di). These predictions
are then combined as before using equations 8.29 and 8.30.

8.5 Approximating the Marginal Likelihood and ∗

its Derivatives

We consider approximations ﬁrst for GP regression, and then for GP classiﬁca-
tion. For GPR, both the SR and PP methods give rise to the same approximate
marginal likelihood as given in eq. (8.17). For the SD method, a very simple

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

186

Approximation Methods for Large Datasets

2 y>

2 log |Kmm + σ2I|− 1

m(Kmm + σ2I)−1ym− m

approximation (ignoring the datapoints not in the active set) is given by
log pSD(ym|Xm) = − 1

2 log(2π),
(8.31)
where ym is the subvector of y corresponding to the active set; eq. (8.31) is
simply the log marginal likelihood under the model ym ∼ N (0, Kmm + σ2I).
For the BCM, a simple approach would be to sum eq. (8.31) evaluated on
each partition of the dataset. This ignores interactions between the partitions.
Tresp and Schwaighofer (pers. comm., 2004) have suggested a more sophisti-
cated BCM-based method which approximately takes these interactions into
account.

For GPC under the SR approximation, one can simply use the Laplace or EP
approximations on the ﬁnite-dimensional model. For SD one can again ignore all
datapoints not in the active set and compute an approximation to log p(ym|Xm)
using either Laplace or EP. For the projected process (PP) method, Seeger
[2003, p. 162] suggests the following lower bound

Z

q(f) p(y|f)p(f)

q(f)

df

Z

Z

Z
Z
nX

≥

=

=

log p(y|X) = log

p(y|f)p(f) df = log

(cid:16) p(y|f)p(f)

(cid:17)

q(f)

q(f) log

df

(8.32)

q(f) log q(y|f) df − KL(q(f)||p(f))

q(fi) log p(yi|fi) dfi − KL(q(fm)||p(fm)),

i=1

where q(f) is a shorthand for q(f|y) and eq. (8.32) follows from the equation
on the previous line using Jensen’s inequality. The KL divergence term can
be readily evaluated using eq. (A.23), and the one-dimensional integrals can be
tackled using numerical quadrature.

We are not aware of work on extending the BCM approximations to the

marginal likelihood to GPC.

Given the various approximations to the marginal likelihood mentioned
above, we may also want to compute derivatives in order to optimize it. Clearly
it will make sense to keep the active set ﬁxed during the optimization, although
note that this clashes with the fact that methods that select the active set
might choose a diﬀerent set as the covariance function parameters θ change.
For the classiﬁcation case the derivatives can be quite complex due to the fact
that site parameters (such as the MAP values ˆf, see section 3.4.1) change as
θ changes. (We have already seen an example of this in section 5.5 for the
non-sparse Laplace approximation.) Seeger [2003, sec. 4.8] describes some ex-
periments comparing SD and PP methods for the optimization of the marginal
likelihood on both regression and classiﬁcation problems.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

8.6 Appendix: Equivalence of SR and GPR Using the Nystr¨om Approximate Kernel 187

8.6 Appendix: Equivalence of SR and GPR Us- ∗

ing the Nystr¨om Approximate Kernel

In section 8.3 we derived the subset of regressors predictors for the mean and
variance, as given in equations 8.14 and 8.15. The aim of this appendix is to
show that these are equivalent to the predictors that are obtained by replacing
k(x, x0) systematically with ˜k(x, x0) in the GPR prediction equations 2.25 and
2.26.

First for the mean. The GPR predictor is E[f(x∗)] = k(x∗)>(K + σ2

Replacing all occurrences of k(x, x0) with ˜k(x, x0) we obtain

nI)−1y.

nI)−1y

E[ ˜f(x∗)] = ˜k(x∗)>( ˜K + σ2
= km(x∗)>K−1
= σ−2
= σ−2
= σ−2
= km(x∗)>Q−1Kmny,

n km(x∗)>K−1
n km(x∗)>K−1
n km(x∗)>K−1

mm

mm

mmKmn

mmKmn(KnmK−1

nI)−1y

mmKmn + σ2

(cid:2)In − KnmQ−1Kmn
(cid:3) y
(cid:2)Im − KmnKnmQ−1(cid:3) Kmny
nKmmQ−1(cid:3) Kmny
(cid:2)σ2

(8.33)
(8.34)
(8.35)
(8.36)
(8.37)
(8.38)

nKmm + KmnKnm, which agrees with eq. (8.14). Equation (8.35)
where Q = σ2
follows from eq. (8.34) by use of the matrix inversion lemma eq. (A.9) and
nKmm + KmnKnm)Q−1. For
eq. (8.37) follows from eq. (8.36) using Im = (σ2
the predictive variance we have
V[ ˜f∗] = ˜k(x∗, x∗) − ˜k(x∗)>( ˜K + σ2

nI)−1˜k(x∗)

= km(x∗)>K−1
km(x∗)>K−1
= km(x∗)>K−1

mmkm(x∗)−
mmKmn(KnmK−1
mmkm(x∗) − km(x∗)>Q−1KmnKnmK−1

mmKmn + σ2

nI)−1KnmK−1

= km(x∗)>(cid:2)Im − Q−1KmnKnm

(cid:3) K−1

mmkm(x∗)

= km(x∗)>Q−1σ2
= σ2

nKmmK−1
nkm(x∗)>Q−1km(x∗),

mmkm(x∗)

(8.39)
(8.40)

mmkm(x∗)

mmkm(x∗) (8.41)
(8.42)
(8.43)
(8.44)

in agreement with eq. (8.15). The step between eqs. (8.40) and (8.41) is obtained
from eqs. (8.34) and (8.38) above, and eq. (8.43) follows from eq. (8.42) using
Im = (σ2

nKmm + KmnKnm)Q−1.

8.7 Exercises

1. Verify that the mean and covariance of the BCM predictions (equations
8.29 and 8.30) are correct. If you are stuck, see Tresp [2000] for details.
mm show that E(Copt) =
tr(K − ˜K), where ˜K = KnmK−1
mmKmn. Now consider adding one data-
point into set I, so that Kmm grows to K(m+1)(m+1). Using eq. (A.12)

2. Using eq. (8.10) and the fact that Copt = KnmK−1

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

188

Approximation Methods for Large Datasets

show that the change in E due to adding the extra datapoint can be
computed in time O(mn).
If you need help, see Sch¨olkopf and Smola
[2002, sec. 10.2.2] for further details.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Chapter 9

Further Issues and
Conclusions

In the previous chapters of the book we have concentrated on giving a solid
grounding in the use of GPs for regression and classiﬁcation problems, includ-
ing model selection issues, approximation methods for large datasets, and con-
nections to related models. In this chapter we provide some short descriptions
of other issues relating to Gaussian process prediction, with pointers to the
literature for further reading.

So far we have mainly discussed the case when the output target y is a single
label, but in section 9.1 we describe how to deal with the case that there are
multiple output targets. Similarly, for the regression problem we have focussed
on i.i.d. Gaussian noise; in section 9.2 we relax this condition to allow the
noise process to have correlations. The classiﬁcation problem is characterized
by a non-Gaussian likelihood function; however, there are other non-Gaussian
likelihoods of interest, as described in section 9.3.

We may not only have observations of function values, by also on derivatives
of the target function. In section 9.4 we discuss how to make use of this infor-
mation in the GPR framework. Also it may happen that there is noise on the
observation of the input variable x; in section 9.5 we explain how this can be
handled. In section 9.6 we mention how more ﬂexible models can be obtained
using mixtures of Gaussian process models.

As well as carrying out prediction for test inputs, one might also wish to try
to ﬁnd the global optimum of a function within some compact set. Approaches
based on Gaussian processes for this problem are described in section 9.7. The
use of Gaussian processes to evaluate integrals is covered in section 9.8.

By using a scale mixture of Gaussians construction one can obtain a mul-
tivariate Student’s t distribution. This construction can be extended to give a
Student’s t process, as explained in section 9.9. One key aspect of the Bayesian
framework relates to the incorporation of prior knowledge into the problem

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

190

Further Issues and Conclusions

formulation. In some applications we not only have the dataset D but also ad-
ditional information. For example, for an optical character recognition problem
we know that translating the input pattern by one pixel will not change the
label of the pattern. Approaches for incorporating this knowledge are discussed
in section 9.10.

In this book we have concentrated on supervised learning problems. How-
ever, GPs can be used as components in unsupervised learning models, as de-
scribed in section 9.11. Finally, we close with some conclusions and an outlook
to the future in section 9.12.

9.1 Multiple Outputs

Throughout this book we have concentrated on the problem of predicting a
single output variable y from an input x. However, it can happen that one
may wish to predict multiple output variables (or channels) simultaneously.
For example in the robot inverse dynamics problem described in section 2.5
there are really seven torques to be predicted. A simple approach is to model
each output variable as independent from the others and treat them separately.
However, this may lose information and be suboptimal.

One way in which correlation can occur is through a correlated noise process.
Even if the output channels are a priori independent, if the noise process is
correlated then this will induce correlations in the posterior processes. Such
a situation is easily handled in the GP framework by considering the joint,
block-diagonal, prior over the function values of each channel.

Another way that correlation of multiple channels can occur is if the prior
already has this structure. For example in geostatistical situations there may be
correlations between the abundances of diﬀerent ores, e.g. silver and lead. This
situation requires that the covariance function models not only the correlation
structure of each channel, but also the cross-correlations between channels.
Some work on this topic can be found in the geostatistics literature under
the name of cokriging, see e.g. Cressie [1993, sec. 3.2.3]. One way to induce
correlations between a number of output channels is to obtain them as linear
combinations of a number of latent channels, as described in Teh et al. [2005];
see also Micchelli and Pontil [2005]. A related approach is taken by Boyle and
Frean [2005] who introduce correlations between two processes by deriving them
as diﬀerent convolutions of the same underlying white noise process.

9.2 Noise Models with Dependencies

The noise models used so far have almost exclusively assumed Gaussianity and
independence. Non-Gaussian likelihoods are mentioned in section 9.3 below.
Inside the family of Gaussian noise models, it is not diﬃcult to model depen-
dencies. This may be particularly useful in models involving time. We simply
add terms to the noise covariance function with the desired structure, including

cokriging

coloured noise

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

191

ARMA

9.3 Non-Gaussian Likelihoods

hyperparameters. In fact, we already used this approach for the atmospheric
carbon dioxide modelling task in section 5.4.3. Also, Murray-Smith and Girard
[2001] have used an autoregressive moving-average (ARMA) noise model (see
also eq. (B.51)) in a GP regression task.

9.3 Non-Gaussian Likelihoods

Our main focus has been on regression with Gaussian noise, and classiﬁcation
using the logistic or probit response functions. However, Gaussian processes can
be used as priors with other likelihood functions. For example, Diggle et al.
[1998] were concerned with modelling count data measured geographically using
a Poisson likelihood with a spatially varying rate. They achieved this by placing
a GP prior over the log Poisson rate.

Goldberg et al. [1998] stayed with a Gaussian noise model, but introduced
heteroscedasticity, i.e. allowing the noise variance to be a function of x. This
was achieved by placing a GP prior on the log variance function. Neal [1997]
robustiﬁed GP regression by using a Student’s t-distributed noise model rather
than Gaussian noise. Chu and Ghahramani [2005] have described how to use
GPs for the ordinal regression problem, where one is given ranked preference
information as the target data.

9.4 Derivative Observations

Since diﬀerentiation is a linear operator, the derivative of a Gaussian process
is another Gaussian process. Thus we can use GPs to make predictions about
derivatives, and also to make inference based on derivative information.
In
general, we can make inference based on the joint Gaussian distribution of
function values and partial derivatives. A covariance function k(·,·) on function
values implies the following (mixed) covariance between function values and
partial derivatives, and between partial derivatives

cov(cid:0)fi,

(cid:1) = ∂k(xi, xj)

,

∂xdj

∂fj
∂xdj

cov(cid:0) ∂fi

∂xdi

,

∂fj
∂xej

(cid:1) = ∂2k(xi, xj)

∂xdi∂xej

,

(9.1)

see e.g. Papoulis [1991, ch. 10] or Adler [1981, sec. 2.2]. With n datapoints in
D dimensions, the complete joint distribution of f and its D partial derivatives
involves n(D+1) quantities, but in a typical application we may only have access
to or interest in a subset of these; we simply remove the rows and columns
from the joint matrix which are not needed. Observed function values and
derivatives may often have diﬀerent noise levels, which are incorporated by
adding a diagonal contribution with diﬀering hyperparameters. Inference and
predictions are done as usual. This approach was used in the context of learning
in dynamical systems by Solak et al. [2003]. In Figure 9.1 the posterior process
with and without derivative observations are compared. Noise-free derivatives
may be a useful way to enforce known constraints in a modelling problem.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

192

Further Issues and Conclusions

(a)

(b)

Figure 9.1: In panel (a) we show four data points in a one dimensional noise-free
regression problem, together with three functions sampled from the posterior and the
95% conﬁdence region in light grey. In panel (b) the same observations have been
augmented by noise-free derivative information, indicated by small tangent segments
at the data points. The covariance function is the squared exponential with unit
process variance and unit length-scale.

9.5 Prediction with Uncertain Inputs

It can happen that the input values to a prediction problem can be uncer-
tain. For example, for a discrete time series one can perform multi-step-ahead
predictions by iterating one-step-ahead predictions. However, if the one-step-
ahead predictions include uncertainty, then it is necessary to propagate this
uncertainty forward to get the proper multi-step-ahead predictions. One sim-
ple approach is to use sampling methods. Alternatively, it may be possible to
use analytical approaches. Girard et al. [2003] showed that it is possible to
compute the mean and variance of the output analytically when using the SE
covariance function and Gaussian input noise.

More generally, the problem of regression with uncertain inputs has been
studied in the statistics literature under the name of errors-in-variables regres-
sion. See Dellaportas and Stephens [1995] for a Bayesian treatment of the
problem and pointers to the literature.

9.6 Mixtures of Gaussian Processes

In chapter 4 we have seen many ideas for making the covariance functions
more ﬂexible. Another route is to use a mixture of diﬀerent Gaussian process
models, each one used in some local region of input space. This kind of model
is generally known as a mixture of experts model and is due to Jacobs et al.
[1991]. In addition to the local expert models, the model has a manager that
(probabilistically) assigns points to the experts. Rasmussen and Ghahramani
[2002] used Gaussian process models as local experts, and based their manager
on another type of stochastic process: the Dirichlet process. Inference in this
model required MCMC methods.

−4−2024−2−1012input, xoutput, y(x)−4−2024−2−1012input, xoutput, y(x)C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

9.7 Global Optimization

193

9.7 Global Optimization

Often one is faced with the problem of being able to evaluate a continuous
function g(x), and wishing to ﬁnd the global optimum (maximum or minimum)
of this function within some compact set A ⊂ RD. There is a very large
literature on the problem of global optimization; see Neumaier [2005] for a
useful overview.

Given a dataset D = {(xi, g(xi))|i=1, . . . , n}, one appealing approach is to
ﬁt a GP regression model to this data. This will give a mean prediction and
predictive variance for every x ∈ A. Jones [2001] examines a number of criteria
that have been suggested for where to make the next function evaluation based
on the predictive mean and variance. One issue with this approach is that one
may need to search to ﬁnd the optimum of the criterion, which may itself be
multimodal optimization problem. However, if evaluations of g are expensive
or time-consuming, it can make sense to work hard on this new optimization
problem.

For historical references and further work in this area see Jones [2001] and

Ritter [2000, sec. VIII.2].

9.8 Evaluation of Integrals

Another interesting and unusual application of Gaussian processes is for the
evaluation of the integrals of a deterministic function f. One evaluates the
function at a number of locations, and then one can use a Gaussian process as
a posterior over functions. This posterior over functions induces a posterior over
the value of the integral (since each possible function from the posterior would
give rise to a particular value of the integral). For some covariance functions
(e.g. the squared exponential), one can compute the expectation and variance of
the value of the integral analytically. It is perhaps unusual to think of the value
of the integral as being random (as it does have one particular deterministic
value), but it is perfectly in line of Bayesian thinking that you treat all kinds
of uncertainty using probabilities. This idea was proposed under the name of
Bayes-Hermite quadrature by O’Hagan [1991], and later under the name of
Bayesian Monte Carlo in Rasmussen and Ghahramani [2003].

Another approach is related to the ideas of global optimization in the section
9.7 above. One can use a GP model of a function to aid an MCMC sampling
procedure, which may be advantageous if the function of interest is computa-
tionally expensive to evaluate. Rasmussen [2003] combines Hybrid Monte Carlo
with a GP model of the log of the integrand, and also uses derivatives of the
function (discussed in section 9.4) to get an accurate model of the integrand
with very few evaluations.

combining GPs
with MCMC

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

194

scale mixture

noise entanglement

Further Issues and Conclusions

9.9 Student’s t Process

A Student’s t process can be obtained by applying the scale mixture of Gaus-
sians construction of a Student’s t distribution to a Gaussian process [O’Hagan,
1991, O’Hagan et al., 1999]. We divide the covariances by the scalar τ and put
a gamma distribution on τ with shape α and mean β so that
βαΓ(α) τ α−1 exp

˜k(x, x0) = τ−1k(x, x0),

(cid:16) − τ α

p(τ|α, β) =

(9.2)

(cid:17)

αα

β

,

Z

where k is any valid covariance function. Now the joint prior distribution of
any ﬁnite number n of function values y becomes
N (y|0, τ−1Ky)p(τ|α, β)dτ
Γ(α + n/2)(2πα)−n/2

(cid:17)−(α+n/2)

p(y|α, β, θ) =

βy>K−1
y y

(9.3)

(cid:16)

,

=

Γ(α)|β−1Ky|−1/2

1 +

2α

which is recognized as the zero mean, multivariate Student’s t distribution
with 2α degrees of freedom: p(y|α, β, θ) = T (0, β−1Ky, 2α). We could state a
deﬁnition analogous to deﬁnition 2.1 on page 13 for the Gaussian process, and
write

(9.4)
cf. eq. (2.14). The marginal likelihood can be directly evaluated using eq. (9.3),
and training can be achieved using the methods discussed in chapter 5 regarding
α and β as hyperparameters. The predictive distribution for test cases are also
t distributions, the derivation of which is left as an exercise below.

f ∼ T P(0, β−1K, 2α),

Notice that the above construction is clear for noise-free processes, but that
the interpretation becomes more complicated if the covariance function k(x, x0)
contains a noise contribution. The noise and signal get entangled by the com-
mon factor τ, and the observations can no longer be written as the sum of
independent signal and noise contributions. Allowing for independent noise
contributions removes analytic tractability, which may reduce the usefulness of
the t process.
Exercise Using the scale mixture representation from eq. (9.3) derive the poste-
rior predictive distribution for a Student’s t process.
Exercise Consider the generating process implied by eq. (9.2), and write a pro-
gram to draw functions at random. Characterize the diﬀerence between the
Student’s t process and the corresponding Gaussian process (obtained in the
limit α → ∞), and explain why the t process is perhaps not as exciting as one
might have hoped.

9.10

Invariances

It can happen that the input is apparently in vector form but in fact it has
additional structure. A good example is a pixelated image, where the 2-d array

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

9.10 Invariances

195

of pixels can be arranged into a vector (e.g. in raster-scan order). Imagine that
the image is of a handwritten digit; then we know that if the image is translated
by one pixel it will remain the same digit. Thus we have knowledge of certain
invariances of the input pattern. In this section we describe a number of ways
in which such invariances can be exploited. Our discussion is based on Sch¨olkopf
and Smola [2002, ch. 11].

Prior knowledge about the problem tells us that certain transformations of
the input would leave the class label invariant—these include simple geometric
transformations such as translations, rotations,1 rescalings, and rather less ob-
vious ones such as line thickness transformations.2 Given enough data it should
be possible to learn the correct input-output mapping, but it would make sense
to try to make use of these known invariances to reduce the amount of training
data needed. There are at least three ways in which this prior knowledge has
been used, as described below.

The ﬁrst approach is to generate synthetic training examples by applying
valid transformations to the examples we already have. This is simple but it
does have the disadvantage of creating a larger training set. As kernel-machine
training algorithms typically scale super-linearly with n this can be problematic.
A second approach is to make the predictor invariant to small transforma-
tions of each training case; this method was ﬁrst developed by Simard et al.
[1992] for neural networks under the name of “tangent prop”. For a single
training image we consider the manifold of images that are generated as various
transformations are applied to it. This manifold will have a complex structure,
but locally we can approximate it by a tangent space. The idea in “tangent
prop” is that the output should be invariant to perturbations of the training
example in this tangent space. For neural networks it is quite straightforward
to modify the training objective function to penalize deviations from this in-
variance, see Simard et al. [1992] for details. Section 11.4 in Sch¨olkopf and
Smola [2002] describes some ways in which these ideas can be extended to
kernel machines.

The third approach to dealing with invariances is to develop a representation
of the input which is invariant to some or all of the transformations. For
example, binary images of handwritten digits are sometimes “skeletonized” to
remove the eﬀect of line thickness. If an invariant representation can be achieved
for all transformations it is the most desirable, but it can be diﬃcult or perhaps
impossible to achieve. For example, if a given training pattern can belong to
more than one class (e.g. an ambiguous handwritten digit) then it is clearly not
possible to ﬁnd a new representation which is invariant to transformations yet
leaves the classes distinguishable.

1The digit recognition problem is only invariant to small rotations; we must avoid turning

a 6 into a 9.

2i.e. changing the thickness of the pen we write with within reasonable bounds does not

change the digit we write.

synthetic training
examples

tangent prop

invariant representation

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

196

Further Issues and Conclusions

9.11 Latent Variable Models

GTM

GPLVM

Our main focus in this book has been on supervised learning. However, GPs
have also been used as components for models carrying out non-linear dimen-
sionality reduction, a form of unsupervised learning. The key idea is that data
which is apparently high-dimensional (e.g. a pixelated image) may really lie on
a low-dimensional non-linear manifold which we wish to model.

Let z ∈ RL be a latent (or hidden) variable, and let x ∈ RD be a visible
variable. We suppose that our visible data is generated by picking a point in
z-space and mapping this point into the data space through a (possibly non-

linear) mapping, and then optionally adding noise. Thus p(x) =R p(x|z)p(z)dz.

If the mapping from z to x is linear and z has a Gaussian distribution then
this is the factor analysis model, and the mean and covariance of the Gaussian
in x-space can easily be determined. However, if the mapping is non-linear
then the integral cannot be computed exactly. In the generative topographic
mapping (GTM) model [Bishop et al., 1998b] the integral was approximated
using a grid of points in z-space. In the original GTM paper the non-linear
mapping was taken to be a linear combination of non-linear basis functions,
but in Bishop et al. [1998a] this was replaced by a Gaussian process mapping
between the latent and visible spaces.

More recently Lawrence [2004] has introduced a rather diﬀerent model known
as the Gaussian process latent variable model (GPLVM). Instead of having a
prior (and thus a posterior) distribution over the latent space, we consider that
each data point xi is derived from a corresponding latent point zi through
a non-linear mapping (with added noise).
If a Gaussian process is used for
this non-linear mapping, then one can easily write down the joint distribution
p(X|Z) of the visible variables conditional on the latent variables. Optimization
routines can then be used to ﬁnd the locations of the latent points that opti-
mize p(X|Z). This has some similarities to the work on regularized principal
manifolds [Sch¨olkopf and Smola, 2002, ch. 17] except that in the GPLVM one
integrates out the latent-to-visible mapping rather than optimizing it.

9.12 Conclusions and Future Directions

In this section we brieﬂy wrap up some of the threads we have developed
throughout the book, and discuss possible future directions of work on Gaussian
processes.

In chapter 2 we saw how Gaussian process regression is a natural extension
of Bayesian linear regression to a more ﬂexible class of models. For Gaussian
noise the model can be treated analytically, and is simple enough that the GP
model could be often considered as a replacement for the traditional linear
analogue. We have also seen that historically there have been numerous ideas
along the lines of Gaussian process models, although they have only gained a
sporadic following.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

9.12 Conclusions and Future Directions

197

One may indeed speculate, why are GPs not currently used more widely in
applications? We see three major reasons: (1) Firstly, that the application of
Gaussian processes requires the handling (inversion) of large matrices. While
these kinds of computations were tedious 20 years ago, and impossible further
in the past, even na¨ıve implementations suﬃce for moderate sized problems on
an anno 2005 PC. (2) Another possibility is that most of the historical work
on GPs was done using ﬁxed covariance functions, with very little guide as
to how to choose such functions. The choice was to some degree arbitrary,
and the idea that one should be able to infer the structure or parameters of
the covariance function as we discuss in chapter 5 is not so well known. This
is probably a very important step in turning GPs into an interesting method
for practitioners. (3) The viewpoint of placing Gaussian process priors over
functions is a Bayesian one. Although the adoption of Bayesian methods in the
machine learning community is quite widespread, these ideas have not always
been appreciated more widely in the statistics community.

Although modern computers allow simple implementations for up to a few
thousand training cases, the computational constraints are still a signiﬁcant
limitation for applications where the datasets are signiﬁcantly larger than this.
In chapter 8 we have given an overview of some of the recent work on approx-
imations for large datasets. Although there are many methods and a lot of
work is currently being undertaken, both the theoretical and practical aspects
of these approximations need to be understood better in order to be a useful
tool to the practitioner.

The computations required for the Gaussian process classiﬁcation models
developed in chapter 3 are a lot more involved than for regression. Although
the theoretical foundations of Gaussian process classiﬁcation are well developed,
it is not yet clear under which circumstances one would expect the extra work
and approximations associated with treating a full probabilistic latent variable
model to pay oﬀ. The answer may depend heavily on the ability to learn
meaningful covariance functions.

The incorporation of prior knowledge through the choice and parameter-
ization of the covariance function is another prime target for future work on
GPs. In chapter 4 we have presented many families of covariance functions with
widely diﬀering properties, and in chapter 5 we presented principled methods
for choosing between and adapting covariance functions. Particularly in the
machine learning community, there has been a tendency to view Gaussian pro-
cesses as a “black box”—what exactly goes on in the box is less important, as
long as it gives good predictions. To our mind, we could perhaps learn some-
thing from the statisticians here, and ask how and why the models work. In fact
the hierarchical formulation of the covariance functions with hyperparameters,
the testing of diﬀerent hypotheses and the adaptation of hyperparameters gives
an excellent opportunity to understand more about the data.

We have attempted to illustrate this line of thinking with the carbon dioxide
prediction example developed at some length in section 5.4.3. Although this
problem is comparatively simple and very easy to get an intuitive understanding
of, the principles of trying out diﬀerent components in the covariance structure

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

198

Further Issues and Conclusions

and adapting their parameters could be used universally. Indeed, the use of
the isotropic squared exponential covariance function in the digit classiﬁcation
examples in chapter 3 is not really a choice which one would expect to provide
very much insight to the classiﬁcation problem. Although some of the results
presented are as good as other current methods in the literature, one could
indeed argue that the use of the squared exponential covariance function for this
task makes little sense, and the low error rate is possibly due to the inherently
low diﬃculty of the task. There is a need to develop more sensible covariance
functions which allow for the incorporation of prior knowledge and help us to
gain real insight into the data.

Going beyond a simple vectorial representation of the input data to take
into account structure in the input domain is also a theme which we see as very
important. Examples of this include the invariances described in section 9.10
arising from the structure of images, and the kernels described in section 4.4
which encode structured objects such as strings and trees.

As this brief discussion shows, we see the current level of development of
Gaussian process models more as a rich, principled framework for supervised
learning than a fully-developed set of tools for applications. We ﬁnd the Gaus-
sian process framework very appealing and are conﬁdent that the near future
will show many important developments, both in theory, methodology and prac-
tice. We look forward very much to following these developments.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Appendix A

Mathematical Background

A.1 Joint, Marginal and Conditional Probability

Let the n (discrete or continuous) random variables y1, . . . , yn have a joint
probability p(y1, . . . , yn), or p(y) for short.1 Technically, one ought to distin-
guish between probabilities (for discrete variables) and probability densities for
continuous variables. Throughout the book we commonly use the term “prob-
ability” to refer to both. Let us partition the variables in y into two groups, yA
and yB, where A and B are two disjoint sets whose union is the set {1, . . . , n},
so that p(y) = p(yA, yB). Each group may contain one or more variables.

The marginal probability of yA is given by

Z

p(yA) =

p(yA, yB) dyB.

(A.1)

The integral is replaced by a sum if the variables are discrete valued. Notice
that if the set A contains more than one variable, then the marginal probability
is itself a joint probability—whether it is referred to as one or the other depends
on the context. If the joint distribution is equal to the product of the marginals,
then the variables are said to be independent, otherwise they are dependent.

The conditional probability function is deﬁned as
p(yA|yB) = p(yA, yB)
p(yB)

,

(A.2)

deﬁned for p(yB) > 0, as it is not meaningful to condition on an impossible
event. If yA and yB are independent, then the marginal p(yA) and the condi-
tional p(yA|yB) are equal.

1One can deal with more general cases where the density function does not exist by using

the distribution function.

joint probability

marginal probability

independence

conditional probability

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

200

Bayes’ rule

Gaussian deﬁnition

conditioning and
marginalizing

products

Mathematical Background

theorem

Using the deﬁnitions of both p(yA|yB) and p(yB|yA) we obtain Bayes’

p(yA|yB) = p(yA)p(yB|yA)

p(yB)

.

(A.3)

Since conditional distributions are themselves probabilities, one can use all of
the above also when further conditioning on other variables. For example, in
supervised learning, one often conditions on the inputs throughout, which would
lead e.g. to a version of Bayes’ rule with additional conditioning on X in all
four probabilities in eq. (A.3); see eq. (2.5) for an example of this.

A.2 Gaussian Identities

The multivariate Gaussian (or Normal) distribution has a joint probability den-
sity given by

p(x|m, Σ) = (2π)−D/2|Σ|−1/2 exp(cid:0)− 1

2(x − m)>Σ−1(x − m)(cid:1),

(A.4)

where m is the mean vector (of length D) and Σ is the (symmetric, positive
deﬁnite) covariance matrix (of size D × D). As a shorthand we write x ∼
N (m, Σ).

Let x and y be jointly Gaussian random vectors

(cid:21)

(cid:20) x

y

(cid:20) A

(cid:18)(cid:20) µx

(cid:21)

µy

∼ N

,

C
C> B

= N

(cid:21)(cid:19)

 (cid:20) µx

(cid:21)

µy

(cid:20) ˜A

,

˜C>

(cid:21)−1!

˜C
˜B

,

(A.5)

then the marginal distribution of x and the conditional distribution of x given
y are

x ∼ N (µx, A), and x|y ∼ N(cid:0)µx + CB−1(y − µy), A − CB−1C>(cid:1)

or x|y ∼ N(cid:0)µx − ˜A−1 ˜C(y − µy), ˜A−1(cid:1).

(A.6)

See, e.g. von Mises [1964, sec. 9.3], and eqs. (A.11 - A.13).

The product of two Gaussians gives another (un-normalized) Gaussian
N (x|a, A)N (x|b, B) = Z−1N (x|c, C)

(A.7)

where c = C(A−1a + B−1b) and C = (A−1 + B−1)−1.

Notice that the resulting Gaussian has a precision (inverse variance) equal to
the sum of the precisions and a mean equal to the convex sum of the means,
weighted by the precisions. The normalizing constant looks itself like a Gaussian
(in a or b)

Z−1 = (2π)−D/2|A + B|−1/2 exp(cid:0)− 1

2(a − b)>(A + B)−1(a − b)(cid:1).

(A.8)

To prove eq. (A.7) simply write out the (lengthy) expressions by introducing
eq. (A.4) and eq. (A.8) into eq. (A.7), and expand the terms inside the exp to

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

A.3 Matrix Identities

201

generating multivariate
Gaussian samples

verify equality. Hint: it may be helpful to expand C using the matrix inversion
lemma, eq. (A.9), C = (A−1+B−1)−1 = A−A(A+B)−1A = B−B(A+B)−1B.
To generate samples x ∼ N (m, K) with arbitrary mean m and covariance
matrix K using a scalar Gaussian generator (which is readily available in many
programming environments) we proceed as follows: ﬁrst, compute the Cholesky
decomposition (also known as the “matrix square root”) L of the positive def-
inite symmetric covariance matrix K = LL>, where L is a lower triangular
matrix, see section A.4. Then generate u ∼ N (0, I) by multiple separate calls
to the scalar Gaussian generator. Compute x = m + Lu, which has the desired
distribution with mean m and covariance LE[uu>]L> = LL> = K (by the
independence of the elements of u).

In practice it may be necessary to add a small multiple of the identity
matrix I to the covariance matrix for numerical reasons. This is because the
eigenvalues of the matrix K can decay very rapidly (see section 4.3.1 for a
closely related analytical result) and without this stabilization the Cholesky
decomposition fails. The eﬀect on the generated samples is to add additional
independent noise of variance . From the context  can usually be chosen to
have inconsequential eﬀects on the samples, while ensuring numerical stability.

A.3 Matrix Identities

The matrix inversion lemma, also known as the Woodbury, Sherman & Morri- matrix inversion lemma
son formula (see e.g. Press et al. [1992, p. 75]) states that

(Z + U W V >)−1 = Z−1 − Z−1U(W −1 + V >Z−1U)−1V >Z−1,

(A.9)
assuming the relevant inverses all exist. Here Z is n×n, W is m×m and U and V
are both of size n×m; consequently if Z−1 is known, and a low rank (i.e. m < n)
perturbation is made to Z as in left hand side of eq. (A.9), considerable speedup
can be achieved. A similar equation exists for determinants

|Z + U W V >| = |Z| |W| |W −1 + V >Z−1U|.

(A.10)

Let the invertible n × n matrix A and its inverse A−1 be partitioned into

(cid:18) P Q

(cid:19)

R S

(cid:19)

(cid:18) ˜P

˜Q
˜R ˜S

A =

,

A−1 =

,

(A.11)

where P and ˜P are n1 × n1 matrices and S and ˜S are n2 × n2 matrices with
n = n1 + n2. The submatrices of A−1 are given in Press et al. [1992, p. 77] as

˜P = P −1 + P −1QM RP −1
˜Q = −P −1QM
˜R = −M RP −1
˜S = M

 where M = (S − RP −1Q)−1,

(A.12)

determinants

inversion of a
partitioned matrix

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

202

Mathematical Background

or equivalently

˜P = N
˜Q = −N QS−1
˜R = −S−1RN
˜S = S−1 + S−1RN QS−1

 where N = (P − QS−1R)−1.

A.3.1 Matrix Derivatives

Derivatives of the elements of an inverse matrix:
K−1 = −K−1 ∂K
∂θ

∂
∂θ

K−1,

(A.13)

(A.14)

where ∂K
positive deﬁnite symmetric matrix we have

∂θ is a matrix of elementwise derivatives. For the log determinant of a

log |K| = tr(cid:0)K−1 ∂K

(cid:1).

∂θ

∂
∂θ

(A.15)

derivative of inverse

derivative of log
determinant

A.3.2 Matrix Norms
The Frobenius norm kAkF of a n1 × n2 matrix A is deﬁned as

n1X

n2X

kAk2

F =

|aij|2 = tr(AA>),

(A.16)

[Golub and Van Loan, 1989, p. 56].

i=1

j=1

A.4 Cholesky Decomposition

The Cholesky decomposition of a symmetric, positive deﬁnite matrix A decom-
poses A into a product of a lower triangular matrix L and its transpose

LL> = A,

(A.17)

where L is called the Cholesky factor. The Cholesky decomposition is useful
for solving linear systems with symmetric, positive deﬁnite coeﬃcient matrix
A. To solve Ax = b for x, ﬁrst solve the triangular system Ly = b by forward
substitution and then the triangular system L>x = y by back substitution.
Using the backslash operator, we write the solution as x = L>\(L\b), where
the notation A\b is the vector x which solves Ax = b. Both the forward and
backward substitution steps require n2/2 operations, when A is of size n × n.
The computation of the Cholesky factor L is considered numerically extremely
stable and takes time n3/6, so it is the method of choice when it can be applied.

solving linear systems

computational cost

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

A.5 Entropy and Kullback-Leibler Divergence

nY

nX

Note also that the determinant of a positive deﬁnite symmetric matrix can be
calculated eﬃciently by

|A| =

ii, or
L2

log |A| = 2

log Lii,

(A.18)

where L is the Cholesky factor from A.

i=1

i=1

A.5 Entropy and Kullback-Leibler Divergence

The entropy H[p(x)] of a distribution p(x) is a non-negative measure of the
amount of “uncertainty” in the distribution, and is deﬁned as

H[p(x)] = −

p(x) log p(x) dx.

(A.19)

Z

The integral is substituted by a sum for discrete variables. Entropy is measured
in bits if the log is to the base 2 and in nats in the case of the natural log. The
entropy of a Gaussian in D dimensions, measured in nats is

H[N (µ, Σ)] = 1

(A.20)
The Kullback-Leibler (KL) divergence (or relative entropy) KL(p||q) be-

2 (log 2πe).

tween two distributions p(x) and q(x) is deﬁned as
p(x) log p(x)

KL(p||q) =

q(x) dx.

(A.21)

2 log |Σ| + D
Z

It is easy to show that KL(p||q) ≥ 0, with equality if p = q (almost everywhere).
For the case of two Bernoulli random variables p and q this reduces to

KLBer(p||q) = p log p
q

+ (1 − p) log

(1 − p)
(1 − q) ,

(A.22)

where we use p and q both as the name and the parameter of the Bernoulli
distributions. For two Gaussian distributions N (µ0, Σ0) and N (µ1, Σ1) we
have [Kullback, 1959, sec. 9.1]

KL(N0||N1) = 1

0 | +

(cid:0)(µ0 − µ1)(µ0 − µ1)> + Σ0 − Σ1

(cid:1).

Consider a general distribution p(x) on RD and a Gaussian distribution q(x) =
N (µ, Σ). Then

KL(p||q) =

1

2(x − µ)>Σ−1(x − µ)p(x) dx +

Z

2 log 2π +

p(x) log p(x) dx.

1

1

2 log |Σ1Σ−1
2 tr Σ−1
Z
2 log |Σ| + D

1

(A.23)

(A.24)

203

determinant

entropy

divergence of Bernoulli
random variables

divergence of Gaussians

minimizing KL(p||q)
divergence leads to
moment matching

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

204

Mathematical Background

Equation (A.24) can be minimized w.r.t. µ and Σ by diﬀerentiating w.r.t. these
parameters and setting the resulting expressions to zero. The optimal q is the
one that matches the ﬁrst and second moments of p.

The KL divergence can be viewed as the extra number of nats needed on
average to code data generated from a source p(x) under the distribution q(x)
as opposed to p(x).

A.6 Limits

The limit of a rational quadratic is a squared exponential

(cid:0)1 + x2

2α

(cid:1)−α = exp(cid:0)− x2

(cid:1).

2

lim
α→∞

(A.25)

A.7 Measure and Integration

Here we sketch some deﬁnitions concerning measure and integration; fuller
treatments can be found e.g. in Doob [1994] and Bartle [1995].

Let Ω be the set of all possible outcomes of an experiment. For example, for
a D-dimensional real-valued variable, Ω = RD. Let F be a σ-ﬁeld of subsets
of Ω which contains all the events in whose occurrences we may be interested.2
Then µ is a countably additive measure if it is real and non-negative and for
all mutually disjoint sets A1, A2, . . . ∈ F we have

µ(cid:0) ∞[

Ai

(cid:1) =

∞X

µ(Ai).

(A.26)

ﬁnite measure
probability measure
Lebesgue measure

i=1

i=1

If µ(Ω) < ∞ then µ is called a ﬁnite measure and if µ(Ω) = 1 it is called
a probability measure. The Lebesgue measure deﬁnes a uniform measure over
subsets of Euclidean space. Here an appropriate σ-algebra is the Borel σ-algebra
BD, where B is the σ-algebra generated by the open subsets of R. For example
on the line R the Lebesgue measure of the interval (a, b) is b − a.

We now restrict Ω to be RD and wish to give meaning to integration of a

function f : RD → R with respect to a measure µ

Z

f(x) dµ(x).

(A.27)

We assume that f is measurable, i.e. that for any Borel-measurable set A ∈ R,
f−1(A) ∈ BD. There are two cases that will interest us (i) when µ is the
Lebesgue measure and (ii) when µ is a probability measure. For the ﬁrst case

expression (A.27) reduces to the usual integral notationR f(x)dx.

2The restriction to a σ-ﬁeld of subsets is important technically to avoid paradoxes such as
the Banach-Tarski paradox. Informally, we can think of the σ-ﬁeld as restricting consideration
to “reasonable” subsets.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

A.8 Fourier Transforms

205

For a probability measure µ on x, the non-negative function p(x) is called

the density of the measure if for all A ∈ BD we have

µ(A) =

p(x) dx.

(A.28)

If such a density exists it is uniquely determined almost everywhere, i.e. except
for sets with measure zero. Not all probability measures have densities—only
distributions that assign zero probability to individual points in x-space can
have densities.3 If p(x) exists then we have

Z

f(x) dµ(x) =

f(x)p(x) dx.

(A.29)

Z

A

Z

If µ does not have a density expression (A.27) still has meaning by the standard
construction of the Lebesgue integral.

For Ω = RD the probability measure µ can be related to the distribution
function F : RD → [0, 1] which is deﬁned as F (z) = µ(x1 ≤ z1, . . . xD ≤
zD). The distribution function is more general than the density as it is always
deﬁned for a given probability measure. A simple example of a random variable
which has a distribution function but no density is obtained by the following
construction: a coin is tossed and with probability p it comes up heads; if it
comes up heads x is chosen from U(0, 1) (the uniform distribution on [0, 1]),
otherwise (with probability 1− p) x is set to 1/2. This distribution has a “point
mass” (or atom) at x = 1/2.

“point mass” example

A.7.1 Lp Spaces
Let µ be a measure on an input set X . For some function f : X → R and
1 ≤ p < ∞, we deﬁne

kfkLp(X ,µ) , (cid:16)Z

(cid:17)1/p

|f(x)|p dµ(x)

if the integral exists. For p = ∞ we deﬁne

kfkL∞(X ,µ) = ess sup
x∈X

|f(x)|,

,

(A.30)

(A.31)

where ess sup denotes the essential supremum, i.e. the smallest number that
upper bounds |f(x)| almost everywhere. The function space Lp(X , µ) is deﬁned
for any p in 1 ≤ p ≤ ∞ as the space of functions for which kfkLp(X ,µ) < ∞.

A.8 Fourier Transforms

For suﬃciently well-behaved functions on RD we have

f(x) =

˜f(s)e2πis·x ds,

˜f(s) =

f(x)e−2πis·x dx,

(A.32)

Z ∞

−∞

Z ∞

−∞

3A measure µ has a density if and only if it is absolutely continuous with respect to
Lebesgue measure on RD, i.e. every set that has Lebesgue measure zero also has µ-measure
zero.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

206

Mathematical Background

where ˜f(s) is called the Fourier transform of f(x), see e.g. Bracewell [1986].
We refer to the equation on the left as the synthesis equation, and the equation
on the right as the analysis equation. There are other conventions for Fourier
transforms, particularly those involving ω = 2πs. However, this tends to de-
stroy symmetry between the analysis and synthesis equations so we use the
deﬁnitions given above.

Here we have deﬁned Fourier transforms for f(x) being a function on RD.
For related transforms for periodic functions, functions deﬁned on the integer
lattice and on the regular N-polygon see section B.1.

A.9 Convexity

convex sets

convex function

Below we state some deﬁnitions and properties of convex sets and functions
taken from Boyd and Vandenberghe [2004].

A set C is convex if the line segment between any two points in C lies in C,

i.e. if for any x1, x2 ∈ C and for any θ with 0 ≤ θ ≤ 1, we have

(A.33)
A function f : X → R is convex if its domain X is a convex set and if for all
x1, x2 ∈ X and θ with 0 ≤ θ ≤ 1, we have:

θx1 + (1 − θ)x2 ∈ C.

f(θx1 + (1 − θ)x2) ≤ θf(x1) + (1 − θ)f(x2),

(A.34)
where X is a (possibly improper) subset of RD. f is concave if −f is convex.
A function f is convex if and only if its domain X is a convex set and its

Hessian is positive semideﬁnite for all x ∈ X .

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Appendix B

Gaussian Markov Processes

A discrete-time autoregressive (AR) process of order p can be written as

AR process

pX

Particularly when the index set for a stochastic process is one-dimensional such
as the real line or its discretization onto the integer lattice, it is very interesting
to investigate the properties of Gaussian Markov processes (GMPs). In this
Appendix we use X(t) to deﬁne a stochastic process with continuous time pa-
rameter t. In the discrete time case the process is denoted . . . , X−1, X0, X1, . . .
etc. We assume that the process has zero mean and is, unless otherwise stated,
stationary.

Xt =

akXt−k + b0Zt,

(B.1)

k=1

where Zt ∼ N (0, 1) and all Zt’s are i.i.d. . Notice the order-p Markov property
that given the history Xt−1, Xt−2, . . ., Xt depends only on the previous p X’s.
This relationship can be conveniently expressed as a graphical model; part of
an AR(2) process is illustrated in Figure B.1. The name autoregressive stems
from the fact that Xt is predicted from the p previous X’s through a regression
equation. If one stores the current X and the p − 1 previous values as a state
vector, then the AR(p) scalar process can be written equivalently as a vector
AR(1) process.

Figure B.1: Graphical model illustrating an AR(2) process.

Moving from the discrete time to the continuous time setting, the question
arises as to how generalize the Markov notion used in the discrete-time AR
process to deﬁne a continuoous-time AR process. It turns out that the correct
generalization uses the idea of having not only the function value but also p of
its derivatives at time t giving rise to the stochastic diﬀerential equation (SDE)1

SDE: stochastic
diﬀerential equation

. . .. . .C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

208

Gaussian Markov Processes

apX (p)(t) + ap−1X (p−1)(t) + . . . + a0X(t) = b0Z(t),

(B.2)
where X (i)(t) denotes the ith derivative of X(t) and Z(t) is a white Gaus-
sian noise process with covariance δ(t − t0). This white noise process can be
considered the derivative of the Wiener process. To avoid redundancy in the
coeﬃcients we assume that ap = 1. A considerable amount of mathemati-
cal machinery is required to make rigorous the meaning of such equations, see
e.g. Øksendal [1985]. As for the discrete-time case, one can write eq. (B.2) as
a ﬁrst-order vector SDE by deﬁning the state to be X(t) and its ﬁrst p − 1
derivatives.

We begin this chapter with a summary of some Fourier analysis results in
section B.1. Fourier analysis is important to linear time invariant systems such
as equations (B.1) and (B.2) because e2πist is an eigenfunction of the corre-
sponding diﬀerence (resp diﬀerential) operator. We then move on in section
B.2 to discuss continuous-time Gaussian Markov processes on the real line and
their relationship to the same SDE on the circle. In section B.3 we describe
discrete-time Gaussian Markov processes on the integer lattice and their re-
lationship to the same diﬀerence equation on the circle.
In section B.4 we
explain the relationship between discrete-time GMPs and the discrete sampling
of continuous-time GMPs. Finally in section B.5 we discuss generalizations
of the Markov concept in higher dimensions. Much of this material is quite
standard, although the relevant results are often scattered through diﬀerent
sources, and our aim is to provide a uniﬁed treatment. The relationship be-
tween the second-order properties of the SDEs on the real line and the circle,
and diﬀerence equations on the integer lattice and the regular polygon is, to
our knowledge, novel.

B.1 Fourier Analysis

We follow the treatment given by Kammler [2000]. We consider Fourier analysis
of functions on the real line R, of periodic functions of period l on the circle
Tl, of functions deﬁned on the integer lattice Z, and of functions on PN , the
regular N-polygon, which is a discretization of Tl.

For suﬃciently well-behaved functions on R we have

f(x) =

˜f(s)e2πisx ds,

˜f(s) =

f(x)e−2πisx dx.

(B.3)

We refer to the equation on the left as the synthesis equation, and the equation
on the right as the analysis equation.

For functions on Tl we obtain the Fourier series representations
f(x)e−2πikx/l dx,

˜f[k]e2πikx/l,

˜f[k] =

f(x) =

∞X

(B.4)

1The ak coeﬃcients in equations (B.1) and (B.2) are not intended to have a close relation-
ship. An approximate relationship might be established through the use of ﬁnite-diﬀerence
approximations to derivatives.

Z ∞

−∞

k=−∞

Z ∞

−∞

Z l

0

1
l

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

B.1 Fourier Analysis

209

Z l

0

N−1X

k=0

where ˜f[k] denotes the coeﬃcient of e2πikx/l in the expansion. We use square
] to denote that the argument is discrete, so that Xt and X[t] are
brackets [
equivalent notations.

Similarly for Z we obtain

f[n] =

˜f(s)e2πisn/l ds,

˜f(s) =

∞X

n=−∞

1
l

f[n]e−2πisn/l.

(B.5)

Note that ˜f(s) is periodic with period l and so is deﬁned only for 0 ≤ s < l to
avoid aliasing. Often this transform is deﬁned for the special case l = 1 but the
general case emphasizes the duality between equations (B.4) and (B.5).
Finally, for functions on PN we have the discrete Fourier transform

f[n] =

˜f[k]e2πikn/N ,

˜f[k] =

1
N

f[n]e−2πikn/N .

(B.6)

N−1X

n=0

Note that there are other conventions for Fourier transforms, particularly those
involving ω = 2πs. However, this tends to destroy symmetry between the
analysis and synthesis equations so we use the deﬁnitions given above.

In the case of stochastic processes, the most important Fourier relationship
is between the covariance function and the power spectrum; this is known as
the Wiener-Khintchine theorem, see e.g. Chatﬁeld [1989].

B.1.1 Sampling and Periodization
We can obtain relationships between functions and their transforms on R, Tl,
Z, PN through the notions of sampling and periodization.
Deﬁnition B.1 h-sampling: Given a function f on R and a spacing parameter
h > 0, we construct a corresponding discrete function φ on Z using

(B.7)
(cid:3)
Similarly we can discretize a function deﬁned on Tl onto PN , but in this case
we must take h = l/N so that N steps of size h will equal the period l.

φ[n] = f(nh),

n ∈ Z.

Deﬁnition B.2 Periodization by summation: Let f(x) be a function on R that
rapidly approaches 0 as x → ±∞. We can sum translates of the function to
produce the l-periodic function

g(x) =

f(x − ml),

(B.8)

for l > 0. Analogously, when φ is deﬁned on Z and φ[n] rapidly approaches 0
as n → ±∞ we can construct a function γ on PN by N-summation by setting

γ[n] =

φ[n − mN].

(B.9)
(cid:3)

∞X

m=−∞

∞X

m=−∞

h-sampling

periodization by
summation

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

210

Gaussian Markov Processes

Let φ[n] be obtained by h-sampling from f(x), with corresponding Fourier

transforms ˜φ(s) and ˜f(s). Then we have

Z ∞

−∞

φ[n] = f(nh) =

˜f(s)e2πisnh ds,

φ[n] =

˜φ(s)e2πisn/l ds.

By breaking up the domain of integration in eq. (B.10) we obtain

(B.10)

(B.11)

(B.12)

(B.13)

Z l

0

∞X
∞X

Z l

Z (m+1)l
Z l

ml

(cid:16) ∞X
∞X

m=−∞

m=−∞

∞X

m=−∞

φ[n] =

=

m=−∞

m=−∞

0

˜f(s)e2πisnh ds

˜f(s0 + ml)e2πinh(s0+ml) ds0,

using the change of variable s0 = s − ml. Now set hl = 1 and use e2πinm = 1
for n, m integers to obtain

φ[n] =

˜f(s + ml)

e2πisn/l ds,

(B.14)

(cid:17)

which implies that

0

˜φ(s) =

˜f(s + ml),

(B.15)

P∞

with l = 1/h. Alternatively setting l = 1 one obtains ˜φ(s) = 1
Similarly if f is deﬁned on Tl and φ[n] = f( nl

m=−∞ ˜f( s+m
h ).
N ) is obtained by sampling then

h

˜φ[n] =

˜f[n + mN].

(B.16)

Thus we see that sampling in x-space causes periodization in Fourier space.

periodic function g(x) ,P∞

Now consider the periodization of a function f(x) with x ∈ R to give the l-
m=−∞ f(x−ml). Let ˜g[k] be the Fourier coeﬃcients

of g(x). We obtain

Z l
Z ∞

0

−∞

˜g[k] =

=

1
l
1
l

g(x)e−2πikx/l dx =

1
l
f(x)e−2πikx/l dx =

Z l
∞X
(cid:16) k
(cid:17)

0

m=−∞

˜f

1
l

,

l

f(x − ml)e−2πikx/l dx (B.17)

(B.18)

assuming that f(x) is suﬃciently well-behaved that the summation and inte-
gration operations can be exchanged. A similar relationship can be obtained
for the periodization of a function deﬁned on Z. Thus we see that periodization
in x-space gives rise to sampling in Fourier space.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

B.2 Continuous-time Gaussian Markov Processes

211

B.2 Continuous-time Gaussian Markov Processes

We ﬁrst consider continuous-time Gaussian Markov processes on the real line,
and then relate the covariance function obtained to that for the stationary
solution of the SDE on the circle. Our treatment of continuous-time GMPs on
R follows Papoulis [1991, ch. 10].

B.2.1 Continuous-time GMPs on R

We wish to ﬁnd the power spectrum and covariance function for the stationary
process corresponding to the SDE given by eq. (B.2). Recall that the covariance
function of a stationary process k(t) and the power spectrum S(s) form a Fourier
transform pair.

The Fourier transform of the stochastic process X(t) is a stochastic process

Z ∞

−∞

˜X(s) given by

Z ∞

−∞

˜X(s) =

X(t)e−2πist dt,

X(t) =

˜X(s)e2πist ds,

(B.19)

where the integrals are interpreted as a mean-square limit. Let ∗ denote complex
conjugation and h. . .i denote expectation with respect to the stochastic process.
Then for a stationary Gaussian process we have

h ˜X(s1) ˜X∗(s2)i =

hX(t)X∗(t0)ie−2πis1te2πis2t0

dt dt0

Z ∞
Z ∞

−∞

Z ∞
dt0e−2πi(s1−s2)t0Z ∞

−∞

=
= S(s1)δ(s1 − s2),

−∞

dτ k(τ)e−2πis1τ

−∞

(B.20)

(B.21)

the delta function R e−2πistdt = δ(s). This shows that ˜X(s1) and ˜X(s2) are

(B.22)
using the change of variables τ = t − t0 and the integral representation of
uncorrelated for s1 6= s2, i.e. that the Fourier basis are eigenfunctions of the
diﬀerential operator. Also from eq. (B.19) we obtain

X (k)(t) =

(2πis)k ˜X(s)e2πist ds.

(B.23)

Now if we Fourier transform eq. (B.2) we obtain

ak(2πis)k ˜X(s) = b0 ˜Z(s),

(B.24)

Z ∞

−∞

pX

k=0

where ˜Z(s) denotes the Fourier transform of the white noise. Taking the product
of equation B.24 with its complex conjugate and taking expectations we obtain

(cid:20) pX

(cid:21)(cid:20) pX

(cid:21)

ak(2πis1)k

ak(−2πis2)k

h ˜X(s1) ˜X∗(s2)i = b2

0h ˜Z(s1) ˜Z∗(s2)i.

k=0

k=0

(B.25)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

212

AR(1) process

AR(p) process

Let A(z) = Pp

spectrum of white noise is 1, we obtain

k=0 akzk. Then using eq. (B.22) and the fact that the power

Gaussian Markov Processes

SR(s) =

b2
0

|A(2πis)|2 .

(B.26)

Note that the denominator is a polynomial of order p in s2. The relationship
of stationary solutions of pth-order SDEs to rational spectral densities can be
traced back at least as far as Doob [1944].

Above we have assumed that the process is stationary. However, this de-
pends on the coeﬃcients a0, . . . , ap. To analyze this issue we assume a solution
of the form Xt ∝ eλt when the driving term b0 = 0. This leads to the condition
k=0 akλk must lie in the left

for stationarity that the roots of the polynomialPp

half plane [Arat´o, 1982, p. 127].
Example: AR(1) process. In this case we have the SDE
X0(t) + a0X(t) = b0Z(t),

(B.27)

where a0 > 0 for stationarity. This gives rise to the power spectrum

S(s) =

b2
0

(2πis + a0)(−2πis + a0)

=

b2
0

(2πs)2 + a2
0

.

(B.28)

Taking the Fourier transform we obtain

k(t) = b2
0
2a0

e−a0|t|.

(B.29)

to the power spectrum S(s) = ([Pp

This process is known as the Ornstein-Uhlenbeck (OU) process [Uhlenbeck and
Ornstein, 1930] and was introduced as a mathematical model of the velocity of
a particle undergoing Brownian motion. It can be shown that the OU process
is the unique stationary ﬁrst-order Gaussian Markov process.
Example: AR(p) process.

In general the covariance transform corresponding
k=0 ak(−2πis)k])−1 can be
quite complicated. For example, Papoulis [1991, p. 326] gives three forms of
1 − 4a0 is
the covariance function for the AR(2) process depending on whether a2
greater than, equal to or less than 0. However, if the coeﬃcients a0, a1, . . . , ap
are chosen in a particular way then one can obtain

k=0 ak(2πis)k][Pp

S(s) =

1

(4π2s2 + α2)p

(B.30)

ance function is of the formPp−1

for some α.

It can be shown [Stein, 1999, p. 31] that the corresponding covari-
k=0 βk|t|ke−α|t| for some coeﬃcients β0, . . . , βp−1.
2α e−α|t| for the OU process. For
4α3 e−α|t|(1+α|t|). These are special cases of the Mat´ern

For p = 1 we have already seen that k(t) = 1
p = 2 we obtain k(t) = 1
class of covariance functions described in section 4.2.1.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

213

Wiener process

B.2 Continuous-time Gaussian Markov Processes

Example: Wiener process. Although our derivations have focussed on stationary
Gaussian Markov processes, there are also several important non-stationary
processes. One of the most important is the Wiener process that satisﬁes the
SDE X0(t) = Z(t) for t ≥ 0 with the initial condition X(0) = 0. This process
has covariance function k(t, s) = min(t, s). An interesting variant of the Wiener
process known as the Brownian bridge (or tied-down Wiener process) is obtained
by conditioning on the Wiener process passing through X(1) = 0. This has
covariance k(t, s) = min(t, s) − st for 0 ≤ s, t ≤ 1. See e.g. Grimmett and
Stirzaker [1992] for further information on these processes.

Markov processes derived from SDEs of order p are p− 1 times MS diﬀeren-
tiable. This is easy to see heuristically from eq. (B.2); given that a process gets
rougher the more times it is diﬀerentiated, eq. (B.2) tells us that X (p)(t) is like
the white noise process, i.e. not MS continuous. So, for example, the OU process
(and also the Wiener process) are MS continuous but not MS diﬀerentiable.

B.2.2 The Solution of the Corresponding SDE on the Cir-

cle

The analogous analysis to that on the real line is carried out on Tl using

X(t) =

˜X[n]e2πint/l,

˜X[n] =

1
l

X(t)e−2πint/ldt.

(B.31)

∞X

n=−∞

Z l

0

As X(t) is assumed stationary we obtain an analogous result to eq. (B.22),
i.e. that the Fourier coeﬃcients are independent

(cid:26) S[n]

0

pX

h ˜X[m] ˜X∗[n]i =

if m = n
otherwise.

(B.32)

P∞
Similarly, the covariance function on the cirle is given by k(t−s) = hX(t)X∗(s)i =
X (k)(t) =P∞
n=−∞ S[n]e2πin(t−s)/l. Let ωl = 2π/l. Then plugging in the expression
n=−∞(inωl)k ˜X[n]einωlt into the SDE eq. (B.2) and equating terms

in [n] we obtain

ak(inωl)k ˜X[n] = b0 ˜Z[n].

(B.33)

k=0

As in the real-line case we form the product of equation B.33 with its complex
conjugate and take expectations to give

b2
0

Note that ST[n] is equal to SR(cid:0) n

ST[n] =

|A(inωl)|2 .

(cid:1), i.e. that it is a sampling of SR at intervals

(B.34)

1/l, where SR(s) is the power spectrum of the continuous process on the real
line given in equation B.26. Let kT(h) denote the covariance function on the

l

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

214

Gaussian Markov Processes

circle and kR(h) denote the covariance function on the real line for the SDE.
Then using eq. (B.15) we ﬁnd that

∞X

m=−∞

kT(t) =

kR(t − ml).

1st order SDE

Example: 1st-order SDE. On R for the OU process we have kR(t) = b2
By summing the series (two geometric progressions) we obtain

0
2a0

kT(t) =

b2
0

2a0(1 − e−a0l)

(cid:16)

e−a0|t| + e−a0(l−|t|)(cid:17)

= b2
0
2a0

cosh[a0( l

2 − |t|)]
sinh( a0l
2 )

(B.36)

(B.35)

e−a0|t|.

for −l ≤ t ≤ l. Eq. (B.36) is also given (up to scaling factors) in Grenander
et al. [1991, eq. 2.15], where it is obtained by a limiting argument from the
discrete-time GMP on Pn, see section B.3.2.

B.3 Discrete-time Gaussian Markov Processes

We ﬁrst consider discrete-time Gaussian Markov processes on Z, and then re-
late the covariance function obtained to that of the stationary solution of the
diﬀerence equation on PN . Chatﬁeld [1989] and Diggle [1990] provide good
coverage of discrete-time ARMA models on Z.

B.3.1 Discrete-time GMPs on Z

Assuming that the process is stationary the covariance function k[i] denotes
hXtXt+ii ∀t ∈ Z. (Note that because of stationarity k[i] = k[−i].)

We ﬁrst use a Fourier approach to derive the power spectrum and hence the
covariance function of the AR(p) process. Deﬁning a0 = −1, we can rewrite

k=0 akXt−k + b0Zt = 0. The Fourier pair for X[t] is

∞X

t=−∞

˜X(s)e2πist/l ds,

˜X(s) =

1
l

X[t]e−2πist/l.

(B.37)

k=0 akXt−k + b0Zt = 0 we obtain

(cid:16) pX

ake−iωlsk(cid:17)

˜X(s)

+ b0 ˜Z(s) = 0,

(B.38)

eq. (B.1) asPp
Z l

X[t] =

Plugging this intoPp

0

k=0

where ωl = 2π/l. As above, taking the product of eq. (B.38) with its complex
conjugate and taking expectations we obtain

SZ(s) =

b2
0

|A(eiωls)|2 .

(B.39)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

B.3 Discrete-time Gaussian Markov Processes

215

Above we have assumed that the process is stationary. However, this de-
pends on the coeﬃcients a0, . . . , ap. To analyze this issue we assume a solution
of the form Xt ∝ zt when the driving term b0 = 0. This leads to the condition
k=0 akzp−k must lie inside

for stationarity that the roots of the polynomial Pp

the unit circle. See Hannan [1970, Theorem 5, p. 19] for further details.

As well as deriving the covariance function from the Fourier transform of
the power spectrum it can also be obtained by solving a set of linear equations.
Our ﬁrst observation is that Xs is independent of Zt for s < t. Multiplying
equation B.1 through by Zt and taking expectations, we obtain hXtZti = b0
and hXt−iZti = 0 for i > 0. By multiplying equation B.1 through by Xt−j for
j = 0, 1, . . . and taking expectations we obtain the Yule-Walker equations

Yule-Walker equations

AR(1) process

k[0] =

k[j] =

aik[i] + b2
0

aik[j − i]

∀j > 0.

(B.40)

(B.41)

The ﬁrst p + 1 of these equations form a linear system that can be used to solve
for k[0], . . . , k[p] in terms of b0 and a1, . . . , ap, and eq. (B.41) can be used to
obtain k[j] for j > p recursively.
Example: AR(1) process. The simplest example of an AR process is the AR(1)
process deﬁned as Xt = a1Xt−1 + b0Zt. This gives rise to the Yule-Walker
equations

k[0] − a1k[1] = b2

0, and k[1] − a1k[0] = 0.

(B.42)

0/(1 − a2

X, where
The linear system for k[0], k[1] can easily be solved to give k[j] = a
1) is the variance of the process. Notice that for the process to
X = b2
σ2
be stationary we require |a1| < 1. The corresponding power spectrum obtained
from equation B.39 is

|j|
1 σ2

S(s) =

b2
0

1 − 2a1 cos(ωls) + a2

1

.

(B.43)

Similarly to the continuous case, the covariance function for the discrete-time
AR(2) process has three diﬀerent forms depending on a2
1 + 4a2. These are
described in Diggle [1990, Example 3.6].

B.3.2 The Solution of the Corresponding Diﬀerence Equa-

tion on PN

We now consider variables X = X0, X1, . . . , XN−1 arranged around the circle
with N ≥ p. By appropriately modifying eq. (B.1) we obtain

Xt =

akXmod(t−k,N ) + b0Zt.

(B.44)

pX
pX

i=1

i=1

pX

k=1

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

216

Gaussian Markov Processes

PN−1

The Zt’s are i.i.d. and ∼ N (0, 1). Thus Z = Z0, Z1, . . . , ZN−1 has density
p(Z) ∝ exp− 1
t . Equation (B.44) shows that X and Z are related by
a linear transformation and thus

t=0 Z 2

2

p(X) ∝ exp

(cid:16)− 1

2b2
0

N−1X

(cid:16)

Xt − pX

t=0

k=1

(cid:17)2(cid:17)

akXmod(t−k,N )

.

(B.45)

This is an N-dimensional multivariate Gaussian. For an AR(p) process the
inverse covariance matrix has a circulant structure [Davis, 1979] consisting of
a diagonal band (2p + 1) entries wide and appropriate circulant entries in the
corners. Thus p(Xt|X\ Xt) = p(Xt|Xmod(t−1,N ), . . . , Xmod(t−p,N ), Xmod(t+1,N ),
. . . , Xmod(t+p,N )), which Geman and Geman [1984] call the “two-sided” Markov
property. Notice that it is the zeros in the inverse covariance matrix that
indicate the conditional independence structure; see also section B.5.

The properties of eq. (B.44) have been studied by a number of authors,
e.g. Whittle [1963] (under the name of circulant processes), Kashyap and Chel-
lappa [1981] (under the name of circular autoregressive models) and Grenander
et al. [1991] (as cyclic Markov process).

As above, we deﬁne the Fourier transform pair

X[n] =

˜X[m]e2πinm/N ,

˜X[m] =

1
N

X[n]e−2πinm/N .

(B.46)

N−1X

n=0

N−1X

m=0

pX

By similar arguments to those above we obtain

ak ˜X[m](e2πim/N )k + b0 ˜Z[m] = 0,

(B.47)

where a0 = −1, and thus

k=0

SP[m] =

b2
0

|A(e2πim/N )|2

.

(B.48)

As in the continuous-time case, we see that SP[m] is obtained by sampling
the power spectrum of the corresponding process on the line, so that SP[m] =

SZ(cid:0) ml

N

(cid:1). Thus using eq. (B.16) we have
∞X

kP[n] =

m=−∞

kZ[n + mN].

(B.49)

AR(1) process

Example: AR(1) process. For this process Xt = a1Xmod(t−1,n) + b0Zt, the
diagonal entries in the inverse covariance are (1 + a2
0 and the non-zero oﬀ-
diagonal entries are −a1/b2
0.

1)/b2

By summing the covariance function kZ[n] = σ2

|n|
1 we obtain

X a

kP[n] =

σ2
X

(1 − aN
1 )

|n|
1 + a

|N−n|
1

(a

)

n = 0, . . . , N − 1.

(B.50)

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

B.4 The Relationship Between Discrete-time and Sampled Continuous-time GMPs

217

We now illustrate this result for N = 3. In this case the covariance matrix has
diagonal entries of
1).
1)(a1 + a2
The inverse covariance matrix has the structure described above. Multiplying
these two matrices together we do indeed obtain the identity matrix.

1) and oﬀ-diagonal entries of

σ2
X
(1−a3

σ2
X
(1−a3

1)(1 + a3

B.4 The Relationship Between Discrete-time and

Sampled Continuous-time GMPs

We now consider the relationship between continuous-time and discrete-time
GMPs. In particular we ask the question, is a regular sampling of a continuous-
time AR(p) process a discrete-time AR(p) process? It turns out that the answer
will, in general, be negative. First we deﬁne a generalization of AR processes
known as autoregressive moving-average (ARMA) processes.

ARMA processes The AR(p) process deﬁned above is a special case of the
more general ARMA(p, q) process which is deﬁned as

pX

qX

Xt =

aiXt−i +

bjZt−j.

(B.51)

i=1

j=0

Observe that the AR(p) process is in fact also an ARMA(p, 0) process. A
spectral analysis of equation B.51 similar to that performed in section B.3.1
gives

(B.52)

(B.53)

where B(z) =Pq

density of the form

S(s) =

|B(eiωls)|2
|A(eiωls)|2 ,

S(s) =

|B(2πis)|2
|A(2πis)|2

j=0 bjzj. In continuous time a process with a rational spectral

we require q < p as k(0) =R S(s)ds < ∞.

is known as a ARMA(p, q) process. For this to deﬁne a valid covariance function

Discrete-time observation of a continuous-time process Let X(t) be
a continuous-time process having covariance function k(t) and power spectrum
S(s). Let Xh be the discrete-time process obtained by sampling X(t) at interval
h, so that Xh[n] = X(nh) for n ∈ Z. Clearly the covariance function of this
process is given by kh[n] = k(nh). By eq. (B.15) this means that

∞X

m=−∞

Sh(s) =

S(s + m
h

)

(B.54)

where Sh(s) is deﬁned using l = 1/h.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

218

Gaussian Markov Processes

Theorem B.1 Let X be a continuous-time stationary Gaussian process and
Xh be the discretization of this process. If X is an ARMA process then Xh
is also an ARMA process. However, if X is an AR process then Xh is not
(cid:3)
necessarily an AR process.

The proof is given in Ihara [1993, Theorem 2.7.1]. It is easy to see using the
covariance functions given in sections B.2.1 and B.3.1 that the discretization
of a continuous-time AR(1) process is indeed a discrete-time AR(1) process.
However, Ihara shows that, in general, the discretization of a continuous-time
AR(2) process is not a discrete-time AR(2) process.

B.5 Markov Processes in Higher Dimensions

We have concentrated above on the case where t is one-dimensional. In higher
dimensions it is interesting to ask how the Markov property might be general-
ized. Let ∂S be an inﬁnitely diﬀerentiable closed surface separating RD into a
bounded part S− and an unbounded part S+. Loosely speaking2 a random ﬁeld
X(t) is said to be quasi-Markovian if X(t) for t ∈ S− and X(u) for u ∈ S+ are
independent given X(s) for s ∈ ∂S. Wong [1971] showed that the only isotropic
quasi-Markov Gaussian ﬁeld with a continuous covariance function is the degen-
erate case X(t) = X(0), where X(0) is a Gaussian variate. However, if instead
of conditioning on the values that the ﬁeld takes on in ∂S, one conditions on
a somewhat larger set, then Gaussian random ﬁelds with non-trivial Markov-
type structure can be obtained. For example, random ﬁelds with an inverse
j=1 kj ≤ 2p
pseudo-Markovian of order p. For example, the D-dimensional tensor-product
i=1 e−αi|ti| is pseudo-Markovian of order D. For
further discussion of Markov properties of random ﬁelds see the Appendix in
Adler [1981].

power spectrum of the formP
and C(s · s)p ≤(cid:12)(cid:12)P
of the OU process k(t) = QD

d with k>1 =PD
(cid:12)(cid:12) for some C > 0 are said to be

k ak1,...,kD sk1
1 ··· skd

k>1=2p ak1,...,kD sk1

1 ··· skd

D

If instead of RD we wish to deﬁne a Markov random ﬁeld (MRF) on a graph-
ical structure (for example the lattice ZD) things become more straightforward.
We follow the presentation in Jordan [2005]. Let G = (X, E) be a graph where
X is a set of nodes that are in one-to-one correspondence with a set of ran-
dom variables, and E be the set of undirected edges of the graph. Let C be
the set of all maximal cliques of G. A potential function ψC(xC) is a function
on the possible realizations xC of the maximal clique XC. Potential functions
are assumed to be (strictly) positive, real-valued functions. The probability
distribution p(x) corresponding to the Markov random ﬁeld is given by

Y
function) obtained by summing/integratingQ

p(x) =

C∈C

1
Z

ψC(xC),

(B.55)

where Z is a normalization factor (known in statistical physics as the partition
C∈C ψC(xC) over all possible as-

2For a precise formulation of this deﬁnition involving σ-ﬁelds see Adler [1981, p. 256].

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

B.5 Markov Processes in Higher Dimensions

219

signments of values to the nodes X. Under this deﬁnition it is easy to show
that a local Markov property holds, i.e. that for any variable x the conditional
distribution of x given all other variables in X depends only on those variables
that are neighbours of x. A useful reference on Markov random ﬁelds is Winkler
[1995].

A simple example of a Gaussian Markov random ﬁeld has the form

,

(B.56)

(cid:16)− α1

X

X

(xi − xj)2(cid:17)

p(x) ∝ exp

i − α2
x2

i

i,j:j∈N (i)

where N(i) denotes the set of neighbours of node xi and α1, α2 > 0. On Z2
one might choose a four-connected neighbourhood, i.e. those nodes to the north,
south, east and west of a given node.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Appendix C

Datasets and Code

The datasets used for experiments in this book and implementations of the
algorithms presented are available for download at the website of the book:

http://www.GaussianProcess.org/gpml

The programs are short stand-alone implementations and not part of a larger
package. They are meant to be simple to understand and modify for a desired
purpose. Some of the programs allow speciﬁcation of covariance functions from
a selection provided, or to link in user deﬁned covariance code. For some of
the plots, code is provided which produces a similar plot, as this may be a
convenient way of conveying the details.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

Abrahamsen, P. (1997). A Review of Gaussian Random Fields and Correlation Functions. Tech-
http://publications.nr.no/
p. 82

nical Report 917, Norwegian Computing Center, Oslo, Norway.
917 Rapport.pdf.

Abramowitz, M. and Stegun, I. A. (1965). Handbook of Mathematical Functions. Dover, New York.
pp. 84, 85

Adams, R. (1975). Sobolev Spaces. Academic Press, New York.

p. 134

Adler, R. J. (1981). The Geometry of Random Fields. Wiley, Chichester.

pp. 80, 81, 83, 191, 218

Amari, S. (1985). Diﬀerential-Geometrical Methods in Statistics. Springer-Verlag, Berlin.

p. 102

Ansley, C. F. and Kohn, R. (1985). Estimation, Filtering, and Smoothing in State Space Models with
p. 29

Incompletely Speciﬁed Initial Conditions. Annals of Statistics, 13(4):1286–1316.

Arat´o, M. (1982). Linear Stochastic Systems with Constant Coeﬃcients. Springer-Verlag, Berlin. Lecture
p. 212

Notes in Control and Information Sciences 45.

Arfken, G. (1985). Mathematical Methods for Physicists. Academic Press, San Diego.

pp. xv, 134

Aronszajn, N. (1950). Theory of Reproducing Kernels. Trans. Amer. Math. Soc., 68:337–404.
pp. 129, 130

Bach, F. R. and Jordan, M. I. (2002). Kernel Independent Component Analysis. Journal of Machine
p. 97

Learning Research, 3(1):1–48.

Baker, C. T. H. (1977). The Numerical Treatment of Integral Equations. Clarendon Press, Oxford.
pp. 98, 99

Barber, D. and Saad, D. (1996). Does Extra Knowledge Necessarily Improve Generalisation? Neural
p. 31

Computation, 8:202–214.

Bartle, R. G. (1995). The Elements of Integration and Lebesgue Measure. Wiley, New York.

p. 204

Bartlett, P. L., Jordan, M. I., and McAuliﬀe, J. D. (2003). Convexity, Classiﬁcation and Risk Bounds.
Technical Report 638, Department of Statistics, University of California, Berkeley. Available from
http://www.stat.berkeley.edu/tech-reports/638.pdf. Accepted for publication in Journal of the
American Statistical Association.
p. 157

Berger, J. O. (1985). Statistical Decision Theory and Bayesian Analysis. Springer, New York. Second
pp. 22, 35

edition.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

224

Bibliography

Bishop, C. M. (1995). Neural Networks for Pattern Recognition. Clarendon Press, Oxford.

p. 45

Bishop, C. M., Svensen, M., and Williams, C. K. I. (1998a). Developments of the Generative Topographic
p. 196

Mapping. Neurocomputing, 21:203–224.

Bishop, C. M., Svensen, M., and Williams, C. K. I. (1998b). GTM: The Generative Topographic
p. 196

Mapping. Neural Computation, 10(1):215–234.

Blake, I. F. and Lindsey, W. C. (1973). Level-Crossing Problems for Random Processes. IEEE Trans
p. 81

Information Theory, 19(3):295–315.

Blight, B. J. N. and Ott, L. (1975). A Bayesian approach to model inadequacy for polynomial regression.
p. 28

Biometrika, 62(1):79–88.

Boyd, S. and Vandenberghe, L. (2004). Convex Optimization. Cambridge University Press, Cambridge,
p. 206

UK.

Boyle, P. and Frean, M. (2005). Dependent Gaussian Processes. In Saul, L. K., Weiss, Y., and Bottou,
L., editors, Advances in Neural Information Processing Systems 17, pages 217–224. MIT Press. p. 190

Bracewell, R. N. (1986). The Fourier Transform and Its Applications. McGraw-Hill, Singapore, inter-
pp. 83, 206

national edition.

Caruana, R. (1997). Multitask Learning. Machine Learning, 28(1):41–75.

p. 115

Chatﬁeld, C. (1989). The Analysis of Time Series: An Introduction. Chapman and Hall, London, 4th
pp. 82, 209, 214

edition.

Choi, T. and Schervish, M. J. (2004). Posterior Consistency in Nonparametric Regression Prob-
lems Under Gaussian Process Priors. Technical Report 809, Department of Statistics, CMU.
http://www.stat.cmu.edu/tr/tr809/tr809.html.
p. 156

Choudhuri, N., Ghosal, S., and Roy, A. (2005). Nonparametric Binary Regression Using a Gaussian
p. 156

Process Prior. Unpublished. http://www4.stat.ncsu.edu/∼sghosal/papers.html.

Chu, W. and Ghahramani, Z. (2005). Gaussian Processes for Ordinal Regression. Journal of Machine
p. 191

Learning Research, 6:1019–1041.

Collins, M. and Duﬀy, N. (2002). Convolution Kernels for Natural Language. In Diettrich, T. G., Becker,
S., and Ghahramani, Z., editors, Advances in Neural Information Processing Systems 14. MIT Press.
p. 101

Collobert, R. and Bengio, S. (2001).

gression Problems.
∼bengio/projects/SVMTorch.html.

Journal of Machine Learning Research, 1:143–160.

SVMTorch: Support Vector Machines for Large-Scale Re-
http://www.idiap.ch/
pp. 69, 72

Cornford, D., Nabney, I. T., and Williams, C. K. I. (2002). Modelling Frontal Discontinuities in Wind
p. 85

Fields. Journal of Nonparameteric Statsitics, 14(1-2):43–58.

Cox, D. D. (1984). Multivariate Smoothing Spline Functions. SIAM Journal on Numerical Analysis,
p. 156

21(4):789–813.

Cox, D. D. and O’Sullivan, F. (1990). Asymptotic Analysis of Penalized Likelihood and Related Esti-
p. 156

mators. Annals of Statistics, 18(4):1676–1695.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

225

Craven, P. and Wahba, G. (1979). Smoothing Noisy Data with Spline Functions. Numer. Math., 31:377–
p. 112

403.

Cressie, N. A. C. (1993). Statistics for Spatial Data. Wiley, New York.

pp. 30, 137, 190

Cristianini, N. and Shawe-Taylor, J. (2000). An Introduction to Support Vector Machines. Cambridge
p. 141

University Press.

Cristianini, N., Shawe-Taylor, J., Elisseeﬀ, A., and Kandola, J. (2002). On Kernel-Target Alignment. In
Diettrich, T. G., Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing
Systems 14. MIT Press.
p. 128

Csat´o, L. (2002). Gaussian Processes—Iterative Sparse Approximations. PhD thesis, Aston University,
p. 179

UK.

Csat´o, L. and Opper, M. (2002). Sparse On-Line Gaussian Processes. Neural Computation, 14(3):641–
pp. 180, 185

668.

Csat´o, L., Opper, M., and Winther, O. (2002). TAP Gibbs Free Energy, Belief Propagation and Spar-
sity. In Diettrich, T. G., Becker, S., and Ghahramani, Z., editors, Advances in Neural Information
Processing Systems 14, pages 657–663. MIT Press.
pp. 180, 185

Daley, R. (1991). Atmospheric Data Analysis. Cambridge University Press, Cambridge, UK.

p. 30

David, H. A. (1970). Order Statistics. Wiley, New York.

Davis, P. J. (1979). Circulant Matrices. Wiley, New York.

Dawid, A. P. (1976). Properties of Diagnostic Data Distributions. Biometrics, 32:647–658.

pp. 169, 170

p. 216

p. 34

Dellaportas, P. and Stephens, D. A. (1995). Bayesian Analysis of Errors-in-Variables Regression Models.
p. 192

Biometrics, 51:1085–1095.

Devroye, L., Gy¨orﬁ, L., and Lugosi, G. (1996). A Probabilistic Theory of Pattern Recognition. Springer,
pp. 156, 166

New York.

Diaconis, P. and Freedman, D. (1986). On the Consistency of Bayes Estimates. Annals of Statistics,
p. 156

14(1):1–26.

Diggle, P. J. (1990). Time Series: A Biostatistical Introduction. Clarendon Press, Oxford. pp. 214, 215

Diggle, P. J., Tawn, J. A., and Moyeed, R. A. (1998). Model-based Geostatistics (with discussion).
p. 191

Applied Statistics, 47:299–350.

Doob, J. L. (1944). The Elementary Gaussian Processes. Annals of Mathematical Statistics, 15(3):229–
p. 212

282.

Doob, J. L. (1994). Measure Theory. Springer-Verlag, New York.

p. 204

Drineas, P. and Mahoney, M. W. (2005). On the Nystr¨om Method for Approximating a Gram Ma-
trix for Improved Kernel-Based Learning. Technical Report YALEU/DCS/TR-1319, Yale University.
p. 174
http://cs-www.cs.yale.edu/homes/mmahoney.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

226

Bibliography

Duchon, J. (1977). Splines Minimizing Rotation-Invariant Semi-norms in Sobolev Spaces. In Schempp,
W. and Zeller, K., editors, Constructive Theory of Functions of Several Variables, pages 85–100.
Springer-Verlag.
p. 137

Duda, R. O. and Hart, P. E. (1973). Pattern Classiﬁcation and Scene Analysis. John Wiley, New York.
p. 146

Edgeworth, F. Y. (1887). On Observations Relating to Several Quantities. Hermathena, 6:279–285.
p. 146

Faul, A. C. and Tipping, M. E. (2002). Analysis of Sparse Bayesian Learning. In Dietterich, T. G.,
Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing Systems 14,
pages 383–389, Cambridge, Massachussetts. MIT Press.
p. 149

Feldman, J. (1958). Equivalence and Perpendicularity of Gaussian Processes. Paciﬁc J. Math., 8:699–
p. 157

708. Erratum in Paciﬁc J. Math. 9, 1295-1296 (1959).

Ferrari Trecate, G., Williams, C. K. I., and Opper, M. (1999). Finite-dimensional Approximation of
Gaussian Processes. In Kearns, M. S., Solla, S. A., and Cohn, D. A., editors, Advances in Neural
Information Processing Systems 11, pages 218–224. MIT Press.
p. 152

Fine, S. and Scheinberg, K. (2002). Eﬃcient SVM Training Using Low-Rank Kernel Representations.
pp. 47, 174

Journal of Machine Learning Research, 2(2):243–264.

Fowlkes, C., Belongie, S., and Malik, J. (2001). Eﬃcient Spatiotemporal Grouping Using the Nystr¨om
Method. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, CVPR
2001.
p. 172

Freedman, D. (1999). On the Bernstein-Von Mises Theorem with Inﬁnite-Dimensional Parameters.
p. 156

Annals of Statistics, 27(4):1119–1140.

Frieze, A., Kannan, R., and Vempala, S. (1998). Fast Monte-Carlo Algorithms for Finding Low-Rank
Approximations. In 39th Conference on the Foundations of Computer Science, pages 370–378. p. 174

Geisser, S. and Eddy, W. F. (1979). A Predictive Approach to Model Selection. Journal of the Americal
p. 117

Statistical Association, 74(365):153–160.

Geman, S. and Geman, D. (1984). Stochastic Relaxation, Gibbs Distributions, and the Bayesian Restora-
p. 216

tion of Images. IEEE Trans. Pattern Analysis and Machine Intellligence, 6(6):721–741.

Gibbs, M. N. (1997). Bayesian Gaussian Processes for Regression and Classiﬁcation. PhD thesis,
p. 93

Department of Physics, University of Cambridge.

Gibbs, M. N. and MacKay, D. J. C. (1997). Eﬃcient Implementation of Gaussian Processes. Unpub-
lished manuscript. Cavendish Laboratory, Cambridge, UK. http://www.inference.phy.cam.ac.uk/
mackay/BayesGP.html.
p. 181

Gibbs, M. N. and MacKay, D. J. C. (2000). Variational Gaussian Process Classiﬁers. IEEE Transactions
p. 41

on Neural Networks, 11(6):1458–1464.

Gihman, I. I. and Skorohod, A. V. (1974). The Theory of Stochastic Processes, volume 1. Springer
p. 82

Verlag, Berlin.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

227

Girard, A., Rasmussen, C. E., Qui˜nonero-Candela, J., and Murray-Smith, R. (2003). Gaussian Process
Priors With Uncertain Inputs: Application to Multiple-Step Ahead Time Series Forecasting. In Becker,
S., Thrun, S., and Obermayer, K., editors, Advances in Neural Information Processing Systems 15.
MIT Press.
p. 192

Girosi, F. (1991). Models of Noise and Robust Estimates. Technical Report AI Memo 1287, MIT AI
p. 146

Laboratory.

Girosi, F., Jones, M., and Poggio, T. (1995). Regularization Theory and Neural Networks Architectures.
p. 25

Neural Computation, 7(2):219–269.

Goldberg, P. W., Williams, C. K. I., and Bishop, C. M. (1998). Regression with Input-dependent Noise:
A Gaussian Process Treatment. In Jordan, M. I., Kearns, M. J., and Solla, S. A., editors, Advances
p. 191
in Neural Information Processing Systems 10. MIT Press, Cambridge, MA.

Golub, G. H. and Van Loan, C. F. (1989). Matrix Computations. Johns Hopkins University Press,
pp. 172, 173, 174, 181, 202

Baltimore. Second edition.

Gradshteyn, I. S. and Ryzhik, I. M. (1980). Tables of Integrals, Series and Products. Academic Press.
pp. 98, 103

Corrected and enlarged edition prepared by A. Jeﬀrey.

Green, P. J. and Silverman, B. W. (1994). Nonparametric Regression and Generalized Linear Models.
p. 138

Chapman and Hall, London.

Grenander, U., Chow, Y., and Keenan, D. M. (1991). Hands: A Pattern Theoretic Study of Biological
pp. 214, 216

Shapes. Springer-Verlag, New York.

Grimmett, G. R. and Stirzaker, D. R. (1992). Probability and Random Processes. Oxford University
pp. 94, 213

Press, Oxford, England, second edition.

Gr¨unwald, P. D. and Langford, J. (2004). Suboptimal Behaviour of Bayes and MDL in Classiﬁcation
Under Misspeciﬁcation. In Proc. Seventeenth Annual Conference on Computational Learning Theory
p. 156
(COLT 2004).

Gy¨orﬁ, L., Kohler, M., Krzy˙zak, A., and Walk, H. (2002). A Distribution-Free Theory of Nonparametric
p. 156

Regression. Springer, New York.

Hajek, J. (1958). On a Property of Normal Distributions of Any Stochastic Process (In Russian).
Czechoslovak Math. J., 8:610–618. Translated in Selected Trans. Math. Statist. Probab. 1 245-252
(1961). Also available in Collected Works of Jaroslav Hajek, eds. M. Huˇskov´a, R. Beran, V. Dupaˇc,
Wiley, (1998).
p. 157

Hand, D. J., Mannila, H., and Smyth, P. (2001). Principles of Data Mining. MIT Press.

Hannan, E. J. (1970). Multiple Time Series. Wiley, New York.

p. 100

p. 215

Hansen, L. K., Liisberg, C., and Salamon, P. (1997). The Error-Reject Tradeoﬀ. Open Sys. & Information
p. 36

Dyn., 4:159–184.

Hastie, T. J. and Tibshirani, R. J. (1990). Generalized Additive Models. Chapman and Hall. pp. 24, 25, 95

Haussler, D. (1999). Convolution Kernels on Discrete Structures. Technical Report UCSC-CRL-99-10,
p. 101

Dept of Computer Science, University of California at Santa Cruz.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

228

Bibliography

Hawkins, D. L. (1989). Some Practical Problems in Implementing a Certain Sieve Estimator of the
Gaussian Mean Function. Communications in Statistics—Simulation and Computation, 18(2):481–
500.
p. 97

Hoerl, A. E. and Kennard, R. W. (1970). Ridge Regression: Biased Estimation for Nonorthogonal
p. 11

Problems. Technometrics, 12(1):55–67.

Hornik, K. (1993). Some New Results on Neural Network Approximation. Neural Networks, 6(8):1069–
p. 90

1072.

Ihara, S. (1993). Information Theory for Continuous Systems. World Scientiﬁc, Singapore.

p. 218

Jaakkola, T. S., Diekhans, M., and Haussler, D. (2000). A Discriminative Framework for Detecting
pp. 101, 102, 104

Remote Protein Homologies. Journal of Computational Biology, 7:95–114.

Jaakkola, T. S. and Haussler, D. (1999). Probabilistic Kernel Regression Models. In Heckerman, D. and
Whittaker, J., editors, Workshop on Artiﬁcial Intelligence and Statistics 7. Morgan Kaufmann. p. 41

Jacobs, R. A., Jordan, M. I., Nowlan, S. J., and Hinton, G. E. (1991). Adaptive Mixtures of Local
p. 192

Experts. Neural Computation, 3:79–87.

Johnson, N. L., Kotz, S., and Balakrishnan, N. (1995). Continuous Univariate Distributions volume 2.
p. 45

John Wiley and Sons, New York, second edition.

Jones, D. R. (2001). A Taxonomy of Global Optimization Methods Based on Response Surfaces. J.
p. 193

Global Optimization, 21:345–383.

Jordan, M. I. (2005). An Introduction to Probabilistic Graphical Models. Draft book.

Journel, A. G. and Huijbregts, C. J. (1978). Mining Geostatistics. Academic Press.

p. 218

p. 30

Kailath, T. (1971). RKHS Approach to Detection and Estimation Problems—Part I: Deterministic
p. 131

Signals in Gaussian Noise. IEEE Trans. Information Theory, 17(5):530–549.

Kammler, D. W. (2000). A First Course in Fourier Analysis. Prentice-Hall, Upper Saddle River, NJ.
p. 208

Kashyap, R. L. and Chellappa, R. (1981). Stochastic Models for Closed Boundary Analysis: Represen-
p. 216

tation and Reconstruction. IEEE Trans. on Information Theory, 27(5):627–637.

Keeling, C. D. and Whorf, T. P. (2004). Atmospheric CO2 Records from Sites in the SIO Air Sampling
Network. In Trends: A Compendium of Data on Global Change. Carbon Dioxide Information Analysis
p. 119
Center, Oak Ridge National Laboratory, Oak Ridge, Tenn., U.S.A.

Kent, J. T. and Mardia, K. V. (1994). The Link Between Kriging and Thin-plate Splines. In Kelly,
p. 137

F. P., editor, Probability, Statsitics and Optimization, pages 325–339. Wiley.

Kimeldorf, G. and Wahba, G. (1970). A Correspondence between Bayesian Estimation of Stochastic
p. 136

Processes and Smoothing by Splines. Annals of Mathematical Statistics, 41:495–502.

Kimeldorf, G. and Wahba, G. (1971). Some Results on Tchebycheﬃan Spline Functions. J. Mathematical
p. 132

Analysis and Applications, 33(1):82–95.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

229

Kohn, R. and Ansley, C. F. (1987). A New Algorithm for Spline Smoothing based on Smoothing a
p. 141

Stochastic Process. SIAM J. Sci. Stat. Comput., 8(1):33–48.

Kolmogorov, A. N. (1941). Interpolation und Extrapolation von station¨aren zuf¨aligen Folgen. Izv. Akad.
p. 29

Nauk SSSR, 5:3–14.

K¨onig, H. (1986). Eigenvalue Distribution of Compact Operators. Birkh¨auser.

Kullback, S. (1959). Information Theory and Statistics. Dover, New York.

p. 96

pp. 158, 203

Kuss, M. and Rasmussen, C. E. (2005). Assessing Approximations for Gaussian Process Classiﬁcation.
In Weiss, Y., Sch¨olkopf, B., and Platt, J., editors, Advances in Neural Information Processing Systems
18. MIT Press.
pp. 72, 73

Lanckriet, G. R. G., Cristianini, N., Bartlett, P. L., El Ghaoui, L., and Jordan, M. I. (2004). Learning the
Kernel Matrix with Semideﬁnite Programming. Journal of Machine Learning Research, 5(1):27–72.
p. 128

Lauritzen, S. L. (1981). Time Series Analysis in 1880: A Discussion of Contributions Made by
p. 29

T. N. Thiele. International Statistical Review, 49:319–333.

Lawrence, N. (2004). Gaussian Process Latent Variable Models for Visualization of High Dimensional
Data. In Thrun, S., Saul, L., and Sch¨olkopf, B., editors, Advances in Neural Information Processing
p. 196
Systems 16, pages 329–336. MIT Press.

Lawrence, N., Seeger, M., and Herbrich, R. (2003). Fast Sparse Gaussian Process Methods: The Infor-
mative Vector Machine. In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural
pp. 178, 185
Information Processing Systems 15, pages 625–632. MIT Press.

Leslie, C., Eskin, E., Weston, J., and Staﬀord Noble, W. (2003). Mismatch String Kernels for SVM
In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural
pp. 100, 101, 104

Protein Classiﬁcation.
Information Processing Systems 15. MIT Press.

Lin, X., Wahba, G., Xiang, D., Gao, F., Klein, R., and Klein, B. (2000). Smoothing Spline ANOVA
Models for Large Data Sets With Bernoulli Observations and the Randomized GACV. Annals of
Statistics, 28:1570–1600.
p. 185

Lindley, D. V. (1985). Making Decisions. John Wiley and Sons, London, UK, second edition.

p. 111

Lodhi, H., Shawe-Taylor, J., Cristianini, N., and Watkins, C. J. C. H. (2001). Text Classiﬁcation using
String Kernels. In Leen, T. K., Diettrich, T. G., and Tresp, V., editors, Advances in Neural Information
p. 101
Processing Systems 13. MIT Press.

Luo, Z. and Wahba, G. (1997). Hybrid Adaptive Splines. J. Amer. Statist. Assoc., 92:107–116. p. 176

MacKay, D. J. C. (1992a). A Practical Bayesian Framework for Backpropagation Networks. Neural
pp. 109, 166, 167

Computation, 4(3):448–472.

MacKay, D. J. C. (1992b). Bayesian Interpolation. Neural Computation, 4(3):415–447. pp. xiii, xvi, 109

MacKay, D. J. C. (1992c). Information-Based Objective Functions for Active Data Selection. Neural
p. 178

Computation, 4(4):590–604.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

230

Bibliography

MacKay, D. J. C. (1992d). The Evidence Framework Applied to Classiﬁcation Networks. Neural Com-
p. 45

putation, 4(5):720–736.

MacKay, D. J. C. (1998). Introduction to Gaussian Processes. In Bishop, C. M., editor, Neural Networks
pp. 84, 92

and Machine Learning. Springer-Verlag.

MacKay, D. J. C. (1999). Comparison of Approximate Methods for Handling Hyperparameters. Neural
p. 110

Computation, 11(5):1035–1068.

MacKay, D. J. C. (2003). Information Theory, Inference, and Learning Algorithms. Cambridge Univer-
pp. xiv, 167

sity Press, Cambridge, UK.

Malzahn, D. and Opper, M. (2002). A Variational Approach to Learning Curves. In Diettrich, T. G.,
Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing Systems 14. MIT
Press.
p. 161

Mandelbrot, B. B. (1982). The Fractal Geometry of Nature. W. H. Freeman, San Francisco.

p. 137

Mardia, K. V. and Marshall, R. J. (1984). Maximum Likelihood Estimation for Models of Residual
p. 115

Covariance in Spatial Regression. Biometrika, 71(1):135–146.

Mat´ern, B. (1960). Spatial Variation. Meddelanden fr˚an Statens Skogsforskningsinstitut, 49, No.5.
pp. 85, 87, 89

Alm¨anna F¨orlaget, Stockholm. Second edition (1986), Springer-Verlag, Berlin.

Matheron, G. (1973). The Intrinsic Random Functions and Their Applications. Advances in Applied
p. 30

Probability, 5:439–468.

Maxwell, J. C. (1850). Letter to Lewis Campbell; reproduced in L. Campbell and W. Garrett, The Life
p. v

of James Clerk Maxwell, Macmillan, 1881.

McAllester, D. (2003). PAC-Bayesian Stochastic Model Selection. Machine Learning, 51(1):5–21. p. 164

McCullagh, P. and Nelder, J. (1983). Generalized Linear Models. Chapman and Hall.

pp. 37, 38, 138

Meinguet, J. (1979). Multivariate Interpolation at Arbitrary Points Made Simple. Journal of Applied
p. 137

Mathematics and Physics (ZAMP), 30:292–304.

Meir, R. and Zhang, T. (2003). Generalization Error Bounds for Bayesian Mixture Algorithms. Journal
p. 164

of Machine Learning Research, 4(5):839–860.

Micchelli, C. A. and Pontil, M. (2005). Kernels for Multi-task Learning.

In Saul, L. K., Weiss, Y.,
and Bottou, L., editors, Advances in Neural Information Processing Systems 17, pages 921–928. MIT
p. 190
Press.

Micchelli, C. A. and Wahba, G. (1981). Design Problems for Optimal Surface Interpolation. In Ziegler,
p. 161

Z., editor, Approximation Theory and Applications, pages 329–348. Academic Press.

Minka, T. P. (2001). A Family of Algorithms for Approximate Bayesian Inference. PhD thesis, Mas-
pp. 41, 52

sachusetts Institute of Technology.

Minka, T. P. (2003). A Comparison of Numerical Optimizers for Logistic Regression.

http://research.microsoft.com/∼minka/papers/logreg.

p. 38

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

Minka, T. P. and Picard, R. W. (1999). Learning How to Learn is Learning With Point Sets.

http://research.microsoft.com/∼minka/papers/point-sets.html.

Mitchell, T. M. (1997). Machine Learning. McGraw-Hill, New York.

231

p. 116

pp. 2, 165

Murray-Smith, R. and Girard, A. (2001). Gaussian Process priors with ARMA noise models.

In
Irish Signals and Systems Conference, pages 147–153, Maynooth. http://www.dcs.gla.ac.uk/∼rod/
publications/MurGir01.pdf.
p. 191

Neal, R. M. (1996). Bayesian Learning for Neural Networks. Springer, New York. Lecture Notes in
pp. xiii, 30, 90, 91, 106, 166, 167

Statistics 118.

Neal, R. M. (1997). Monte Carlo Implementation of Gaussian Process Models for Bayesian Regres-
sion and Classiﬁcation. Technical Report 9702, Department of Statistics, University of Toronto.
http://www.cs.toronto.edu/∼radford.
p. 191

Neal, R. M. (1999). Regression and Classiﬁcation using Gaussian Process Priors. In Bernardo, J. M.,
Berger, J. O., Dawid, A. P., and Smith, A. F. M., editors, Bayesian Statistics 6, pages 475–501. Oxford
pp. 41, 47
University Press. (with discussion).

Neal, R. M. (2001). Annealed Importance Sampling. Statistics and Computing, 11:125–139.

p. 72

Neumaier, A. (2005). Introduction to Global Optimization. http://www.mat.univie.ac.at/∼neum/
p. 193

glopt/intro.html.

O’Hagan, A. (1978). Curve Fitting and Optimal Design for Prediction. Journal of the Royal Statistical
pp. 28, 30, 94

Society B, 40:1–42. (with discussion).

O’Hagan, A. (1991). Bayes-Hermite Quadrature. Journal of Statistical Planning and Inference, 29:245–
pp. 193, 194

260.

O’Hagan, A., Kennedy, M. C., and Oakley, J. E. (1999). Uncertainty Analysis and other Inference Tools
for Complex Computer Codes. In Bernardo, J. M., Berger, J. O., Dawid, A. P., and Smith, A. F. M.,
editors, Bayesian Statistics 6, pages 503–524. Oxford University Press. (with discussion).
p. 194

Øksendal, B. (1985). Stochastic Diﬀerential Equations. Springer-Verlag, Berlin.

p. 208

Opper, M. and Vivarelli, F. (1999). General Bounds on Bayes Errors for Regression with Gaussian
Processes. In Kearns, M. S., Solla, S. A., and Cohn, D. A., editors, Advances in Neural Information
Processing Systems 11, pages 302–308. MIT Press.
p. 160

Opper, M. and Winther, O. (2000). Gaussian Processes for Classiﬁcation: Mean-Field Algorithms.
pp. 41, 44, 52, 127, 128

Neural Computation, 12(11):2655–2684.

O’Sullivan, F., Yandell, B. S., and Raynor, W. J. (1986). Automatic Smoothing of Regression Functions
in Generalized Linear Models. Journal of the American Statistical Association, 81:96–103. pp. 132, 138

Paciorek, C. and Schervish, M. J. (2004). Nonstationary Covariance Functions for Gaussian Process Re-
gression. In Thrun, S., Saul, L., and Sch¨olkopf, B., editors, Advances in Neural Information Processing
pp. 93, 94
Systems 16. MIT Press.

Papoulis, A. (1991). Probability, Random Variables, and Stochastic Processes. McGraw-Hill, New York.
pp. 79, 153, 154, 191, 211, 212

Third Edition.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

232

Bibliography

Plaskota, L. (1996). Noisy Information and Computational Complexity. Cambridge University Press,
pp. 161, 169

Cambridge.

Plate, T. A. (1999). Accuarcy versus Interpretability in Flexible Modeling: Implementing a Tradeoﬀ
p. 95

using Gaussian Process Models. Behaviourmetrika, 26(1):29–50.

Platt, J. C. (1999). Fast Training of Support Vector Machines Using Sequential Minimal Optimization.
In Sch¨olkopf, B., Burges, C. J. C., and Smola, A. J., editors, Advances in Kernel Methods, pages
p. 144
185–208. MIT Press.

Platt, J. C. (2000). Probabilities for SV Machines.

In Smola, A., Bartlett, P., Sch¨olkopf, B.,
and Schuurmans, D., editors, Advances in Large Margin Classiﬁers, pages 61–74. MIT Press.
pp. 69, 70, 145, 147, 148

Poggio, T. and Girosi, F. (1990). Networks for Approximation and Learning. Proceedings of IEEE,
pp. 89, 133, 134, 135, 147, 176

78:1481–1497.

Poggio, T., Voorhees, H., and Yuille, A. (1985). A Regularized Solution to Edge Detection. Technical
p. 154

Report AI Memo 833, MIT AI Laboratory.

Pontil, M., Mukherjee, S., and Girosi, F. (1998). On the Noise Model of Support Vector Machine
p. 146

Regression. Technical Report AI Memo 1651, MIT AI Laboratory.

Press, W. H., Teukolsky, S. A., Vetterling, W. T., and Flannery, B. P. (1992). Numerical Recipes in C.
pp. 96, 99, 201

Cambridge University Press, Second edition.

Qui˜nonero-Candela, J. (2004). Learning with Uncertainty—Gaussian Processes and Relevance Vector
Machines. PhD thesis, Informatics and Mathematical Modelling, Technical Univeristy of Denmark.
p. 177

Rasmussen, C. E. (1996). Evaluation of Gaussian Processes and Other Methods for Non-linear Re-
gression. PhD thesis, Dept. of Computer Science, University of Toronto. http://www.kyb.mpg.de/
p. 30
publications/pss/ps2304.ps.

Rasmussen, C. E. (2003). Gaussian Processes to Speed up Hybrid Monte Carlo for Expensive Bayesian
Integrals. In Bernardo, J. M., Bayarri, M. J., Berger, J. O., Dawid, A. P., Heckerman, D., Smith, A.
F. M., and West, M., editors, Bayesian Statistics 7, pages 651–659. Oxford University Press. p. 193

Rasmussen, C. E. and Ghahramani, Z. (2001). Occam’s Razor. In Leen, T., Dietterich, T. G., and Tresp,
V., editors, Advances in Neural Information Processing Systems 13, pages 294–300. MIT Press. p. 110

Rasmussen, C. E. and Ghahramani, Z. (2002).

In
Diettrich, T. G., Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing
Systems 14. MIT Press.
p. 192

Inﬁnite Mixtures of Gaussian Process Experts.

Rasmussen, C. E. and Ghahramani, Z. (2003). Bayesian Monte Carlo. In Suzanna Becker, S. T. and
Obermayer, K., editors, Advances in Neural Information Processing Systems 15, pages 489–496. MIT
Press.
p. 193

Rasmussen, C. E. and Qui˜nonero-Candela, J. (2005). Healing the Relevance Vector Machine through
pp. 150, 176

Augmentation. In Proc. 22nd International Conference on Machine Learning.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

233

Rifkin, R. and Klautau, A. (2004). In Defense of One-Vs-All Classiﬁcation. Journal of Machine Learning
pp. 146, 147

Research, 5:101–141.

Ripley, B. (1981). Spatial Statistics. Wiley, New York.

p. 30

Ripley, B. (1996). Pattern Recognition and Neural Networks. Cambridge University Press, Cambridge,
p. 35

UK.

Ritter, K. (2000). Average-Case Analysis of Numerical Problems. Springer Verlag. pp. 159, 161, 169, 193

Ritter, K., Wasilkowski, G. W., and Wo´zniakowski, H. (1995). Multivariate Integration and Approxima-
tion of Random Fields Satisfying Sacks-Ylvisaker Conditions. Annals of Applied Probability, 5:518–540.
p. 97

Rousseeuw, P. J. (1984). Least Median of Squares Regression. Journal of the American Statistical
p. 146

Association, 79:871–880.

Sacks, J., Welch, W. J., Mitchell, T. J., and Wynn, H. P. (1989). Design and Analysis of Computer
pp. 16, 30

Experiments. Statistical Science, 4(4):409–435.

Saitoh, S. (1988). Theory of Reproducing Kernels and its Applications. Longman, Harlow, England.
p. 129

Salton, G. and Buckley, C. (1988). Term-weighting Approaches in Automatic Text Retrieval. Information
p. 100

Processing and Management, 24:513–523.

Sampson, P. D. and Guttorp, P. (1992). Nonparametric Estimation of Nonstationary Covariance Struc-
p. 92

ture. Journal of the American Statistical Association, 87:108–119.

Santner, T. J., Williams, B. J., and Notz, W. (2003). The Design and Analysis of Computer Experiments.
p. 30

Springer, New York.

Saunders, C., Gammerman, A., and Vovk, V. (1998). Ridge Regression Learning Algorithm in Dual
Variables. In Shavlik, J., editor, Proceedings of the Fifteenth International Conference on Machine
Learning (ICML 1998). Morgan Kaufmann.
p. 30

Saunders, C., Shawe-Taylor, J., and Vinokourov, A. (2003). String Kernels, Fisher Kernels and Finite
State Automata. In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural Information
Processing Systems 15. MIT Press.
p. 101

Schoenberg, I. J. (1938). Metric Spaces and Positive Deﬁnite Functions. Trans. American Mathematical
p. 86

Society, 44(3):522–536.

Schoenberg, I. J. (1964). Spline Functions and the Problem of Graduation. Proc. Nat. Acad. Sci. USA,
pp. 132, 138

52:947–950.

Sch¨olkopf, B. and Smola, A. J. (2002). Learning with Kernels. MIT Press.

pp. xvi, 73, 89, 90, 91, 129, 130, 133, 141, 144, 147, 173, 188, 195, 196

Sch¨olkopf, B., Smola, A. J., and M¨uller, K.-R. (1998). Nonlinear Component Analysis as a Kernel
p. 99

Eigenvalue Problem. Neural Computation, 10:1299–1319.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

234

Bibliography

Schwaighofer, A. and Tresp, V. (2003). Transductive and Inductive Methods for Approximate Gaus-
sian Process Regression. In Becker, S., Thrun, S., and Obermayer, K., editors, Advances in Neural
Information Processing Systems 15. MIT Press.
pp. 181, 184

Scott, D. W. (1992). Multivariate Density Estimation. Wiley, New York.

p. 25

Seeger, M. (2000). Bayesian Model Selection for Support Vector Machines, Gaussian Processes and
Other Kernel Classiﬁers. In Solla, S. A., Leen, T. K., and M¨uller, K.-R., editors, Advances in Neural
pp. 41, 54, 145
Information Processing Systems 12. MIT Press, Cambridge, MA.

Seeger, M. (2002). PAC-Bayesian Generalisation Error Bounds for Gaussian Process Classiﬁcation.
pp. 161, 164, 165

Journal of Machine Learning Research, 3:322–269.

Seeger, M. (2003).

Bayesian Gaussian Process Models: PAC-Bayesian Generalisation Error
Bounds and Sparse Approximations. PhD thesis, School of Informatics, University of Edinburgh.
http://www.cs.berkeley.edu/∼mseeger.
pp. 46, 145, 161, 162, 163, 179, 180, 186

Seeger, M. (2005). Expectation Propagation for Exponential Families. http://www.cs.berkeley.edu/
p. 127

∼mseeger/papers/epexpfam.ps.gz.

Seeger, M. and Jordan, M. I. (2004). Sparse Gaussian Process Classiﬁcation With Multiple Classes.
p. 50

Technical Report TR 661, Department of Statistics, University of California at Berkeley.

Seeger, M., Williams, C. K. I., and Lawrence, N. (2003). Fast Forward Selection to Speed Up Sparse
Gaussian Process Regression.
In Bishop, C. and Frey, B. J., editors, Proceedings of the Ninth In-
ternational Workshop on Artiﬁcial Intelligence and Statistics. Society for Artiﬁcial Intelligence and
Statistics.
pp. 178, 180

Shawe-Taylor, J. and Williams, C. K. I. (2003). The Stability of Kernel Principal Components Analysis
and its Relation to the Process Eigenspectrum. In Becker, S., Thrun, S., and Obermayer, K., editors,
Advances in Neural Information Processing Systems 15. MIT Press.
p. 99

Shepp, L. A. (1966). Radon-Nikodym Derivatives of Gaussian Measures. Annals of Mathematical Statis-
p. 139

tics, 37(2):321–354.

Silverman, B. W. (1978). Density Ratios, Empirical Likelihood and Cot Death. Applied Statistics,
p. 138

27(1):26–33.

Silverman, B. W. (1984). Spline Smoothing: The Equivalent Variable Kernel Method. Annals of
pp. 25, 153, 154

Statistics, 12(3):898–916.

Silverman, B. W. (1985). Some Aspects of the Spline Smoothing Approach to Non-parametric Regression
pp. 170, 175

Curve Fitting (with discussion). J. Roy. Stat. Soc. B, 47(1):1–52.

Simard, P., Victorri, B., Le Cun, Y., and Denker, J. (1992). Tangent Prop—A Formalism for Specifying
Selected Invariances in an Adaptive Network. In Moody, J. E., Hanson, S. J., and Lippmann, R. P.,
editors, Advances in Neural Information Processing Systems 4, pages 895–903. Morgan Kaufmann.
pp. 73, 195

Smola, A. J. and Bartlett, P. L. (2001). Sparse Greedy Gaussian Process Regression. In Leen, T. K.,
Diettrich, T. G., and Tresp, V., editors, Advances in Neural Information Processing Systems 13, pages
p. 176
619–625. MIT Press.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

235

Smola, A. J. and Sch¨olkopf, B. (2000). Sparse Greedy Matrix Approximation for Machine Learning. In
Proceedings of the Seventeenth International Conference on Machine Learning. Morgan Kaufmann.
pp. 173, 174

Solak, E., Murray-Smith, R., Leithead, W. E., Leith, D., and Rasmussen, C. E. (2003). Derivative
Observations in Gaussian Process Models of Dynamic Systems. In Becker, S., S. T. and Obermayer,
K., editors, Advances in Neural Information Processing Systems 15, pages 1033–1040. MIT Press.
p. 191

Sollich, P. (1999). Learning Curves for Gaussian Processes. In Kearns, M. S., Solla, S. A., and Cohn,
pp. 160, 161

D. A., editors, Neural Information Processing Systems, Vol. 11. MIT Press.

Sollich, P. (2002). Bayesian Methods for Support Vector Machines: Evidence and Predictive Class
pp. 145, 150, 161

Probabilities. Machine Learning, 46:21–52.

Sollich, P. and Williams, C. K. I. (2005). Using the Equivalent Kernel to Understand Gaussian Process
In Saul, L. K., Weiss, Y., and Bottou, L., editors, Advances in Neural Information
p. 154

Regression.
Processing Systems 17. MIT Press.

Stein, M. L. (1991). A Kernel Approximation to the Kriging Predictor of a Spatial Process. Ann. Inst.
p. 154

Statist. Math, 43(1):61–75.

Stein, M. L. (1999). Interpolation of Spatial Data. Springer-Verlag, New York.

pp. 82, 83, 85, 86, 87, 115, 137, 157, 158, 161, 212

Steinwart, I. (2005). Consistency of Support Vector Machines and Other Regularized Kernel Classiﬁers.
p. 157

IEEE Trans. on Information Theory, 51(1):128–142.

Stitson, M. O., Gammerman, A., Vapnik, V. N., Vovk, V., Watkins, C. J. C. H., and Weston, J. (1999).
Support Vector Regression with ANOVA Decomposition Kernels. In Sch¨olkopf, B., Burges, C. J. C.,
and Smola, A. J., editors, Advances in Kernel Methods. MIT Press.
p. 95

Sundararajan, S. and Keerthi, S. S. (2001). Predictive Approaches for Choosing Hyperparameters in
p. 117

Gaussian Processes. Neural Computation, 13:1103–1118.

Suykens, J. A. K. and Vanderwalle, J. (1999). Least Squares Support Vector Machines. Neural Processing
p. 147

Letters, 9:293–300.

Szeliski, R. (1987). Regularization uses Fractal Priors. In Proceedings of the 6th National Conference
pp. 135, 137

on Artiﬁcial Intelligence (AAAI-87).

Teh, Y. W., Seeger, M., and Jordan, M. I. (2005). Semiparametric Latent Factor Models. In Cowell,
R. G. and Ghahramani, Z., editors, Proceedings of Tenth International Workshop on Artiﬁcial Inte
lligence and Statistics, pages 333–340. Society for Artiﬁcial Intelligence and Statistics.
p. 190

Thomas-Agnan, C. (1996). Computing a Family of Reproducing Kernels for Statistical Applications.
p. 154

Numerical Algorithms, 13:21–32.

Thompson, P. D. (1956). Optimum Smoothing of Two-Dimensional Fields. Tellus, 8:384–393.

p. 30

Tikhonov, A. N. (1963). Solution of Incorrectly Formulated Problems and the Regularization Method.
p. 133

Soviet. Math. Dokl., 5:1035–1038.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

236

Bibliography

Tikhonov, A. N. and Arsenin, V. Y. (1977). Solutions of Ill-posed Problems. W. H. Winston, Washington,
p. 133

D.C.

Tipping, M. E. (2001). Sparse Bayesian Learning and the Relevance Vector Machine. Journal of Machine
p. 149

Learning Research, 1:211–244.

Tipping, M. E. and Faul, A. C. (2003). Fast Marginal Likelihood Maximisation for Sparse Bayesian
Models. In Bishop, C. M. and Frey, B. J., editors, Proceedings of Ninth International Workshop on
p. 149
Artiﬁcial Intelligence and Statistics. Society for Artiﬁcial Intelligence and Statistics.

Tresp, V. (2000). A Bayesian Committee Machine. Neural Computation, 12(11):2719–2741.

pp. 180, 181, 185, 187

Tsuda, K., Kawanabe, M., R¨atsch, G., Sonnenburg, S., and M¨uller, K.-R. (2002). A New Discriminative
p. 102

Kernel from Probabilistic Models. Neural Computation, 14(10):2397–2414.

Uhlenbeck, G. E. and Ornstein, L. S. (1930). On the Theory of Brownian Motion. Phys. Rev., 36:823–841.
pp. 86, 212

Valiant, L. G. (1984). A Theory of the Learnable. Communications of the ACM, 27(11):1134–1142.
p. 161

Vapnik, V. N. (1995). The Nature of Statistical Learning Theory. Springer Verlag, New York.

pp. 36, 141, 181

Vapnik, V. N. (1998). Statistical Learning Theory. John Wiley and Sons.

p. 140

Vijayakumar, S., D’Souza, A., and Schaal, S. (2005). Incremental Online Learning in High Dimensions.
pp. 22, 24

Accepted for publication in Neural Computation.

Vijayakumar, S., D’Souza, A., Shibata, T., Conradt, J., and Schaal, S. (2002). Statistical Learning for
p. 22

Humanoid Robots. Autonomous Robot, 12(1):55–69.

Vijayakumar, S. and Schaal, S. (2000). LWPR: An O(n) Algorithm for Incremental Real Time Learning
in High Dimensional Space. In Proc. of the Seventeenth International Conference on Machine Learning
(ICML 2000), pages 1079–1086.
p. 22

Vishwanathan, S. V. N. and Smola, A. J. (2003). Fast Kernels for String and Tree Matching. In Becker,
S., Thrun, S., and Obermayer, K., editors, Advances in Neural Information Processing Systems 15.
MIT Press.
p. 101

Vivarelli, F. and Williams, C. K. I. (1999). Discovering Hidden Features with Gaussian Processes
Regression. In Kearns, M. S., Solla, S. A., and Cohn, D. A., editors, Advances in Neural Information
Processing Systems 11. MIT Press.
p. 89

von Mises, R. (1964). Mathematical Theory of Probability and Statistics. Academic Press.

p. 200

Wahba, G. (1978). Improper Priors, Spline Smoothing and the Problem of Guarding Against Model
p. 139

Errors in Regression. Journal of the Royal Statistical Society B, 40(3):364–372.

Wahba, G. (1985). A Comparison of GCV and GML for Choosing the Smoothing Parameter in the
p. 29

Generalized Spline Smoothing Problem. Annals of Statistics, 13:1378–1402.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Bibliography

237

Wahba, G. (1990).

Society for Industrial and Applied
Mathematics, Philadelphia, PA. CBMS-NSF Regional Conference series in applied mathematics.
pp. 95, 112, 117, 118, 129, 131, 137, 138, 157, 176

Spline Models for Observational Data.

Wahba, G., Johnson, D. R., Gao, F., and Gong, J. (1995). Adaptive Tuning of Numerical Weather
Prediction Models: Randomized GCV in Three-and Four-Dimensional Data Assimilation. Monthly
Weather Review, 123:3358–3369.
p. 181

Watkins, C. J. C. H. (1999). Dynamic Alignment Kernels. Technical Report CSD-TR-98-11, Dept of
p. 101

Computer Science, Royal Holloway, University of London.

Watkins, C. J. C. H. (2000). Dynamic Alignment Kernels. In Smola, A. J., Bartlett, P. L., and Sch¨olkopf,
B., editors, Advances in Large Margin Classiﬁers, pages 39–50. MIT Press, Cambridge, MA. p. 100

Wegman, E. J. (1982). Reproducing Kernel Hilbert Spaces. In Kotz, S. and Johnson, N. L., editors,
pp. 129, 130

Encyclopedia of Statistical Sciences, volume 8, pages 81–84. Wiley, New York.

Weinert, H. L., editor (1982). Reproducing Kernel Hilbert Spaces. Hutchinson Ross, Stroudsburg,
p. 129

Pennsylvania.

Wendland, H. (2005). Scattered Data Approximation. Cambridge Monographs on Applied and Compu-
p. 88

tational Mathematics. Cambridge University Press.

Whittle, P. (1963). Prediction and Regulation by Linear Least-square Methods. English Universities
pp. 30, 216

Press.

Widom, H. (1963). Asymptotic Behavior of the Eigenvalues of Certain Integral Equations. Trans. of the
p. 97

American Mathematical Society, 109(2):278–295.

Widom, H. (1964). Asymptotic Behavior of the Eigenvalues of Certain Integral Equations II. Archive
p. 97

for Rational Mechanics and Analysis, 17:215–229.

Wiener, N. (1949). Extrapolation, Interpolation and Smoothing of Stationary Time Series. MIT Press,
p. 29

Cambridge, Mass.

Williams, C. K. I. (1998). Computation with Inﬁnite Neural Networks. Neural Computation, 10(5):1203–
p. 91

1216.

Williams, C. K. I. and Barber, D. (1998). Bayesian Classiﬁcation with Gaussian Processes.

Transactions on Pattern Analysis and Machine Intelligence, 20(12):1342–1351.

IEEE
pp. 41, 45, 48, 49

Williams, C. K. I. and Rasmussen, C. E. (1996). Gaussian Processes for Regression. In Touretzky, D. S.,
Mozer, M. C., and Hasselmo, M. E., editors, Advances in Neural Information Processing Systems 8,
pages 514–520. MIT Press.
pp. 30, 107

Williams, C. K. I., Rasmussen, C. E., Schwaighofer, A., and Tresp, V. (2002). Observations on
the Nystr¨om Method for Gaussian Process Prediction. Technical report, University of Edinburgh.
http://www.dai.ed.ac.uk/homes/ckiw/online pubs.html.
p. 177

Williams, C. K. I. and Seeger, M. (2001). Using the Nystr¨om Method to Speed Up Kernel Machines.
In Leen, T. K., Diettrich, T. G., and Tresp, V., editors, Advances in Neural Information Processing
Systems 13, pages 682–688. MIT Press.
pp. 173, 177

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

238

Bibliography

Williams, C. K. I. and Vivarelli, F. (2000). Upper and Lower Bounds on the Learning Curve for Gaussian
pp. 31, 161, 168

Proccesses. Machine Learning, 40:77–102.

Winkler, G. (1995). Image Analysis, Random Fields and Dynamic Monte Carlo Methods. Springer,
p. 219

Berlin.

Wong, E. (1971). Stochastic Processes in Information and Dynamical Systems. McGraw-Hill, New York.
p. 218

Wood, S. and Kohn, R. (1998). A Bayesian Approach to Robust Binary Nonparametric Regression. J.
p. 45

American Statistical Association, 93(441):203–213.

Yaglom, A. M. (1987). Correlation Theory of Stationary and Related Random Functions Volume I: Basic
p. 89

Results. Springer Verlag.

Yang, C., Duraiswami, R., and David, L. (2005). Eﬃcient Kernel Machines Using the Improved Fast
Gauss Transform. In Saul, L. K., Weiss, Y., and Bottou, L., editors, Advances in Neural Information
Processing Systems 17. MIT Press.
p. 182

Ylvisaker, D. (1975). Designs on Random Fields. In Srivastava, J. N., editor, A Survey of Statistical
p. 159

Design and Linear Models, pages 593–608. North-Holland.

Yuille, A. and Grzywacz, N. M. (1989). A Mathematical Analysis of Motion Coherence Theory. Inter-
p. 134

national Journal of Computer Vision, 3:155–175.

Zhang, T. (2004). Statistical Behaviour and Consistency of Classiﬁcation Methods based on Convex
p. 157

Risk Minimization (with discussion). Annals of Statistics, 32(1):56–85.

Zhu, H., Williams, C. K. I., Rohwer, R. J., and Morciniec, M. (1998). Gaussian Regression and Optimal
Finite Dimensional Linear Models. In Bishop, C. M., editor, Neural Networks and Machine Learning.
Springer-Verlag, Berlin.
p. 97

Zhu, J. and Hastie, T. J. (2002). Kernel Logistic Regression and the Import Vector Machine. In Diettrich,
T. G., Becker, S., and Ghahramani, Z., editors, Advances in Neural Information Processing Systems
14, pages 1081–1088. MIT Press.
p. 185

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Author Index

Abrahamsen, P. 82
Abramowitz, M. 84, 85
Adams, R. 134
Adler, R. J. 80, 81, 83, 191, 218
Amari, S. 102
Ansley, C. F. 29
Ansley, C. F., see Kohn, R. 141
Arat´o, M. 212
Arfken, G. xv, 134
Aronszajn, N. 129, 130
Arsenin, V. Y., see Tikhonov, A. N. 133

Bach, F. R. 97
Baker, C. T. H. 98, 99
Balakrishnan, N., see Johnson, N. L. 45
Barber, D. 31
Barber, D., see Williams, C. K. I. 41, 45, 48, 49
Bartle, R. G. 204
Bartlett, P. L. 157
Bartlett, P. L., see Lanckriet, G. R. G. 128
Bartlett, P. L., see Smola, A. J. 176
Belongie, S., see Fowlkes, C. 172
Bengio, S., see Collobert, R. 69, 72
Berger, J. O. 22, 35
Bishop, C. M. 45, 196
Bishop, C. M., see Goldberg, P. W. 191
Blake, I. F. 81
Blight, B. J. N. 28
Boyd, S. 206
Boyle, P. 190
Bracewell, R. N. 83, 206
Buckley, C., see Salton, G. 100

Caruana, R. 115
Chatﬁeld, C. 82, 209, 214
Chellappa, R., see Kashyap, R. L. 216

Choi, T. 156
Choudhuri, N. 156
Chow, Y., see Grenander, U. 214, 216
Chu, W. 191
Collins, M. 101
Collobert, R. 69, 72
Conradt, J., see Vijayakumar, S. 22
Cornford, D. 85
Cox, D. D. 156
Craven, P. 112
Cressie, N. A. C. 30, 137, 190
Cristianini, N. 128, 141
Cristianini, N., see Lanckriet, G. R. G. 128
Cristianini, N., see Lodhi, H. 101
Csat´o, L. 179, 180, 185

Daley, R. 30
David, H. A. 169, 170
David, L., see Yang, C. 182
Davis, P. J. 216
Dawid, A. P. 34
Dellaportas, P. 192
Denker, J., see Simard, P. 73, 195
Devroye, L. 156, 166
Diaconis, P. 156
Diekhans, M., see Jaakkola, T. S. 101, 102, 104
Diggle, P. J. 191, 214, 215
Doob, J. L. 204, 212
Drineas, P. 174
D’Souza, A., see Vijayakumar, S. 22, 24
Duchon, J. 137
Duda, R. O. 146
Duﬀy, N., see Collins, M. 101
Duraiswami, R., see Yang, C. 182

Eddy, W. F., see Geisser, S. 117

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

240

Author Index

Edgeworth, F. Y. 146
El Ghaoui, L., see Lanckriet, G. R. G. 128
Elisseeﬀ, A., see Cristianini, N. 128
Eskin, E., see Leslie, C. 100, 101, 104

Faul, A. C. 149
Faul, A. C., see Tipping, M. E. 149
Feldman, J. 157
Ferrari Trecate, G. 152
Fine, S. 47, 174
Flannery, B. P., see Press, W. H. 96, 99, 201
Fowlkes, C. 172
Frean, M., see Boyle, P. 190
Freedman, D. 156
Freedman, D., see Diaconis, P. 156
Frieze, A. 174

Gammerman, A., see Saunders, C. 30
Gammerman, A., see Stitson, M. O. 95
Gao, F., see Lin, X. 185
Gao, F., see Wahba, G. 181
Geisser, S. 117
Geman, D., see Geman, S. 216
Geman, S. 216
Ghahramani, Z., see Chu, W. 191
Ghahramani, Z., see Rasmussen, C. E. 110, 192,

193

Ghosal, S., see Choudhuri, N. 156
Gibbs, M. N. 41, 93, 181
Gihman, I. I. 82
Girard, A. 192
Girard, A., see Murray-Smith, R. 191
Girosi, F. 25, 146
Girosi, F., see Poggio, T. 89, 133–135, 147, 176
Girosi, F., see Pontil, M. 146
Goldberg, P. W. 191
Golub, G. H. 172–174, 181, 202
Gong, J., see Wahba, G. 181
Gradshteyn, I. S. 98, 103
Green, P. J. 138
Grenander, U. 214, 216
Grimmett, G. R. 94, 213
Gr¨unwald, P. D. 156
Grzywacz, N. M., see Yuille, A. 134
Guttorp, P., see Sampson, P. D. 92
Gy¨orﬁ, L. 156
Gy¨orﬁ, L., see Devroye, L. 156, 166

Hajek, J. 157
Hand, D. J. 100
Hannan, E. J. 215
Hansen, L. K. 36
Hart, P. E., see Duda, R. O. 146
Hastie, T. J. 24, 25, 95
Hastie, T. J., see Zhu, J. 185
Haussler, D. 101
Haussler, D., see Jaakkola, T. S. 41, 101, 102, 104
Hawkins, D. L. 97
Herbrich, R., see Lawrence, N. 178, 185
Hinton, G. E., see Jacobs, R. A. 192
Hoerl, A. E. 11
Hornik, K. 90
Huijbregts, C. J., see Journel, A. G. 30

Ihara, S. 218

Jaakkola, T. S. 41, 101, 102, 104
Jacobs, R. A. 192
Johnson, D. R., see Wahba, G. 181
Johnson, N. L. 45
Jones, D. R. 193
Jones, M., see Girosi, F. 25
Jordan, M. I. 218
Jordan, M. I., see Bach, F. R. 97
Jordan, M. I., see Bartlett, P. L. 157
Jordan, M. I., see Jacobs, R. A. 192
Jordan, M. I., see Lanckriet, G. R. G. 128
Jordan, M. I., see Seeger, M. 50
Jordan, M. I., see Teh, Y. W. 190
Journel, A. G. 30

Kailath, T. 131
Kammler, D. W. 208
Kandola, J., see Cristianini, N. 128
Kannan, R., see Frieze, A. 174
Kashyap, R. L. 216
Kawanabe, M., see Tsuda, K. 102
Keeling, C. D. 119
Keenan, D. M., see Grenander, U. 214, 216
Keerthi, S. S., see Sundararajan, S. 117
Kennard, R. W., see Hoerl, A. E. 11
Kennedy, M. C., see O’Hagan, A. 194
Kent, J. T. 137
Kimeldorf, G. 132, 136
Klautau, A., see Rifkin, R. 146, 147
Klein, B., see Lin, X. 185

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Author Index

Klein, R., see Lin, X. 185
Kohler, M., see Gy¨orﬁ, L. 156
Kohn, R. 141
Kohn, R., see Ansley, C. F. 29
Kohn, R., see Wood, S. 45
Kolmogorov, A. N. 29
K¨onig, H. 96
Kotz, S., see Johnson, N. L. 45
Krzy˙zak, A., see Gy¨orﬁ, L. 156
Kullback, S. 158, 203
Kuss, M. 72, 73

Lanckriet, G. R. G. 128
Langford, J., see Gr¨unwald, P. D. 156
Lauritzen, S. L. 29
Lawrence, N. 178, 185, 196
Lawrence, N., see Seeger, M. 178, 180
Le Cun, Y., see Simard, P. 73, 195
Leith, D., see Solak, E. 191
Leithead, W. E., see Solak, E. 191
Leslie, C. 100, 101, 104
Liisberg, C., see Hansen, L. K. 36
Lin, X. 185
Lindley, D. V. 111
Lindsey, W. C., see Blake, I. F. 81
Lodhi, H. 101
Lugosi, G., see Devroye, L. 156, 166
Luo, Z. 176

MacKay, D. J. C. xiii, xiv, xvi, 45, 84, 92, 109,

110, 166, 167, 178

MacKay, D. J. C., see Gibbs, M. N. 41, 181
Mahoney, M. W., see Drineas, P. 174
Malik, J., see Fowlkes, C. 172
Malzahn, D. 161
Mandelbrot, B. B. 137
Mannila, H., see Hand, D. J. 100
Mardia, K. V. 115
Mardia, K. V., see Kent, J. T. 137
Marshall, R. J., see Mardia, K. V. 115
Mat´ern, B. 85, 87, 89
Matheron, G. 30
Maxwell, J. C. v
McAllester, D. 164
McAuliﬀe, J. D., see Bartlett, P. L. 157
McCullagh, P. 37, 38, 138
Meinguet, J. 137
Meir, R. 164

241

Micchelli, C. A. 161, 190
Minka, T. P. 38, 41, 52, 116
Mitchell, T. J., see Sacks, J. 16, 30
Mitchell, T. M. 2, 165
Morciniec, M., see Zhu, H. 97
Moyeed, R. A., see Diggle, P. J. 191
Mukherjee, S., see Pontil, M. 146
M¨uller, K.-R., see Sch¨olkopf, B. 99
M¨uller, K.-R., see Tsuda, K. 102
Murray-Smith, R. 191
Murray-Smith, R., see Girard, A. 192
Murray-Smith, R., see Solak, E. 191

Nabney, I. T., see Cornford, D. 85
Neal, R. M. xiii, 30, 41, 47, 72, 90, 91, 106, 166,

167, 191

Nelder, J., see McCullagh, P. 37, 38, 138
Neumaier, A. 193
Notz, W., see Santner, T. J. 30
Nowlan, S. J., see Jacobs, R. A. 192

Oakley, J. E., see O’Hagan, A. 194
O’Hagan, A. 28, 30, 94, 193, 194
Øksendal, B. 208
Opper, M. 41, 44, 52, 127, 128, 160
Opper, M., see Csat´o, L. 180, 185
Opper, M., see Ferrari Trecate, G. 152
Opper, M., see Malzahn, D. 161
Ornstein, L. S., see Uhlenbeck, G. E. 86, 212
O’Sullivan, F., see Cox, D. D. 156
O’Sullivan, F. 132, 138
Ott, L., see Blight, B. J. N. 28

Paciorek, C. 93, 94
Papoulis, A. 79, 153, 154, 191, 211, 212
Picard, R. W., see Minka, T. P. 116
Plaskota, L. 161, 169
Plate, T. A. 95
Platt, J. C. 69, 70, 144, 145, 147, 148
Poggio, T. 89, 133–135, 147, 154, 176
Poggio, T., see Girosi, F. 25
Pontil, M. 146
Pontil, M., see Micchelli, C. A. 190
Press, W. H. 96, 99, 201

Qui˜nonero-Candela, J. 177
Qui˜nonero-Candela, J., see Girard, A. 192
Qui˜nonero-Candela, J., see Rasmussen, C. E. 150,

176

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

242

Author Index

Rasmussen, C. E. 30, 110, 150, 176, 192, 193
Rasmussen, C. E., see Girard, A. 192
Rasmussen, C. E., see Kuss, M. 72, 73
Rasmussen, C. E., see Solak, E. 191
Rasmussen, C. E., see Williams, C. K. I. 30, 107,

177

R¨atsch, G., see Tsuda, K. 102
Raynor, W. J., see O’Sullivan, F. 132, 138
Rifkin, R. 146, 147
Ripley, B. 30, 35
Ritter, K. 97, 159, 161, 169, 193
Rohwer, R. J., see Zhu, H. 97
Rousseeuw, P. J. 146
Roy, A., see Choudhuri, N. 156
Ryzhik, I. M., see Gradshteyn, I. S. 98, 103

Saad, D., see Barber, D. 31
Sacks, J. 16, 30
Saitoh, S. 129
Salamon, P., see Hansen, L. K. 36
Salton, G. 100
Sampson, P. D. 92
Santner, T. J. 30
Saunders, C. 30, 101
Schaal, S., see Vijayakumar, S. 22, 24
Scheinberg, K., see Fine, S. 47, 174
Schervish, M. J., see Choi, T. 156
Schervish, M. J., see Paciorek, C. 93, 94
Schoenberg, I. J. 86, 132, 138
Sch¨olkopf, B. xvi, 73, 89–91, 99, 129, 130, 133,

141, 144, 147, 173, 188, 195, 196

Sch¨olkopf, B., see Smola, A. J. 173, 174
Schwaighofer, A. 181, 184
Schwaighofer, A., see Williams, C. K. I. 177
Scott, D. W. 25
Seeger, M. 41, 46, 50, 54, 127, 145, 161–165,

178–180, 186

Seeger, M., see Lawrence, N. 178, 185
Seeger, M., see Teh, Y. W. 190
Seeger, M., see Williams, C. K. I. 173, 177
Shawe-Taylor, J. 99
Shawe-Taylor, J., see Cristianini, N. 128, 141
Shawe-Taylor, J., see Lodhi, H. 101
Shawe-Taylor, J., see Saunders, C. 101
Shepp, L. A. 139
Shibata, T., see Vijayakumar, S. 22
Silverman, B. W. 25, 138, 153, 154, 170, 175
Silverman, B. W., see Green, P. J. 138

Simard, P. 73, 195
Skorohod, A. V., see Gihman, I. I. 82
Smola, A. J. 173, 174, 176
Smola, A. J., see Sch¨olkopf, B. xvi, 73, 89–91, 99,
129, 130, 133, 141, 144, 147, 173, 188, 195, 196

Smola, A. J., see Vishwanathan, S. V. N. 101
Smyth, P., see Hand, D. J. 100
Solak, E. 191
Sollich, P. 145, 150, 154, 160, 161
Sonnenburg, S., see Tsuda, K. 102
Staﬀord Noble, W., see Leslie, C. 100, 101, 104
Stegun, I. A., see Abramowitz, M. 84, 85
Stein, M. L. 82, 83, 85–87, 115, 137, 154, 157, 158,

161, 212

Steinwart, I. 157
Stephens, D. A., see Dellaportas, P. 192
Stirzaker, D. R., see Grimmett, G. R. 94, 213
Stitson, M. O. 95
Sundararajan, S. 117
Suykens, J. A. K. 147
Svensen, M., see Bishop, C. M. 196
Szeliski, R. 135, 137

Tawn, J. A., see Diggle, P. J. 191
Teh, Y. W. 190
Teukolsky, S. A., see Press, W. H. 96, 99, 201
Thomas-Agnan, C. 154
Thompson, P. D. 30
Tibshirani, R. J., see Hastie, T. J. 24, 25, 95
Tikhonov, A. N. 133
Tipping, M. E. 149
Tipping, M. E., see Faul, A. C. 149
Tresp, V. 180, 181, 185, 187
Tresp, V., see Schwaighofer, A. 181, 184
Tresp, V., see Williams, C. K. I. 177
Tsuda, K. 102

Uhlenbeck, G. E. 86, 212

Valiant, L. G. 161
Van Loan, C. F., see Golub, G. H. 172–174, 181,

202

Vandenberghe, L., see Boyd, S. 206
Vanderwalle, J., see Suykens, J. A. K. 147
Vapnik, V. N. 36, 140, 141, 181
Vapnik, V. N., see Stitson, M. O. 95
Vempala, S., see Frieze, A. 174
Vetterling, W. T., see Press, W. H. 96, 99, 201

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Author Index

243

Victorri, B., see Simard, P. 73, 195
Vijayakumar, S. 22, 24
Vinokourov, A., see Saunders, C. 101
Vishwanathan, S. V. N. 101
Vivarelli, F. 89
Vivarelli, F., see Opper, M. 160
Vivarelli, F., see Williams, C. K. I. 31, 161, 168
von Mises, R. 200
Voorhees, H., see Poggio, T. 154
Vovk, V., see Saunders, C. 30
Vovk, V., see Stitson, M. O. 95

Wahba, G. 29, 95, 112, 117, 118, 129, 131,

137–139, 157, 176, 181

Wahba, G., see Craven, P. 112
Wahba, G., see Kimeldorf, G. 132, 136
Wahba, G., see Lin, X. 185
Wahba, G., see Luo, Z. 176
Wahba, G., see Micchelli, C. A. 161
Walk, H., see Gy¨orﬁ, L. 156
Wasilkowski, G. W., see Ritter, K. 97
Watkins, C. J. C. H. 100, 101
Watkins, C. J. C. H., see Lodhi, H. 101
Watkins, C. J. C. H., see Stitson, M. O. 95
Wegman, E. J. 129, 130
Welch, W. J., see Sacks, J. 16, 30
Wendland, H. 88
Weston, J., see Leslie, C. 100, 101, 104
Weston, J., see Stitson, M. O. 95
Whittle, P. 30, 216
Whorf, T. P., see Keeling, C. D. 119
Widom, H. 97
Wiener, N. 29

Williams, B. J., see Santner, T. J. 30
Williams, C. K. I. 30, 31, 41, 45, 48, 49, 91, 107,

161, 168, 173, 177

Williams, C. K. I., see Bishop, C. M. 196
Williams, C. K. I., see Cornford, D. 85
Williams, C. K. I., see Ferrari Trecate, G. 152
Williams, C. K. I., see Goldberg, P. W. 191
Williams, C. K. I., see Seeger, M. 178, 180
Williams, C. K. I., see Shawe-Taylor, J. 99
Williams, C. K. I., see Sollich, P. 154
Williams, C. K. I., see Vivarelli, F. 89
Williams, C. K. I., see Zhu, H. 97
Winkler, G. 219
Winther, O., see Csat´o, L. 180, 185
Winther, O., see Opper, M. 41, 44, 52, 127, 128
Wong, E. 218
Wood, S. 45
Wo´zniakowski, H., see Ritter, K. 97
Wynn, H. P., see Sacks, J. 16, 30

Xiang, D., see Lin, X. 185

Yaglom, A. M. 89
Yandell, B. S., see O’Sullivan, F. 132, 138
Yang, C. 182
Ylvisaker, D. 159
Yuille, A. 134
Yuille, A., see Poggio, T. 154

Zhang, T. 157
Zhang, T., see Meir, R. 164
Zhu, H. 97
Zhu, J. 185

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Subject Index

ARMA process, see autoregressive moving-average

covariance

cokriging, 190
consistency, 155
convex

function, 206
set, 206

predictive, 18

covariance function, 13, 79, see also kernel

ANOVA, 95
compact support, 87
dot product, 89
exponential, 85
γ-exponential, 86
Gaussian, see covariance function, squared ex-

alignment, 128
anisotropy, 89
AR process, see autoregressive process
ARD, see automatic relevance

determination

process

automatic relevance

determination, 106

autoregressive moving-average process, 217

noise model, 191

autoregressive process, 207

Bayes classiﬁer, 36
Bayes’ theorem, 200
Bayesian committee machine, 180
BCM, see Bayesian committee machine
bias

inductive, 165

binary classiﬁcation, 33
bits, 203
blitzkrieging, see fast Gaussian processes
Bochner’s theorem, 82
Brownian bridge, 213
Brownian motion, see Wiener process

canonical hyperplane, 142
Cholesky decomposition, 202
Christ, bowels of, 111
classiﬁcation, 33

binary, 33
least-squares, 146

probabilistic, 148

multi-class, 33
probabilistic, 33

classiﬁer

Gibbs, 163
predictive, 163

ponential

inhomogeneous polynomial, 89
Mat´ern, 84
neural network, 91
Ornstein-Uhlenbeck, 86
covariance
OU,

see

Uhlenbeck

periodic, 92, 119
polynomial, 89
piecewise, 87

function, Ornstein-

radial basis function, see covariance function,

squared exponential

rational quadratic, 86
RBF, see covariance function, squared expo-

SE, see covariance function, squared exponen-

nential

tial

squared exponential, 14, 83

covariance matrix, 80
Cromwell’s dictum, 111
cross-validation, 111
generalized, 112
leave-one-out, 111

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

246

Subject Index

dataset

robot, inverse dynamics, 23
USPS, 63

decision region, 36
decision surface, 36
degenerate, see kernel, degenerate
degrees of freedom, 25
derivative observations, 191
Dirichlet process, 192
discriminative approach, 34

eigenfunction, 96
eigenvalue, 96
entropy, 203
EP, see expectation propagation
-insensitive error function, 145
equivalent kernel, 25, 151
error

generalization, 159

error function

-insensitive, 145
hinge, 145

error-reject curve, 36, 68
errors-in-variables regression, 192
evidence, see marginal likelihood
expectation propagation, 52
experimental design

optimal, 159

factor analysis, 89, 107
feature space, 11
Fisher information matrix, 102
Fisher kernel, 101
Fourier transform, 206
fractal, 137

gamma distribution, 87, 194
Gaussian distribution, 200
Gaussian Markov process, 207
Gaussian process, 13
Gaussian process classiﬁcation, 34
Gaussian process latent variable model, 196
Gaussian process regression, 16
generalization error, 108, 159
generative approach, 34
generative topographic mapping, 196
geostatistics, 30
GMP, see Gaussian Markov process

GP, see Gaussian process
GPC, see Gaussian process classiﬁcation
GPLVM, see Gaussian process latent variable model
GPR, see Gaussian process regression
Gram matrix, 80
Green’s function, 134
GTM, see generative topographic mapping

hidden Markov model, 102
hinge error function, 145
hyperparameters, 20, 106
hyperplane

canonical, 142

index set, 13
informative vector machine, 178
integrals, evaluation of, 193
intrinsic random function, 137
invariances, 195
IRLS, see iteratively reweighted least squares
isotropy, 80
iteratively reweighted least squares, 38
IVM, see informative vector machine

jitter, 47

kernel, 80, see also covariance function

bag-of-characters, 100
degenerate, 94, 97
equivalent, 151
Fisher, 101
k-spectrum, 100
nondegenerate, 97
positive deﬁnite, 80
string, 100
tangent of posterior odds, 102

kernel classiﬁer, 167
kernel PCA, 99
kernel ridge regression, see regression, ridge, kernel
kernel smoother, 25, 167
kernel trick, 12
kriging, 30
Kullback-Leibler divergence, 54, 203

Laplace approximation, 41
latent variable model, 196
learning curve, 159
learning, supervised, 1

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

Subject Index

247

least-squares classiﬁcation, 146
leave-one-out, 148
leave-one-out cross-validation, 111
length-scale, characteristic, 14, 83, 106
likelihood, 8, 37

mean square continuity, 81
mean square diﬀerentiability, 81
mean standardized log loss, 23
mean-ﬁeld approximation, 52
measure, 204
Mercer’s theorem, 96
mixture of experts, 192
ML-II, see type II maximum likelihood
model

non-parametric, 166
parametric, 166
semi-parametric, 166

Moore-Aronszajn theorem, 130
MS continuity, see mean square continuity
MS diﬀerentiability, see mean square diﬀerentiabil-

ity

MSLL, see mean standardized log loss
multi-class classiﬁcation, 33
multi-task learning, 115
multiple outputs, 190

Nadaraya-Watson estimator, 25, 155
nats, 203
neural network, 90, 166
Newton’s method, 43, 49
noise model, 8, 16
correlated, 190
heteroscedastic, 191

norm

Frobenius, 202

null space, 137
Nystr¨om approximation, 172
Nystr¨om method, 177

Occam’s razor, 110
one-versus-rest, 147
operator, integral, 80
optimal experimental design, 159
outputs, multiple, 190

P1NN, see probabilistic one nearest neighbour
PAC-Bayesian theorem

McAllester, 163
Seeger, 164

penalized maximum likelihood estimate, 10
PLSC, see probabilistic least-squares classiﬁcation
positive deﬁnite matrix, 80
positive semideﬁnite matrix, 80

logistic, 35, 43
multiple-logistic, 38
non-Gaussian, 33, 191
probit, 35, 43
linear classiﬁer, 37
linear regression, 8
link function, 35
log odds ratio, 37
logistic function, 35
logistic regression, 35
LOO, see leave-one-out
loss

negative log probability, 23
squared, 22
zero-one, 36
loss function, 21
loss matrix, 36
LSC, see least-squares classiﬁcation

MAP, see maximum a posteriori
margin

functional, 142
geometrical, 142

marginal likelihood, 18, 112
marginalization property, 13
Markov chain Monte Carlo, 41
Markov random ﬁeld, 218
matrix

covariance, 80
Fisher information, 102
Gram, 80
inversion lemma, 201
loss, 36
partitioned inversion of, 201
positive deﬁnite, 80
positive semideﬁnite, 80

maximum a posteriori, see penalized maximum like-

lihood

maximum likelihood

penalized, 10

MCMC, see Markov chain Monte Carlo
mean function, 13, 27

C. E. Rasmussen & C. K. I. Williams, Gaussian Processes for Machine Learning, the MIT Press, 2006,
c(cid:13) 2006 Massachusetts Institute of Technology. www.GaussianProcess.org/gpml
ISBN 026218253X.

248

Subject Index

stationarity, 79
stochastic diﬀerential equation, 207
Student’s t process, 194
subset of datapoints, 177
subset of regressors, 175
supervised learning, 1
support vector, 143
support vector machine, 141

soft margin, 143

support vector regression, 145
SVM, see support vector machine
SVR, see support vector regression

tangent of posterior odds kernel, 102
TOP kernel, see tangent of posterior odds kernel
transduction, 181
type II maximum likelihood, 109

uncertain inputs, 192
upcrossing rate, 80
USPS dataset, 63

weight function, 25
weight vector, 8
Wiener process, 213
integrated, 139
tied-down, 213

Wiener-Khintchine theorem, 82, 209

Yule-Walker equations, 215

posterior process, 18
PP, see projected process approximation
prediction

classiﬁcation

averaged, 44
MAP, 45

probabilistic classiﬁcation, 33
probabilistic least-squares classiﬁcation, 147
probabilistic one nearest neighbour, 69
probability

conditional, 199
joint, 199
marginal, 199

probit regression, 35
projected process approximation, 178
pseudo-likelihood, 117

quadratic form, 80
quadratic programming, 142

regression

errors-in-variables, 192
Gaussian process, 16
linear, 8
polynomial, 11, 28
ridge, 11, 132

kernel, 30, 132

regularization, 132
regularization network, 135
reject option, 36
relative entropy, see Kullback Leibler divergence
relevance vector machine, 149
representer theorem, 132
reproducing kernel Hilbert space, 129
response function, 35
ridge regression, see regression, ridge
risk, 22, 36
RKHS, see reproducing kernel Hilbert space
RVM, see relevance vector machine

scale mixture, 87, 194
SD, see subset of datapoints
SDE, see stochastic diﬀerential equation
SMSE, see standardized mean squared error
softmax, 38
splines, 136
SR, see subset of regressors
standardized mean squared error, 23

