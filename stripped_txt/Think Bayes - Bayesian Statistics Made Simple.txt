think bayes bayesian statistics made simple version think bayes bayesian statistics made simple version allen b. downey green tea press needham massachusetts copyright allen b. downey. green tea press washburn ave needham ma permission is granted to copy distribute andor modify this document under the terms of the creative commons attribution-noncommercial unported license which is available at httpcreativecommons.org preface my theory which is mine the premise of this book and the other books in the think x series is that if you know how to program you can use that skill to learn other topics. most books on bayesian statistics use mathematical notation and present ideas in terms of mathematical concepts like calculus. this book uses python code instead of math and discrete approximations instead of continuous mathematics. as a result what would be an integral in a math book becomes a summation and most operations on probability distributions are simple loops. i think this presentation is easier to understand at least for people with programming skills. it is also more general because when we make modeling decisions we can choose the most appropriate model without worrying too much about whether the model lends itself to conventional analysis. also it provides a smooth development path from simple examples to realworld problems. chapter is a good example. it starts with a simple example involving dice one of the staples of basic probability. from there it proceeds in small steps to the locomotive problem which i borrowed from mosteller s fifty challenging problems in probability with solutions and from there to the german tank problem a famously successful application of bayesian methods during world war ii. modeling and approximation most chapters in this book are motivated by a real-world problem so they involve some degree of modeling. before we can apply bayesian methods any other analysis we have to make decisions about which parts of the vi chapter preface real-world system to include in the model and which details we can abstract away. for example in chapter the motivating problem is to predict the winner of a hockey game. i model goal-scoring as a poisson process which implies that a goal is equally likely at any point in the game. that is not exactly true but it is probably a good enough model for most purposes. in chapter the motivating problem is interpreting sat scores sat is a standardized test used for college admissions in the united states. i start with a simple model that assumes that all sat questions are equally difficult but in fact the designers of the sat deliberately include some questions that are relatively easy and some that are relatively hard. i present a second model that accounts for this aspect of the design and show that it doesn t have a big effect on the results after all. i think it is important to include modeling as an explicit part of problem solving because it reminds us to think about modeling errors is errors due to simplifications and assumptions of the model. many of the methods in this book are based on discrete distributions which makes some people worry about numerical errors. but for real-world problems numerical errors are almost always smaller than modeling errors. furthermore the discrete approach often allows better modeling decisions and i would rather have an approximate solution to a good model than an exact solution to a bad model. on the other hand continuous methods sometimes yield performance advantages for example by replacing a linear- or quadratic-time computation with a constant-time solution. so i recommend a general process with these steps while you are exploring a problem start with simple models and implement them in code that is clear readable and demonstrably correct. focus your attention on good modeling decisions not optimization. once you have a simple model working identify the biggest sources of error. you might need to increase the number of values in a discrete approximation or increase the number of iterations in a monte carlo simulation or add details to the model. if the performance of your solution is good enough for your application you might not have to do any optimization. but if you do there are two approaches to consider. you can review your code and look working with the code vii for optimizations for example if you cache previously computed results you might be able to avoid redundant computation. or you can look for analytic methods that yield computational shortcuts. one benefit of this process is that steps and tend to be fast so you can explore several alternative models before investing heavily in any of them. another benefit is that if you get to step you will be starting with a reference implementation that is likely to be correct which you can use for regression testing is checking that the optimized code yields the same results at least approximately. working with the code the code and sound samples used in this book are available from https github.comallendowneythinkbayes. git is a version control system that allows you to keep track of the files that make up a project. a collection of files under git s control is called a repository github is a hosting service that provides storage for git repositories and a convenient web interface. the github homepage for my repository provides several ways to work with the code you can create a copy of my repository on github by pressing the fork button. if you don t already have a github account you ll need to create one. after forking you ll have your own repository on github that you can use to keep track of code you write while working on this book. then you can clone the repo which means that you copy the files to your computer. or you could clone my repository. you don t need a github account to do this but you won t be able to write your changes back to github. if you don t want to use git at all you can download the files in a zip file using the button in the lower-right corner of the github page. the code for the first edition of the book works with python if you are using python you might want to use the updated code in https instead. i developed this book using anaconda from continuum analytics which is a free python distribution that includes all the packages you ll need to viii chapter preface run the code lots more. i found anaconda easy to install. by default it does a user-level installation not system-level so you don t need administrative privileges. you can download anaconda from httpcontinuum. iodownloads. if you don t want to use anaconda you will need the following packages numpy for basic numerical computation httpwww.numpy.org scipy for scientific computation httpwww.scipy.org matplotlib for visualization httpmatplotlib.org. although these are commonly used packages they are not included with all python installations and they can be hard to install in some environments. if you have trouble installing them i recommend using anaconda or one of the other python distributions that include these packages. many of the examples in this book use classes and functions defined in thinkbayes.py. some of them also use thinkplot.py which provides wrappers for some of the functions in pyplot which is part of matplotlib. code style experienced python programmers will notice that the code in this book does not comply with pep which is the most common style guide for python specifically pep calls for lowercase function names with underscores between words like_this. in this book and the accompanying code function and method names begin with a capital letter and use camel case likethis. i broke this rule because i developed some of the code while i was a visiting scientist at google so i followed the google style guide which deviates from pep in a few places. once i got used to google style i found that i liked it. and at this point it would be too much trouble to change. also on the topic of style i write bayes s theorem with an s after the apostrophe which is preferred in some style guides and deprecated in others. i don t have a strong preference. i had to choose one and this is the one i chose. and finally one typographical note throughout the book i use pmf and cdf for the mathematical concept of a probability mass function or cumulative distribution function and pmf and cdf to refer to the python objects i use to represent them. prerequisites prerequisites ix there are several excellent modules for doing bayesian statistics in python including pymc and openbugs. i chose not to use them for this book because you need a fair amount of background knowledge to get started with these modules and i want to keep the prerequisites minimal. if you know python and a little bit about probability you are ready to start this book. chapter is about probability and bayes s theorem it has no code. chapter introduces pmf a thinly disguised python dictionary i use to represent a probability mass function then chapter introduces suite a kind of pmf that provides a framework for doing bayesian updates. in some of the later chapters i use analytic distributions including the gaussian distribution the exponential and poisson distributions and the beta distribution. in chapter i break out the less-common dirichlet distribution but i explain it as i go along. if you are not familiar with these distributions you can read about them on wikipedia. you could also read the companion to this book think stats or an introductory statistics book i m afraid most of them take a mathematical approach that is not particularly helpful for practical purposes. contributor list if you have a suggestion or downeyallendowney.com. i will add you to the contributor list you ask to be omitted. to if i make a change based on your feedback correction please send email if you include at least part of the sentence the error appears in that makes it easy for me to search. page and section numbers are fine too but not as easy to work with. thanks! first i have to acknowledge david mackay s excellent book information theory inference and learning algorithms which is where i first came to understand bayesian methods. with his permission i use several problems from his book as examples. this book also benefited from my interactions with sanjoy mahajan especially in fall when i audited his class on bayesian inference at olin college. i wrote parts of this book during project nights with the boston python user group so i would like to thank them for their company and pizza. x chapter preface olivier yiptong sent several helpful suggestions. yuriy pasichnyk found several errors. kristopher overholt sent a long list of corrections and suggestions. max hailperin suggested a clarification in chapter markus dobler pointed out that drawing cookies from a bowl with replace ment is an unrealistic scenario. in spring students in my class computational bayesian statistics made many helpful corrections and suggestions kai austin claire barnes kari bender rachel boy kat mendoza arjun iyer ben kroop nathan lintz kyle mcconnaughay alec radford brendan ritter and evan simpson. greg marra and matt aasted helped me clarify the discussion of the price is right problem. marcus ogren pointed out that the original statement of the locomotive prob lem was ambiguous. jasmine kwityn and dan fauxsmith at o reilly media proofread the book and found many opportunities for improvement. linda pescatore found a typo and made some helpful suggestions. tomasz mi asko sent many excellent corrections and suggestions. other people who spotted typos and small errors include tom pollard paul a. giannaros jonathan edwards george purkins robert marcus ram limbu james lawry ben kahle jeffrey law and alvaro sanchez. contents preface my theory which is mine modeling and approximation v v v working with the code vii code style viii prerequisites ix bayes s theorem conditional probability conjoint probability the cookie problem bayes s theorem the diachronic interpretation the mm problem the monty hall problem discussion computational statistics distributions the cookie problem xii contents the bayesian framework the monty hall problem encapsulating the framework the mm problem discussion exercises estimation the dice problem the locomotive problem what about that prior? an alternative prior credible intervals cumulative distribution functions the german tank problem discussion exercises more estimation the euro problem summarizing the posterior swamping the priors optimization the beta distribution discussion exercises contents odds and addends xiii odds the odds form of bayes s theorem oliver s blood addends maxima mixtures discussion decision analysis the price is right problem the prior probability density functions representing pdfs modeling the contestants likelihood update optimal bidding discussion prediction the boston bruins problem poisson processes the posteriors the distribution of goals the probability of winning sudden death discussion exercises xiv observer bias contents the red line problem the model wait times predicting wait times estimating the arrival rate incorporating uncertainty two dimensions decision analysis discussion exercises paintball the suite trigonometry likelihood joint distributions conditional distributions credible intervals discussion exercises approximate bayesian computation the variability hypothesis mean and standard deviation update the posterior distribution of cv contents xv underflow log-likelihood a little optimization abc robust estimation who is more variable? discussion exercises hypothesis testing back to the euro problem making a fair comparison the triangle prior discussion exercises evidence interpreting sat scores the scale the prior posterior a better model calibration posterior distribution of efficacy predictive distribution discussion xvi simulation contents the kidney tumor problem a simple model a more general model implementation caching the joint distribution conditional distributions serial correlation discussion a hierarchical model the geiger counter problem start simple make it hierarchical a little optimization extracting the posteriors discussion exercises dealing with dimensions belly button bacteria lions and tigers and bears the hierarchical version random sampling optimization collapsing the hierarchy one more problem contents xvii we re not done yet the belly button data predictive distributions joint posterior coverage discussion xviii contents chapter bayes s theorem conditional probability the fundamental idea behind all bayesian statistics is bayes s theorem which is surprisingly easy to derive provided that you understand conditional probability. so we ll start with probability then conditional probability then bayes s theorem and on to bayesian statistics. a probability is a number between and both that represents a degree of belief in a fact or prediction. the value represents certainty that a fact is true or that a prediction will come true. the value represents certainty that the fact is false. intermediate values represent degrees of certainty. the value often written as means that a predicted outcome is as likely to happen as not. for example the probability that a tossed coin lands face up is very close to a conditional probability is a probability based on some background information. for example i want to know the probability that i will have a heart attack in the next year. according to the cdc every year about americans have a first coronary attack. heartdiseasefacts.htm the u.s. population is about million so the probability that a randomly chosen american will have a heart attack in the next year is roughly but i am not a randomly chosen american. epidemiologists have identified many factors that affect the risk of heart attacks depending on those factors my risk might be higher or lower than average. chapter bayes s theorem i am male years old and i have borderline high cholesterol. those factors increase my chances. however i have low blood pressure and i don t smoke and those factors decrease my chances. plugging everything into the online calculator at httpcvdrisk.nhlbi. nih.govcalculator.asp i find that my risk of a heart attack in the next year is about less than the national average. that value is a conditional probability because it is based on a number of factors that make up my condition. the usual notation for conditional probability is pab which is the probability of a given that b is true. in this example a represents the prediction that i will have a heart attack in the next year and b is the set of conditions i listed. conjoint probability conjoint probability is a fancy way to say the probability that two things are true. i write pa and b to mean the probability that a and b are both true. if you learned about probability in the context of coin tosses and dice you might have learned the following formula pa and b pa pb warning not always true for example if i toss two coins and a means the first coin lands face up and b means the second coin lands face up then pa pb and sure enough pa and b pa pb but this formula only works because in this case a and b are independent that is knowing the outcome of the first event does not change the probability of the second. or more formally pba pb. here is a different example where the events are not independent. suppose that a means that it rains today and b means that it rains tomorrow. if i know that it rained today it is more likely that it will rain tomorrow so pba pb. in general the probability of a conjunction is pa and b pa pba the cookie problem for any a and b. so if the chance of rain on any given day is the chance of rain on two consecutive days is not but probably a bit higher. the cookie problem we ll get to bayes s theorem soon but i want to motivate it with an example called the cookie suppose there are two bowls of cookies. bowl contains vanilla cookies and chocolate cookies. bowl contains of each. now suppose you choose one of the bowls at random and without looking select a cookie at random. the cookie is vanilla. what is the probability that it came from bowl this is a conditional probability we want pbowl but it is not obvious how to compute it. if i asked a different question the probability of a vanilla cookie given bowl it would be easy pvanillabowl sadly pab is not the same as pba but there is a way to get from one to the other bayes s theorem. bayes s theorem at this point we have everything we need to derive bayes s theorem. we ll start with the observation that conjunction is commutative that is pa and b pb and a for any events a and b. next we write the probability of a conjunction pa and b pa pba since we have not said anything about what a and b mean they are interchangeable. interchanging them yields pb and a pb pab on an example from httpen.wikipedia.orgwikibayes_theorem that is no longer there. chapter bayes s theorem that s all we need. pulling those pieces together we get pb pab pa pba which means there are two ways to compute the conjunction. if you have pa you multiply by the conditional probability pba. or you can do it the other way around if you know pb you multiply by pab. either way you should get the same thing. finally we can divide through by pb pab pa pba pb and that s bayes s theorem! it might not look like much but it turns out to be surprisingly powerful. for example we can use it to solve the cookie problem. i ll write for the hypothesis that the cookie came from bowl and v for the vanilla cookie. plugging in bayes s theorem we get pv the term on the left is what we want the probability of bowl given that we chose a vanilla cookie. the terms on the right are this is the probability that we chose bowl unconditioned by what kind of cookie we got. since the problem says we chose a bowl at random we can assume this is the probability of getting a vanilla cookie from bowl which is pv this is the probability of drawing a vanilla cookie from either bowl. since we had an equal chance of choosing either bowl and the bowls contain the same number of cookies we had the same chance of choosing any cookie. between the two bowls there are vanilla and chocolate cookies so pv putting it together we have the diachronic interpretation which reduces to so the vanilla cookie is evidence in favor of the hypothesis that we chose bowl because vanilla cookies are more likely to come from bowl this example demonstrates one use of bayes s theorem it provides a strategy to get from pba to pab. this strategy is useful in cases like the cookie problem where it is easier to compute the terms on the right side of bayes s theorem than the term on the left. the diachronic interpretation there is another way to think of bayes s theorem it gives us a way to update the probability of a hypothesis h in light of some body of data d. this way of thinking about bayes s theorem is called the diachronic interpretation. diachronic means that something is happening over time in this case the probability of the hypotheses changes over time as we see new data. rewriting bayes s theorem with h and d yields ph pdh phd pd in this interpretation each term has a name ph is the probability of the hypothesis before we see the data called the prior probability or just prior. phd is what we want to compute the probability of the hypothesis after we see the data called the posterior. pdh is the probability of the data under the hypothesis called the likelihood. pd is the probability of the data under any hypothesis called the normalizing constant. sometimes we can compute the prior based on background information. for example the cookie problem specifies that we choose a bowl at random with equal probability. chapter bayes s theorem in other cases the prior is subjective that is reasonable people might disagree either because they use different background information or because they interpret the same information differently. the likelihood is usually the easiest part to compute. in the cookie problem if we know which bowl the cookie came from we find the probability of a vanilla cookie by counting. the normalizing constant can be tricky. it is supposed to be the probability of seeing the data under any hypothesis at all but in the most general case it is hard to nail down what that means. most often we simplify things by specifying a set of hypotheses that are mutually exclusive at most one hypothesis in the set can be true and collectively exhaustive there are no other possibilities at least one of the hypotheses has to be true. i use the word suite for a set of hypotheses that has these properties. in the cookie problem there are only two hypotheses the cookie came from bowl or bowl and they are mutually exclusive and collectively exhaustive. in that case we can compute pd using the law of total probability which says that if there are two exclusive ways that something might happen you can add up the probabilities like this pd plugging in the values from the cookie problem we have pd which is what we computed earlier by mentally combining the two bowls. the mm problem mm s are small candy-coated chocolates that come in a variety of colors. mars inc. which makes mm s changes the mixture of colors from time to time. the mm problem in they introduced blue mm s. before then the color mix in a bag of plain mm s was brown yellow red green orange tan. afterward it was blue green orange yellow red brown. suppose a friend of mine has two bags of mm s and he tells me that one is from and one from he won t tell me which is which but he gives me one mm from each bag. one is yellow and one is green. what is the probability that the yellow one came from the bag? this problem is similar to the cookie problem with the twist that i draw one sample from each bowlbag. this problem also gives me a chance to demonstrate the table method which is useful for solving problems like this on paper. in the next chapter we will solve them computationally. the first step is to enumerate the hypotheses. the bag the yellow mm came from i ll call bag i ll call the other bag so the hypotheses are a bag is from which implies that bag is from b bag is from and bag from now we construct a table with a row for each hypothesis and a column for each term in bayes s theorem prior likelihood pdh ph a b ph pdh posterior phd the first column has the priors. based on the statement of the problem it is reasonable to choose pa pb the second column has the likelihoods which follow from the information in the problem. for example if a is true the yellow mm came from the bag with probability and the green came from the bag with probability if b is true the yellow mm came from the bag with probability and the green came from the bag with probability because the selections are independent we get the conjoint probability by multiplying. the third column is just the product of the previous two. the sum of this column is the normalizing constant. to get the last column which chapter bayes s theorem contains the posteriors we divide the third column by the normalizing constant. that s it. simple right? well you might be bothered by one detail. i write pdh in terms of percentages not probabilities which means it is off by a factor of but that cancels out when we divide through by the normalizing constant so it doesn t affect the result. when the set of hypotheses is mutually exclusive and collectively exhaustive you can multiply the likelihoods by any factor if it is convenient as long as you apply the same factor to the entire column. the monty hall problem the monty hall problem might be the most contentious question in the history of probability. the scenario is simple but the correct answer is so counterintuitive that many people just can t accept it and many smart people have embarrassed themselves not just by getting it wrong but by arguing the wrong side aggressively in public. monty hall was the original host of the game show let s make a deal. the monty hall problem is based on one of the regular games on the show. if you are on the show here s what happens monty shows you three closed doors and tells you that there is a prize behind each door one prize is a car the other two are less valuable prizes like peanut butter and fake finger nails. the prizes are arranged at random. the object of the game is to guess which door has the car. if you guess right you get to keep the car. you pick a door which we will call door a. we ll call the other doors b and c. before opening the door you chose monty increases the suspense by opening either door b or c whichever does not have the car. the car is actually behind door a monty can safely open b or c so he chooses one at random. then monty offers you the option to stick with your original choice or switch to the one remaining unopened door. the monty hall problem the question is should you stick or switch or does it make no difference? most people have the strong intuition that it makes no difference. there are two doors left they reason so the chance that the car is behind door a is but that is wrong. in fact the chance of winning if you stick with door a is only if you switch your chances are by applying bayes s theorem we can break this problem into simple pieces and maybe convince ourselves that the correct answer is in fact correct. to start we should make a careful statement of the data. in this case d consists of two parts monty chooses door b and there is no car there. next we define three hypotheses a b and c represent the hypothesis that the car is behind door a door b or door c. again let s apply the table method prior likelihood pdh ph a b c ph pdh posterior phd filling in the priors is easy because we are told that the prizes are arranged at random which suggests that the car is equally likely to be behind any door. figuring out the likelihoods takes some thought but with reasonable care we can be confident that we have it right if the car is actually behind a monty could safely open doors b or c. so the probability that he chooses b is and since the car is actually behind a the probability that the car is not behind b is if the car is actually behind b monty has to open door c so the prob ability that he opens door b is finally if the car is behind door c monty opens b with probability and finds no car there with probability now the hard part is over the rest is just arithmetic. the sum of the third column is dividing through yields pad and pcd so you are better off switching. chapter bayes s theorem there are many variations of the monty hall problem. one of the strengths of the bayesian approach is that it generalizes to handle these variations. for example suppose that monty always chooses b if he can and only chooses c if he has to the car is behind b. in that case the revised table is ph pdh posterior phd prior likelihood pdh ph a b c the only change is pda. if the car is behind a monty can choose to open b or c. but in this variation he always chooses b so pda as a result the likelihoods are the same for a and c and the posteriors are the same pad pcd in this case the fact that monty chose b reveals no information about the location of the car so it doesn t matter whether the contestant sticks or switches. on the other hand if he had opened c we would know pbd i included the monty hall problem in this chapter because i think it is fun and because bayes s theorem makes the complexity of the problem a little more manageable. but it is not a typical use of bayes s theorem so if you found it confusing don t worry! discussion for many problems involving conditional probability bayes s theorem provides a divide-and-conquer strategy. if pab is hard to compute or hard to measure experimentally check whether it might be easier to compute the other terms in bayes s theorem pba pa and pb. if the monty hall problem is your idea of fun i have collected a number of similar problems in an article called all your bayes are belong to us which you can read at all-your-bayes-are-belong-to-us.html. chapter computational statistics distributions in statistics a distribution is a set of values and their corresponding probabilities. for example if you roll a six-sided die the set of possible values is the numbers to and the probability associated with each value is as another example you might be interested in how many times each word appears in common english usage. you could build a distribution that includes each word and how many times it appears. to represent a distribution in python you could use a dictionary that maps from each value to its probability. i have written a class called pmf that uses a python dictionary in exactly that way and provides a number of useful methods. i called the class pmf in reference to a probability mass function which is a way to represent a distribution mathematically. pmf is defined in a python module i wrote to accompany this book thinkbayes.py. you can download it from httpthinkbayes.com thinkbayes.py. for more information see section to use pmf you can import it like this from thinkbayes import pmf the following code builds a pmf to represent the distribution of outcomes for a six-sided die pmf pmf for x in pmf.setx chapter computational statistics pmf creates an empty pmf with no values. the set method sets the probability associated with each value to here s another example that counts the number of times each word appears in a sequence pmf pmf for word in word_list pmf.incrword incr increases the probability associated with each word by if a word is not already in the pmf it is added. i put probability in quotes because in this example the probabilities are not normalized that is they do not add up to so they are not true probabilities. but in this example the word counts are proportional to the probabilities. so after we count all the words we can compute probabilities by dividing through by the total number of words. pmf provides a method normalize that does exactly that pmf.normalize once you have a pmf object you can ask for the probability associated with any value print pmf.probthe and that would print the frequency of the word the as a fraction of the words in the list. pmf uses a python dictionary to store the values and their probabilities so the values in the pmf can be any hashable type. the probabilities can be any numerical type but they are usually floating-point numbers float. the cookie problem in the context of bayes s theorem it is natural to use a pmf to map from each hypothesis to its probability. in the cookie problem the hypotheses are and in python i represent them with strings pmf pmf pmf.setbowl pmf.setbowl the bayesian framework this distribution which contains the priors for each hypothesis is called for it the prior distribution. to update the distribution based on new data vanilla cookie we multiply each prior by the corresponding likelihood. the likelihood of drawing a vanilla cookie from bowl is the likelihood for bowl is pmf.multbowl pmf.multbowl mult does what you would expect. it gets the probability for the given hypothesis and multiplies by the given likelihood. after this update the distribution is no longer normalized but because these hypotheses are mutually exclusive and collectively exhaustive we can renormalize pmf.normalize the result is a distribution that contains the posterior probability for each hypothesis which is called now the posterior distribution. finally we can get the posterior probability for bowl print pmf.probbowl and the answer is you can download this example from http thinkbayes.comcookie.py. for more information see section the bayesian framework before we go on to other problems i want to rewrite the code from the previous section to make it more general. first i ll define a class to encapsulate the code related to this problem class cookiepmf def hypos pmf.__init__self for hypo in hypos self.sethypo self.normalize a cookie object is a pmf that maps from hypotheses to their probabilities. the method gives each hypothesis the same prior probability. as in the previous section there are two hypotheses chapter computational statistics hypos pmf cookiehypos cookie provides an update method that takes data as a parameter and updates the probabilities def updateself data for hypo in self.values like self.likelihooddata hypo self.multhypo like self.normalize update loops through each hypothesis in the suite and multiplies its probability by the likelihood of the data under the hypothesis which is computed by likelihood mixes def likelihoodself data hypo mix self.mixeshypo like mixdata return like likelihood uses mixes which is a dictionary that maps from the name of a bowl to the mix of cookies in the bowl. here s what the update looks like pmf.updatevanilla and then we can print the posterior probability of each hypothesis for hypo prob in pmf.items print hypo prob the result is bowl bowl which is the same as what we got before. this code is more complicated than what we saw in the previous section. one advantage is that it generalizes to the case where we draw more than one cookie from the same bowl replacement dataset for data in dataset pmf.updatedata the monty hall problem the other advantage is that it provides a framework for solving many similar problems. in the next section we ll solve the monty hall problem computationally and then see what parts of the framework are the same. the code in this section is available from py. for more information see section the monty hall problem to solve the monty hall problem i ll define a new class class montypmf def hypos pmf.__init__self for hypo in hypos self.sethypo self.normalize so far monty and cookie are exactly the same. and the code that creates the pmf is the same too except for the names of the hypotheses hypos pmf montyhypos calling update is pretty much the same data pmf.updatedata and the implementation of update is exactly the same def updateself data for hypo in self.values like self.likelihooddata hypo self.multhypo like self.normalize the only part that requires some work is likelihood def likelihoodself data hypo if hypo data return elif hypo return else return chapter computational statistics finally printing the results is the same for hypo prob in pmf.items print hypo prob and the answer is a b c in this example writing likelihood is a little complicated but the framework of the bayesian update is simple. the code in this section is available from httpthinkbayes.commonty.py. for more information see section encapsulating the framework now that we see what elements of the framework are the same we can encapsulate them in an object a suite is a pmf that provides update and print class suitepmf a suite of hypotheses and their probabilities. def hypotuple the distribution. def updateself data each hypothesis based on the data. def printself the hypotheses and their probabilities. the implementation of suite is in thinkbayes.py. to use suite you should write a class that inherits from it and provides likelihood. for example here is the solution to the monty hall problem rewritten to use suite from thinkbayes import suite class montysuite def likelihoodself data hypo if hypo data return the mm problem elif hypo return else return and here s the code that uses this class suite montyabc suite.updateb suite.print you can download this example from for more information see section the mm problem we can use the suite framework to solve the mm problem. writing the likelihood function is tricky but everything else is straightforward. first i need to encode the color mixes from before and after then i have to encode the hypotheses hypoa hypob hypoa represents the hypothesis that bag is from and bag from hypob is the other way around. next i map from the name of the hypothesis to the representation hypotheses dictahypoa bhypob chapter computational statistics and finally i can write likelihood. in this case the hypothesis hypo is a string either a or b. the data is a tuple that specifies a bag and a color. def likelihoodself data hypo bag color data mix self.hypotheseshypobag like mixcolor return like here s the code that creates the suite and updates it suite m_and_mab suite.print and here s the result a b the posterior probability of a is approximately which is what we got before. the code in this section is available from httpthinkbayes.comm_and_ m.py. for more information see section discussion this chapter presents the suite class which encapsulates the bayesian update framework. suite is an abstract type which means that it defines the interface a suite is supposed to have but does not provide a complete implementation. the suite interface includes update and likelihood but the suite class only provides an implementation of update not likelihood. a concrete type is a class that extends an abstract parent class and provides an implementation of the missing methods. for example monty extends suite so it inherits update and provides likelihood. if you are familiar with design patterns you might recognize this as an example of the template method pattern. you can read about this pattern at httpen.wikipedia.orgwikitemplate_method_pattern. exercises most of the examples in the following chapters follow the same pattern for each problem we define a new class that extends suite inherits update and provides likelihood. in a few cases we override update usually to improve performance. exercises exercise in section i said that the solution to the cookie problem generalizes to the case where we draw multiple cookies with replacement. but in the more likely scenario where we eat the cookies we draw the likelihood of each draw depends on the previous draws. modify the solution in this chapter to handle selection without replacement. hint add instance variables to cookie to represent the hypothetical state of the bowls and modify likelihood accordingly. you might want to define a bowl object. chapter computational statistics chapter estimation the dice problem suppose i have a box of dice that contains a die a die an die a die and a die. if you have ever played dungeons dragons you know what i am talking about. suppose i select a die from the box at random roll it and get a what is the probability that i rolled each die? let me suggest a three-step strategy for approaching a problem like this. choose a representation for the hypotheses. choose a representation for the data. write the likelihood function. in previous examples i used strings to represent hypotheses and data but for the die problem i ll use numbers. specifically i ll use the integers and to represent hypotheses suite and integers from to for the data. these representations make it easy to write the likelihood function class dicesuite def likelihoodself data hypo if hypo data return else return chapter estimation here s how likelihood works. if hypodata that means the roll is greater than the number of sides on the die. that can t happen so the likelihood is otherwise the question is given that there are hypo sides what is the chance of rolling data? the answer is regardless of data. here is the statement that does the update i roll a and here is the posterior distribution after we roll a the probability for the die is the most likely alternative is the die but there is still almost a chance for the die. what if we roll a few more times and get and for roll in suite.updateroll with this data the die is eliminated and the die seems quite likely. here are the results now the probability is that we are rolling the die and less than for the die. the dice problem is based on an example i saw in sanjoy mahajan s class on bayesian inference. you can download the code in this section from http for more information see section the locomotive problem i found the locomotive problem in frederick mosteller s fifty challenging problems in probability with solutions the locomotive problem figure posterior distribution for the locomotive problem based on a uniform prior. a railroad numbers its locomotives in order one day you see a locomotive with the number estimate how many locomotives the railroad has. based on this observation we know the railroad has or more locomotives. but how many more? to apply bayesian reasoning we can break this problem into two steps what did we know about n before we saw the data? for any given value of n what is the likelihood of seeing the data locomotive with number the answer to the first question is the prior. the answer to the second is the likelihood. we don t have much basis to choose a prior but we can start with something simple and then consider alternatives. let s assume that n is equally likely to be any value from to hypos now all we need is a likelihood function. in a hypothetical fleet of n locomotives what is the probability that we would see number if we assume that there is only one train-operating company only one we care about and that we are equally likely to see any of its locomotives then the chance of seeing any particular locomotive is here s the likelihood function of chapter estimation class trainsuite def likelihoodself data hypo if hypo data return else return this might look familiar the likelihood functions for the locomotive problem and the dice problem are identical. here s the update suite trainhypos there are too many hypotheses to print so i plotted the results in figure not surprisingly all values of n below have been eliminated. the most likely value if you had to guess is that might not seem like a very good guess after all what are the chances that you just happened to see the train with the highest number? nevertheless if you want to maximize the chance of getting the answer exactly right you should guess but maybe that s not the right goal. an alternative is to compute the mean of the posterior distribution def meansuite total for hypo prob in suite.items total hypo prob return total print meansuite or you could use the very similar method provided by pmf print suite.mean the mean of the posterior is so that might be a good guess if you wanted to minimize error. if you played this guessing game over and over using the mean of the posterior as your estimate would minimize the mean squared error over the long run httpen.wikipedia.org wikiminimum_mean_square_error. you can download this example from httpthinkbayes.comtrain.py. for more information see section what about that prior? what about that prior? to make any progress on the locomotive problem we had to make assumptions and some of them were pretty arbitrary. in particular we chose a uniform prior from to without much justification for choosing or for choosing a uniform distribution. it is not crazy to believe that a railroad company might operate locomotives but a reasonable person might guess more or fewer. so we might wonder whether the posterior distribution is sensitive to these assumptions. with so little data only one observation it probably is. recall that with a uniform prior from to the mean of the posterior is with an upper bound of we get a posterior mean of and with an upper bound of the posterior mean is so that s bad. there are two ways to proceed get more data. get more background information. with more data posterior distributions based on different priors tend to converge. for example suppose that in addition to train we also see trains and we can update the distribution like this for data in suite.updatedata with these data the means of the posteriors are upper posterior bound mean so the differences are smaller. an alternative prior if more data are not available another option is to improve the priors by gathering more background information. it is probably not reasonable to assume that a train-operating company with locomotives is just as likely as a company with only chapter estimation figure posterior distribution based on a power law prior compared to a uniform prior. with some effort we could probably find a list of companies that operate locomotives in the area of observation. or we could interview an expert in rail shipping to gather information about the typical size of companies. but even without getting into the specifics of railroad economics we can make some educated guesses. in most fields there are many small companies fewer medium-sized companies and only one or two very large companies. in fact the distribution of company sizes tends to follow a power law as robert axtell reports in science httpwww.sciencemag.org this law suggests that if there are companies with fewer than locomotives there might be companies with locomotives companies with and possibly one company with locomotives. mathematically a power law means that the number of companies with a given size is inversely proportional to size or pmfx x where pmfx is the probability mass function of x and is a parameter that is often near we can construct a power law prior like this class traindice of law credible intervals def hypos pmf.__init__self for hypo in hypos self.sethypo hypo-alpha self.normalize and here s the code that constructs the prior hypos suite trainhypos again the upper bound is arbitrary but with a power law prior the posterior is less sensitive to this choice. figure shows the new posterior based on the power law compared to the posterior based on the uniform prior. using the background information represented in the power law prior we can all but eliminate values of n greater than if we start with this prior and observe trains and the means of the posteriors are upper posterior bound mean now the differences are much smaller. in fact with an arbitrarily large upper bound the mean converges on so the power law prior is more realistic because it is based on general information about the size of companies and it behaves better in practice. you can download the examples in this section from httpthinkbayes. for more information see section credible intervals once you have computed a posterior distribution it is often useful to summarize the results with a single point estimate or an interval. for point estimates it is common to use the mean median or the value with maximum likelihood. chapter estimation for intervals we usually report two values computed so that there is a chance that the unknown value falls between them any other probability. these values define a credible interval. a simple way to compute a credible interval is to add up the probabilities in the posterior distribution and record the values that correspond to probabilities and in other words the and percentiles. thinkbayes provides a function that computes percentiles def percentilepmf percentage p percentage total for val prob in pmf.items total prob if total p return val and here s the code that uses it interval percentilesuite percentilesuite print interval for the previous example the locomotive problem with a power law prior and three trains the credible interval is the width of this range suggests correctly that we are still quite uncertain about how many locomotives there are. cumulative distribution functions in the previous section we computed percentiles by iterating through the values and probabilities in a pmf. if we need to compute more than a few percentiles it is more efficient to use a cumulative distribution function or cdf. cdfs and pmfs are equivalent in the sense that they contain the same information about the distribution and you can always convert from one to the other. the advantage of the cdf is that you can compute percentiles more efficiently. thinkbayes provides a cdf class that represents a cumulative distribution function. pmf provides a method that makes the corresponding cdf cdf suite.makecdf and cdf provides a function named percentile the german tank problem interval converting from a pmf to a cdf takes time proportional to the number of values lenpmf. the cdf stores the values and probabilities in sorted lists so looking up a probability to get the corresponding value takes log time that is time proportional to the logarithm of the number of values. looking up a value to get the corresponding probability is also logarithmic so cdfs are efficient for many calculations. the examples in this section are in for more information see section the german tank problem during world war ii the economic warfare division of the american embassy in london used statistical analysis to estimate german production of tanks and other the western allies had captured log books inventories and repair records that included chassis and engine serial numbers for individual tanks. analysis of these records indicated that serial numbers were allocated by manufacturer and tank type in blocks of numbers that numbers in each block were used sequentially and that not all numbers in each block were used. so the problem of estimating german tank production could be reduced within each block of numbers to a form of the locomotive problem. based on this insight american and british analysts produced estimates substantially lower than estimates from other forms of intelligence. and after the war records indicated that they were substantially more accurate. they performed similar analyses for tires trucks rockets and other equipment yielding accurate and actionable economic intelligence. the german tank problem is historically interesting it is also a nice example of real-world application of statistical estimation. so far many of the examples in this book have been toy problems but it will not be long before we start solving real problems. i think it is an advantage of bayesian analysis especially with the computational approach we are taking that it provides such a short path from a basic introduction to the research frontier. and brodie an empirical approach to economic intelligence in world war ii journal of the american statistical association vol. no. discussion chapter estimation among bayesians there are two approaches to choosing prior distributions. some recommend choosing the prior that best represents background information about the problem in that case the prior is said to be informative. the problem with using an informative prior is that people might use different background information interpret it differently. so informative priors often seem subjective. the alternative is a so-called uninformative prior which is intended to be as unrestricted as possible in order to let the data speak for themselves. in some cases you can identify a unique prior that has some desirable property like representing minimal prior information about the estimated quantity. uninformative priors are appealing because they seem more objective. but i am generally in favor of using informative priors. why? first bayesian analysis is always based on modeling decisions. choosing the prior is one of those decisions but it is not the only one and it might not even be the most subjective. so even if an uninformative prior is more objective the entire analysis is still subjective. also for most practical problems you are likely to be in one of two regimes either you have a lot of data or not very much. if you have a lot of data the choice of the prior doesn t matter very much informative and uninformative priors yield almost the same results. we ll see an example like this in the next chapter. but if as in the locomotive problem you don t have much data using relevant background information the power law distribution makes a big difference. and if as in the german tank problem you have to make life-and-death decisions based on your results you should probably use all of the information at your disposal rather than maintaining the illusion of objectivity by pretending to know less than you do. exercises exercise to write a likelihood function for the locomotive problem we had to answer this question if the railroad has n locomotives what is the probability that we see number exercises the answer depends on what sampling process we use when we observe the locomotive. in this chapter i resolved the ambiguity by specifying that there is only one train-operating company only one that we care about. but suppose instead that there are many companies with different numbers of trains. and suppose that you are equally likely to see any train operated by any company. in that case the likelihood function is different because you are more likely to see a train operated by a large company. as an exercise implement the likelihood function for this variation of the locomotive problem and compare the results. chapter estimation chapter more estimation the euro problem in information theory inference and learning algorithms david mackay poses this problem a statistical statement appeared in the guardian on friday january when spun on edge times a belgian one-euro coin came up heads times and tails it looks very suspicious to me said barry blight a statistics lecturer at the london school of economics. if the coin were unbiased the chance of getting a result as extreme as that would be less than but do these data give evidence that the coin is biased rather than fair? to answer that question we ll proceed in two steps. the first is to estimate the probability that the coin lands face up. the second is to evaluate whether the data support the hypothesis that the coin is biased. you can download the code in this section from httpthinkbayes.com euro.py. for more information see section any given coin has some probability x of landing heads up when spun on edge. it seems reasonable to believe that the value of x depends on some physical characteristics of the coin primarily the distribution of weight. chapter more estimation figure posterior distribution for the euro problem on a uniform prior. if a coin is perfectly balanced we expect x to be close to but for a lopsided coin x might be substantially different. we can use bayes s theorem and the observed data to estimate x. let s define hypotheses where hx is the hypothesis that the probability of heads is x for values from to i ll start with a uniform prior where the probability of hx is the same for all x. we ll come back later to consider other priors. the likelihood function is relatively easy if hx is true the probability of heads is and the probability of tails is class eurosuite def likelihoodself data hypo x hypo if data return else return here s the code that makes the suite and updates it suite dataset for data in dataset suite.updatedata the result is in figure summarizing the posterior summarizing the posterior again there are several ways to summarize the posterior distribution. one option is to find the most likely value in the posterior distribution. thinkbayes provides a function that does that def maximumlikelihoodpmf the value with the highest probability. prob val maxprob val for val prob in pmf.items return val in this case the result is which is also the observed percentage of heads so that suggests that the observed percentage is the maximum likelihood estimator for the population. we might also summarize the posterior by computing the mean and median print suite.mean print thinkbayes.percentilesuite the mean is the median is finally we can compute a credible interval print thinkbayes.credibleintervalsuite the result is now getting back to the original question we would like to know whether the coin is fair. we observe that the posterior credible interval does not include which suggests that the coin is not fair. but that is not exactly the question we started with. mackay asked do these data give evidence that the coin is biased rather than fair? to answer that question we will have to be more precise about what it means to say that data constitute evidence for a hypothesis. and that is the subject of the next chapter. but before we go on i want to address one possible source of confusion. since we want to know whether the coin is fair it might be tempting to ask for the probability that x is print the result is but that value is almost meaningless. the decision to evaluate hypotheses was arbitrary we could have divided the range into more or fewer pieces and if we had the probability for any given hypothesis would be greater or less. chapter more estimation figure uniform and triangular priors for the euro problem. swamping the priors we started with a uniform prior but that might not be a good choice. i can believe that if a coin is lopsided x might deviate substantially from but it seems unlikely that the belgian euro coin is so imbalanced that x is or it might be more reasonable to choose a prior that gives higher probability to values of x near and lower probability to extreme values. as an example i constructed a triangular prior shown in figure here s the code that constructs the prior def triangleprior suite euro for x in suite.setx x for x in suite.setx suite.normalize figure shows the result the uniform prior for comparison. updating this prior with the same dataset yields the posterior distribution shown in figure even with substantially different priors the posterior distributions are very similar. the medians and the credible intervals are identical the means differ by less than this is an example of swamping the priors with enough data people who start with different priors will tend to converge on the same posterior. optimization figure posterior distributions for the euro problem. optimization the code i have shown so far is meant to be easy to read but it is not very efficient. in general i like to develop code that is demonstrably correct then check whether it is fast enough for my purposes. if so there is no need to optimize. for this example if we care about run time there are several ways we can speed it up. the first opportunity is to reduce the number of times we normalize the suite. in the original code we call update once for each spin. dataset heads tails for data in dataset suite.updatedata and here s what update looks like def updateself data for hypo in self.values like self.likelihooddata hypo self.multhypo like return self.normalize each update iterates through the hypotheses then calls normalize which iterates through the hypotheses again. we can save some time by doing all of the updates before normalizing. suite provides a method called updateset that does exactly that. here it is chapter more estimation def updatesetself dataset for data in dataset for hypo in self.values like self.likelihooddata hypo self.multhypo like return self.normalize and here s how we can invoke it dataset heads tails suite.updatesetdataset this optimization speeds things up but the run time is still proportional to the amount of data. we can speed things up even more by rewriting likelihood to process the entire dataset rather than one spin at a time. in the original version data is a string that encodes either heads or tails def likelihoodself data hypo x hypo if data return x else return as an alternative we could encode the dataset as a tuple of two integers the number of heads and tails. in that case likelihood looks like this def likelihoodself data hypo x hypo heads tails data like xheads return like and then we can call update like this heads tails suite.updateheads tails since we have replaced repeated multiplication with exponentiation this version takes the same time for any number of spins. the beta distribution there is one more optimization that solves this problem even faster. the beta distribution so far we have used a pmf object to represent a discrete set of values for x. now we will use a continuous distribution specifically the beta distribution httpen.wikipedia.orgwikibeta_distribution. the beta distribution is defined on the interval from to both so it is a natural choice for describing proportions and probabilities. but wait it gets better. it turns out that if you do a bayesian update with a binomial likelihood function which is what we did in the previous section the beta distribution is a conjugate prior. that means that if the prior distribution for x is a beta distribution the posterior is also a beta distribution. but wait it gets even better. the shape of the beta distribution depends on two parameters written and or alpha and beta. if the prior is a beta distribution with parameters alpha and beta and we see data with h heads and t tails the posterior is a beta distribution with parameters alphah and betat. in other words we can do an update with two additions. so that s great but it only works if we can find a beta distribution that is a good choice for a prior. fortunately for many realistic priors there is a beta distribution that is at least a good approximation and for a uniform prior there is a perfect match. the beta distribution with and is uniform from to let s see how we can take advantage of all this. thinkbayes.py provides a class that represents a beta distribution class betaobject def self.alpha alpha self.beta beta by default makes a uniform distribution. update performs a bayesian update def updateself data heads tails data self.alpha heads self.beta tails data is a pair of integers representing the number of heads and tails. so we have yet another way to solve the euro problem chapter more estimation beta thinkbayes.beta print beta.mean beta provides mean which computes a simple function of alpha and beta def meanself return floatself.alpha self.beta for the euro problem the posterior mean is which is the same result we got using pmfs. beta also provides evalpdf which evaluates the probability density function of the beta distribution def evalpdfself x return finally beta provides makepmf which uses evalpdf to generate a discrete approximation of the beta distribution. discussion in this chapter we solved the same problem with two different priors and found that with a large dataset the priors get swamped. if two people start with different prior beliefs they generally find as they see more data that their posterior distributions converge. at some point the difference between their distributions is small enough that it has no practical effect. when this happens it relieves some of the worry about objectivity that i discussed in the previous chapter. and for many real-world problems even stark prior beliefs can eventually be reconciled by data. but that is not always the case. first remember that all bayesian analysis is based on modeling decisions. if you and i do not choose the same model we might interpret data differently. so even with the same data we would compute different likelihoods and our posterior beliefs might not converge. also notice that in a bayesian update we multiply each prior probability by a likelihood so if ph is phd is also regardless of d. in the euro problem if you are convinced that x is less than and you assign probability to all other hypotheses no amount of data will convince you otherwise. exercises this observation is the basis of cromwell s rule which is the recommendation that you should avoid giving a prior probability of to any hypothesis that is even remotely possible httpen.wikipedia.orgwiki cromwells_rule. cromwell s rule is named after oliver cromwell who wrote i beseech you in the bowels of christ think it possible that you may be mistaken. for bayesians this turns out to be good advice if it s a little overwrought. exercises exercise suppose that instead of observing coin tosses directly you measure the outcome using an instrument that is not always correct. specifically suppose there is a probability y that an actual heads is reported as tails or actual tails reported as heads. write a class that estimates the bias of a coin given a series of outcomes and the value of y. how does the spread of the posterior distribution depend on y? exercise this exercise is inspired by a question posted by a redditor named dominosci on reddit s statistics subreddit at http reddit. com r statistics reddit is an online forum with many interest groups called subreddits. users called redditors post links to online content and other web pages. other redditors vote on the links giving an upvote to high-quality links and a downvote to links that are bad or irrelevant. a problem identified by dominosci is that some redditors are more reliable than others and reddit does not take this into account. the challenge is to devise a system so that when a redditor casts a vote the estimated quality of the link is updated in accordance with the reliability of the redditor and the estimated reliability of the redditor is updated in accordance with the quality of the link. one approach is to model the quality of the link as the probability of garnering an upvote and to model the reliability of the redditor as the probability of correctly giving an upvote to a high-quality item. write class definitions for redditors and links and an update function that updates both objects whenever a redditor casts a vote. chapter more estimation chapter odds and addends odds one way to represent a probability is with a number between and but that s not the only way. if you have ever bet on a football game or a horse race you have probably encountered another representation of probability called odds. you might have heard expressions like the odds are three to one but you might not know what that means. the odds in favor of an event are the ratio of the probability it will occur to the probability that it will not. so if i think my team has a chance of winning i would say that the odds in their favor are three to one because the chance of winning is three times the chance of losing. you can write odds in decimal form but it is most common to write them as a ratio of integers. so three to one is written when probabilities are low it is more common to report the odds against rather than the odds in favor. for example if i think my horse has a chance of winning i would say that the odds against are probabilities and odds are different representations of the same information. given a probability you can compute the odds like this def oddsp return p given the odds in favor in decimal form you can convert to probability like this chapter odds and addends def probabilityo return o if you represent odds with a numerator and denominator you can convert to probability like this def no return yes no when i work with odds in my head i find it helpful to picture people at the track. if of them think my horse will win then of them don t so the odds in favor are or if the odds are against my horse then five out of six people think she will lose so the probability of winning is the odds form of bayes s theorem in chapter i wrote bayes s theorem in the probability form phd ph pdh pd if we have two hypotheses a and b we can write the ratio of posterior probabilities like this pad pbd pa pda pb pdb notice that the normalizing constant pd drops out of this equation. if a and b are mutually exclusive and collectively exhaustive that means pb pa so we can rewrite the ratio of the priors and the ratio of the posteriors as odds. writing oa for odds in favor of a we get oad oa pda pdb in words this says that the posterior odds are the prior odds times the likelihood ratio. this is the odds form of bayes s theorem. this form is most convenient for computing a bayesian update on paper or in your head. for example let s go back to the cookie problem oliver s blood suppose there are two bowls of cookies. bowl contains vanilla cookies and chocolate cookies. bowl contains of each. now suppose you choose one of the bowls at random and without looking select a cookie at random. the cookie is vanilla. what is the probability that it came from bowl the prior probability is so the prior odds are or just the hood ratio is or so the posterior odds are which corresponds to probability oliver s blood here is another problem from mackay s information theory inference and learning algorithms two people have left traces of their own blood at the scene of a crime. a suspect oliver is tested and found to have type o blood. the blood groups of the two traces are found to be of type o common type in the local population having frequency and of type ab rare type with frequency do these data traces found at the scene give evidence in favor of the proposition that oliver was one of the people left blood at the scene? to answer this question we need to think about what it means for data to give evidence in favor of against a hypothesis. intuitively we might say that data favor a hypothesis if the hypothesis is more likely in light of the data than it was before. in the cookie problem the prior odds are or probability the posterior odds are or probability so we could say that the vanilla cookie is evidence in favor of bowl the odds form of bayes s theorem provides a way to make this intuition more precise. again oad oa pda pdb or dividing through by oa oad oa pda pdb chapter odds and addends the term on the left is the ratio of the posterior and prior odds. the term on the right is the likelihood ratio also called the bayes factor. if the bayes factor value is greater than that means that the data were more likely under a than under b. and since the odds ratio is also greater than that means that the odds are greater in light of the data than they were before. if the bayes factor is less than that means the data were less likely under a than under b so the odds in favor of a go down. finally if the bayes factor is exactly the data are equally likely under either hypothesis so the odds do not change. if oliver is one of now we can get back to the oliver s blood problem. the people who left blood at the crime scene then he accounts for the o sample so the probability of the data is just the probability that a random member of the population has type ab blood which is if oliver did not leave blood at the scene then we have two samples to account for. if we choose two random people from the population what is the chance of finding one with type o and one with type ab well there are two ways it might happen the first person we choose might have type o and the second ab or the other way around. so the total probability is the likelihood of the data is slightly higher if oliver is not one of the people who left blood at the scene so the blood data is actually evidence against oliver s guilt. this example is a little contrived but it is an example of the counterintuitive result that data consistent with a hypothesis are not necessarily in favor of the hypothesis. if this result is so counterintuitive that it bothers you this way of thinking might help the data consist of a common event type o blood and a rare event type ab blood. if oliver accounts for the common event that leaves the rare event still unexplained. if oliver doesn t account for the o blood then we have two chances to find someone in the population with ab blood. and that factor of two makes the difference. addends the fundamental operation of bayesian statistics is update which takes a prior distribution and a set of data and produces a posterior distribution. addends but solving real problems usually involves a number of other operations including scaling addition and other arithmetic operations max and min and mixtures. this chapter presents addition and max i will present other operations as we need them. the first example is based on dungeons dragons a role-playing game where the results of players decisions are usually determined by rolling dice. in fact before game play starts players generate each attribute of their characters strength intelligence wisdom dexterity constitution and charisma by rolling three dice and adding them up. so you might be curious to know the distribution of this sum. there are two ways you might compute it simulation given a pmf that represents the distribution for a single die you can draw random samples add them up and accumulate the distribution of simulated sums. enumeration given two pmfs you can enumerate all possible pairs of val ues and compute the distribution of the sums. thinkbayes provides functions for both. here s an example of the first approach. first i ll define a class to represent a single die as a pmf class diethinkbayes.pmf def sides thinkbayes.pmf.__init__self for x in self.setx self.normalize now i can create a die and use thinkbayes.samplesum to generate a sample of rolls. dice three thinkbayes.samplesumdice samplesum takes list of distributions pmf or cdf objects and the sample size n. it generates n random sums and returns their distribution as a pmf object. chapter odds and addends def samplesumdists n pmf makepmffromlistrandomsumdists for i in xrangen return pmf samplesum uses randomsum also in thinkbayes.py def randomsumdists total sumdist.random for dist in dists return total randomsum invokes random on each distribution and adds up the results. the drawback of simulation is that the result is only approximately correct. as n gets larger it gets more accurate but of course the run time increases as well. the other approach is to enumerate all pairs of values and compute the sum and probability of each pair. this is implemented in pmf.__add__ class pmf def other pmf pmf for in self.items for in other.items return pmf self is a pmf of course other can be a pmf or anything else that provides items. the result is a new pmf. the time to run depends on the number of items in self and other it is proportional to lenself lenother. and here s how it s used three_exact when you apply the operator to a pmf python invokes in this example is invoked twice. figure shows an approximate result generated by simulation and the exact result computed by enumeration. pmf.__add__ is based on the assumption that the random selections from each pmf are independent. in the example of rolling several dice this assumption is pretty good. in other cases we would have to extend this method to use conditional probabilities. the code from this section is available from httpthinkbayes.com dungeons.py. for more information see section maxima figure approximate and exact distributions for the sum of three dice. maxima when you generate a dungeons dragons character you are particularly interested in the character s best attributes so you might like to know the distribution of the maximum attribute. there are three ways to compute the distribution of a maximum simulation given a pmf that represents the distribution for a single selection you can generate random samples find the maximum and accumulate the distribution of simulated maxima. enumeration given two pmfs you can enumerate all possible pairs of val ues and compute the distribution of the maximum. exponentiation if we convert a pmf to a cdf there is a simple and efficient algorithm for finding the cdf of the maximum. the code to simulate maxima is almost identical to the code for simulating sums def randommaxdists total maxdist.random for dist in dists return total def samplemaxdists n pmf makepmffromlistrandommaxdists for i in xrangen return pmf of three chapter odds and addends figure distribution of the maximum of six rolls of three dice. all i did was replace sum with max and the code for enumeration is almost identical too def res thinkbayes.pmf for in for in return res in fact you could generalize this function by taking the appropriate operator as a parameter. the only problem with this algorithm is that if each pmf has m values the run time is proportional to and if we want the maximum of k selections it takes time proportional to if we convert the pmfs to cdfs we can do the same calculation much faster! the key is to remember the definition of the cumulative distribution function cdfx px x where x is a random variable that means a value chosen randomly from this distribution. so for example is the probability that a value from this distribution is less than or equal to if i draw x from and y from and compute the maximum z maxx y what is the chance that z is less than or equal to well in that case both x and y must be less than or equal to of three mixtures if the selections of x and y are independent where is the distribution of z. i chose the value because i think it makes the formulas easy to read but we can generalize for any value of z in the special case where we draw k values from the same distribution cdfkz so to find the distribution of the maximum of k values we can enumerate the probabilities in the given cdf and raise them to the kth power. cdf provides a method that does just that class cdf def maxself k cdf self.copy cdf.ps for p in cdf.ps return cdf max takes the number of selections k and returns a new cdf that represents the distribution of the maximum of k selections. the run time for this method is proportional to m the number of items in the cdf. pmf.max does the same thing for pmfs. it has to do a little more work to convert the pmf to a cdf so the run time is proportional to m log m but that s still better than quadratic. finally here s an example that computes the distribution of a character s best attribute best_attr_cdf best_attr_pmf best_attr_cdf.makepmf where three_exact is defined in the previous section. if we print the results we see that the chance of generating a character with at least one attribute of is about figure shows the distribution. mixtures let s do one more example from dungeons dragons. suppose i have a box of dice with the following inventory chapter odds and addends figure distribution outcome for random die from a box. dice dice dice dice die i choose a die from the box and roll it. what is the distribution of the outcome? if you know which die it is the answer is easy. a die with n sides yields a uniform distribution from to n including both. but if we don t know which die it is the resulting distribution is a mixture of uniform distributions with different bounds. in general this kind of mixture does not fit any simple mathematical model but it is straightforward to compute the distribution in the form of a pmf. as always one option is to simulate the scenario generate a random sample and compute the pmf of the sample. this approach is simple and it generates an approximate solution quickly. but if we want an exact solution we need a different approach. let s start with a simple version of the problem where there are only two dice one with sides and one with we can make a pmf to represent each die then we create a pmf to represent the mixture mixtures mix thinkbayes.pmf for die in for outcome prob in die.items mix.incroutcome prob mix.normalize the first loop enumerates the dice the second enumerates the outcomes and their probabilities. inside the loop pmf.incr adds up the contributions from the two distributions. this code assumes that the two dice are equally likely. more generally we need to know the probability of each die so we can weight the outcomes accordingly. first we create a pmf that maps from each die to the probability it is selected pmf_dice thinkbayes.pmf pmf_dice.normalize next we need a more general version of the mixture algorithm mix thinkbayes.pmf for die weight in pmf_dice.items for outcome prob in die.items mix.incroutcome weightprob now each die has a weight associated with it makes it a weighted die i suppose. when we add each outcome to the mixture its probability is multiplied by weight. figure shows the result. as expected values through are the most likely because any die can produce them. values above are unlikely because there is only one die in the box that can produce them it does so less than half the time. thinkbayes provides a function named makemixture that encapsulates this algorithm so we could have written mix thinkbayes.makemixturepmf_dice we ll use makemixture again in chapters and chapter odds and addends discussion other than the odds form of bayes s theorem this chapter is not specifically bayesian. but bayesian analysis is all about distributions so it is important to understand the concept of a distribution well. from a computational point of view a distribution is any data structure that represents a set of values outcomes of a random process and their probabilities. we have seen two representations of distributions pmfs and cdfs. these representations are equivalent in the sense that they contain the same information so you can convert from one to the other. the primary difference between them is performance some operations are faster and easier with a pmf others are faster with a cdf. the other goal of this chapter is to introduce operations that act on distributions like pmf.__add__ cdf.max and thinkbayes.makemixture. we will use these operations later but i introduce them now to encourage you to think of a distribution as a fundamental unit of computation not just a container for values and probabilities. chapter decision analysis the price is right problem on november contestants named letia and nathaniel appeared on the price is right an american game show. they competed in a game called the showcase where the objective is to guess the price of a showcase of prizes. the contestant who comes closest to the actual price of the showcase without going over wins the prizes. nathaniel went first. his showcase included a dishwasher a wine cabinet a laptop computer and a car. he bid letia s showcase included a pinball machine a video arcade game a pool table and a cruise of the bahamas. she bid the actual price of nathaniel s showcase was his bid was too high so he lost. the actual price of letia s showcase was she was only off by so she won her showcase and because her bid was off by less than she also won nathaniel s showcase. for a bayesian thinker this scenario suggests several questions before seeing the prizes what prior beliefs should the contestant have about the price of the showcase? after seeing the prizes how should the contestant update those be liefs? based on the posterior distribution what should the contestant bid? chapter decision analysis figure distribution of prices for showcases on the price is right the third question demonstrates a common use of bayesian analysis decision analysis. given a posterior distribution we can choose the bid that maximizes the contestant s expected return. this problem is inspired by an example in cameron davidson-pilon s book bayesian methods for hackers. the code i wrote for this chapter is available from httpthinkbayes.comprice.py it reads data files you can download from and http for more information see section the prior to choose a prior distribution of prices we can take advantage of data from previous episodes. fortunately fans of the show keep detailed records. when i corresponded with mr. davidson-pilon about his book he sent me data collected by steve gee at it includes the price of each showcase from the and seasons and the bids offered by the contestants. figure shows the distribution of prices for these showcases. the most common value for both showcases is around but the first showcase has a second mode near and the second showcase is occasionally worth more than these distributions are based on actual data but they have been smoothed probability density functions by gaussian kernel density estimation before we go on i want to take a detour to talk about probability density functions and kde. probability density functions so far we have been working with probability mass functions or pmfs. a pmf is a map from each possible value to its probability. in my implementation a pmf object provides a method named prob that takes a value and returns a probability also known as a probability mass. a probability density function or pdf is the continuous version of a pmf where the possible values make up a continuous range rather than a discrete set. in mathematical notation pdfs are usually written as functions for example here is the pdf of a gaussian distribution with mean and standard deviation f exp for a given value of x this function computes a probability density. a density is similar to a probability mass in the sense that a higher density indicates that a value is more likely. but a density is not a probability. a density can be or any positive value it is not bounded like a probability between and if you integrate a density over a continuous range the result is a probability. but for the applications in this book we seldom have to do that. instead we primarily use probability densities as part of a likelihood function. we will see an example soon. representing pdfs to represent pdfs in python thinkbayes.py provides a class named pdf. pdf is an abstract type which means that it defines the interface a pdf is supposed to have but does not provide a complete implementation. the pdf interface includes two methods density and makepmf class pdfobject chapter decision analysis def densityself x raise unimplementedmethodexception def makepmfself xs pmf pmf for x in xs pmf.setx self.densityx pmf.normalize return pmf density takes a value x and returns the corresponding density. makepmf makes a discrete approximation to the pdf. pdf provides an implementation of makepmf but not density which has to be provided by a child class. a concrete type is a child class that extends an abstract type and provides an implementation of the missing methods. for example gaussianpdf extends pdf and provides density class gaussianpdfpdf def mu sigma self.mu mu self.sigma sigma def densityself x return scipy.stats.norm.pdfx self.mu self.sigma takes mu and sigma which are the mean and standard deviation of the distribution and stores them as attributes. density uses a function from scipy.stats to evaluate the gaussian pdf. the function is called norm.pdf because the gaussian distribution is also called the normal distribution. the gaussian pdf is defined by a simple mathematical function so it is easy to evaluate. and it is useful because many quantities in the real world have distributions that are approximately gaussian. but with real data there is no guarantee that the distribution is gaussian or any other simple mathematical function. in that case we can use a sample to estimate the pdf of the whole population. for example in the price is right data we have prices for the first showcase. we can think of these values as a sample from the population of all possible showcase prices. representing pdfs this sample includes the following values order in the sample no values appear between and but there is no reason to think that these values are impossible. based on our background information we expect all values in this range to be equally likely. in other words we expect the pdf to be fairly smooth. kernel density estimation is an algorithm that takes a sample and finds an appropriately smooth pdf that fits the data. you can read details at httpen.wikipedia.orgwikikernel_density_estimation. scipy provides an implementation of kde and thinkbayes provides a class called estimatedpdf that uses it class estimatedpdfpdf def sample self.kde scipy.stats.gaussian_kdesample def densityself x return self.kde.evaluatex takes a sample and computes a kernel density estimate. the result is a gaussian_kde object that provides an evaluate method. density takes a value calls gaussian_kde.evaluate and returns the resulting density. finally here s an outline of the code i used to generate figure prices readdata pdf thinkbayes.estimatedpdfprices low high n xs numpy.linspacelow high n pmf pdf.makepmfxs pdf is a pdf object estimated by kde. pmf is a pmf object that approximates the pdf by evaluating the density at a sequence of equally spaced values. linspace stands for linear space. it takes a range low and high and the number of points n and returns a new numpy array with n elements equally spaced between low and high including both. and now back to the price is right. chapter decision analysis figure cumulative distribution of the difference between the contestant s bid and the actual price. modeling the contestants the pdfs in figure estimate the distribution of possible prices. if you were a contestant on the show you could use this distribution to quantify your prior belief about the price of each showcase you see the prizes. to update these priors we have to answer these questions what data should we consider and how should we quantify it? can we compute a likelihood function that is for each hypothetical value of price can we compute the conditional likelihood of the data? to answer these questions i am going to model the contestant as a priceguessing instrument with known error characteristics. in other words when the contestant sees the prizes he or she guesses the price of each prize ideally without taking into consideration the fact that the prize is part of a showcase and adds up the prices. let s call this total guess. under this model the question we have to answer is if the actual price is price what is the likelihood that the contestant s estimate would be guess? or if we define error price guess modeling the contestants then we could ask what is the likelihood that the contestant s estimate is off by error? to answer this question we can use the historical data again. figure shows the cumulative distribution of diff the difference between the contestant s bid and the actual price of the showcase. the definition of diff is diff price bid when diff is negative the bid is too high. as an aside we can use this distribution to compute the probability that the contestants overbid the first contestant overbids of the time the second contestant overbids of the time. we can also see that the bids are biased that is they are more likely to be too low than too high. and that makes sense given the rules of the game. finally we can use this distribution to estimate the reliability of the contestants guesses. this step is a little tricky because we don t actually know the contestant s guesses we only know what they bid. so we ll have to make some assumptions. specifically i assume that the distribution of error is gaussian with mean and the same variance as diff. the player class implements this model class playerobject def prices bids diffs self.pdf_price thinkbayes.estimatedpdfprices self.cdf_diff thinkbayes.makecdffromlistdiffs mu sigma numpy.stddiffs self.pdf_error thinkbayes.gaussianpdfmu sigma prices is a sequence of showcase prices bids is a sequence of bids and diffs is a sequence of diffs where again diff price bid. pdf_price is the smoothed pdf of prices estimated by kde. cdf_diff is the cumulative distribution of diff which we saw in figure and pdf_error is the pdf that characterizes the distribution of errors where error price guess. chapter decision analysis again we use the variance of diff to estimate the variance of error. this estimate is not perfect because contestants bids are sometimes strategic for example if player thinks that player has overbid player might make a very low bid. in that case diff does not reflect error. if this happens a lot the observed variance in diff might overestimate the variance in error. nevertheless i think it is a reasonable modeling decision. as an alternative someone preparing to appear on the show could estimate their own distribution of error by watching previous shows and recording their guesses and the actual prices. likelihood now we are ready to write the likelihood function. as usual i define a new class that extends thinkbayes.suite class pricethinkbayes.suite def pmf player thinkbayes.suite.__init__self pmf self.player player pmf represents the prior distribution and player is a player object as described in the previous section. here s likelihood def likelihoodself data hypo price hypo guess data error price guess like self.player.errordensityerror return like hypo is the hypothetical price of the showcase. data is the contestant s best guess at the price. error is the difference and like is the likelihood of the data given the hypothesis. errordensity is defined in player class player def errordensityself error return self.pdf_error.densityerror update figure prior and posterior distributions for player based on a best guess of errordensity works by evaluating pdf_error at the given value of error. the result is a probability density so it is not really a probability. but remember that likelihood doesn t need to compute a probability it only has to compute something proportional to a probability. as long as the constant of proportionality is the same for all likelihoods it gets canceled out when we normalize the posterior distribution. and therefore a probability density is a perfectly good likelihood. update player provides a method that takes the contestant s guess and computes the posterior distribution class player def makebeliefsself guess pmf self.pmfprice self.prior pricepmf self self.posterior self.prior.copy self.posterior.updateguess pmfprice generates a discrete approximation to the pdf of price which we use to construct the prior. pmfprice uses makepmf which evaluates pdf_price at a sequence of values class player chapter decision analysis n price_xs n def pmfpriceself return self.pdf_price.makepmfself.price_xs to construct the posterior we make a copy of the prior and then invoke update which invokes likelihood for each hypothesis multiplies the priors by the likelihoods and renormalizes. so let s get back to the original scenario. suppose you are player and when you see your showcase your best guess is that the total price of the prizes is figure shows prior and posterior beliefs about the actual price. the posterior is shifted to the left because your guess is on the low end of the prior range. on one level this result makes sense. the most likely value in the prior is your best guess is and the mean of the posterior is somewhere in between on another level you might find this result bizarre because it suggests that if you think the price is then you should believe the price is to resolve this apparent paradox remember that you are combining two sources of information historical data about past showcases and guesses about the prizes you see. we are treating the historical data as the prior and updating it based on your guesses but we could equivalently use your guess as a prior and update it based on historical data. if you think of it that way maybe it is less surprising that the most likely value in the posterior is not your original guess. optimal bidding now that we have a posterior distribution we can use it to compute the optimal bid which i define as the bid that maximizes expected return httpen.wikipedia.orgwikiexpected_return. optimal bidding i m going to present the methods in this section top-down which means i will show you how they are used before i show you how they work. if you see an unfamiliar method don t worry the definition will be along shortly. to compute optimal bids i wrote a class called gaincalculator class gaincalculatorobject def player opponent self.player player self.opponent opponent player and opponent are player objects. gaincalculator provides expectedgains which computes a sequence of bids and the expected gain for each bid def expectedgainsself bids numpy.linspacelow high n gains for bid in bids return bids gains low and high specify the range of possible bids n is the number of bids to try. expectedgains calls expectedgain which computes expected gain for a given bid def expectedgainself bid suite self.player.posterior total for price prob in sortedsuite.items gain self.gainbid price total prob gain return total expectedgain loops through the values in the posterior and computes the gain for each bid given the actual prices of the showcase. it weights each gain with the corresponding probability and returns the total. expectedgain invokes gain which takes a bid and an actual price and returns the expected gain def gainself bid price if bid price return chapter decision analysis figure expected gain versus bid in a scenario where player s best guess is and player s best guess is diff price bid prob self.probwindiff if diff return price prob else return price prob if you overbid you get nothing. otherwise we compute the difference between your bid and the price which determines your probability of winning. if diff is less than you win both showcases. for simplicity i assume that both showcases have the same price. since this outcome is rare it doesn t make much difference. finally we have to compute the probability of winning based on diff def probwinself diff prob self.opponent.probworsethandiff return prob if your opponent overbids you win. otherwise you have to hope that your opponent is off by more than diff. player provides methods to compute both probabilities class player gain discussion def proboverbidself return def probworsethanself diff return self.cdf_diff.probdiff this code might be confusing because the computation is now from the point of view of the opponent who is computing what is the probability that i overbid? and what is the probability that my bid is off by more than diff? both answers are based on the cdf of diff. if the opponent s diff is less than or equal to you win. if the opponent s diff is worse than yours you win. otherwise you lose. finally here s the code that computes optimal bids class player def optimalbidself guess opponent self.makebeliefsguess calc gaincalculatorself opponent bids gains calc.expectedgains gain bid maxzipgains bids return bid gain given a guess and an opponent optimalbid computes the posterior distribution instantiates a gaincalculator computes expected gains for a range of bids and returns the optimal bid and expected gain. whew! figure shows the results for both players based on a scenario where player s best guess is and player s best guess is for player the optimal bid is yielding an expected return of almost this is a case turns out to be unusual where the optimal bid is actually higher than the contestant s best guess. for player the optimal bid is yielding an expected return of almost this is the more typical case where the optimal bid is less than the best guess. discussion one of the features of bayesian estimation is that the result comes in the form of a posterior distribution. classical estimation usually generates a chapter decision analysis single point estimate or a confidence interval which is sufficient if estimation is the last step in the process but if you want to use an estimate as an input to a subsequent analysis point estimates and intervals are often not much help. in this example we use the posterior distribution to compute an optimal bid. the return on a given bid is asymmetric and discontinuous you overbid you lose so it would be hard to solve this problem analytically. but it is relatively simple to do computationally. newcomers to bayesian thinking are often tempted to summarize the posterior distribution by computing the mean or the maximum likelihood estimate. these summaries can be useful but if that s all you need then you probably don t need bayesian methods in the first place. bayesian methods are most useful when you can carry the posterior distribution into the next step of the analysis to perform some kind of decision analysis as we did in this chapter or some kind of prediction as we see in the next chapter. chapter prediction the boston bruins problem in the national hockey league finals my beloved boston bruins played a best-of-seven championship series against the despised vancouver canucks. boston lost the first two games and then won the next two games and at this point in the series what is the probability that boston will win the next game and what is their probability of winning the championship? as always to answer a question like this we need to make some assumptions. first it is reasonable to believe that goal scoring in hockey is at least approximately a poisson process which means that it is equally likely for a goal to be scored at any time during a game. second we can assume that against a particular opponent each team has some long-term average goals per game denoted given these assumptions my strategy for answering this question is use statistics from previous games to choose a prior distribution for use the score from the first four games to estimate for each team. use the posterior distributions of to compute distribution of goals for each team the distribution of the goal differential and the probability that each team wins the next game. compute the probability that each team wins the series. chapter prediction to choose a prior distribution i got some statistics from httpwww.nhl. com specifically the average goals per game for each team in the season. the distribution is roughly gaussian with mean and standard deviation the gaussian distribution is continuous but we ll approximate it with a discrete pmf. thinkbayes provides makegaussianpmf to do exactly that def makegaussianpmfmu sigma num_sigmas pmf pmf low mu num_sigmassigma high mu num_sigmassigma for x in numpy.linspacelow high n p scipy.stats.norm.pdfx mu sigma pmf.setx p pmf.normalize return pmf mu and sigma are the mean and standard deviation of the gaussian distribution. num_sigmas is the number of standard deviations above and below the mean that the pmf will span and n is the number of values in the pmf. again we use numpy.linspace to make an array of n equally spaced values between low and high including both. norm.pdf evaluates the gaussian probability density function getting back to the hockey problem here s the definition for a suite of hypotheses about the value of class hockeythinkbayes.suite def pmf thinkbayes.suite.__init__self pmf so the prior distribution is gaussian with mean standard deviation and it spans sigmas above and below the mean. as always we have to decide how to represent each hypothesis in this case i represent the hypothesis that x with the floating-point value x. poisson processes poisson processes in mathematical statistics a process is a stochastic model of a physical system stochastic means that the model has some kind of randomness in it. for example a bernoulli process is a model of a sequence of events called trials in which each trial has two possible outcomes like success and failure. so a bernoulli process is a natural model for a series of coin flips or a series of shots on goal. a poisson process is the continuous version of a bernoulli process where an event can occur at any point in time with equal probability. poisson processes can be used to model customers arriving in a store buses arriving at a bus stop or goals scored in a hockey game. in many real systems the probability of an event changes over time. customers are more likely to go to a store at certain times of day buses are supposed to arrive at fixed intervals and goals are more or less likely at different times during a game. but all models are based on simplifications and in this case modeling a hockey game with a poisson process is a reasonable choice. heuer m ller and rubner analyze scoring in a german soccer league and come to the same conclusion see poisson.pdf. the benefit of using this model is that we can compute the distribution of goals per game efficiently as well as the distribution of time between goals. specifically if the average number of goals in a game is lam the distribution of goals per game is given by the poisson pmf def evalpoissonpmfk lam return math.exp-lam math.factorialk and the distribution of time between goals is given by the exponential pdf def evalexponentialpdfx lam return lam math.exp-lam x i use the variable lam because lambda is a reserved keyword in python. both of these functions are in thinkbayes.py. the posteriors now we can compute the likelihood that a team with a hypothetical value of lam scores k goals in a game chapter prediction figure posterior distribution of the number of goals per game. class hockey def likelihoodself data hypo lam hypo k data like thinkbayes.evalpoissonpmfk lam return like each hypothesis is a possible value of data is the observed number of goals k. with the likelihood function in place we can make a suite for each team and update them with the scores from the first four games. hockeybruins hockeycanucks figure shows the resulting posterior distributions for lam. based on the first four games the most likely values for lam are for the canucks and for the bruins. the distribution of goals to compute the probability that each team wins the next game we need to compute the distribution of goals for each team. per the distribution of goals figure distribution of goals in a single game. if we knew the value of lam exactly we could use the poisson distribution again. thinkbayes provides a method that computes a truncated approximation of a poisson distribution def makepoissonpmflam high pmf pmf for k in p evalpoissonpmfk lam pmf.setk p pmf.normalize return pmf the range of values in the computed pmf is from to high. so if the value of lam were exactly we would compute lam goal_dist thinkbayes.makepoissonpmflam i chose the upper bound because the probability of scoring more than goals in a game is quite low. that s simple enough so far the problem is that we don t know the value of lam exactly. instead we have a distribution of possible values for lam. for each value of lam the distribution of goals is poisson. so the overall distribution of goals is a mixture of these poisson distributions weighted according to the probabilities in the distribution of lam. given the posterior distribution of lam here s the code that makes the distribution of goals chapter prediction figure distribution of time between goals. def makegoalpmfsuite metapmf thinkbayes.pmf for lam prob in suite.items pmf thinkbayes.makepoissonpmflam metapmf.setpmf prob mix thinkbayes.makemixturemetapmf return mix for each value of lam we make a poisson pmf and add it to the meta-pmf. i call it a meta-pmf because it is a pmf that contains pmfs as its values. then we use makemixture to compute the mixture saw makemixture in section figure shows the resulting distribution of goals for the bruins and canucks. the bruins are less likely to score goals or fewer in the next game and more likely to score or more. the probability of winning to get the probability of winning first we compute the distribution of the goal differential diff until sudden death the subtraction operator invokes pmf.__sub__ which enumerates pairs of values and computes the difference. subtracting two distributions is almost the same as adding which we saw in section if the goal differential is positive the bruins win if negative the canucks win if it s a tie p_win p_loss p_tie with the distributions from the previous section p_win is p_loss is and p_tie is in the event of a tie at the end of regulation play the teams play overtime periods until one team scores. since the game ends immediately when the first goal is scored this overtime format is known as sudden death. sudden death to compute the probability of winning in a sudden death overtime the important statistic is not goals per game but time until the first goal. the assumption that goal-scoring is a poisson process implies that the time between goals is exponentially distributed. given lam we can compute the time between goals like this lam time_dist thinkbayes.makeexponentialpmflam high is the upper bound of the distribution. in this case i chose because the probability of going more than two games without scoring is small. n is the number of values in the pmf. if we know lam exactly that s all there is to it. but we don t instead we have a posterior distribution of possible values. so as we did with the distribution of goals we make a meta-pmf and compute a mixture of pmfs. def makegoaltimepmfsuite metapmf thinkbayes.pmf for lam prob in suite.items pmf thinkbayes.makeexponentialpmflam metapmf.setpmf prob chapter prediction mix thinkbayes.makemixturemetapmf return mix figure shows the resulting distributions. for time values less than one period third of a game the bruins are more likely to score. the time until the canucks score is more likely to be longer. i set the number of values n fairly high in order to minimize the number of ties since it is not possible for both teams to score simultaneously. now we compute the probability that the bruins score first p_overtime for the bruins the probability of winning in overtime is finally the total probability of winning is the chance of winning at the end of regulation play plus the probability of winning in overtime. p_tie p_overtime p_win p_tie p_overtime for the bruins the overall chance of winning the next game is to win the series the bruins can either win the next two games or split the next two and win the third. again we can compute the total probability win the next two p_series split the next two win the third p_series p_win p_win the bruins chance of winning the series is and in they did. discussion as always the analysis in this chapter is based on modeling decisions and modeling is almost always an iterative process. in general you want to start with something simple that yields an approximate answer identify likely sources of error and look for opportunities for improvement. in this example i would consider these options discussion i chose a prior based on the average goals per game for each team. but this statistic is averaged across all opponents. against a particular opponent we might expect more variability. for example if the team with the best offense plays the team with the worst defense the expected goals per game might be several standard deviations above the mean. for data i used only the first four games of the championship series. if the same teams played each other during the regular season i could use the results from those games as well. one complication is that the composition of teams changes during the season due to trades and injuries. so it might be best to give more weight to recent games. to take advantage of all available information we could use results from all regular season games to estimate each team s goal scoring rate possibly adjusted by estimating an additional factor for each pairwise match-up. this approach would be more complicated but it is still feasible. for the first option we could use the results from the regular season to estimate the variability across all pairwise match-ups. thanks to dirk hoag at httpforechecker.blogspot.com i was able to get the number of goals scored during regulation play overtime for each game in the regular season. teams in different conferences only play each other one or two times in the regular season so i focused on pairs that played each other times. for each pair i computed the average goals per game which is an estimate of then plotted the distribution of these estimates. the mean of these estimates is again but the standard deviation is substantially higher than what we got computing one estimate for each team. if we run the analysis again with the higher-variance prior the probability that the bruins win the series is substantially higher than the result with the low-variance prior so it turns out that the results are sensitive to the prior which makes sense considering how little data we have to work with. based on the difference between the low-variance model and the high-variable model it seems worthwhile to put some effort into getting the prior right. chapter prediction the code and data for this chapter are available from httpthinkbayes. comhockey.py and httpthinkbayes.comhockey_data.csv. for more information see section exercises exercise if buses arrive at a bus stop every minutes and you arrive at the bus stop at a random time your wait time until the bus arrives is uniformly distributed from to minutes. but in reality there is variability in the time between buses. suppose you are waiting for a bus and you know the historical distribution of time between buses. compute your distribution of wait times. hint suppose that the time between buses is either or minutes with equal probability. what is the probability that you arrive during one of the minute intervals? i solve a version of this problem in the next chapter. exercise suppose that passengers arriving at the bus stop are well-modeled by a poisson process with parameter if you arrive at the stop and find people waiting what is your posterior distribution for the time since the last bus arrived. i solve a version of this problem in the next chapter. exercise suppose that you are an ecologist sampling the insect population in a new environment. you deploy traps in a test area and come back the next day to check on them. you find that traps have been triggered trapping an insect inside. once a trap triggers it cannot trap another insect until it has been reset. if you reset the traps and come back in two days how many traps do you expect to find triggered? compute a posterior predictive distribution for the number of traps. exercise suppose you are the manager of an apartment building with light bulbs in common areas. it is your responsibility to replace light bulbs when they break. on january all bulbs are working. when you inspect them on february you find light bulbs out. if you come back on april how many light bulbs do you expect to find broken? in the previous exercise you could reasonably assume that an event is equally likely at any time. for light bulbs the likelihood of failure depends on the age of the exercises bulb. specifically old bulbs have an increasing failure rate due to evaporation of the filament. this problem is more open-ended than some you will have to make modeling decisions. you might want to read about the weibull distribution en. wikipedia. org wiki weibull_ distribution or you might want to look around for information about light bulb survival curves. chapter prediction chapter observer bias the red line problem in massachusetts the red line is a subway that connects cambridge and boston. when i was working in cambridge i took the red line from kendall square to south station and caught the commuter rail to needham. during rush hour red line trains run every minutes on average. when i arrived at the station i could estimate the time until the next train based on the number of passengers on the platform. if there were only a few people i inferred that i just missed a train and expected to wait about minutes. if there were more passengers i expected the train to arrive sooner. but if there were a large number of passengers i suspected that trains were not running on schedule so i would go back to the street level and get a taxi. while i was waiting for trains i thought about how bayesian estimation could help predict my wait time and decide when i should give up and take a taxi. this chapter presents the analysis i came up with. this chapter is based on a project by brendan ritter and kai austin who took a class with me at olin college. the code in this chapter is available from httpthinkbayes.comredline.py. the code i used to collect data is in httpthinkbayes.comredline_data.py. for more information see section chapter observer bias figure pmf of gaps between trains based on collected data smoothed by kde. z is the actual distribution zb is the biased distribution seen by passengers. the model before we get to the analysis we have to make some modeling decisions. first i will treat passenger arrivals as a poisson process which means i assume that passengers are equally likely to arrive at any time and that they arrive at an unknown rate measured in passengers per minute. since i observe passengers during a short period of time and at the same time every day i assume that is constant. on the other hand the arrival process for trains is not poisson. trains to boston are supposed to leave from the end of the line station every minutes during peak times but by the time they get to kendall square the time between trains varies between and minutes. to gather data on the time between trains i wrote a script that downloads real-time data from httpwww.mbta.comrider_toolsdevelopers selects south-bound trains arriving at kendall square and records their arrival times in a database. i ran the script from to every weekday for days and recorded about arrivals per day. then i computed the time between consecutive arrivals the distribution of these gaps is shown in figure labeled z. if you stood on the platform from to and recorded the time between trains this is the distribution you would see. but if you arrive at some random time regard to the train schedule you would see a wait times different distribution. the average time between trains as seen by a random passenger is substantially higher than the true average. why? because a passenger is more like to arrive during a large interval than a small one. consider a simple example suppose that the time between trains is either minutes or minutes with equal probability. in that case the average time between trains is minutes. but a passenger is more likely to arrive during a minute gap than a minute gap in fact twice as likely. if we surveyed arriving passengers we would find that of them arrived during a minute gap and only during a minute gap. so the average time between trains as seen by an arriving passenger is minutes. this kind of observer bias appears in many contexts. students think that classes are bigger than they are because more of them are in the big classes. airline passengers think that planes are fuller than they are because more of them are on full flights. in each case values from the actual distribution are oversampled in proportion to their value. in the red line example a gap that is twice as big is twice as likely to be observed. so given the actual distribution of gaps we can compute the distribution of gaps as seen by passengers. biaspmf does this computation def biaspmfpmf new_pmf pmf.copy for x p in pmf.items new_pmf.multx x new_pmf.normalize return new_pmf pmf is the actual distribution new_pmf is the biased distribution. inside the loop we multiply the probability of each value x by the likelihood it will be observed which is proportional to x. then we normalize the result. figure shows the actual distribution of gaps labeled z and the distribution of gaps seen by passengers labeled zb for z biased chapter observer bias figure cdf of z zb and the wait time seen by passengers y. wait times wait time which i call y is the time between the arrival of a passenger and the next arrival of a train. elapsed time which i call x is the time between the arrival of the previous train and the arrival of a passenger. i chose these definitions so that zb x y. given the distribution of zb we can compute the distribution of y. i ll start with a simple case and then generalize. suppose as in the previous example that zb is either minutes with probability or minutes with probability if we arrive at a random time during a minute gap y is uniform from to minutes. if we arrive during a minute gap y is uniform from to so the overall distribution is a mixture of uniform distributions weighted according to the probability of each gap. the following function takes the distribution of zb and computes the distribution of y def pmfofwaittimepmf_zb metapmf thinkbayes.pmf for gap prob in pmf_zb.items uniform gap metapmf.setuniform prob pmf_y thinkbayes.makemixturemetapmf return pmf_y wait times pmfofwaittime makes a meta-pmf that maps from each uniform distribution to its probability. then it uses makemixture which we saw in section to compute the mixture. pmfofwaittime also uses makeuniformpmf defined here def makeuniformpmflow high pmf thinkbayes.pmf for x in makerangelowlow highhigh pmf.setx pmf.normalize return pmf low and high are the range of the uniform distribution ends included. finally makeuniformpmf uses makerange defined here def makerangelow high return rangelow highskip skip makerange defines a set of possible values for wait time in seconds. by default it divides the range into second intervals. to encapsulate the process of computing these distributions i created a class called waittimecalculator class waittimecalculatorobject def pmf_z self.pmf_z pmf_z self.pmf_zb biaspmfpmf self.pmf_y self.pmfofwaittimeself.pmf_zb self.pmf_x self.pmf_y the parameter pmf_z is the unbiased distribution of z. pmf_zb is the biased distribution of gap time as seen by passengers. pmf_y is the distribution of wait time. pmf_x is the distribution of elapsed time which is the same as the distribution of wait time. to see why remember that for a particular value of zp the distribution of y is uniform from to zp. also x zp y so the distribution of x is also uniform from to zp. figure shows the distribution of z zb and y based on the data i collected from the red line web site. chapter observer bias figure prior and posterior of x and predicted y. to present these distributions i am switching from pmfs to cdfs. most people are more familiar with pmfs but i think cdfs are easier to interpret once you get used to them. and if you want to plot several distributions on the same axes cdfs are the way to go. the mean of z is minutes. the mean of zb is minutes about higher. the mean of y is half the mean of zb. as an aside the red line schedule reports that trains run every minutes during peak times. this is close to the average of zb but higher than the average of z. i exchanged email with a representative of the mbta who confirmed that the reported time between trains is deliberately conservative in order to account for variability. predicting wait times let s get back to the motivating question suppose that when i arrive at the platform i see people waiting. how long should i expect to wait until the next train arrives? as always let s start with the easiest version of the problem and work our way up. suppose we are given the actual distribution of z and we know that the passenger arrival rate is passengers per minute. in that case we can use the distribution of z to compute the prior distribution of zp the time between trains as seen by a passenger. xposterior xpred y predicting wait times then we can use the number of passengers to estimate the distribution of x the elapsed time since the last train. finally we use the relation y zp x to get the distribution of y. the first step is to create a waittimecalculator that encapsulates the distributions of zp x and y prior to taking into account the number of passengers. wtc waittimecalculatorpmf_z pmf_z is the given distribution of gap times. the next step is to make an elapsedtimeestimator below which encapsulates the posterior distribution of x and the predictive distribution of y. ete elapsedtimeestimatorwtc the parameters are the waittimecalculator the passenger arrival rate lam in passengers per second and the observed number of passengers let s say here is the definition of elapsedtimeestimator class elapsedtimeestimatorobject def wtc lam num_passengers self.prior_x elapsedwtc.pmf_x self.post_x self.prior_x.copy self.post_x.updatelam num_passengers self.pmf_y predictwaittimewtc.pmf_zb self.post_x prior_x and posterior_x are the prior and posterior distributions of elapsed time. pmf_y is the predictive distribution of wait time. elapsedtimeestimator uses elapsed and predictwaittime defined below. elapsed is a suite that represents the hypothetical distribution of x. the prior distribution of x comes straight from the waittimecalculator. then we use the data which consists of the arrival rate lam and the number of passengers on the platform to compute the posterior distribution. here s the definition of elapsed chapter observer bias class elapsedthinkbayes.suite def likelihoodself data hypo x hypo lam k data like thinkbayes.evalpoissonpmfk lam x return like as always likelihood takes a hypothesis and data and computes the likelihood of the data under the hypothesis. in this case hypo is the elapsed time since the last train and data is a tuple of lam and the number of passengers. the likelihood of the data is the probability of getting k arrivals in x time given arrival rate lam. we compute that using the pmf of the poisson distribution. finally here s the definition of predictwaittime def predictwaittimepmf_zb pmf_x pmf_y pmf_zb pmf_x removenegativespmf_y return pmf_y pmf_zb is the distribution of gaps between trains pmf_x is the distribution of elapsed time based on the observed number of passengers. since y zb x we can compute pmf_y pmf_zb pmf_x the subtraction operator invokes pmf.__sub__ which enumerates all pairs of zb and x computes the differences and adds the results to pmf_y. the resulting pmf includes some negative values which we know are impossible. for example if you arrive during a gap of minutes you can t wait more than minutes. removenegatives removes the impossible values from the distribution and renormalizes. def removenegativespmf for val in pmf.values if val pmf.removeval pmf.normalize figure shows the results. the prior distribution of x is the same as the distribution of y in figure the posterior distribution of x shows that after seeing passengers on the platform we believe that the time since estimating the arrival rate figure prior and posterior distributions of lam based on five days of passenger data. the last train is probably minutes. the predictive distribution of y indicates that we expect the next train in less than minutes with about confidence. estimating the arrival rate the analysis so far has been based on the assumption that we know the distribution of gaps and the passenger arrival rate. now we are ready to relax the second assumption. suppose that you just moved to boston so you don t know much about the passenger arrival rate on the red line. after a few days of commuting you could make a guess at least qualitatively. with a little more effort you could estimate quantitatively. each day when you arrive at the platform you should note the time and the number of passengers waiting the platform is too big you could choose a sample area. then you should record your wait time and the number of new arrivals while you are waiting. after five days you might have data like this y rate chapter observer bias where is the number of passengers waiting when you arrive y is your wait time in minutes and is the number of passengers who arrive while you are waiting. over the course of one week you waited minutes and saw passengers arrive so you would estimate that the arrival rate is passengers per minute. for practical purposes that estimate is good enough but for the sake of completeness i will compute a posterior distribution for and show how to use that distribution in the rest of the analysis. arrivalrate is a suite that represents hypotheses about as always likelihood takes a hypothesis and data and computes the likelihood of the data under the hypothesis. in this case the hypothesis is a value of the data is a pair y k where y is a wait time and k is the number of passengers that arrived. class arrivalratethinkbayes.suite def likelihoodself data hypo lam hypo y k data like thinkbayes.evalpoissonpmfk lam y return like look familiar to identical this likelihood might in that elapsed.likelihood in section in elapsed time elapsed.likelihood the hypothesis arrivalrate.likelihood the hypothesis is lam the arrival rate. but in both cases the likelihood is the probability of seeing k arrivals in some period of time given lam. it the difference is is almost is x the arrivalrateestimator encapsulates the process of estimating the parameter passenger_data is a list of y tuples as in the table above. class arrivalrateestimatorobject def passenger_data low high n incorporating uncertainty figure predictive distributions of y for possible values of lam. hypos numpy.linspacelow high n self.prior_lam arrivalratehypos self.post_lam self.prior_lam.copy for y in passenger_data self.post_lam.updatey builds hypos which is a sequence of hypothetical values for lam then builds the prior distribution prior_lam. the for loop updates the prior with data yielding the posterior distribution post_lam. figure shows the prior and posterior distributions. as expected the mean and median of the posterior are near the observed rate passengers per minute. but the spread of the posterior distribution captures our uncertainty about based on a small sample. incorporating uncertainty whenever there is uncertainty about one of the inputs to an analysis we can take it into account by a process like this implement the analysis based on a deterministic value of the uncertain parameter this case compute the distribution of the uncertain parameter. time chapter observer bias run the analysis for each value of the parameter and generate a set of predictive distributions. compute a mixture of the predictive distributions using the weights from the distribution of the parameter. we have already done steps and waitmixtureestimator to handle steps and class waitmixtureestimatorobject i wrote a class called def wtc are self.metapmf thinkbayes.pmf for lam prob in sortedare.post_lam.items ete elapsedtimeestimatorwtc lam num_passengers self.metapmf.setete.pmf_y prob self.mixture thinkbayes.makemixtureself.metapmf wtc is the waittimecalculator that contains the distribution of zb. are is the arrivaltimeestimator that contains the distribution of lam. the first line makes a meta-pmf that maps from each possible distribution of y to its probability. for each value of lam we use elapsedtimeestimator to compute the corresponding distribution of y and store it in the meta-pmf. then we use makemixture to compute the mixture. figure shows the results. the shaded lines in the background are the distributions of y for each value of lam with line thickness that represents likelihood. the dark line is the mixture of these distributions. in this case we could get a very similar result using a single point estimate of lam. so it was not necessary for practical purposes to include the uncertainty of the estimate. in general it is important to include variability if the system response is non-linear that is if small changes in the input can cause big changes in the output. in this case posterior variability in lam is small and the system response is approximately linear for small perturbations. decision analysis at this point we can use the number of passengers on the platform to predict the distribution of wait times. now let s get to the second part of the decision analysis figure probability that wait time exceeds minutes as a function of the number of passengers on the platform. question when should i stop waiting for the train and go catch a taxi? remember that in the original scenario i am trying to get to south station to catch the commuter rail. suppose i leave the office with enough time that i can wait minutes and still make my connection at south station. in that case i would like to know the probability that y exceeds minutes as a function of num_passengers. it is easy enough to use the analysis from section and run it for a range of num_passengers. but there s a problem. the analysis is sensitive to the frequency of long delays and because long delays are rare it is hard to estimate their frequency. i only have data from one week and the longest delay i observed was minutes. so i can t estimate the frequency of longer delays accurately. however i can use previous observations to make at least a coarse estimate. when i commuted by red line for a year i saw three long delays caused by a signaling problem a power outage and police activity at another stop. so i estimate that there are about major delays per year. but remember that my observations are biased. i am more likely to observe long delays because they affect a large number of passengers. so we should treat my observations as a sample of zb rather than z. here s how we can do that. during my year of commuting i took the red line home about times. so i take the observed gap times gap_times generate a sample of gaps and compute their pmf min chapter observer bias n cdf_z thinkbayes.makecdffromlistgap_times sample_z cdf_z.samplen pmf_z thinkbayes.makepmffromlistsample_z next i bias pmf_z to get the distribution of zb draw a sample and then add in delays of and minutes in seconds cdf_zp biaspmfpmf_z.makecdf sample_zb cdf_zp.samplen cdf.sample is more efficient than pmf.sample so it is usually faster to convert a pmf to a cdf before sampling. next i use the sample of zb to estimate a pdf using kde and then convert the pdf to a pmf pdf_zb thinkbayes.estimatedpdfsample_zb xs pmf_zb pdf_zb.makepmfxs finally i unbias the distribution of zb to get the distribution of z which i use to create the waittimecalculator pmf_z unbiaspmfpmf_zb wtc waittimecalculatorpmf_z this process is complicated but all of the steps are operations we have seen before. now we are ready to compute the probability of a long wait. def problongwaitnum_passengers minutes ete elapsedtimeestimatorwtc lam num_passengers cdf_y ete.pmf_y.makecdf prob cdf_y.probminutes given the number of passengers on the platform problongwait makes an elapsedtimeestimator extracts the distribution of wait time and computes the probability that wait time exceeds minutes. figure shows the result. when the number of passengers is less than we infer that the system is operating normally so the probability of a long delay is small. if there are passengers we estimate that it has been minutes since the last train that s longer than a normal delay so we infer that something is wrong and expect longer delays. if we are willing to accept a chance of missing the connection at south station we should stay and wait as long as there are fewer than passengers and take a taxi if there are more. discussion or to take this analysis one step further we could quantify the cost of missing the connection and the cost of taking a taxi then choose the threshold that minimizes expected cost. discussion the analysis so far has been based on the assumption that the arrival rate of passengers is the same every day. for a commuter train during rush hour that might not be a bad assumption but there are some obvious exceptions. for example if there is a special event nearby a large number of people might arrive at the same time. in that case the estimate of lam would be too low so the estimates of x and y would be too high. if special events are as common as major delays it would be important to include them in the model. we could do that by extending the distribution of lam to include occasional large values. we started with the assumption that we know distribution of z. as an alternative a passenger could estimate z but it would not be easy. as a passenger you only observe only your own wait time y. unless you skip the first train and wait for the second you don t observe the gap between trains z. however we could make some inferences about zb. if we note the number of passengers waiting when we arrive we can estimate the elapsed time since the last train x. then we observe y. if we add the posterior distribution of x to the observed y we get a distribution that represents our posterior belief about the observed value of zb. we can use this distribution to update our beliefs about the distribution of zb. finally we can compute the inverse of biaspmf to get from the distribution of zb to the distribution of z. i leave this analysis as an exercise for the reader. one suggestion you should read chapter first. you can find the outline of a solution in httpthinkbayes.comredline.py. for more information see section exercises exercise this exercise is from mackay information theory inference and learning algorithms chapter observer bias unstable particles are emitted from a source and decay at a distance x a real number that has an exponential probability distribution with decay events can only be observed if they occur in a window extending from x cm to x cm. n decays are observed at locations cm. what is the posterior distribution of you can download a solution to this exercise from http thinkbayes. com decay. py chapter two dimensions paintball paintball is a sport in which competing teams try to shoot each other with guns that fire paint-filled pellets that break on impact leaving a colorful mark on the target. it is usually played in an arena decorated with barriers and other objects that can be used as cover. suppose you are playing paintball in an indoor arena feet wide and feet long. you are standing near one of the foot walls and you suspect that one of your opponents has taken cover nearby. along the wall you see several paint spatters all the same color that you think your opponent fired recently. the spatters are at and feet measured from the lower-left corner of the room. based on these data where do you think your opponent is hiding? figure shows a diagram of the arena. using the lower-left corner of the room as the origin i denote the unknown location of the shooter with coordinates and or alpha and beta. the location of a spatter is labeled x. the angle the opponent shoots at is or theta. the paintball problem is a modified version of the lighthouse problem a common example of bayesian analysis. my notation follows the presentation of the problem in d.s. sivia s data analysis a bayesian tutorial second edition you can download the code in this chapter from httpthinkbayes.com paintball.py. for more information see section chapter two dimensions figure diagram of the layout for the paintball problem. the suite to get started we need a suite that represents a set of hypotheses about the location of the opponent. each hypothesis is a pair of coordinates beta. here is the definition of the paintball suite class paintballthinkbayes.suite thinkbayes.joint def alphas betas locations self.locations locations pairs beta for alpha in alphas for beta in betas thinkbayes.suite.__init__self pairs paintball inherits from suite which we have seen before and joint which i will explain soon. alphas is the list of possible values for alpha betas is the list of values for beta. pairs is a list of all beta pairs. locations is a list of possible locations along the wall it is stored for use in likelihood. the room is feet wide and feet long so here s the code that creates the suite alphas xshooterwall trigonometry figure posterior cdfs for alpha and beta given the data. betas locations suite paintballalphas betas locations this prior distribution assumes that all locations in the room are equally likely. given a map of the room we might choose a more detailed prior but we ll start simple. trigonometry now we need a likelihood function which means we have to figure out the likelihood of hitting any spot along the wall given the location of the opponent. as a simple model imagine that the opponent is like a rotating turret equally likely to shoot in any direction. in that case he is most likely to hit the wall at location alpha and less likely to hit the wall far away from alpha. with a little trigonometry we can compute the probability of hitting any spot along the wall. imagine that the shooter fires a shot at angle the pellet would hit the wall at location x where x tan chapter two dimensions figure pmf of location given for several values of beta. solving this equation for yields tan x so given a location on the wall we can find taking the derivative of the first equation with respect to yields dx d this derivative is what i ll call the strafing speed which is the speed of the target location along the wall as increases. the probability of hitting a given point on the wall is inversely related to strafing speed. if we know the coordinates of the shooter and a location along the wall we can compute strafing speed def strafingspeedalpha beta x theta alpha beta speed beta return speed alpha and beta are the coordinates of the shooter x is the location of a spatter. the result is the derivative of x with respect to theta. now we can compute a pmf that represents the probability of hitting any location on the wall. makelocationpmf takes alpha and beta the coordinates of the shooter and locations a list of possible values of x. likelihood def makelocationpmfalpha beta locations pmf thinkbayes.pmf for x in locations prob strafingspeedalpha beta x pmf.setx prob pmf.normalize return pmf makelocationpmf computes the probability of hitting each location which is inversely related to strafing speed. the result is a pmf of locations and their probabilities. figure shows the pmf of location with alpha and a range of values for beta. for all values of beta the most likely spatter location is x as beta increases so does the spread of the pmf. likelihood now all we need is a likelihood function. we can use makelocationpmf to compute the likelihood of any value of x given the coordinates of the opponent. def likelihoodself data hypo alpha beta hypo x data pmf makelocationpmfalpha beta self.locations like pmf.probx return like again alpha and beta are the hypothetical coordinates of the shooter and x is the location of an observed spatter. pmf contains the probability of each location given the coordinates of the shooter. from this pmf we select the probability of the observed location. and we re done. to update the suite we can use updateset which is inherited from suite. the result is a distribution that maps each beta pair to a posterior probability. joint distributions chapter two dimensions when each value in a distribution is a tuple of variables it is called a joint distribution because it represents the distributions of the variables together that is jointly a joint distribution contains the distributions of the variables as well information about the relationships among them. given a joint distribution we can compute the distributions of each variable independently which are called the marginal distributions. thinkbayes.joint provides a method that computes marginal distributions class joint def marginalself i pmf pmf for vs prob in self.items pmf.incrvsi prob return pmf i is the index of the variable we want in this example indicates the distribution of alpha and indicates the distribution of beta. here s the code that extracts the marginal distributions marginal_alpha marginal_beta figure shows the results to cdfs. the median value for alpha is near the center of mass of the observed spatters. for beta the most likely values are close to the wall but beyond feet the distribution is almost uniform which indicates that the data do not distinguish strongly between these possible locations. given the posterior marginals we can compute credible intervals for each coordinate independently print ci print ci the credible intervals are for alpha and for beta. so the data provide evidence that the shooter is in the near side of the room. but it is not strong evidence. the credible intervals cover most of the room! conditional distributions figure posterior distributions for alpha conditioned on several values of beta. conditional distributions the marginal distributions contain information about the variables independently but they do not capture the dependence between variables if any. one way to visualize dependence is by computing conditional distributions. thinkbayes.joint provides a method that does that def conditionalself i j val pmf pmf for vs prob in self.items if vsj val continue pmf.incrvsi prob pmf.normalize return pmf again i is the index of the variable we want j is the index of the conditioning variable and val is the conditional value. the result is the distribution of the ith variable under the condition that the jth variable is val. for example the following code computes the conditional distributions of alpha for a range of values of beta betas chapter two dimensions figure credible intervals for the coordinates of the opponent. for beta in betas cond beta figure shows the results which we could fully describe as posterior conditional marginal distributions. whew! if the variables were independent the conditional distributions would all be the same. since they are all different we can tell the variables are dependent. for example if we know that beta the conditional distribution of alpha is fairly narrow. for larger values of beta the distribution of alpha is wider. credible intervals another way to visualize the posterior joint distribution is to compute credible intervals. when we looked at credible intervals in section i skipped over a subtle point for a given distribution there are many intervals with the same level of credibility. for example if you want a credible interval you could choose any set of values whose probability adds up to when the values are one-dimensional it is most common to choose the central credible interval for example the central credible interval contains all values between the and percentiles. in multiple dimensions it is less obvious what the right credible interval should be. the best choice might depend on context but one common credible intervals choice is the maximum likelihood credible interval which contains the most likely values that add up to some other percentage. thinkbayes.joint provides a method that computes maximum likelihood credible intervals. class joint def maxlikeintervalself interval total t val for val prob in self.items t.sortreversetrue for prob val in t interval.appendval total prob if total break return interval the first step is to make a list of the values in the suite sorted in descending order by probability. next we traverse the list adding each value to the interval until the total probability exceeds percentage. the result is a list of values from the suite. notice that this set of values is not necessarily contiguous. to visualize the intervals i wrote a function that colors each value according to how many intervals it appears in def makecredibleplotsuite d dictpair for pair in suite.values percentages for p in percentages interval suite.maxlikeintervalp for pair in interval dpair return d d is a dictionary that maps from each value in the suite to the number of intervals it appears in. the loop computes intervals for several percentages and modifies d. chapter two dimensions figure shows the result. the credible interval is the darkest region near the bottom wall. for higher percentages the credible interval is bigger of course and skewed toward the right side of the room. discussion this chapter shows that the bayesian framework from the previous chapters can be extended to handle a two-dimensional parameter space. the only difference is that each hypothesis is represented by a tuple of parameters. i also presented joint which is a parent class that provides methods that apply to joint distributions marginal conditional and makelikeinterval. in object-oriented terms joint is a mixin http there is a lot of new vocabulary in this chapter so let s review joint distribution a distribution that represents all possible values in a multidimensional space and their probabilities. the example in this chapter is a two-dimensional space made up of the coordinates alpha and beta. the joint distribution represents the probability of each beta pair. marginal distribution the distribution of one parameter in a joint distribution treating the other parameters as unknown. for example figure shows the distributions of alpha and beta independently. conditional distribution the distribution of one parameter in a joint distribution conditioned on one or more of the other parameters. figure several distributions for alpha conditioned on different values of beta. given the joint distribution you can compute marginal and conditional distributions. with enough conditional distributions you could re-create the joint distribution at least approximately. but given the marginal distributions you cannot re-create the joint distribution because you have lost information about the dependence between variables. if there are n possible values for each of two parameters most operations on the joint distribution take time proportional to if there are d parameters run time is proportional to nd which quickly becomes impractical as the number of dimensions increases. exercises if you can process a million hypotheses in a reasonable amount of time you could handle two dimensions with values for each parameter or three dimensions with values each or six dimensions with values each. if you need more dimensions or more values per dimension there are optimizations you can try. i present an example in chapter you can download the code in this chapter from httpthinkbayes.com paintball.py. for more information see section exercises exercise in our simple model the opponent is equally likely to shoot in any direction. as an exercise let s consider improvements to this model. the analysis in this chapter suggests that a shooter is most likely to hit the closest wall. but in reality if the opponent is close to a wall he is unlikely to shoot at the wall because he is unlikely to see a target between himself and the wall. design an improved model that takes this behavior into account. try to find a model that is more realistic but not too complicated. chapter two dimensions chapter approximate bayesian computation the variability hypothesis i have a soft spot for crank science. recently i visited norumbega tower which is an enduring monument to the crackpot theories of eben norton horsford inventor of double-acting baking powder and fake history. but that s not what this chapter is about. this chapter is about the variability hypothesis which in the early nineteenth century with johann meckel who argued that males have a greater range of ability than females especially in intelligence. in other words he believed that most geniuses and most mentally retarded people are men. because he considered males to be the superior animal meckel concluded that females lack of variation was a sign of inferiority. from hypothesis. httpen.wikipedia.orgwikivariability_ i particularly like that last part because i suspect that if it turns out that women are actually more variable meckel would take that as a sign of inferiority too. anyway you will not be surprised to hear that the evidence for the variability hypothesis is weak. nevertheless it came up in my class recently when we looked at data from the cdc s behavioral risk factor surveillance system specifically chapter approximate bayesian computation the self-reported heights of adult american men and women. the dataset includes responses from men and women. here s what we found the average height for men is cm the average height for women is cm. so men are taller on average. no surprise there. for men the standard deviation is cm for women it is cm. so in absolute terms men s heights are more variable. but to compare variability between groups it is more meaningful to use the coefficient of variation which is the standard deviation divided by the mean. it is a dimensionless measure of variability relative to scale. for men cv is for women it is that s very close so we could conclude that this dataset provides weak evidence against the variability hypothesis. but we can use bayesian methods to make that conclusion more precise. and answering this question gives me a chance to demonstrate some techniques for working with large datasets. i will proceed in a few steps we ll start with the simplest implementation but it only works for datasets smaller than values. by computing probabilities under a log transform we can scale up to the full size of the dataset but the computation gets slow. finally we speed things up substantially with approximate bayesian computation also known as abc. you can download the code in this chapter from httpthinkbayes.com variability.py. for more information see section mean and standard deviation in chapter we estimated two parameters simultaneously using a joint distribution. in this chapter we use the same method to estimate the parameters of a gaussian distribution the mean mu and the standard deviation sigma. for this problem i define a suite called height that represents a map from each mu sigma pair to its probability mean and standard deviation class heightthinkbayes.suite thinkbayes.joint def mus sigmas pairs sigma for mu in mus for sigma in sigmas thinkbayes.suite.__init__self pairs mus is a sequence of possible values for mu sigmas is a sequence of values for sigma. the prior distribution is uniform over all mu sigma pairs. the likelihood function is easy. given hypothetical values of mu and sigma we compute the likelihood of a particular value x. that s what evalgaussianpdf does so all we have to do is use it class height def likelihoodself data hypo x data mu sigma hypo like thinkbayes.evalgaussianpdfx mu sigma return like if you have studied statistics from a mathematical perspective you know that when you evaluate a pdf you get a probability density. in order to get a probability you have to integrate probability densities over some range. but for our purposes we don t need a probability we just need something proportional to the probability we want. a probability density does that job nicely. the hardest part of this problem turns out to be choosing appropriate ranges for mus and sigmas. if the range is too small we omit some possibilities with non-negligible probability and get the wrong answer. if the range is too big we get the right answer but waste computational power. so this is an opportunity to use classical estimation to make bayesian techniques more efficient. specifically we can use classical estimators to find a likely location for mu and sigma and use the standard errors of those estimates to choose a likely spread. if the true parameters of the distribution are and and we take a sample of n values an estimator of is the sample mean m. and an estimator of is the sample standard variance s. chapter approximate bayesian computation estimated is the standard error of the estimated is s n and the standard error of the here s the code to compute all that def findpriorrangesxs num_points compute m and s n lenxs m numpy.meanxs s numpy.stdxs compute ranges for m and s stderr_m s math.sqrtn mus makerangem stderr_m num_stderrs stderr_s s sigmas makeranges stderr_s num_stderrs return mus sigmas xs is the dataset. num_points is the desired number of values in the range. num_stderrs is the width of the range on each side of the estimate in number of standard errors. the return value is a pair of sequences mus and sigmas. here s makerange def makerangeestimate stderr num_stderrs spread stderr num_stderrs array numpy.linspaceestimate-spread estimatespread num_points return array numpy.linspace makes an array of equally spaced elements between estimate-spread and estimatespread including both. update finally here s the code to make and update the suite mus sigmas findpriorrangesxs num_points suite heightmus sigmas the posterior distribution of cv suite.updatesetxs print suite.maximumlikelihood this process might seem bogus because we use the data to choose the range of the prior distribution and then use the data again to do the update. in general using the same data twice is in fact bogus. but in this case it is ok. really. we use the data to choose the range for the prior but only to avoid computing a lot of probabilities that would have been very small anyway. with the range is big enough to cover all values with non-negligible likelihood. after that making it bigger has no effect on the results. in effect the prior is uniform over all values of mu and sigma but for computational efficiency we ignore all the values that don t matter. the posterior distribution of cv once we have the posterior joint distribution of mu and sigma we can compute the distribution of cv for men and women and then the probability that one exceeds the other. to compute the distribution of cv we enumerate pairs of mu and sigma def coefvariationsuite pmf thinkbayes.pmf for sigma p in suite.items pmf.incrsigmamu p return pmf then we use thinkbayes.pmfprobgreater to compute the probability that men are more variable. the analysis itself is simple but there are two more issues we have to deal with as the size of the dataset increases we run into a series of computa tional problems due to the limitations of floating-point arithmetic. the dataset contains a number of extreme values that are almost certainly errors. we will need to make the estimation process robust in the presence of these outliers. the following sections explain these problems and their solutions. chapter approximate bayesian computation underflow if we select the first values from the brfss dataset and run the analysis i just described it runs without errors and we get posterior distributions that look reasonable. if we select the first values and run the program again we get an error in pmf.normalize valueerror total probability is zero. the problem is that we are using probability densities to compute likelihoods and densities from continuous distributions tend to be small. and if you take small values and multiply them together the result is very small. in this case it is so small it can t be represented by a floating-point number so it gets rounded down to zero which is called underflow. and if all probabilities in the distribution are it s not a distribution any more. a possible solution is to renormalize the pmf after each update or after each batch of that would work but it would be slow. a better alternative is to compute likelihoods under a log transform. that way instead of multiplying small values we can add up log likelihoods. pmf provides methods log logupdateset and exp to make this process easy. log computes the log of the probabilities in a pmf class pmf def logself m self.maxlike for x p in self.d.iteritems if p self.setx math.logpm else self.removex before applying the log transform log uses maxlike to find m the highest probability in the pmf. it divide all probabilities by m so the highest probability gets normalized to which yields a log of the other log probabilities are all negative. if there are any values in the pmf with probability they are removed. while the pmf is under a log transform we can t use update updateset or normalize. the result would be nonsensical if you try pmf raises an exception. instead we have to use logupdate and logupdateset. log-likelihood here s the implementation of logupdateset class suite def logupdatesetself dataset for data in dataset self.logupdatedata logupdateset loops through the data and calls logupdate class suite def logupdateself data for hypo in self.values like self.loglikelihooddata hypo self.incrhypo like logupdate is just like update except that it calls loglikelihood instead of likelihood and incr instead of mult. using log-likelihoods avoids the problem with underflow but while the pmf is under the log transform there s not much we can do with it. we have to use exp to invert the transform class pmf def expself m self.maxlike for x p in self.d.iteritems self.setx math.expp-m if the log-likelihoods are large negative numbers the resulting likelihoods might underflow. so exp finds the maximum log-likelihood m and shifts all the likelihoods up by m. the resulting distribution has a maximum likelihood of this process inverts the log transform with minimal loss of precision. log-likelihood now all we need is loglikelihood. class height def loglikelihoodself data hypo x data chapter approximate bayesian computation mu sigma hypo loglike scipy.stats.norm.logpdfx mu sigma return loglike norm.logpdf computes the log-likelihood of the gaussian pdf. here s what the whole update process looks like suite.log suite.logupdatesetxs suite.exp suite.normalize to review log puts the suite under a log transform. logupdateset calls logupdate which calls loglikelihood. logupdate uses pmf.incr because adding a log-likelihood is the same as multiplying by a likelihood. after the update the log-likelihoods are large negative numbers so exp shifts them up before inverting the transform which is how we avoid underflow. once the suite is transformed back the probabilities are linear again which means not logarithmic so we can use normalize again. using this algorithm we can process the entire dataset without underflow but it is still slow. on my computer it might take an hour. we can do better. a little optimization this section uses math and computational optimization to speed things up by a factor of but the following section presents an algorithm that is even faster. so if you want to get right to the good stuff feel free to skip this section. suite.logupdateset calls logupdate once for each data point. we can speed it up by computing the log-likelihood of the entire dataset at once. x x log we ll start with the gaussian pdf exp and compute the log the constant term a little optimization given a sequence of values xi the total log-likelihood is xi i log pulling out the terms that don t depend on i we get n log i which we can translate into python class height def logupdatesetfastself data xs tupledata n lenxs for hypo in self.values mu sigma hypo total summationxs mu loglike math.logsigma total self.incrhypo loglike by itself this would be a small improvement but it creates an opportunity for a bigger one. notice that the summation only depends on mu not sigma so we only have to compute it once for each value of mu. to avoid recomputing i factor out a function that computes the summation and memoize it so it stores previously computed results in a dictionary httpen.wikipedia.orgwikimemoization def summationxs mu cache try return cachexs mu except keyerror ds for x in xs total sumds cachexs mu total return total cache stores previously computed sums. the try statement returns a result from the cache if possible otherwise it computes the summation then caches and returns the result. the only catch is that we can t use a list as a key in the cache because it is chapter approximate bayesian computation not a hashable type. that s why logupdatesetfast converts the dataset to a tuple. this optimization speeds up the computation by about a factor of processing the entire dataset men and women in less than a minute on my not-very-fast computer. abc but maybe you don t have that kind of time. in that case approximate bayesian computation might be the way to go. the motivation behind abc is that the likelihood of any particular dataset is very small especially for large datasets which is why we had to use the log transform expensive to compute which is why we had to do so much optimiza tion and not really what we want anyway. we don t really care about the likelihood of seeing the exact dataset we saw. especially for continuous variables we care about the likelihood of seeing any dataset like the one we saw. for example in the euro problem we don t care about the order of the coin flips only the total number of heads and tails. and in the locomotive problem we don t care about which particular trains were seen only the number of trains and the maximum of the serial numbers. similarly in the brfss sample we don t really want to know the probability of seeing one particular set of values since there are hundreds of thousands of them. it is more relevant to ask if we sample people from a population with hypothetical values of and what would be the chance of collecting a sample with the observed mean and variance? for samples from a gaussian distribution we can answer this question efficiently because we can find the distribution of the sample statistics analytically. in fact we already did it when we computed the range of the prior. if you draw n values from a gaussian distribution with parameters and and compute the sample mean m the distribution of m is gaussian with parameters and n. robust estimation with parameters and similarly the distribution of the sample standard deviation s is gaussian we can use these sample distributions to compute the likelihood of the sample statistics m and s given hypothetical values for and here s a new version of logupdateset that does it def logupdatesetabcself data xs data n lenxs compute sample statistics m numpy.meanxs s numpy.stdxs for hypo in sortedself.values mu sigma hypo compute log likelihood of m given hypo stderr_m sigma math.sqrtn loglike evalgaussianlogpdfm mu stderr_m log likelihood of s given hypo stderr_s sigma loglike evalgaussianlogpdfs sigma stderr_s self.incrhypo loglike on my computer this function processes the entire dataset in about a second and the result agrees with the exact result with about digits of precision. robust estimation we are almost ready to look at results but we have one more problem to deal with. there are a number of outliers in this dataset that are almost certainly errors. for example there are three adults with reported height of cm which would place them among the shortest living adults in the world. at the other end there are four women with reported height cm just short of the tallest women in the world. it is not impossible that these values are correct but it is unlikely which makes it hard to know how to deal with them. and we have to get it chapter approximate bayesian computation figure contour plot of the posterior joint distribution of mean and standard deviation of height for men in the u.s. figure contour plot of the posterior joint distribution of mean and standard deviation of height for women in the u.s. height joint height joint distribution robust estimation right because these extreme values have a disproportionate effect on the estimated variability. because abc is based on summary statistics rather than the entire dataset we can make it more robust by choosing summary statistics that are robust in the presence of outliers. for example rather than use the sample mean and standard deviation we could use the median and inter-quartile range which is the difference between the and percentiles. more generally we could compute an inter-percentile range that spans any given fraction of the distribution p def medianiprxs p cdf thinkbayes.makecdffromlistxs median alpha ipr cdf.valuealpha return median ipr xs is a sequence of values. p is the desired range for example yields the inter-quartile range. medianipr works by computing the cdf of xs then extracting the median and the difference between two percentiles. we can convert from ipr to an estimate of sigma using the gaussian cdf to compute the fraction of the distribution covered by a given number of standard deviations. for example it is a well-known rule of thumb that of a gaussian distribution falls within one standard deviation of the mean which leaves in each tail. if we compute the range between the and percentiles we expect the result to be sigma. so we can estimate sigma by computing the ipr and dividing by more generally we could use any number of sigmas. medians performs the more general version of this computation def mediansxs num_sigmas half_p thinkbayes.standardgaussiancdfnum_sigmas median ipr medianiprxs half_p s ipr num_sigmas return median s chapter approximate bayesian computation figure posterior distributions of cv for men and women based on robust estimators. again xs is the sequence of values num_sigmas is the number of standard deviations the results should be based on. the result is median which estimates and s which estimates finally in logupdatesetabc we can replace the sample mean and standard deviation with median and s. and that pretty much does it. it might seem odd that we are using observed percentiles to estimate and but it is an example of the flexibility of the bayesian approach. in effect we are asking given hypothetical values for and and a sampling process that has some chance of introducing errors what is the likelihood of generating a given set of sample statistics? we are free to choose any sample statistics we like up to a point and determine the location and spread of a distribution so we need to choose statistics that capture those characteristics. for example if we chose the and percentiles we would get very little information about spread so it would leave the estimate of relatively unconstrained by the data. all values of sigma would have nearly the same likelihood of producing the observed values so the posterior distribution of sigma would look a lot like the prior. who is more variable? finally we are ready to answer the question we started with is the coefficient of variation greater for men than for women? of discussion using abc based on the median and ipr with i computed posterior joint distributions for mu and sigma. figures and show the results as a contour plot with mu on the x-axis sigma on the y-axis and probability on the z-axis. for each joint distribution i computed the posterior distribution of cv. figure shows these distributions for men and women. the mean for men is for women it is since there is no overlap between the distributions we conclude with near certainty that women are more variable in height than men. so is that the end of the variability hypothesis? it turns out that this result depends on the choice of the inter-percentile range. with we conclude that women are more variable but with we conclude with equal confidence that men are more variable. sadly no. the reason for the difference is that there are more men of short stature and their distance from the mean is greater. so our evaluation of the variability hypothesis depends on the interpretation of variability. with we focus on people near the mean. as we increase num_sigmas we give more weight to the extremes. to decide which emphasis is appropriate we would need a more precise statement of the hypothesis. as it is the variability hypothesis may be too vague to evaluate. nevertheless it helped me demonstrate several new ideas and i hope you agree it makes an interesting example. discussion there are two ways you might think of abc. one interpretation is that it is as the name suggests an approximation that is faster to compute than the exact value. but remember that bayesian analysis is always based on modeling decisions which implies that there is no exact solution. for any interesting physical system there are many possible models and each model yields different results. to interpret the results we have to evaluate the models. chapter approximate bayesian computation so another interpretation of abc is that it represents an alternative model of the likelihood. when we compute pdh we are asking what is the likelihood of the data under a given hypothesis? for large datasets the likelihood of the data is very small which is a hint that we might not be asking the right question. what we really want to know is the likelihood of any outcome like the data where the definition of like is yet another modeling decision. the underlying idea of abc is that two datasets are alike if they yield the same summary statistics. but in some cases like the example in this chapter it is not obvious which summary statistics to choose. you can download the code in this chapter from httpthinkbayes.com variability.py. for more information see section exercises exercise an effect size is a statistic intended to measure the difference between two groups http en. wikipedia. org wiki effect_ size for example we could use data from the brfss to estimate the difference in height between men and women. by sampling values from the posterior distributions of and we could generate the posterior distribution of this difference. but it might be better to use a dimensionless measure of effect size rather than a difference measured in cm. one option is to use divide through by the standard deviation to what we did with the coefficient of variation. if the parameters for group are and the parameters for group are the dimensionless effect size is write a function that takes joint distributions of mu and sigma for two groups and returns the posterior distribution of effect size. hint if enumerating all pairs from the two distributions takes too long consider random sampling. chapter hypothesis testing back to the euro problem in section i presented a problem from mackay s information theory inference and learning algorithms a statistical statement appeared in the guardian on friday january when spun on edge times a belgian one-euro coin came up heads times and tails it looks very suspicious to me said barry blight a statistics lecturer at the london school of economics. if the coin were unbiased the chance of getting a result as extreme as that would be less than but do these data give evidence that the coin is biased rather than fair? we estimated the probability that the coin would land face up but we didn t really answer mackay s question do the data give evidence that the coin is biased? in chapter i proposed that data are in favor of a hypothesis if the data are more likely under the hypothesis than under the alternative or equivalently if the bayes factor is greater than in the euro example we have two hypotheses to consider i ll use f for the hypothesis that the coin is fair and b for the hypothesis that it is biased. if the coin is fair it is easy to compute the likelihood of the data pdf. in fact we already wrote the function that does it. chapter hypothesis testing def likelihoodself data hypo x hypo head tails data like xheads return like to use it we can create a euro suite and invoke likelihood suite euro likelihood suite.likelihooddata pdf is which doesn t tell us much except that the probability of seeing any particular dataset is very small. it takes two likelihoods to make a ratio so we also have to compute pdb. it is not obvious how to compute the likelihood of b because it s not obvious what biased means. one possibility is to cheat and look at the data before we define the hypothesis. in that case we would say that biased means that the probability of heads is actual_percent likelihood suite.likelihooddata actual_percent this version of b i call b_cheat the likelihood of b_cheat is and the likelihood ratio is so we would say that the data are evidence in favor of this version of b. but using the data to formulate the hypothesis is obviously bogus. by that definition any dataset would be evidence in favor of b unless the observed percentage of heads is exactly making a fair comparison to make a legitimate comparison we have to define b without looking at the data. so let s try a different definition. if you inspect a belgian euro coin you might notice that the heads side is more prominent than the tails side. you might expect the shape to have some effect on x but be unsure whether it makes heads more or less likely. so you might say i think the coin is biased so that x is either or but i am not sure which. we can think of this version which i ll call b_two as a hypothesis made up of two sub-hypotheses. we can compute the likelihood for each subhypothesis and then compute the average likelihood. making a fair comparison suite.likelihooddata suite.likelihooddata likelihood the likelihood ratio bayes factor for b_two is which means the data provide weak evidence in favor of b_two. more generally suppose you suspect that the coin is biased but you have no clue about the value of x. in that case you might build a suite which i call b_uniform to represent sub-hypotheses from to b_uniform b_uniform.normalize i initialize b_uniform with values from to i removed the subhypothesis that x is because if x is the coin is fair but it has almost no effect on the result whether you remove it or not. to compute the likelihood of b_uniform we compute the likelihood of each sub-hypothesis and accumulate a weighted average. def suitelikelihoodsuite data total for hypo prob in suite.items like suite.likelihooddata hypo total prob like return total the likelihood ratio for b_uniform is which means that the data are weak evidence against b_uniform compared to f. if you think about the computation performed by suitelikelihood you might notice that it is similar to an update. to refresh your memory here s the update function def updateself data for hypo in self.values like self.likelihooddata hypo self.multhypo like return self.normalize and here s normalize def normalizeself total self.total factor total chapter hypothesis testing for x in self.d self.dx factor return total the return value from normalize is the total of the probabilities in the suite which is the average of the likelihoods for the sub-hypotheses weighted by the prior probabilities. and update passes this value along so instead of using suitelikelihood we could compute the likelihood of b_uniform like this likelihood b_uniform.updatedata the triangle prior in chapter we also considered a triangle-shaped prior that gives higher probability to values of x near if we think of this prior as a suite of sub-hypotheses we can compute its likelihood like this b_triangle triangleprior likelihood b_triangle.updatedata the likelihood ratio for b_triangle is compared to f so again we would say that the data are weak evidence against b. the following table shows the priors we have considered the likelihood of each and the likelihood ratio bayes factor relative to f. hypothesis likelihood bayes factor f b_cheat b_two b_uniform b_triangle depending on which definition we choose the data might provide evidence for or against the hypothesis that the coin is biased but in either case it is relatively weak evidence. in summary we can use bayesian hypothesis testing to compare the likelihood of f and b but we have to do some work to specify precisely what b means. this specification depends on background information about coins and their behavior when spun so people could reasonably disagree about the right definition. discussion my presentation of this example follows david mackay s discussion and comes to the same conclusion. you can download the code i used in this chapter from for more information see section discussion the bayes factor for b_uniform is which means that the data provide evidence against this hypothesis compared to f. in the previous section i characterized this evidence as weak but didn t say why. part of the answer is historical. harold jeffreys an early proponent of bayesian statistics suggested a scale for interpreting bayes factors strength bayes factor very strong barely worth mentioning substantial strong decisive in the example the bayes factor is in favor of b_uniform so it is in favor of f which jeffreys would consider barely worth mentioning. other authors have suggested variations on the wording. to avoid arguing about adjectives we could think about odds instead. if your prior odds are and you see evidence with bayes factor your posterior odds are in terms of probability the data changed your degree of belief from to for most real world problems that change would be small relative to modeling errors and other sources of uncertainty. on the other hand if you had seen evidence with bayes factor your posterior odds would be or more than whether or not you agree that such evidence is decisive it is certainly strong. exercises exercise some people believe in the existence of extra-sensory perception for example the ability of some people to guess the value of an unseen playing card with probability better than chance. chapter hypothesis testing what is your prior degree of belief in this kind of esp? do you think it is as likely to exist as not? or are you more skeptical about it? write down your prior odds. now compute the strength of the evidence it would take to convince you that esp is at least likely to exist. what bayes factor would be needed to make you sure that esp exists? exercise suppose that your answer to the previous question is that is evidence with bayes factor in favor of esp would be sufficient to change your mind. now suppose that you read a paper in a respectable peer-reviewed scientific journal that presents evidence with bayes factor in favor of esp. would that change your mind? if not how do you resolve the apparent contradiction? you might find it helpful to read about david hume s article of miracles at http en. wikipedia. org wiki of_ miracles chapter evidence interpreting sat scores suppose you are the dean of admission at a small engineering college in massachusetts and you are considering two candidates alice and bob whose qualifications are similar in many ways with the exception that alice got a higher score on the math portion of the sat a standardized test intended to measure preparation for college-level work in mathematics. if alice got and bob got a of a possible you might want to know whether that difference is evidence that alice is better prepared than bob and what the strength of that evidence is. now in reality both scores are very good and both candidates are probably well prepared for college math. so the real dean of admission would probably suggest that we choose the candidate who best demonstrates the other skills and attitudes we look for in students. but as an example of bayesian hypothesis testing let s stick with a narrower question how strong is the evidence that alice is better prepared than bob? to answer that question we need to make some modeling decisions. i ll start with a simplification i know is wrong then we ll come back and improve the model. i pretend temporarily that all sat questions are equally difficult. actually the designers of the sat choose questions with a range of difficulty because that improves the ability to measure statistical differences between test-takers. but if we choose a model where all questions are equally difficult we can define a characteristic p_correct for each test-taker which is the probabil chapter evidence ity of answering any question correctly. this simplification makes it easy to compute the likelihood of a given score. the scale in order to understand sat scores we have to understand the scoring and scaling process. each test-taker gets a raw score based on the number of correct and incorrect questions. the raw score is converted to a scaled score in the range in there were questions on the math sat. the raw score for each test-taker is the number of questions answered correctly minus a penalty of point for each question answered incorrectly. the college board which administers the sat publishes the map from raw scores to scaled scores. i have downloaded that data and wrapped it in an interpolator object that provides a forward lookup raw score to scaled and a reverse lookup scaled score to raw. you can download the code for this example from httpthinkbayes.com sat.py. for more information see section the prior the college board also publishes the distribution of scaled scores for all test-takers. if we convert each scaled score to a raw score and divide by the number of questions the result is an estimate of p_correct. so we can use the distribution of raw scores to model the prior distribution of p_correct. here is the code that reads and processes the data class examobject def self.scale readscale scores readranks score_pmf thinkbayes.makepmffromdictdictscores self.raw self.reversescalescore_pmf self.max_score maxself.raw.values self.prior dividevaluesself.raw self.max_score the prior figure prior distribution of p_correct for sat test-takers. exam encapsulates the information we have about the exam. readscale and readranks read files and return objects that contain the data self.scale is the interpolator that converts from raw to scaled scores and back scores is a list of frequency pairs. score_pmf is the pmf of scaled scores. self.raw is the pmf of raw scores and self.prior is the pmf of p_correct. figure shows the prior distribution of p_correct. this distribution is approximately gaussian but it is compressed at the extremes. by design the sat has the most power to discriminate between test-takers within two standard deviations of the mean and less power outside that range. for each test-taker i define a suite called sat that represents the distribution of p_correct. here s the definition class satthinkbayes.suite def exam score thinkbayes.suite.__init__self self.exam exam self.score score start with the prior distribution for p_correct prob in exam.prior.items self.setp_correct prob chapter evidence figure posterior distributions of p_correct for alice and bob. update based on an exam score self.updatescore takes an exam object and a scaled score. it makes a copy of the prior distribution and then updates itself based on the exam score. as usual we inherit update from suite and provide likelihood def likelihoodself data hypo p_correct hypo score data k self.exam.reversescore n self.exam.max_score like thinkbayes.evalbinomialpmfk n p_correct return like hypo is a hypothetical value of p_correct and data is a scaled score. to keep things simple i interpret the raw score as the number of correct answers ignoring the penalty for wrong answers. with this simplification the likelihood is given by the binomial distribution which computes the probability of k correct responses out of n questions. posterior figure shows the posterior distributions of p_correct for alice and bob based on their exam scores. we can see that they overlap so it is possible that p_correct is actually higher for bob but it seems unlikely. posterior which brings us back to the original question how strong is the evidence that alice is better prepared than bob? we can use the posterior distributions of p_correct to answer this question. to formulate the question in terms of bayesian hypothesis testing i define two hypotheses a p_correct is higher for alice than for bob. b p_correct is higher for bob than for alice. to compute the likelihood of a we can enumerate all pairs of values from the posterior distributions and add up the total probability of the cases where p_correct is higher for alice than for bob. and we already have a function thinkbayes.pmfprobgreater that does that. so we can define a suite that computes the posterior probabilities of a and b class toplevelthinkbayes.suite def updateself data a_sat b_sat data a_like thinkbayes.pmfprobgreatera_sat b_sat b_like thinkbayes.pmfproblessa_sat b_sat c_like thinkbayes.pmfprobequala_sat b_sat a_like c_like b_like c_like self.multa a_like self.multb b_like self.normalize usually when we define a new suite we inherit update and provide likelihood. in this case i override update because it is easier to evaluate the likelihood of both hypotheses at the same time. the data passed to update are sat objects that represent the posterior distributions of p_correct. a_like is the total probability that p_correct is higher for alice b_like is that probability that it is higher for bob. chapter evidence c_like is the probability that they are equal but this equality is an artifact of the decision to model p_correct with a set of discrete values. if we use more values c_like is smaller and in the extreme if p_correct is continuous c_like is zero. so i treat c_like as a kind of round-off error and split it evenly between a_like and b_like. here is the code that creates toplevel and updates it exam exam a_sat satexam b_sat satexam top toplevelab top.updatea_sat b_sat top.print the likelihood of a is and the likelihood of b is the likelihood ratio bayes factor is which means that these test scores are evidence that alice is better than bob at answering sat questions. if we believed before seeing the test scores that a and b were equally likely then after seeing the scores we should believe that the probability of a is which means there is still a chance that bob is actually better prepared. a better model remember that the analysis we have done so far is based on the simplification that all sat questions are equally difficult. in reality some are easier than others which means that the difference between alice and bob might be even smaller. but how big is the modeling error? if it is small we conclude that the first model based on the simplification that all questions are equally difficult is good enough. if it s large we need a better model. in the next few sections i develop a better model and discover alert! that the modeling error is small. so if you are satisfied with the simple model you can skip to the next chapter. if you want to see how the more realistic model works read on... assume that each test-taker has some degree of efficacy which mea sures their ability to answer sat questions. assume that each question has some level of difficulty. a better model finally assume that the chance that a test-taker answers a question correctly is related to efficacy and difficulty according to this function def probcorrectefficacy difficulty return math.exp-a difficulty this function is a simplified version of the curve used in item response theory which you can read about at httpen.wikipedia.orgwikiitem_ response_theory. efficacy and difficulty are considered to be on the same scale and the probability of getting a question right depends only on the difference between them. when efficacy and difficulty are equal the probability of getting the question right is as efficacy increases this probability approaches as it decreases as difficulty increases the probability approaches given the distribution of efficacy across test-takers and the distribution of difficulty across questions we can compute the expected distribution of raw scores. we ll do that in two steps. first for a person with given efficacy we ll compute the distribution of raw scores. def pmfcorrectefficacy difficulties ps diff for diff in difficulties pmfs for p in ps dist sumpmfs return dist difficulties is a list of difficulties one for each question. ps is a list of probabilities and pmfs is a list of two-valued pmf objects here s the function that makes them def binarypmfp pmf thinkbayes.pmf p return pmf dist is the sum of these pmfs. remember from section that when we add up pmf objects the result is the distribution of the sums. in order to use python s sum to add up pmfs we have to provide which is the identity for pmfs so pmf is always pmf. chapter evidence if we know a person s efficacy we can compute their distribution of raw scores. for a group of people with a different efficacies the resulting distribution of raw scores is a mixture. here s the code that computes the mixture class exam def makerawscoredistself efficacies pmfs thinkbayes.pmf for efficacy prob in efficacies.items scores pmfcorrectefficacy self.difficulties pmfs.setscores prob mix thinkbayes.makemixturepmfs return mix makerawscoredist takes efficacies which is a pmf that represents the distribution of efficacy across test-takers. i assume it is gaussian with mean and standard deviation this choice is mostly arbitrary. the probability of getting a question correct depends on the difference between efficacy and difficulty so we can choose the units of efficacy and then calibrate the units of difficulty accordingly. pmfs is a meta-pmf that contains one pmf for each level of efficacy and maps to the fraction of test-takers at that level. makemixture takes the meta-pmf and computes the distribution of the mixture section calibration if we were given the distribution of difficulty we could use makerawscoredist to compute the distribution of raw scores. but for us the problem is the other way around we are given the distribution of raw scores and we want to infer the distribution of difficulty. i assume that the distribution of difficulty is uniform with parameters center and width. makedifficulties makes a list of difficulties with these parameters. def makedifficultiescenter width n low high center-width centerwidth return numpy.linspacelow high n by trying out a few combinations i found that and yield a distribution of raw scores similar to the actual data as shown in figure posterior distribution of efficacy figure actual distribution of raw scores and a model to fit it. so assuming that the distribution of difficulty is uniform its range is approximately to given that efficacy is gaussian with mean and standard deviation the following table shows the range of probcorrect for test-takers at different levels of efficacy difficulty efficacy someone with efficacy standard deviations above the mean has a chance of answering the easiest questions on the exam and a chance of answering the hardest. on the other end of the range someone two standard deviations below the mean has only a chance of answering the easiest questions. posterior distribution of efficacy now that the model is calibrated we can compute the posterior distribution of efficacy for alice and bob. here is a version of the sat class that uses the new model chapter evidence figure posterior distributions of efficacy for alice and bob. class def exam score self.exam exam self.score score start with the gaussian prior efficacies thinkbayes.suite.__init__self efficacies update based on an exam score self.updatescore update invokes likelihood which computes the likelihood of a given test score for a hypothetical level of efficacy. def likelihoodself data hypo efficacy hypo score data raw self.exam.reversescore pmf self.exam.pmfcorrectefficacy like pmf.probraw return like pmf is the distribution of raw scores for a test-taker with the given efficacy like is the probability of the observed score. predictive distribution figure shows the posterior distributions of efficacy for alice and bob. as expected the location of alice s distribution is farther to the right but again there is some overlap. using toplevel again we compare a the hypothesis that alice s efficacy is higher and b the hypothesis that bob s is higher. the likelihood ratio is a bit smaller than what we got from the simple model so this model indicates that the data are evidence in favor of a but a little weaker than the previous estimate. if our prior belief is that a and b are equally likely then in light of this evidence we would give a a posterior probability of leaving a chance that bob s efficacy is higher. predictive distribution the analysis we have done so far generates estimates for alice and bob s efficacy but since efficacy is not directly observable it is hard to validate the results. to give the model predictive power we can use it to answer a related question if alice and bob take the math sat again what is the chance that alice will do better again? we ll answer this question in two steps we ll use the posterior distribution of efficacy to generate a predictive distribution of raw score for each test-taker. we ll compare the two predictive distributions to compute the proba bility that alice gets a higher score again. we already have most of the code we need. to compute the predictive distributions we can use makerawscoredist again exam exam a_sat satexam b_sat satexam a_pred exam.makerawscoredista_sat b_pred exam.makerawscoredistb_sat then we can find the likelihood that alice does better on the second test bob does better or they tie chapter evidence figure joint posterior distribution of p_correct for alice and bob. a_like thinkbayes.pmfprobgreatera_pred b_pred b_like thinkbayes.pmfproblessa_pred b_pred c_like thinkbayes.pmfprobequala_pred b_pred the probability that alice does better on the second exam is which means that bob has a chance of doing as well or better. notice that we have more confidence about alice s efficacy than we do about the outcome of the next test. the posterior odds are that alice s efficacy is higher but only that alice will do better on the next exam. discussion we started this chapter with the question how strong is the evidence that alice is better prepared than bob? on the face of it that sounds like we want to test two hypotheses either alice is more prepared or bob is. but in order to compute likelihoods for these hypotheses we have to solve an estimation problem. for each test-taker we have to find the posterior distribution of either p_correct or efficacy. values like this are called nuisance parameters because we don t care what they are but we have to estimate them to answer the question we care about. one way to visualize the analysis we did in this chapter is to plot the space of these parameters. thinkbayes.makejoint takes two pmfs com bob discussion putes their joint distribution and returns a joint pmf of each possible pair of values and its probability. def joint joint for in for in return joint this function assumes that the two distributions are independent. figure shows the joint posterior distribution of p_correct for alice and bob. the diagonal line indicates the part of the space where p_correct is the same for alice and bob. to the right of this line alice is more prepared to the left bob is more prepared. in toplevel.update when we compute the likelihoods of a and b we add up the probability mass on each side of this line. for the cells that fall on the line we add up the total mass and split it between a and b. the process we used in this chapter estimating nuisance parameters in order to evaluate the likelihood of competing hypotheses is a common bayesian approach to problems like this. chapter evidence chapter simulation in this chapter i describe my solution to a problem posed by a patient with a kidney tumor. i think the problem is important and relevant to patients with these tumors and doctors treating them. and i think the solution is interesting because although it is a bayesian approach to the problem the use of bayes s theorem is implicit. i present the solution and my code at the end of the chapter i will explain the bayesian part. if you want more technical detail than i present here you can read my paper on this work at the kidney tumor problem i am a frequent reader and occasional contributor to the online statistics forum at httpreddit.comrstatistics. in november i read the following message have stage iv kidney cancer and am trying to determine if the cancer formed before i retired from the military. given the dates of retirement and detection is it possible to determine when there was a chance that i developed the disease? is it possible to determine the probability on the retirement date? my tumor was cm x cm at detection. grade ii. i contacted the author of the message and got more information i learned that veterans get different benefits if it is likely than not that a tumor formed while they were in military service other considerations. chapter simulation figure cdf of rdt in doublings per year. because renal tumors grow slowly and often do not cause symptoms they are sometimes left untreated. as a result doctors can observe the rate of growth for untreated tumors by comparing scans from the same patient at different times. several papers have reported these growth rates. i collected data from a paper by zhang et i contacted the authors to see if i could get raw data but they refused on grounds of medical privacy. nevertheless i was able to extract the data i needed by printing one of their graphs and measuring it with a ruler. they report growth rates in reciprocal doubling time which is in units of doublings per year. so a tumor with rdt doubles in volume each year with rdt it quadruples in the same time and with rdt it halves. figure shows the distribution of rdt for patients. the squares are the data points from the paper the line is a model i fit to the data. the positive tail fits an exponential distribution well so i used a mixture of two exponentials. a simple model it is usually a good idea to start with a simple model before trying something more challenging. sometimes the simple model is sufficient for the et al distribution of renal tumor growth rates determined by using serial volumetric ct measurements january radiology doublings per of rdtmodeldata a simple model problem at hand and if not you can use it to validate the more complex model. for my simple model i assume that tumors grow with a constant doubling time and that they are three-dimensional in the sense that if the maximum linear measurement doubles the volume is multiplied by eight. i learned from my correspondent that the time between his discharge from the military and his diagnosis was days years. so my first calculation was if this tumor grew at the median rate how big would it have been at the date of discharge? the median volume doubling time reported by zhang et al is days. assuming geometry the doubling time for a linear measure is three times longer. time between discharge and diagnosis in days interval doubling time in linear measure is doubling time in volume dt number of doublings since discharge doublings interval dt how big was the tumor at time of discharge in cm doublings you can download the code in this chapter from httpthinkbayes.com kidney.py. for more information see section the result is about cm. so if this tumor formed after the date of discharge it must have grown substantially faster than the median rate. therefore i concluded that it is more likely than not that this tumor formed before the date of discharge. in addition i computed the growth rate that would be implied if this tumor had formed after the date of discharge. if we assume an initial size of cm we can compute the number of doublings to get to a final size of cm assume an initial linear measure of cm chapter simulation how many doublings would it take to get from to doublings what linear doubling time does that imply? dt interval doublings compute the volumetric doubling time and rdt vdt dt rdt vdt dt is linear doubling time so vdt is volumetric doubling time and rdt is reciprocal doubling time. the number of doublings in linear measure is which implies an rdt of in the data from zhang et al only of tumors grew this fast during a period of observation. so again i concluded that is more likely than not that the tumor formed prior to the date of discharge. these calculations are sufficient to answer the question as posed and on behalf of my correspondent i wrote a letter explaining my conclusions to the veterans benefit administration. later i told a friend who is an oncologist about my results. he was surprised by the growth rates observed by zhang et al and by what they imply about the ages of these tumors. he suggested that the results might be interesting to researchers and doctors. but in order to make them useful i wanted a more general model of the relationship between age and size. a more general model given the size of a tumor at time of diagnosis it would be most useful to know the probability that the tumor formed before any given date in other words the distribution of ages. to find it i run simulations of tumor growth to get the distribution of size conditioned on age. then we can use a bayesian approach to get the distribution of age conditioned on size. the simulation starts with a small tumor and runs these steps choose a growth rate from the distribution of rdt. a more general model figure simulations of tumor growth size vs. time. compute the size of the tumor at the end of an interval. record the size of the tumor at each interval. repeat until the tumor exceeds the maximum relevant size. for the initial size i chose cm because carcinomas smaller than that are less likely to be invasive and less likely to have the blood supply needed for rapid growth httpen.wikipedia.orgwikicarcinoma_in_situ. i chose an interval of days months because that is the median time between measurements in the data source. for the maximum size i chose cm. in the data source the range of observed sizes is to cm so we are extrapolating beyond the observed range at each end but not by far and not in a way likely to have a strong effect on the results. the simulation is based on one big simplification the growth rate is chosen independently during each interval so it does not depend on age size or growth rate during previous intervals. in section i review these assumptions and consider more detailed models. but first let s look at some examples. figure shows the size of simulated tumors as a function of age. the dashed line at cm shows the range of ages for tumors at that size the fastest-growing tumor gets there in years the slowest takes more than age log scalesimulations of tumor growth chapter simulation i am presenting results in terms of linear measurements but the calculations are in terms of volume. to convert from one to the other again i use the volume of a sphere with the given diameter. implementation here is the kernel of the simulation def makesequencerdt_seq seq age for rdt in rdt_seq age interval final seq extendsequenceage seq rdt interval if final vmax break return seq rdt_seq is an iterator that yields random values from the cdf of growth rate. is the initial volume in ml. interval is the time step in years. vmax is the final volume corresponding to a linear measurement of cm. volume converts from linear measurement in cm to volume in ml based on the simplification that the tumor is a sphere def volumediameter return factor extendsequence computes the volume of the tumor at the end of the interval. def extendsequenceage seq rdt interval initial doublings rdt interval final initial new_seq seq cache.addage new_seq rdt return final new_seq age is the age of the tumor at the end of the interval. seq is a tuple that contains the volumes so far. rdt is the growth rate during the interval in doublings per year. interval is the size of the time step in years. caching the joint distribution figure joint distribution of age and tumor size. the return values are final the volume of the tumor at the end of the interval and new_seq a new tuple containing the volumes in seq plus the new volume final. cache.add records the age and size of each tumor at the end of each interval as explained in the next section. caching the joint distribution here s how the cache works. class cacheobject def self.joint thinkbayes.joint joint is a joint pmf that records the frequency of each age-size pair so it approximates the joint distribution of age and size. at the end of each simulated interval extendsequence calls add class cache def addself age seq final cm diameterfinal bucket roundcmtobucketcm self.joint.incrage bucket log scale chapter simulation figure distributions of age conditioned on size. again age is the age of the tumor and seq is the sequence of volumes so far. before adding the new data to the joint distribution we use diameter to convert from volume to diameter in centimeters def diametervolume return volume exp and cmtobucket to convert from centimeters to a discrete bucket number def cmtobucketx return factor math.logx the buckets are equally spaced on a log scale. using yields a reasonable number of buckets for example cm maps to bucket and cm maps to bucket after running the simulations we can plot the joint distribution as a pseudocolor plot where each cell represents the number of tumors observed at a given size-age pair. figure shows the joint distribution after simulations. conditional distributions by taking a vertical slice from the joint distribution we can get the distribution of sizes for any given age. by taking a horizontal slice we can get the distribution of ages conditioned on size. age of age for several cm conditional distributions figure percentiles of tumor age as a function of size. here s the code that reads the joint distribution and builds the conditional distribution for a given size. class cache def conditionalcdfself bucket pmf bucket cdf pmf.makecdf return cdf bucket is the integer bucket number corresponding to tumor size. joint.conditional computes the pmf of age conditioned on bucket. the result is the cdf of age conditioned on bucket. figure shows several of these cdfs for a range of sizes. to summarize these distributions we can compute percentiles as a function of size. percentiles for bucket in cache.getbuckets cdf conditionalcdfbucket ps for p in percentiles figure shows these percentiles for each size bucket. the data points are computed from the estimated joint distribution. in the model size and time are discrete which contributes numerical errors so i also show a least squares fit for each sequence of percentiles. log age interval for age vs diameter chapter simulation serial correlation the results so far are based on a number of modeling decisions let s review them and consider which ones are the most likely sources of error to convert from linear measure to volume we assume that tumors are approximately spherical. this assumption is probably fine for tumors up to a few centimeters but not for very large tumors. the distribution of growth rates in the simulations are based on a continuous model we chose to fit the data reported by zhang et al which is based on patients. the fit is only approximate and more importantly a larger sample would yield a different distribution. the growth model does not take into account tumor subtype or grade this assumption is consistent with the conclusion of zhang et al growth rates in renal tumors of different sizes subtypes and grades represent a wide range and overlap substantially. but with a larger sample a difference might become apparent. the distribution of growth rate does not depend on the size of the tumor. this assumption would not be realistic for very small and very large tumors whose growth is limited by blood supply. but tumors observed by zhang et al ranged from to cm and they found no statistically significant relationship between size and growth rate. so if there is a relationship it is likely to be weak at least in this size range. in the simulations growth rate during each interval is independent of previous growth rates. in reality it is plausible that tumors that have grown quickly in the past are more likely to grow quickly. in other words there is probably a serial correlation in growth rate. of these the first and last seem the most problematic. i ll investigate serial correlation first then come back to spherical geometry. to simulate correlated growth i wrote a that yields a correlated series from a given cdf. here s how the algorithm works generate correlated values from a gaussian distribution. this is easy to do because we can compute the distribution of the next value conditioned on the previous value. you are not familiar with python generators see httpwiki.python.orgmoin generators. serial correlation transform each value to its cumulative probability using the gaussian cdf. transform each cumulative probability to the corresponding value us ing the given cdf. here s what that looks like in code def correlatedgeneratorcdf rho x yield transformx sigma while true x random.gaussx rho sigma yield transformx cdf is the desired cdf rho is the desired correlation. the values of x are gaussian transform converts them to the desired distribution. the first value of x is gaussian with mean and standard deviation for subsequent values the mean and standard deviation depend on the previous value. given the previous x the mean of the next value is x rho and the variance is transform maps from each gaussian value x to a value from the given cdf y. def transformx p thinkbayes.gaussiancdfx y cdf.valuep return y gaussiancdf computes the cdf of the standard gaussian distribution at x returning a cumulative probability. cdf.value maps from a cumulative probability to the corresponding value in cdf. depending on the shape of cdf information can be lost in transformation so the actual correlation might be lower than rho. for example when i generate values from the distribution of growth rates with the actual correlation is but since we are guessing at the right correlation anyway that s close enough. remember that makesequence takes an iterator as an argument. that interface allows it to work with different generators chapter simulation serial correlation diameter percentiles of age table percentiles of tumor age conditioned on size. iterator uncorrelatedgeneratorcdf makesequenceiterator iterator correlatedgeneratorcdf rho makesequenceiterator in this example and are drawn from the same distribution but the values in are uncorrelated and the values in are correlated with a coefficient of approximately rho. now we can see what effect serial correlation has on the results the following table shows percentiles of age for a cm tumor using the uncorrelated generator and a correlated generator with target correlation makes the fastest growing tumors faster and the slowest slower so the range of ages is wider. the difference is modest for low percentiles but for the percentile it is more than years. to compute these percentiles precisely we would need a better estimate of the actual serial correlation. however this model is sufficient to answer the question we started with given a tumor with a linear dimension of cm what is the probability that it formed more than years ago? here s the code class cache def probolderself cm age bucket cmtobucketcm cdf self.conditionalcdfbucket p cdf.probage return cm is the size of the tumor age is the age threshold in years. probolder converts size to a bucket number gets the cdf of age conditioned on bucket and computes the probability that age exceeds the given value. discussion with no serial correlation the probability that a cm tumor is older than years is or almost certain. with correlation faster-growing tumors are more likely but the probability is still even with correlation the probability is another likely source of error is the assumption that tumors are approximately spherical. for a tumor with linear dimensions x cm this assumption is probably not valid. if as seems likely a tumor this size is relatively flat it might have the same volume as a cm sphere. with this smaller volume and correlation the probability of age greater than is still so even taking into account modeling errors it is unlikely that such a large tumor could have formed less than years prior to the date of diagnosis. discussion well we got through a whole chapter without using bayes s theorem or the suite class that encapsulates bayesian updates. what happened? one way to think about bayes s theorem is as an algorithm for inverting conditional probabilities. given pba we can compute pab provided we know pa and pb. of course this algorithm is only useful if for some reason it is easier to compute pba than pab. in this example it is. by running simulations we can estimate the distribution of size conditioned on age or psizeage. but it is harder to get the distribution of age conditioned on size or pagesize. so this seems like a perfect opportunity to use bayes s theorem. the reason i didn t is computational efficiency. to estimate psizeage for any given size you have to run a lot of simulations. along the way you end up computing psizeage for a lot of sizes. in fact you end up computing the entire joint distribution of size and age psize age. and once you have the joint distribution you don t really need bayes s theorem you can extract pagesize by taking slices from the joint distribution as demonstrated in conditionalcdf. so we side-stepped bayes but he was with us in spirit. chapter simulation chapter a hierarchical model the geiger counter problem i got the idea for the following problem from tom campbell-ricketts author of the maximum entropy blog at httpmaximum-entropy-blog. blogspot.com. and he got the idea from e. t. jaynes author of the classic probability theory the logic of science suppose that a radioactive source emits particles toward a geiger counter at an average rate of r particles per second but the counter only registers a fraction f of the particles that hit it. if f is and the counter registers particles in a one second interval what is the posterior distribution of n the actual number of particles that hit the counter and r the average rate particles are emitted? to get started on a problem like this think about the chain of causation that starts with the parameters of the system and ends with the observed data the source emits particles at an average rate r. during any given second the source emits n particles toward the counter. out of those n particles some number k get counted. the probability that an atom decays is the same at any point in time so radioactive decay is well modeled by a poisson process. given r the distribution of n is poisson distribution with parameter r. chapter a hierarchical model figure posterior distribution of n for three values of r. and if we assume that the probability of detection for each particle is independent of the others the distribution of k is the binomial distribution with parameters n and f given the parameters of the system we can find the distribution of the data. so we can solve what is called the forward problem. now we want to go the other way given the data we want the distribution of the parameters. this is called the inverse problem. and if you can solve the forward problem you can use bayesian methods to solve the inverse problem. start simple let s start with a simple version of the problem where we know the value of r. we are given the value of f so all we have to do is estimate n. i define a suite called detector that models the behavior of the detector and estimates n. class detectorthinkbayes.suite def r f pmf thinkbayes.makepoissonpmfr high stepstep thinkbayes.suite.__init__self pmf namer self.r r self.f f of particles make it hierarchical if the average emission rate is r particles per second the distribution of n is poisson with parameter r. high and step determine the upper bound for n and the step size between hypothetical values. now we need a likelihood function class detector def likelihoodself data hypo k data n hypo p self.f return thinkbayes.evalbinomialpmfk n p data is the number of particles detected and hypo is the hypothetical number of particles emitted n. if there are actually n particles and the probability of detecting any one of them is f the probability of detecting k particles is given by the binomial distribution. that s it for the detector. we can try it out for a range of values of r f k for r in suite detectorr f suite.updatek print suite.maximumlikelihood figure shows the posterior distribution of n for several given values of r. make it hierarchical in the previous section we assume r is known. now let s relax that assumption. i define another suite called emitter that models the behavior of the emitter and estimates r class emitterthinkbayes.suite def rs detectors f for r in rs thinkbayes.suite.__init__self detectors chapter a hierarchical model rs is a sequence of hypothetical value for r. detectors is a sequence of detector objects one for each value of r. the values in the suite are detectors so emitter is a meta-suite that is a suite that contains other suites as values. to update the emitter we have to compute the likelihood of the data under each hypothetical value of r. but each value of r is represented by a detector that contains a range of values for n. to compute the likelihood of the data for a given detector we loop through the values of n and add up the total probability of k. that s what suitelikelihood does class detector def suitelikelihoodself data total for hypo prob in self.items like self.likelihooddata hypo total prob like return total now we can write the likelihood function for the emitter class emitter def likelihoodself data hypo detector hypo like detector.suitelikelihooddata return like each hypo is a detector so we can invoke suitelikelihood to get the likelihood of the data under the hypothesis. after we update the emitter we have to update each of the detectors too. class emitter def updateself data thinkbayes.suite.updateself data for detector in self.values detector.update a model like this with multiple levels of suites is called hierarchical. a little optimization figure posterior distributions of n and r. a little optimization you might recognize suitelikelihood we saw it in section at the time i pointed out that we didn t really need it because the total probability computed by suitelikelihood is exactly the normalizing constant computed and returned by update. so instead of updating the emitter and then updating the detectors we can do both steps at the same time using the result from detector.update as the likelihood of emitter. here s the streamlined version of emitter.likelihood class emitter def likelihoodself data hypo return hypo.updatedata and with this version of likelihood we can use the default version of update. so this version has fewer lines of code and it runs faster because it does not compute the normalizing constant twice. extracting the posteriors after we update the emitter we can get the posterior distribution of r by looping through the detectors and their probabilities rposterior n chapter a hierarchical model class emitter def distofrself items prob for detector prob in self.items return thinkbayes.makepmffromitemsitems items is a list of values of r and their probabilities. the result is the pmf of r. to get the posterior distribution of n we have to compute the mixture of the detectors. we can use thinkbayes.makemixture which takes a metapmf that maps from each distribution to its probability. and that s exactly what the emitter is class emitter def distofnself return thinkbayes.makemixtureself figure shows the results. not surprisingly the most likely value for n is given f and n the expected count is k f n so given f and k the expected value of n is k f which is and if particles are emitted in one second the most likely value of r is particles per second. so the posterior distribution of r is also centered on the posterior distributions of r and n are similar the only difference is that we are slightly less certain about n. in general we can be more certain about the long-range emission rate r than about the number of particles emitted in any particular second n. you can download the code in this chapter from httpthinkbayes.com jaynes.py. for more information see section discussion the geiger counter problem demonstrates the connection between causation and hierarchical modeling. in the example the emission rate r has a causal effect on the number of particles n which has a causal effect on the particle count k. the hierarchical model reflects the structure of the system with causes at the top and effects at the bottom. exercises at the top level we start with a range of hypothetical values for r. for each value of r we have a range of values for n and the prior distribution of n depends on r. when we update the model we go bottom-up. we compute a posterior distribution of n for each value of r then compute the posterior distribution of r. so causal information flows down the hierarchy and inference flows up. exercises exercise this exercise is also inspired by an example in jaynes probability theory. suppose you buy a mosquito trap that is supposed to reduce the population of mosquitoes near your house. each week you empty the trap and count the number of mosquitoes captured. after the first week you count mosquitoes. after the second week you count mosquitoes. estimate the percentage change in the number of mosquitoes in your yard. to answer this question you have to make some modeling decisions. here are some suggestions suppose that each week a large number of mosquitoes n is bred in a wetland near your home. during the week some fraction of them wander into your yard and of those some fraction are caught in the trap. your solution should take into account your prior belief about how much n is likely to change from one week to the next. you can do that by adding a level to the hierarchy to model the percent change in n. chapter a hierarchical model chapter dealing with dimensions belly button bacteria belly button biodiversity is a nation-wide citizen science project with the goal of identifying bacterial species that can be found in human navels the project might seem whimsical but it is part of an increasing interest in the human microbiome the set of microorganisms that live on human skin and parts of the body. in their pilot study researchers collected swabs from the navels of volunteers used multiplex pyrosequencing to extract and sequence fragments of rdna then identified the species or genus the fragments came from. each identified fragment is called a read. we can use these data to answer several related questions based on the number of species observed can we estimate the total number of species in the environment? can we estimate the prevalence of each species that is the fraction of the total population belonging to each species? if we are planning to collect additional samples can we predict how many new species we are likely to discover? how many additional reads are needed to increase the fraction of ob served species to a given threshold? these questions make up what is called the unseen species problem. chapter dealing with dimensions lions and tigers and bears i ll start with a simplified version of the problem where we know that there are exactly three species. let s call them lions tigers and bears. suppose we visit a wild animal preserve and see lions tigers and one bear. if we have an equal chance of observing any animal in the preserve the number of each species we see is governed by the multinomial distribution. if the prevalence of lions and tigers and bears is p_lion and p_tiger and p_bear the likelihood of seeing lions tigers and one bear is proportional to an approach that is tempting but not correct is to use beta distributions as in section to describe the prevalence of each species separately. for example we saw lions and non-lions if we think of that as heads and tails then the posterior distribution of p_lion is beta thinkbayes.beta print beta.maximumlikelihood the maximum likelihood estimate for p_lion is the observed rate similarly the mles for p_tiger and p_bear are and but there are two problems we have implicitly used a prior for each species that is uniform from to but since we know that there are three species that prior is not correct. the right prior should have a mean of and there should be zero likelihood that any species has a prevalence of the distributions for each species are not independent because the prevalences have to add up to to capture this dependence we need a joint distribution for the three prevalences. we can use a dirichlet distribution to solve both of these problems httpen.wikipedia.orgwikidirichlet_distribution. in the same way we used the beta distribution to describe the distribution of bias for a coin we can use a dirichlet distribution to describe the joint distribution of p_lion p_tiger and p_bear. the dirichlet distribution is the multi-dimensional generalization of the beta distribution. instead of two possible outcomes like heads and tails lions and tigers and bears the dirichlet distribution handles any number of outcomes in this example three species. if there are n outcomes the dirichlet distribution is described by n parameters written through n. here s the definition from thinkbayes.py of a class that represents a dirichlet distribution class dirichletobject def n self.n n self.params numpy.onesn dtypenumpy.int n is the number of dimensions initially the parameters are all i use a numpy array to store the parameters so i can take advantage of array operations. given a dirichlet distribution the marginal distribution for each prevalence is a beta distribution which we can compute like this def marginalbetaself i self.params.sum alpha self.paramsi return betaalpha i is the index of the marginal distribution we want. is the sum of the parameters alpha is the parameter for the given species. in the example the prior marginal distribution for each species is we can compute the prior means like this dirichlet for i in beta dirichlet.marginalbetai print beta.mean as expected the prior mean prevalence for each species is to update the dirichlet distribution we add the observations to the parameters like this def updateself data m lendata self.paramsm data here data is a sequence of counts in the same order as params so in this example it should be the number of lions tigers and bears. chapter dealing with dimensions figure distribution of prevalences for three species. data can be shorter than params in that case there are some species that have not been observed. here s code that updates dirichlet with the observed data and computes the posterior marginal distributions. data dirichlet.updatedata for i in beta dirichlet.marginalbetai pmf beta.makepmf print i pmf.mean figure shows the results. the posterior mean prevalences are and the hierarchical version we have solved a simplified version of the problem if we know how many species there are we can estimate the prevalence of each. now let s get back to the original problem estimating the total number of species. to solve this problem i ll define a meta-suite which is a suite that contains other suites as hypotheses. in this case the top-level suite contains hypotheses about the number of species the bottom level contains hypotheses about prevalences. the hierarchical version here s the class definition class speciesthinkbayes.suite def ns hypos for n in ns thinkbayes.suite.__init__self hypos takes a list of possible values for n and makes a list of dirichlet objects. here s the code that creates the top-level suite ns suite speciesns ns is the list of possible values for n. we have seen species so there have to be at least that many. i chose an upper bound that seems reasonable but we will check later that the probability of exceeding this bound is low. and at least initially we assume that any value in this range is equally likely. to update a hierarchical model you have to update all levels. usually you have to update the bottom level first and work up but in this case we can update the top level first species def updateself data thinkbayes.suite.updateself data for hypo in self.values hypo.updatedata species.update invokes update in the parent class then loops through the sub-hypotheses and updates them. now all we need is a likelihood function class species def likelihoodself data hypo dirichlet hypo like for i in like dirichlet.likelihooddata return like chapter dealing with dimensions data is a sequence of observed counts hypo is a dirichlet object. species.likelihood calls dirichlet.likelihood times and returns the total. why call it times? because dirichlet.likelihood doesn t actually compute the likelihood of the data under the whole dirichlet distribution. instead it draws one sample from the hypothetical distribution and computes the likelihood of the data under the sampled set of prevalences. here s what it looks like class dirichlet def likelihoodself data m lendata if self.n m return x data p self.random q pmx return q.prod the length of data is the number of species observed. if we see more species than we thought existed the likelihood is otherwise we select a random set of prevalences p and compute the multinomial pmf which is cx pxn n pi is the prevalence of the ith species and xi is the observed number. the first term cx is the multinomial coefficient i leave it out of the computation because it is a multiplicative factor that depends only on the data not the hypothesis so it gets normalized away httpen.wikipedia.org wikimultinomial_distribution. m is the number of observed species. we only need the first m elements of p for the others xi is so pxi is and we can leave them out of the product. i random sampling there are two ways to generate a random sample from a dirichlet distribution. one is to use the marginal beta distributions but in that case you have to select one at a time and scale the rest so they add up to random sampling figure posterior distribution of n. httpen.wikipedia.orgwikidirichlet_distributionrandom_ number_generation. a less obvious but faster way is to select values from n gamma distributions then normalize by dividing through by the total. here s the code class dirichlet def randomself p numpy.random.gammaself.params return p p.sum now we re ready to look at some results. here is the code that extracts the posterior distribution of n def distofnself pmf thinkbayes.pmf for hypo prob in self.items pmf.sethypo.n prob return pmf distofn iterates through the top-level hypotheses and accumulates the probability of each n. figure shows the result. the most likely value is values from to are reasonably likely after that the probabilities drop off quickly. the probability that there are species is low enough to be negligible if we chose a higher bound we would get nearly the same result. of chapter dealing with dimensions remember that this result is based on a uniform prior for n. if we have background information about the number of species in the environment we might choose a different prior. optimization i have to admit that i am proud of this example. the unseen species problem is not easy and i think this solution is simple and clear and takes surprisingly few lines of code so far. the only problem is that it is slow. it s good enough for the example with only observed species but not good enough for the belly button data with more than species in some samples. the next few sections present a series of optimizations we need to make this solution scale. before we get into the details here s a road map. the first step is to recognize that if we update the dirichlet distributions with the same data the first m parameters are the same for all of them. the only difference is the number of hypothetical unseen species. so we don t really need n dirichlet objects we can store the parameters in the top level of the hierarchy. implements this optimization. also uses the same set of random values for all of the hypotheses. this saves time generating random values but it has a second benefit that turns out to be more important by giving all hypotheses the same selection from the sample space we make the comparison between the hypotheses more fair so it takes fewer iterations to converge. even with these changes there is a major performance problem. as the number of observed species increases the array of random prevalences gets bigger and the chance of choosing one that is approximately right becomes small. so the vast majority of iterations yield small likelihoods that don t contribute much to the total and don t discriminate between hypotheses. the solution is to do the updates one species at a time. is a simple implementation of this strategy using dirichlet objects to represent the sub-hypotheses. collapsing the hierarchy finally combines the sub-hypotheses into the top level and uses numpy array operations to speed things up. if you are not interested in the details feel free to skip to section where we look at results from the belly button data. collapsing the hierarchy all of the bottom-level dirichlet distributions are updated with the same data so the first m parameters are the same for all of them. we can eliminate them and merge the parameters into the top-level suite. implements this optimization class def ns self.ns ns self.probs numpy.oneslenns dtypenumpy.double self.params numpy.onesself.high dtypenumpy.int ns is the list of hypothetical values for n probs is the list of corresponding probabilities. and params is the sequence of dirichlet parameters initially all updates both levels of the hierarchy first the probability for each value of n then the dirichlet parameters class def updateself data like numpy.zeroslenself.ns dtypenumpy.double for i in like self.samplelikelihooddata self.probs like self.probs self.probs.sum m lendata self.paramsm data samplelikelihood returns an array of likelihoods one for each value of n. like accumulates the total likelihood for samples. self.probs is multiplied by the total likelihood then normalized. the last two lines which update the parameters are the same as in dirichlet.update. chapter dealing with dimensions now let s look at samplelikelihood. there are two opportunities for optimization here when the hypothetical number of species n exceeds the observed number m we only need the first m terms of the multinomial pmf the rest are if the number of species is large the likelihood of the data might be too small for floating-point so it is safer to compute loglikelihoods. again the multinomial pmf is cx pxn n so the log-likelihood is log cx log xn log pn which is fast and easy to compute. again cx it is the same for all hypotheses so we can drop it. here s the code class def samplelikelihoodself data gammas numpy.random.gammaself.params m lendata row gammasm col numpy.cumsumgammas log_likes for n in self.ns ps row terms data numpy.logps log_like terms.sum log_likes.appendlog_like log_likes numpy.maxlog_likes likes numpy.explog_likes coefs m for n in self.ns likes coefs one more problem return likes gammas is an array of values from a gamma distribution its length is the largest hypothetical value of n. row is just the first m elements of gammas since these are the only elements that depend on the data they are the only ones we need. for each value of n we need to divide row by the total of the first n values from gamma. cumsum computes these cumulative sums and stores them in col. the loop iterates through the values of n and accumulates a list of loglikelihoods. inside the loop ps contains the row of probabilities normalized with the appropriate cumulative sum. terms contains the terms of the summation xi log pi and log_like contains their sum. after the loop we want to convert the log-likelihoods to linear likelihoods but first it s a good idea to shift them so the largest log-likelihood is that way the linear likelihoods are not too small finally before we return the likelihood we have to apply a correction factor which is the number of ways we could have observed these m species if the total number of species is n. binomialcoefficient computes n choose m which is written n m. as often happens the optimized version is less readable and more errorprone than the original. but that s one reason i think it is a good idea to start with the simple version we can use it for regression testing. i plotted results from both versions and confirmed that they are approximately equal and that they converge as the number of iterations increases. one more problem there s more we could do to optimize this code but there s another problem we need to fix first. as the number of observed species increases this version gets noisier and takes more iterations to converge on a good answer. the problem is that if the prevalences we choose from the dirichlet distribution the ps are not at least approximately right the likelihood of the observed data is close to zero and almost equally bad for all values of n. chapter dealing with dimensions so most iterations don t provide any useful contribution to the total likelihood. and as the number of observed species m gets large the probability of choosing ps with non-negligible likelihood gets small. really small. fortunately there is a solution. remember that if you observe a set of data you can update the prior distribution with the entire dataset or you can break it up into a series of updates with subsets of the data and the result is the same either way. for this example the key is to perform the updates one species at a time. that way when we generate a random set of ps only one of them affects the computed likelihood so the chance of choosing a good one is much better. here s a new version that updates one species at a time class def updateself data m lendata for i in rangem one onei datai species.updateself one this version inherits from species so it represents the hypotheses as a list of dirichlet objects update loops through the observed species and makes an array one with all zeros and one species count. then it calls update in the parent class which computes the likelihoods and updates the sub-hypotheses. so in the running example we do three updates. the first is something like i have seen three lions. the second is i have seen two tigers and no additional lions. and the third is i have seen one bear and no more lions and tigers. here s the new version of likelihood class def likelihoodself data hypo dirichlet hypo like for i in rangeself.iterations we re not done yet like dirichlet.likelihooddata correct for the number of unseen species the new one could have been m lendata num_unseen dirichlet.n m like num_unseen return like this is almost the same as species.likelihood. the difference is the factor num_unseen. this correction is necessary because each time we see a species for the first time we have to consider that there were some number of other unseen species that we might have seen. for larger values of n there are more unseen species that we could have seen which increases the likelihood of the data. this is a subtle point and i have to admit that i did not get it right the first time. but again i was able to validate this version by comparing it to the previous versions. we re not done yet performing the updates one species at a time solves one problem but it creates another. each update takes time proportional to km where k is the number of hypotheses and m is the number of observed species. so if we do m updates the total run time is proportional to but we can speed things up using the same trick we used in section we ll get rid of the dirichlet objects and collapse the two levels of the hierarchy into a single object. so here s yet another version of species class def updateself data m lendata for i in rangem datai self.paramsi datai this version inherits from so it uses ns and probs to represent the distribution of n and params to represent the parameters of the dirichlet distribution. chapter dealing with dimensions update is similar to what we saw in the previous section. it loops through the observed species and calls updateone class def updateoneself i count likes numpy.zeroslenself.ns dtypenumpy.double for i in rangeself.iterations likes self.samplelikelihoodi count unseen_species for n in self.ns likes unseen_species self.probs likes self.probs self.probs.sum this function is similar to with two changes the interface is different. instead of the whole dataset we get i the index of the observed species and count how many of that species we ve seen. we have to apply a correction factor for the number of unseen species as in the difference here is that we update all of the likelihoods at once with array multiplication. finally here s samplelikelihood class def samplelikelihoodself i count gammas numpy.random.gammaself.params sums ps sums log_likes numpy.logps count log_likes numpy.maxlog_likes likes numpy.explog_likes return likes this is similar to the difference is that each update only includes a single species so we don t need a loop. the belly button data the runtime of this function is proportional to the number of hypotheses k. it runs m times so the run time of the update is proportional to km. and the number of iterations we need to get an accurate result is usually small. the belly button data that s enough about lions and tigers and bears. let s get back to belly buttons. to get a sense of what the data look like consider subject whose sample of reads yielded species with the following counts there are a few dominant species that make up a large fraction of the whole but many species that yielded only a single read. the number of these singletons suggests that there are likely to be at least a few unseen species. in the example with lions and tigers we assume that each animal in the preserve is equally likely to be observed. similarly for the belly button data we assume that each bacterium is equally likely to yield a read. in reality each step in the data-collection process might introduce biases. some species might be more likely to be picked up by a swab or to yield identifiable amplicons. so when we talk about the prevalence of each species we should remember this source of error. i should also acknowledge that i am using the term species loosely. first bacterial species are not well defined. second some reads identify a particular species others only identify a genus. to be more precise i should say operational taxonomic unit or otu. now let s process some of the belly button data. subject to represent information about each subject in the study class subjectobject i define a class called def code self.code code self.species each subject has a string code like and a list of species name pairs sorted in increasing order by count. subject provides several chapter dealing with dimensions figure distribution of n for subject methods to make it easy to access these counts and species names. you can see the details in httpthinkbayes.comspecies.py. for more information see section subject provides a method named process that creates and updates a suite which represents the distributions of n and the prevalences. and provides distofn which returns the posterior distribution of n. class def distnself items zipself.ns self.probs pmf thinkbayes.makepmffromitemsitems return pmf figure shows the distribution of n for subject the probability that there are exactly species and no unseen species is nearly zero. the most likely value is with credible interval to at the high end it is unlikely that there are as many as species. next we compute the posterior distribution of prevalence for each species. provides distofprevalence class def distofprevalenceself index metapmf thinkbayes.pmf of the belly button data figure distribution of prevalences for subject for n prob in zipself.ns self.probs beta self.marginalbetan index pmf beta.makepmf metapmf.setpmf prob mix thinkbayes.makemixturemetapmf return metapmf mix index indicates which species we want. for each n we have a different posterior distribution of prevalence. the loop iterates through the possible values of n and their probabilities. for each value of n it gets a beta object representing the marginal distribution for the indicated species. remember that beta objects contain the parameters alpha and beta they don t have values and probabilities like a pmf but they provide makepmf which generates a discrete approximation to the continuous beta distribution. metapmf is a meta-pmf that contains the distributions of prevalence conditioned on n. makemixture combines the meta-pmf into mix which combines the conditional distributions into a single distribution of prevalence. figure shows results for the five species with the most reads. the most prevalent species accounts for of the reads but since there are almost certainly unseen species the most likely estimate for its prevalence is with credible interval between and chapter dealing with dimensions figure simulated rarefaction curves for subject predictive distributions i introduced the hidden species problem in the form of four related questions. we have answered the first two by computing the posterior distribution for n and the prevalence of each species. the other two questions are if we are planning to collect additional reads can we predict how many new species we are likely to discover? how many additional reads are needed to increase the fraction of ob served species to a given threshold? to answer predictive questions like this we can use the posterior distributions to simulate possible future events and compute predictive distributions for the number of species and fraction of the total we are likely to see. the kernel of these simulations looks like this choose n from its posterior distribution. choose a prevalence for each species species using the dirichlet distribution. including possible unseen generate a random sequence of future observations. species predictive distributions compute the number of new species num_new as a function of the number of additional reads k. repeat the previous steps and accumulate the joint distribution of num_new and k. and here s the code. runsimulation runs a single simulation class subject def runsimulationself num_reads m seen self.getseenspecies n observations self.generateobservationsnum_reads curve for k obs in enumerateobservations seen.addobs num_new lenseen m num_new return curve num_reads is the number of additional reads to simulate. m is the number of seen species and seen is a set of strings with a unique name for each species. n is a random value from the posterior distribution and observations is a random sequence of species names. each time through the loop we add the new observation to seen and record the number of reads and the number of new species so far. the result of runsimulation is a rarefaction curve represented as a list of pairs with the number of reads and the number of new species. the before we generateobservations. see subject results let s look at getseenspecies and def getseenspeciesself names self.getnames m lennames seen setspeciesgeneratornames m return m seen chapter dealing with dimensions getnames returns the list of species names that appear in the data files but for many subjects these names are not unique. so i use speciesgenerator to extend each name with a serial number def speciesgeneratornames num i for name in names yield i i while i num yield i i given a name when the list of names is exhausted names like corynebacterium like speciesgenerator yields it yields here is generateobservations class subject def generateobservationsself num_reads n prevalences self.suite.sampleposterior names self.getnames name_iter speciesgeneratornames n d dictzipname_iter prevalences cdf thinkbayes.makecdffromdictd observations cdf.samplenum_reads return n observations again num_reads is the number of additional reads to generate. n and prevalences are samples from the posterior distribution. cdf is a cdf object that maps species names including the unseen to cumulative probabilities. using a cdf makes it efficient to generate a random sequence of species names. finally here is def sampleposteriorself pmf self.distofn n pmf.random joint posterior figure distributions of the number of new species conditioned on the number of additional reads. prevalences self.sampleprevalencesn return n prevalences and sampleprevalences which generates a sample of prevalences conditioned on n class def sampleprevalencesself n params self.paramsn gammas numpy.random.gammaparams gammas gammas.sum return gammas we saw this algorithm for generating random values from a dirichlet distribution in section figure shows simulated rarefaction curves for subject the curves are jittered that is i shifted each curve by a random offset so they would not all overlap. by inspection we can estimate that after more reads we are likely to find new species. joint posterior we can use these simulations to estimate the joint distribution of num_new and k and from that we can get the distribution of num_new conditioned on any value of k. new chapter dealing with dimensions def makejointpredictivecurves joint thinkbayes.joint for curve in curves for k num_new in curve joint.incrk num_new joint.normalize return joint makejointpredictive makes a joint object which is a pmf whose values are tuples. curves is a list of rarefaction curves created by runsimulation. each curve contains a list of pairs of k and num_new. the resulting joint distribution is a map from each pair to its probability of occurring. given the joint distribution we can use joint.conditional get the distribution of num_new conditioned on k section subject.makeconditionals takes a list of ks and computes the conditional distribution of num_new for each k. the result is a list of cdf objects. def makeconditionalscurves ks joint makejointpredictivecurves cdfs for k in ks pmf k pmf.name k cdf pmf.makecdf cdfs.appendcdf return cdfs figure shows the results. after reads the median predicted number of new species is the credible interval is to after reads we expect to see to new species. coverage the last question we want to answer is how many additional reads are needed to increase the fraction of observed species to a given threshold? to answer this question we need a version of runsimulation that computes the fraction of observed species rather than the number of new species. coverage figure complementary cdf of coverage for a range of additional reads. class subject def runsimulationself num_reads m seen self.getseenspecies n observations self.generateobservationsnum_reads curve for k obs in enumerateobservations seen.addobs frac_seen lenseen floatn frac_seen return curve next we loop through each curve and make a dictionary d that maps from the number of additional reads k to a list of fracs that is a list of values for the coverage achieved after k reads. def makefraccdfsself curves d for curve in curves for k frac in curve d.setdefaultk cdfs for k fracs in d.iteritems of species chapter dealing with dimensions cdf thinkbayes.makecdffromlistfracs cdfsk cdf return cdfs then for each value of k we make a cdf of fracs this cdf represents the distribution of coverage after k reads. remember that the cdf tells you the probability of falling below a given threshold so the complementary cdf tells you the probability of exceeding it. figure shows complementary cdfs for a range of values of k. to read this figure select the level of coverage you want to achieve along the x-axis. as an example choose now you can read up the chart to find the probability of achieving coverage after k reads. for example with reads you have about a chance of getting coverage. with reads you have a chance of getting coverage. with that we have answered the four questions that make up the unseen species problem. to validate the algorithms in this chapter with real data i had to deal with a few more details. but this chapter is already too long so i won t discuss them here. read about you can them belly-button-biodiversity-end-game.html. at problems the addressed and how i you can download the code in this chapter from httpthinkbayes.com species.py. for more information see section discussion the unseen species problem is an area of active research and i believe the algorithm in this chapter is a novel contribution. so in fewer than pages we have made it from the basics of probability to the research frontier. i m very happy about that. my goal for this book is to present three related ideas bayesian thinking the foundation of bayesian analysis is the idea of using probability distributions to represent uncertain beliefs using data to update those distributions and using the results to make predictions and inform decisions. discussion a computational approach the premise of this book is that it is easier to understand bayesian analysis using computation rather than math and easier to implement bayesian methods with reusable building blocks that can be rearranged to solve real-world problems quickly. iterative modeling most real-world problems involve modeling decisions and trade-offs between realism and complexity. it is often impossible to know ahead of time what factors should be included in the model and which can be abstracted away. the best approach is to iterate starting with simple models and adding complexity gradually using each model to validate the others. these ideas are versatile and powerful they are applicable to problems in every area of science and engineering from simple examples to topics of current research. if you made it this far you should be prepared to apply these tools to new problems relevant to your work. i hope you find them useful let me know how it goes! index abc abstract type anaconda viii approximate bayesian computa tion arrival rate axtell robert bacteria bayes factor bayes s theorem derivation odds form bayesian framework behavioral risk factor surveillance system belly button bernoulli process beta distribution beta object biased coin binomial coefficient binomial distribution binomial likelihood function biodiversity bogus boston boston bruins brfss bucket bus stop problem cache calibration campbell-ricketts tom carcinoma causation cdc cdf centers for disease control central credible interval classical estimation clone vii coefficient of variation coin toss collectively exhaustive college board complementary cdf concrete type conditional distribution conditional probability conjoint probability conjugate prior conjunction continuous distribution contributors ix convergence cookie problem cookie.py correlated random value coverage crank science credible interval cromwell s rule cromwell oliver cumulative distribution function cumulative probability index cumulative sum davidson-pilon cameron decision analysis degree of belief density dependence diachronic interpretation dice dice problem dice problem dirichlet distribution distribution operations divide-and-conquer doubling time dungeons and dragons efficacy enumeration error esp euro problem evidence exception exponential distribution exponentiation extra-sensory perception fair coin fork vii forward problem gamma distribution gaussian distribution gaussian pdf gee steve geiger counter problem generator german tank problem git vii github vii growth rate heart attack height heuer andreas hierarchical model hoag dirk hockey horse racing horsford eben norton hume david hypothesis testing implementation independence informative prior insect sampling problem installation viii inter-quartile range interface intuition inverse problem iqr item response theory iterative modeling iterator jaynes e. t. joint joint distribution joint object joint pmf kde kernel density estimation kidney tumor problem least squares fit light bulb problem index likelihood likelihood likelihood function likelihood ratio linspace lions and tigers and bears locomotive problem log scale log transform log-likelihood logarithm m and m problem mackay david makemixture marginal distribution matplotlib viii maximum maximum likelihood mean squared error meckel johann median memoization meta-pmf meta-suite microbiome mixture modeling vi modeling error monty hall problem mosteller frederick mult multinomial coefficient multinomial distribution mutually exclusive national hockey league navel nhl non-linear normal distribution normalize normalizing constant nuisance parameter numpy viii numpy objectivity observer bias odds olin college oliver s blood problem operational taxonomic unit optimization otu overtime paintball problem parameter pdf pdf pep viii percentile pmf pmf class pmf methods poisson distribution poisson process vi posterior posterior distribution power law predictive distribution prevalence price is right prior prior distribution suite suite class summary statistic swamping the priors switch table method template method pattern total probability triangle distribution trigonometry tumor type tuple uncertainty underflow uniform distribution uniform distribution uninformative prior unseen species problem update vancouver canucks variability hypothesis veterans benefit administration volume weibull distribution word frequency index prob probability conditional conjoint probability density probability density function probability mass function process pseudocolor plot pyrosequencing radioactive decay random sample rarefaction curve raw score rdna red line problem reddit regression testing vii renormalize repository vii robust estimation sample bias sample statistics sat scaled score scipy viii scipy serial correlation showcase simulation sivia d.s. species sphere standardized test stick strafing speed subjective prior subjectivity sudden death