reinforcement learning an introduction second edition richard s. sutton and andrew g. barto a bradford book the mit press cambridge massachusetts london england in memory of a. harry klopf contents preface to the second edition preface to the first edition summary of notation ix xv xvii introduction reinforcement learning examples elements of reinforcement learning limitations and scope an extended example tic-tac-toe summary early history of reinforcement learning i tabular solution methods multi-armed bandits a k bandit problem action-value methods the testbed incremental implementation tracking a nonstationary problem optimistic initial values upper-confidence-bound action selection gradient bandit algorithms associative search bandits summary iii iv contents finite markov decision processes the agent environment interface goals and rewards returns and episodes unified notation for episodic and continuing tasks policies and value functions optimal policies and optimal value functions optimality and approximation summary dynamic programming policy evaluation policy improvement policy iteration value iteration asynchronous dynamic programming generalized policy iteration efficiency of dynamic programming summary monte carlo methods monte carlo prediction monte carlo estimation of action values monte carlo control monte carlo control without exploring starts off-policy prediction via importance sampling incremental implementation off-policy monte carlo control importance sampling importance sampling summary temporal-difference learning td prediction advantages of td prediction methods optimality of sarsa on-policy td control q-learning off-policy td control expected sarsa maximization bias and double learning games afterstates and other special cases summary contents v n-step bootstrapping n-step td prediction n-step sarsa n-step off-policy learning by importance sampling off-policy methods with control variates off-policy learning without importance sampling the n-step tree backup algorithm unifying algorithm n-step q summary planning and learning with tabular methods models and planning dyna integrated planning acting and learning when the model is wrong prioritized sweeping expected vs. sample updates trajectory sampling real-time dynamic programming planning at decision time heuristic search rollout algorithms monte carlo tree search summary of the chapter summary of part i dimensions ii approximate solution methods on-policy prediction with approximation value-function approximation the prediction objective stochastic-gradient and semi-gradient methods linear methods feature construction for linear methods polynomials fourier basis coarse coding tile coding radial basis functions selecting step-size parameters manually nonlinear function approximation artificial neural networks vi contents least-squares td memory-based function approximation kernel-based function approximation looking deeper at on-policy learning interest and emphasis summary on-policy control with approximation episodic semi-gradient control semi-gradient n-step sarsa average reward a new problem setting for continuing tasks deprecating the discounted setting differential semi-gradient n-step sarsa summary methods with approximation semi-gradient methods examples of off-policy divergence the deadly triad linear value-function geometry gradient descent in the bellman error the bellman error is not learnable gradient-td methods emphatic-td methods reducing variance summary eligibility traces the td n-step truncated methods redoing updates the online algorithm true online td dutch traces in monte carlo learning sarsa variable and off-policy eligibility traces with control variates watkins s q to tree-backup stable off-policy methods with traces implementation issues conclusions contents vii policy gradient methods policy approximation and its advantages the policy gradient theorem reinforce monte carlo policy gradient reinforce with baseline actor critic methods policy gradient for continuing problems policy parameterization for continuous actions summary iii looking deeper psychology prediction and control classical conditioning blocking and higher-order conditioning the rescorla wagner model the td model td model simulations instrumental conditioning delayed reinforcement cognitive maps habitual and goal-directed behavior summary neuroscience neuroscience basics reward signals reinforcement signals values and prediction errors the reward prediction error hypothesis dopamine experimental support for the reward prediction error hypothesis td errordopamine correspondence neural actor critic actor and critic learning rules hedonistic neurons collective reinforcement learning model-based methods in the brain addiction summary viii contents applications and case studies td-gammon samuel s checkers player watson s daily-double wagering optimizing memory control human-level video game play mastering the game of go alphago alphago zero personalized web services thermal soaring frontiers general value functions and auxiliary tasks temporal abstraction via options observations and state designing reward signals remaining issues reinforcement learning and the future of artificial intelligence references index preface to the second edition the twenty years since the publication of the first edition of this book have seen tremendous progress in artificial intelligence propelled in large part by advances in machine learning including advances in reinforcement learning. although the impressive computational power that became available is responsible for some of these advances new developments in theory and algorithms have been driving forces as well. in the face of this progress a second edition of our book was long overdue and we finally began the project in our goal for the second edition was the same as our goal for the first to provide a clear and simple account of the key ideas and algorithms of reinforcement learning that is accessible to readers in all the related disciplines. the edition remains an introduction and we retain a focus on core online learning algorithms. this edition includes some new topics that rose to importance over the intervening years and we expanded coverage of topics that we now understand better. but we made no attempt to provide comprehensive coverage of the field which has exploded in many different directions with outstanding contributions by many active researchers. we apologize for having to leave out all but a handful of these contributions. as in the first edition we chose not to produce a rigorous formal treatment of reinforcement learning or to formulate it in the most general terms. however since the first edition our deeper understanding of some topics required a bit more mathematics to explain we have set off the more mathematical parts in shaded boxes that the nonmathematically-inclined may choose to skip. we also use a slightly different notation than was used in the first edition. in teaching we have found that the new notation helps to address some common points of confusion. it emphasizes the difference between random variables denoted with capital letters and their instantiations denoted in lower case. for example the state action and reward at time step t are denoted st at and rt while their possible values might be denoted s a and r. along with this it is natural to use lower case for value functions v and restrict capitals to their tabular estimates qts a. approximate value functions are deterministic functions of random parameters and are thus also in lower case vswt v vectors such as the weight vector wt t and the feature vector xt t are bold and written in lowercase even if they are random variables. uppercase bold is reserved for matrices. in the first edition we used special notations pa for the transition probabilities and expected rewards. one weakness of that notation is that it still did not fully characterize the dynamics of the rewards giving only their expectations and ra ix x preface to the second edition which is sufficient for dynamic programming but not for reinforcement learning. another weakness is the excess of subscripts and superscripts. in this edition we use the explicit notation of rs a for the joint probability for the next state and reward given the current state and action. all the changes in notation are summarized in a table on page xvii. the second edition is significantly expanded and its top-level organization has been revamped. after the introductory first chapter the second edition is divided into three new parts. the first part treats as much of reinforcement learning as possible without going beyond the tabular case for which exact solutions can be found. we cover both learning and planning methods for the tabular case as well as their unification in n-step methods and in dyna. many algorithms presented in this part are new to the second edition including ucb expected sarsa double learning tree-backup q rtdp and mcts. doing the tabular case first and thoroughly enables core ideas to be developed in the simplest possible setting. the whole second part of the book is then devoted to extending the ideas to function approximation. it has new sections on artificial neural networks the fourier basis lstd kernel-based methods gradient-td and emphatic-td methods average-reward methods true online td and policy-gradient methods. the second edition significantly expands the treatment of off-policy learning first for the tabular case in chapters then with function approximation in chapters and another change is that the second edition separates the forward-view idea of n-step bootstrapping treated more fully in chapter from the backward-view idea of eligibility traces treated independently in chapter the third part of the book has large new chapters on reinforcement learning s relationships to psychology and neuroscience as well as an updated case-studies chapter including atari game playing watson s wagering strategy and the go playing programs alphago and alphago zero still out of necessity we have included only a small subset of all that has been done in the field. our choices reflect our long-standing interests in inexpensive model-free methods that should scale well to large applications. the final chapter now includes a discussion of the future societal impacts of reinforcement learning. for better or worse the second edition is about twice as large as the first. this book is designed to be used as the primary text for a one- or two-semester course on reinforcement learning. for a one-semester course the first ten chapters should be covered in order and form a good core to which can be added material from the other chapters from other books such as bertsekas and tsitsiklis wiering and van otterlo and szepesv ari or from the literature according to taste. depending of the students background some additional material on online supervised learning may be helpful. the ideas of options and option models are a natural addition precup and singh a two-semester course can cover all the chapters as well as supplementary material. the book can also be used as part of broader courses on machine learning artificial intelligence or neural networks. in this case it may be desirable to cover only a subset of the material. we recommend covering chapter for a brief overview chapter through section chapter and then selecting sections from the remaining chapters according to time and interests. chapter is the most important for the subject and for the rest of the book. a course focusing on machine preface to the second edition xi learning or neural networks should cover chapters and and a course focusing on artificial intelligence or planning should cover chapter throughout the book sections and chapters that are more difficult and not essential to the rest of the book are marked with a these can be omitted on first reading without creating problems later on. some exercises are also marked with a to indicate that they are more advanced and not essential to understanding the basic material of the chapter. most chapters end with a section entitled bibliographical and historical remarks wherein we credit the sources of the ideas presented in that chapter provide pointers to further reading and ongoing research and describe relevant historical background. despite our attempts to make these sections authoritative and complete we have undoubtedly left out some important prior work. for that we again apologize and we welcome corrections and extensions for incorporation into the electronic version of the book. like the first edition this edition of the book is dedicated to the memory of a. harry klopf. it was harry who introduced us to each other and it was his ideas about the brain and artificial intelligence that launched our long excursion into reinforcement learning. trained in neurophysiology and long interested in machine intelligence harry was a senior scientist affiliated with the avionics directorate of the air force office of scientific research at wright-patterson air force base ohio. he was dissatisfied with the great importance attributed to equilibrium-seeking processes including homeostasis and error-correcting pattern classification methods in explaining natural intelligence and in providing a basis for machine intelligence. he noted that systems that try to maximize something that might be are qualitatively different from equilibrium-seeking systems and he argued that maximizing systems hold the key to understanding important aspects of natural intelligence and for building artificial intelligences. harry was instrumental in obtaining funding from afosr for a project to assess the scientific merit of these and related ideas. this project was conducted in the late at the university of massachusetts amherst amherst initially under the direction of michael arbib william kilmer and nico spinelli professors in the department of computer and information science at umass amherst and founding members of the cybernetics center for systems neuroscience at the university a farsighted group focusing on the intersection of neuroscience and artificial intelligence. barto a recent ph.d. from the university of michigan was hired as post doctoral researcher on the project. meanwhile sutton an undergraduate studying computer science and psychology at stanford had been corresponding with harry regarding their mutual interest in the role of stimulus timing in classical conditioning. harry suggested to the umass group that sutton would be a great addition to the project. thus sutton became a umass graduate student whose ph.d. was directed by barto who had become an associate professor. the study of reinforcement learning as presented in this book is rightfully an outcome of that project instigated by harry and inspired by his ideas. further harry was responsible for bringing us the authors together in what has been a long and enjoyable interaction. by dedicating this book to harry we honor his essential contributions not only to the field of reinforcement learning but also to our collaboration. we also thank professors arbib kilmer and spinelli for the opportunity they provided to us to begin exploring these ideas. finally we thank afosr for generous support over the early years of our xii preface to the second edition research and the nsf for its generous support over many of the following years. we have very many people to thank for their inspiration and help with this second edition. everyone we acknowledged for their inspiration and help with the first edition deserve our deepest gratitude for this edition as well which would not exist were it not for their contributions to edition number one. to that long list we must add many others who contributed specifically to the second edition. our students over the many years that we have taught this material contributed in countless ways exposing errors offering fixes and not the least being confused in places where we could have explained things better. we especially thank martha steenstrup for reading and providing detailed comments throughout. the chapters on psychology and neuroscience could not have been written without the help of many experts in those fields. we thank john moore for his patient tutoring over many many years on animal learning experiments theory and neuroscience and for his careful reading of multiple drafts of chapters and we also thank matt botvinick nathaniel daw peter dayan and yael niv for their penetrating comments on drafts of these chapter their essential guidance through the massive literature and their interception of many of our errors in early drafts. of course the remaining errors in these chapters and there must still be some are totally our own. we thank phil thomas for helping us make these chapters accessible to non-psychologists and non-neuroscientists and we thank peter sterling for helping us improve the exposition. we are grateful to jim houk for introducing us to the subject of information processing in the basal ganglia and for alerting us to other relevant aspects of neuroscience. jos e mart nez terry sejnowski david silver gerry tesauro georgios theocharous and phil thomas generously helped us understand details of their reinforcement learning applications for inclusion in the case-studies chapter and they provided helpful comments on drafts of these sections. special thanks are owed to david silver for helping us better understand monte carlo tree search and the deepmind go-playing programs. we thank george konidaris for his help with the section on the fourier basis. emilio cartoni thomas cederborg stefan dernbach clemens rosenbaum patrick taylor and pierre-luc bacon helped us in a number important ways for which we are most grateful. sutton would also like to thank the members of the reinforcement learning and artificial intelligence laboratory at the university of alberta for contributions to the second edition. he owes a particular debt to rupam mahmood for essential contributions to the treatment of off-policy monte carlo methods in chapter to hamid maei for helping develop the perspective on off-policy learning presented in chapter to eric graves for conducting the experiments in chapter to shangtong zhang for replicating and thus verifying almost all the experimental results to kris de asis for improving the new technical content of chapters and and to harm van seijen for insights that led to the separation of n-step methods from eligibility traces and with hado van hasselt for the ideas involving exact equivalence of forward and backward views of eligibility traces presented in chapter sutton also gratefully acknowledges the support and freedom he was granted by the government of alberta and the national science and engineering research council of canada throughout the period during which the second edition was conceived and written. in particular he would like to thank randy goebel for creating a supportive and far-sighted environment for research in alberta. he preface to the second edition xiii would also like to thank deepmind their support in the last six months of writing the book. finally we owe thanks to the many careful readers of drafts of the second edition that we posted on the internet. they found many errors that we had missed and alerted us to potential points of confusion. preface to the first edition we first came to focus on what is now known as reinforcement learning in late we were both at the university of massachusetts working on one of the earliest projects to revive the idea that networks of neuronlike adaptive elements might prove to be a promising approach to artificial adaptive intelligence. the project explored the heterostatic theory of adaptive systems developed by a. harry klopf. harry s work was a rich source of ideas and we were permitted to explore them critically and compare them with the long history of prior work in adaptive systems. our task became one of teasing the ideas apart and understanding their relationships and relative importance. this continues today but in we came to realize that perhaps the simplest of the ideas which had long been taken for granted had received surprisingly little attention from a computational perspective. this was simply the idea of a learning system that wants something that adapts its behavior in order to maximize a special signal from its environment. this was the idea of a hedonistic learning system or as we would say now the idea of reinforcement learning. like others we had a sense that reinforcement learning had been thoroughly explored in the early days of cybernetics and artificial intelligence. on closer inspection though we found that it had been explored only slightly. while reinforcement learning had clearly motivated some of the earliest computational studies of learning most of these researchers had gone on to other things such as pattern classification supervised learning and adaptive control or they had abandoned the study of learning altogether. as a result the special issues involved in learning how to get something from the environment received relatively little attention. in retrospect focusing on this idea was the critical step that set this branch of research in motion. little progress could be made in the computational study of reinforcement learning until it was recognized that such a fundamental idea had not yet been thoroughly explored. the field has come a long way since then evolving and maturing in several directions. reinforcement learning has gradually become one of the most active research areas in machine learning artificial intelligence and neural network research. the field has developed strong mathematical foundations and impressive applications. the computational study of reinforcement learning is now a large field with hundreds of active researchers around the world in diverse disciplines such as psychology control theory artificial intelligence and neuroscience. particularly important have been the contributions establishing and developing the relationships to the theory of optimal control and xv xvi preface to the first edition dynamic programming. the overall problem of learning from interaction to achieve goals is still far from being solved but our understanding of it has improved significantly. we can now place component ideas such as temporal-difference learning dynamic programming and function approximation within a coherent perspective with respect to the overall problem. our goal in writing this book was to provide a clear and simple account of the key ideas and algorithms of reinforcement learning. we wanted our treatment to be accessible to readers in all of the related disciplines but we could not cover all of these perspectives in detail. for the most part our treatment takes the point of view of artificial intelligence and engineering. coverage of connections to other fields we leave to others or to another time. we also chose not to produce a rigorous formal treatment of reinforcement learning. we did not reach for the highest possible level of mathematical abstraction and did not rely on a theorem proof format. we tried to choose a level of mathematical detail that points the mathematically inclined in the right directions without distracting from the simplicity and potential generality of the underlying ideas. paragraphs elided in favor of updated content in the second edition. in some sense we have been working toward this book for thirty years and we have lots of people to thank. first we thank those who have personally helped us develop the overall view presented in this book harry klopf for helping us recognize that reinforcement learning needed to be revived chris watkins dimitri bertsekas john tsitsiklis and paul werbos for helping us see the value of the relationships to dynamic programming john moore and jim kehoe for insights and inspirations from animal learning theory oliver selfridge for emphasizing the breadth and importance of adaptation and more generally our colleagues and students who have contributed in countless ways ron williams charles anderson satinder singh sridhar mahadevan steve bradtke bob crites peter dayan and leemon baird. our view of reinforcement learning has been significantly enriched by discussions with paul cohen paul utgoff martha steenstrup gerry tesauro mike jordan leslie kaelbling andrew moore chris atkeson tom mitchell nils nilsson stuart russell tom dietterich tom dean and bob narendra. we thank michael littman gerry tesauro bob crites satinder singh and wei zhang for providing specifics of sections and respectively. we thank the air force office of scientific research the national science foundation and gte laboratories for their long and farsighted support. we also wish to thank the many people who have read drafts of this book and provided valuable comments including tom kalt john tsitsiklis pawel cichosz olle g allmo chuck anderson stuart russell ben van roy paul steenstrup paul cohen sridhar mahadevan jette randlov brian sheppard thomas o connell richard coggins cristina versino john h. hiett andreas badelt jay ponte joe beck justus piater martha steenstrup satinder singh tommi jaakkola dimitri bertsekas torbj orn ekman christina bj orkman jakob carlstr om and olle palmgren. finally we thank gwyn mitchell for helping in many ways and harry stanton and bob prior for being our champions at mit press. summary of notation capital letters are used for random variables whereas lower case letters are used for the values of random variables and for scalar functions. quantities that are required to be real-valued vectors are written in bold and in lower case if random variables. matrices are bold capitals. equality relationship that is true by definition approximately equal proportional to probability that a random variable x takes on the value x random variable x selected from distribution px prx x x p ex argmaxa f a value of a at which f takes its maximal value ln x ex r f x y b prx x expectation of a random variable x i.e. ex pxx natural logarithm of x the base of the natural logarithm e carried to the power x eln x x set of real numbers function f from elements of set x to elements of set y assignment the real interval between a and b including b but not including a probability of taking a random action in an policy step-size parameters discount-rate parameter decay-rate parameter for eligibility traces indicator function if the predicate is true else in a multi-arm bandit problem k t q qta nta hta ta rt number of actions discrete time step or play number true value reward of action a estimate at time t of q number of times action a has been selected up prior to time t learned preference for selecting action a probability of selecting action a at time t estimate at time t of the expected reward given xvii xviii summary of notation in a markov decision process s a r s s a r t t t at st rt gt gttn gth gth g t g th g s t g a t states an action a reward set of all nonterminal states set of all states including the terminal state set of all actions set of all possible rewards a finite subset of r subset of e.g. r r is an element of e.g. s s r r number of elements in set s discrete time step final time step of an episode or of the episode including time step t action at time t state at time t typically due stochastically to st and at reward at time t typically due stochastically to st and at policy rule action taken in state s under deterministic policy probability of taking action a in state s under stochastic policy probability of taking action a in state s given parameter vector column vector of partial derivatives of with respect to return following time t n-step return from t to hdiscounted and corrected flat return and uncorrected from t to h truncated corrected corrected by estimated state values corrected by estimated action values rs a a rs a probability of transition to state with reward r from state s and action a probability of transition to state from state s taking action a expected immediate reward on transition from s to under action a v v q a q a v vt q qt vts ut value of state s under policy return value of state s under the optimal policy value of taking action a in state s under policy value of taking action a in state s under the optimal policy array estimates of state-value function v or v array estimates of action-value function q or q expected approximate action value a target for estimate at time t summary of notation xix temporal-difference error at t random variable d-vector of weights underlying an approximate value function ith component of learnable weight vector dimensionality the number of components of w alternate dimensionality the number of components of number of in a sparse binary feature vector approximate value of state s given weight vector w alternate notation for vsw approximate value of state action pair s a given weight vector w vector of features visible when in state s vector of features visible when in state s taking action a t w wt wi wti d m vsw vws qs a w xs xs a xis xis a ith component of vector xs or xs a xt v vt zt vsw qs a w t j j j hs a shorthand for xst or xst at inner product of vectors on-policy distribution over states of the for all s s wixi e.g. vsw norm of any vector xs i secondary d-vector of weights used to learn w d-vector of eligibility traces at time t column vector of partial derivatives of vsw with respect to w column vector of partial derivatives of qs a w with respect to w parameter vector of target policy policy corresponding to parameter performance measure for policy or column vector of partial derivatives of j with respect to preference for selecting action a in state s based on b behavior policy used to select actions while learning about target policy th t r rt a b wtd i p d x or a baseline function b s r for policy-gradient methods or a branching factor for a search tree importance sampling ratio for time t through time h importance sampling ratio for time t alone t tt average reward rate for policy estimate of r at time t d d matrix a d-dimensional vector b a d-vector td fixed point wtd identity matrix matrix of state-transition probabilities under diagonal matrix with the on its diagonal d matrix with xs as its rows chapter introduction the idea that we learn by interacting with our environment is probably the first to occur to us when we think about the nature of learning. when an infant plays waves its arms or looks about it has no explicit teacher but it does have a direct sensorimotor connection to its environment. exercising this connection produces a wealth of information about cause and effect about the consequences of actions and about what to do in order to achieve goals. throughout our lives such interactions are undoubtedly a major source of knowledge about our environment and ourselves. whether we are learning to drive a car or to hold a conversation we are acutely aware of how our environment responds to what we do and we seek to influence what happens through our behavior. learning from interaction is a foundational idea underlying nearly all theories of learning and intelligence. in this book we explore a computational approach to learning from interaction. rather than directly theorizing about how people or animals learn we primarily explore idealized learning situations and evaluate the effectiveness of various learning that is we adopt the perspective of an artificial intelligence researcher or engineer. we explore designs for machines that are effective in solving learning problems of scientific or economic interest evaluating the designs through mathematical analysis or computational experiments. the approach we explore called reinforcement learning is much more focused on goal-directed learning from interaction than are other approaches to machine learning. reinforcement learning reinforcement learning is learning what to do how to map situations to actions so as to maximize a numerical reward signal. the learner is not told which actions to take but instead must discover which actions yield the most reward by trying them. in the most interesting and challenging cases actions may affect not only the immediate relationships to psychology and neuroscience are summarized in chapters and chapter introduction reward but also the next situation and through that all subsequent rewards. these two characteristics trial-and-error search and delayed reward are the two most important distinguishing features of reinforcement learning. reinforcement learning like many topics whose names end with ing such as machine learning and mountaineering is simultaneously a problem a class of solution methods that work well on the problem and the field that studies this problem and its solution methods. it is convenient to use a single name for all three things but at the same time essential to keep the three conceptually separate. in particular the distinction between problems and solution methods is very important in reinforcement learning failing to make this distinction is the source of many confusions. we formalize the problem of reinforcement learning using ideas from dynamical systems theory specifically as the optimal control of incompletely-known markov decision processes. the details of this formalization must wait until chapter but the basic idea is simply to capture the most important aspects of the real problem facing a learning agent interacting over time with its environment to achieve a goal. a learning agent must be able to sense the state of its environment to some extent and must be able to take actions that affect the state. the agent also must have a goal or goals relating to the state of the environment. markov decision processes are intended to include just these three aspects sensation action and goal in their simplest possible forms without trivializing any of them. any method that is well suited to solving such problems we consider to be a reinforcement learning method. reinforcement learning is different from supervised learning the kind of learning studied in most current research in the field of machine learning. supervised learning is learning from a training set of labeled examples provided by a knowledgable external supervisor. each example is a description of a situation together with a specification the label of the correct action the system should take to that situation which is often to identify a category to which the situation belongs. the object of this kind of learning is for the system to extrapolate or generalize its responses so that it acts correctly in situations not present in the training set. this is an important kind of learning but alone it is not adequate for learning from interaction. in interactive problems it is often impractical to obtain examples of desired behavior that are both correct and representative of all the situations in which the agent has to act. in uncharted territory where one would expect learning to be most beneficial an agent must be able to learn from its own experience. reinforcement learning is also different from what machine learning researchers call unsupervised learning which is typically about finding structure hidden in collections of unlabeled data. the terms supervised learning and unsupervised learning would seem to exhaustively classify machine learning paradigms but they do not. although one might be tempted to think of reinforcement learning as a kind of unsupervised learning because it does not rely on examples of correct behavior reinforcement learning is trying to maximize a reward signal instead of trying to find hidden structure. uncovering structure in an agent s experience can certainly be useful in reinforcement learning but by itself does not address the reinforcement learning problem of maximizing a reward signal. we therefore consider reinforcement learning to be a third machine learning reinforcement learning paradigm alongside supervised learning and unsupervised learning and perhaps other paradigms as well. one of the challenges that arise in reinforcement learning and not in other kinds of learning is the trade-off between exploration and exploitation. to obtain a lot of reward a reinforcement learning agent must prefer actions that it has tried in the past and found to be effective in producing reward. but to discover such actions it has to try actions that it has not selected before. the agent has to exploit what it has already experienced in order to obtain reward but it also has to explore in order to make better action selections in the future. the dilemma is that neither exploration nor exploitation can be pursued exclusively without failing at the task. the agent must try a variety of actions and progressively favor those that appear to be best. on a stochastic task each action must be tried many times to gain a reliable estimate of its expected reward. the exploration exploitation dilemma has been intensively studied by mathematicians for many decades yet remains unresolved. for now we simply note that the entire issue of balancing exploration and exploitation does not even arise in supervised and unsupervised learning at least in their purest forms. another key feature of reinforcement learning is that it explicitly considers the whole problem of a goal-directed agent interacting with an uncertain environment. this is in contrast to many approaches that consider subproblems without addressing how they might fit into a larger picture. for example we have mentioned that much of machine learning research is concerned with supervised learning without explicitly specifying how such an ability would finally be useful. other researchers have developed theories of planning with general goals but without considering planning s role in real-time decision making or the question of where the predictive models necessary for planning would come from. although these approaches have yielded many useful results their focus on isolated subproblems is a significant limitation. reinforcement learning takes the opposite tack starting with a complete interactive goal-seeking agent. all reinforcement learning agents have explicit goals can sense aspects of their environments and can choose actions to influence their environments. moreover it is usually assumed from the beginning that the agent has to operate despite significant uncertainty about the environment it faces. when reinforcement learning involves planning it has to address the interplay between planning and real-time action selection as well as the question of how environment models are acquired and improved. when reinforcement learning involves supervised learning it does so for specific reasons that determine which capabilities are critical and which are not. for learning research to make progress important subproblems have to be isolated and studied but they should be subproblems that play clear roles in complete interactive goal-seeking agents even if all the details of the complete agent cannot yet be filled in. by a complete interactive goal-seeking agent we do not always mean something like a complete organism or robot. these are clearly examples but a complete interactive goal-seeking agent can also be a component of a larger behaving system. in this case the agent directly interacts with the rest of the larger system and indirectly interacts with the larger system s environment. a simple example is an agent that monitors the charge level of robot s battery and sends commands to the robot s control architecture. chapter introduction this agent s environment is the rest of the robot together with the robot s environment. one must look beyond the most obvious examples of agents and their environments to appreciate the generality of the reinforcement learning framework. one of the most exciting aspects of modern reinforcement learning is its substantive and fruitful interactions with other engineering and scientific disciplines. reinforcement learning is part of a decades-long trend within artificial intelligence and machine learning toward greater integration with statistics optimization and other mathematical subjects. for example the ability of some reinforcement learning methods to learn with parameterized approximators addresses the classical curse of dimensionality in operations research and control theory. more distinctively reinforcement learning has also interacted strongly with psychology and neuroscience with substantial benefits going both ways. of all the forms of machine learning reinforcement learning is the closest to the kind of learning that humans and other animals do and many of the core algorithms of reinforcement learning were originally inspired by biological learning systems. reinforcement learning has also given back both through a psychological model of animal learning that better matches some of the empirical data and through an influential model of parts of the brain s reward system. the body of this book develops the ideas of reinforcement learning that pertain to engineering and artificial intelligence with connections to psychology and neuroscience summarized in chapters and finally reinforcement learning is also part of a larger trend in artificial intelligence back toward simple general principles. since the late s many artificial intelligence researchers presumed that there are no general principles to be discovered that intelligence is instead due to the possession of a vast number of special purpose tricks procedures and heuristics. it was sometimes said that if we could just get enough relevant facts into a machine say one million or one billion then it would become intelligent. methods based on general principles such as search or learning were characterized as weak methods whereas those based on specific knowledge were called strong methods. this view is still common today but not dominant. from our point of view it was simply premature too little effort had been put into the search for general principles to conclude that there were none. modern artificial intelligence now includes much research looking for general principles of learning search and decision making as well as trying to incorporate vast amounts of domain knowledge. it is not clear how far back the pendulum will swing but reinforcement learning research is certainly part of the swing back toward simpler and fewer general principles of artificial intelligence. examples a good way to understand reinforcement learning is to consider some of the examples and possible applications that have guided its development. a master chess player makes a move. the choice is informed both by planning anticipating possible replies and counterreplies and by immediate intuitive judgments of the desirability of particular positions and moves. an adaptive controller adjusts parameters of a petroleum refinery s operation in examples real time. the controller optimizes the yieldcostquality trade-off on the basis of specified marginal costs without sticking strictly to the set points originally suggested by engineers. a gazelle calf struggles to its feet minutes after being born. half an hour later it is running at miles per hour. a mobile robot decides whether it should enter a new room in search of more trash to collect or start trying to find its way back to its battery recharging station. it makes its decision based on the current charge level of its battery and how quickly and easily it has been able to find the recharger in the past. phil prepares his breakfast. closely examined even this apparently mundane activity reveals a complex web of conditional behavior and interlocking goal subgoal relationships walking to the cupboard opening it selecting a cereal box then reaching for grasping and retrieving the box. other complex tuned interactive sequences of behavior are required to obtain a bowl spoon and milk jug. each step involves a series of eye movements to obtain information and to guide reaching and locomotion. rapid judgments are continually made about how to carry the objects or whether it is better to ferry some of them to the dining table before obtaining others. each step is guided by goals such as grasping a spoon or getting to the refrigerator and is in service of other goals such as having the spoon to eat with once the cereal is prepared and ultimately obtaining nourishment. whether he is aware of it or not phil is accessing information about the state of his body that determines his nutritional needs level of hunger and food preferences. these examples share features that are so basic that they are easy to overlook. all involve interaction between an active decision-making agent and its environment within which the agent seeks to achieve a goal despite uncertainty about its environment. the agent s actions are permitted to affect the future state of the environment the next chess position the level of reservoirs of the refinery the robot s next location and the future charge level of its battery thereby affecting the options and opportunities available to the agent at later times. correct choice requires taking into account indirect delayed consequences of actions and thus may require foresight or planning. at the same time in all these examples the effects of actions cannot be fully predicted thus the agent must monitor its environment frequently and react appropriately. for example phil must watch the milk he pours into his cereal bowl to keep it from overflowing. all these examples involve goals that are explicit in the sense that the agent can judge progress toward its goal based on what it can sense directly. the chess player knows whether or not he wins the refinery controller knows how much petroleum is being produced the gazelle calf knows when it falls the mobile robot knows when its batteries run down and phil knows whether or not he is enjoying his breakfast. in all of these examples the agent can use its experience to improve its performance over time. the chess player refines the intuition he uses to evaluate positions thereby improving his play the gazelle calf improves the efficiency with which it can run phil learns to streamline making his breakfast. the knowledge the agent brings to the task chapter introduction at the start either from previous experience with related tasks or built into it by design or evolution influences what is useful or easy to learn but interaction with the environment is essential for adjusting behavior to exploit specific features of the task. elements of reinforcement learning beyond the agent and the environment one can identify four main subelements of a reinforcement learning system a policy a reward signal a value function and optionally a model of the environment. a policy defines the learning agent s way of behaving at a given time. roughly speaking a policy is a mapping from perceived states of the environment to actions to be taken when in those states. it corresponds to what in psychology would be called a set of stimulus response rules or associations. in some cases the policy may be a simple function or lookup table whereas in others it may involve extensive computation such as a search process. the policy is the core of a reinforcement learning agent in the sense that it alone is sufficient to determine behavior. in general policies may be stochastic. a reward signal defines the goal in a reinforcement learning problem. on each time step the environment sends to the reinforcement learning agent a single number called the reward. the agent s sole objective is to maximize the total reward it receives over the long run. the reward signal thus defines what are the good and bad events for the agent. in a biological system we might think of rewards as analogous to the experiences of pleasure or pain. they are the immediate and defining features of the problem faced by the agent. the reward signal is the primary basis for altering the policy if an action selected by the policy is followed by low reward then the policy may be changed to select some other action in that situation in the future. in general reward signals may be stochastic functions of the state of the environment and the actions taken. whereas the reward signal indicates what is good in an immediate sense a value function specifies what is good in the long run. roughly speaking the value of a state is the total amount of reward an agent can expect to accumulate over the future starting from that state. whereas rewards determine the immediate intrinsic desirability of environmental states values indicate the long-term desirability of states after taking into account the states that are likely to follow and the rewards available in those states. for example a state might always yield a low immediate reward but still have a high value because it is regularly followed by other states that yield high rewards. or the reverse could be true. to make a human analogy rewards are somewhat like pleasure high and pain low whereas values correspond to a more refined and farsighted judgment of how pleased or displeased we are that our environment is in a particular state. rewards are in a sense primary whereas values as predictions of rewards are secondary. without rewards there could be no values and the only purpose of estimating values is to achieve more reward. nevertheless it is values with which we are most concerned when making and evaluating decisions. action choices are made based on value judgments. we seek actions that bring about states of highest value not highest reward because these actions obtain the greatest amount of reward for us over the long run. unfortunately it is much harder to determine values than it is to determine limitations and scope rewards. rewards are basically given directly by the environment but values must be estimated and re-estimated from the sequences of observations an agent makes over its entire lifetime. in fact the most important component of almost all reinforcement learning algorithms we consider is a method for efficiently estimating values. the central role of value estimation is arguably the most important thing that has been learned about reinforcement learning over the last six decades. the fourth and final element of some reinforcement learning systems is a model of the environment. this is something that mimics the behavior of the environment or more generally that allows inferences to be made about how the environment will behave. for example given a state and action the model might predict the resultant next state and next reward. models are used for planning by which we mean any way of deciding on a course of action by considering possible future situations before they are actually experienced. methods for solving reinforcement learning problems that use models and planning are called model-based methods as opposed to simpler model-free methods that are explicitly trial-and-error learners viewed as almost the opposite of planning. in chapter we explore reinforcement learning systems that simultaneously learn by trial and error learn a model of the environment and use the model for planning. modern reinforcement learning spans the spectrum from low-level trial-and-error learning to high-level deliberative planning. limitations and scope reinforcement learning relies heavily on the concept of state as input to the policy and value function and as both input to and output from the model. informally we can think of the state as a signal conveying to the agent some sense of how the environment is at a particular time. the formal definition of state as we use it here is given by the framework of markov decision processes presented in chapter more generally however we encourage the reader to follow the informal meaning and think of the state as whatever information is available to the agent about its environment. in effect we assume that the state signal is produced by some preprocessing system that is nominally part of the agent s environment. we do not address the issues of constructing changing or learning the state signal in this book than briefly in section we take this approach not because we consider state representation to be unimportant but in order to focus fully on the decision-making issues. in other words our main concern is not with designing the state signal but with deciding what action to take as a function of whatever state signal is available. most of the reinforcement learning methods we consider in this book are structured around estimating value functions but it is not strictly necessary to do this to solve reinforcement learning problems. for example solution methods such as genetic algorithms genetic programming simulated annealing and other optimization methods never estimate value functions. these methods apply multiple static policies each interacting over an extended period of time with a separate instance of the environment. the policies that obtain the most reward and random variations of them are carried over to the next generation of policies and the process repeats. we call these evolutionary methods chapter introduction because their operation is analogous to the way biological evolution produces organisms with skilled behavior even if they do not learn during their individual lifetimes. if the space of policies is sufficiently small or can be structured so that good policies are common or easy to find or if a lot of time is available for the search then evolutionary methods can be effective. in addition evolutionary methods have advantages on problems in which the learning agent cannot sense the complete state of its environment. our focus is on reinforcement learning methods that learn while interacting with the environment which evolutionary methods do not do. methods able to take advantage of the details of individual behavioral interactions can be much more efficient than evolutionary methods in many cases. evolutionary methods ignore much of the useful structure of the reinforcement learning problem they do not use the fact that the policy they are searching for is a function from states to actions they do not notice which states an individual passes through during its lifetime or which actions it selects. in some cases this information can be misleading when states are misperceived but more often it should enable more efficient search. although evolution and learning share many features and naturally work together we do not consider evolutionary methods by themselves to be especially well suited to reinforcement learning problems and accordingly we do not cover them in this book. an extended example tic-tac-toe to illustrate the general idea of reinforcement learning and contrast it with other approaches we next consider a single example in more detail. consider the familiar child s game of tic-tac-toe. two players take turns playing on a three-by-three board. one player plays xs and the other os until one player wins by placing three marks in a row horizontally vertically or diagonally as the x player has in the game shown to the right. if the board fills up with neither player getting three in a row the game is a draw. because a skilled player can play so as never to lose let us assume that we are playing against an imperfect player one whose play is sometimes incorrect and allows us to win. for the moment in fact let us consider draws and losses to be equally bad for us. how might we construct a player that will find the imperfections in its opponent s play and learn to maximize its chances of winning? although this is a simple problem it cannot readily be solved in a satisfactory way through classical techniques. for example the classical minimax solution from game theory is not correct here because it assumes a particular way of playing by the opponent. for example a minimax player would never reach a game state from which it could lose even if in fact it always won from that state because of incorrect play by the opponent. classical optimization methods for sequential decision problems such as dynamic programming can compute an optimal solution for any opponent but require as input a complete specification of that opponent including the probabilities with which the opponent makes each move in each board state. let us assume that this information xxxooxo an extended example tic-tac-toe is not available a priori for this problem as it is not for the vast majority of problems of practical interest. on the other hand such information can be estimated from experience in this case by playing many games against the opponent. about the best one can do on this problem is first to learn a model of the opponent s behavior up to some level of confidence and then apply dynamic programming to compute an optimal solution given the approximate opponent model. in the end this is not that different from some of the reinforcement learning methods we examine later in this book. an evolutionary method applied to this problem would directly search the space of possible policies for one with a high probability of winning against the opponent. here a policy is a rule that tells the player what move to make for every state of the game every possible configuration of xs and os on the three-by-three board. for each policy considered an estimate of its winning probability would be obtained by playing some number of games against the opponent. this evaluation would then direct which policy or policies were considered next. a typical evolutionary method would hill-climb in policy space successively generating and evaluating policies in an attempt to obtain incremental improvements. or perhaps a genetic-style algorithm could be used that would maintain and evaluate a population of policies. literally hundreds of different optimization methods could be applied. here is how the tic-tac-toe problem would be approached with a method making use of a value function. first we set up a table of numbers one for each possible state of the game. each number will be the latest estimate of the probability of our winning from that state. we treat this estimate as the state s value and the whole table is the learned value function. state a has higher value than state b or is considered better than state b if the current estimate of the probability of our winning from a is higher than it is from b. assuming we always play xs then for all states with three xs in a row the probability of winning is because we have already won. similarly for all states with three os in a row or that are filled up the correct probability is as we cannot win from them. we set the initial values of all the other states to representing a guess that we have a chance of winning. we play many games against the opponent. to select our moves we examine the states that would result from each of our possible moves for each blank space on the board and look up their current values in the table. most of the time we move greedily selecting the move that leads to the state with greatest value that is with the highest estimated probability of winning. occasionally however we select randomly from among the other moves instead. these are called exploratory moves because they cause us to experience states that we might otherwise never see. a sequence of moves made and considered during a game can be diagrammed as in figure while we are playing we change the values of the states in which we find ourselves during the game. we attempt to make them more accurate estimates of the probabilities of winning. to do this we back up the value of the state after each greedy move to the state before the move as suggested by the arrows in figure more precisely the current value of the earlier state is updated to be closer to the value of the later state. this can be done by moving the earlier state s value a fraction of the way toward the value of the later state. if we let s denote the state before the greedy move and the chapter introduction figure a sequence of tic-tac-toe moves. the solid lines represent the moves taken during a game the dashed lines represent moves that we reinforcement learning player considered but did not make. our second move was an exploratory move meaning that it was taken even though another sibling move the one leading to e was ranked higher. exploratory moves do not result in any learning but each of our other moves does causing updates as suggested by the red arrows in which estimated values are moved up the tree from later nodes to earlier as detailed in the text. state after the move then the update to the estimated value of s denoted v can be written as v v v where is a small positive fraction called the step-size parameter which influences the rate of learning. this update rule is an example of a temporal-difference learning method so called because its changes are based on a difference v v between estimates at two different times. the method described above performs quite well on this task. for example if the step-size parameter is reduced properly over time then this method converges for any fixed opponent to the true probabilities of winning from each state given optimal play by our player. furthermore the moves then taken on exploratory moves are in fact the optimal moves against this opponent. in other words the method converges to an optimal policy for playing the game against this opponent. if the stepsize parameter is not reduced all the way to zero over time then this player also plays well against opponents that slowly change their way of playing. our moveopponents moveour movestarting position abcdeeopponents movec f ggopponents moveour move. agcstarting positionbcdeefg an extended example tic-tac-toe this example illustrates the differences between evolutionary methods and methods that learn value functions. to evaluate a policy an evolutionary method holds the policy fixed and plays many games against the opponent or simulates many games using a model of the opponent. the frequency of wins gives an unbiased estimate of the probability of winning with that policy and can be used to direct the next policy selection. but each policy change is made only after many games and only the final outcome of each game is used what happens during the games is ignored. for example if the player wins then all of its behavior in the game is given credit independently of how specific moves might have been critical to the win. credit is even given to moves that never occurred! value function methods in contrast allow individual states to be evaluated. in the end evolutionary and value function methods both search the space of policies but learning a value function takes advantage of information available during the course of play. this simple example illustrates some of the key features of reinforcement learning methods. first there is the emphasis on learning while interacting with an environment in this case with an opponent player. second there is a clear goal and correct behavior requires planning or foresight that takes into account delayed effects of one s choices. for example the simple reinforcement learning player would learn to set up multi-move traps for a shortsighted opponent. it is a striking feature of the reinforcement learning solution that it can achieve the effects of planning and lookahead without using a model of the opponent and without conducting an explicit search over possible sequences of future states and actions. while this example illustrates some of the key features of reinforcement learning it is so simple that it might give the impression that reinforcement learning is more limited than it really is. although tic-tac-toe is a two-person game reinforcement learning also applies in the case in which there is no external adversary that is in the case of a game against nature. reinforcement learning also is not restricted to problems in which behavior breaks down into separate episodes like the separate games of tic-tactoe with reward only at the end of each episode. it is just as applicable when behavior continues indefinitely and when rewards of various magnitudes can be received at any time. reinforcement learning is also applicable to problems that do not even break down into discrete time steps like the plays of tic-tac-toe. the general principles apply to continuous-time problems as well although the theory gets more complicated and we omit it from this introductory treatment. tic-tac-toe has a relatively small finite state set whereas reinforcement learning can be used when the state set is very large or even infinite. for example gerry tesauro combined the algorithm described above with an artificial neural network to learn to play backgammon which has approximately states. with this many states it is impossible ever to experience more than a small fraction of them. tesauro s program learned to play far better than any previous program and now plays at the level of the world s best human players chapter the neural network provides the program with the ability to generalize from its experience so that in new states it selects moves based on information saved from similar states faced in the past as determined by its network. how well a reinforcement learning system can work in problems with such large chapter introduction state sets is intimately tied to how appropriately it can generalize from past experience. it is in this role that we have the greatest need for supervised learning methods with reinforcement learning. neural networks and deep learning are not the only or necessarily the best way to do this. in this tic-tac-toe example learning started with no prior knowledge beyond the rules of the game but reinforcement learning by no means entails a tabula rasa view of learning and intelligence. on the contrary prior information can be incorporated into reinforcement learning in a variety of ways that can be critical for efficient learning. we also had access to the true state in the tic-tac-toe example whereas reinforcement learning can also be applied when part of the state is hidden or when different states appear to the learner to be the same. finally the tic-tac-toe player was able to look ahead and know the states that would result from each of its possible moves. to do this it had to have a model of the game that allowed it to foresee how its environment would change in response to moves that it might never make. many problems are like this but in others even a short-term model of the effects of actions is lacking. reinforcement learning can be applied in either case. no model is required but models can easily be used if they are available or can be learned on the other hand there are reinforcement learning methods that do not need any kind of environment model at all. model-free systems cannot even think about how their environments will change in response to a single action. the tic-tac-toe player is modelfree in this sense with respect to its opponent it has no model of its opponent of any kind. because models have to be reasonably accurate to be useful model-free methods can have advantages over more complex methods when the real bottleneck in solving a problem is the difficulty of constructing a sufficiently accurate environment model. model-free methods are also important building blocks for model-based methods. in this book we devote several chapters to model-free methods before we discuss how they can be used as components of more complex model-based methods. reinforcement learning can be used at both high and low levels in a system. although the tic-tac-toe player learned only about the basic moves of the game nothing prevents reinforcement learning from working at higher levels where each of the actions may itself be the application of a possibly elaborate problem-solving method. in hierarchical learning systems reinforcement learning can work simultaneously on several levels. exercise self-play suppose instead of playing against a random opponent the reinforcement learning algorithm described above played against itself with both sides learning. what do you think would happen in this case? would it learn a different policy for selecting moves? exercise symmetries many tic-tac-toe positions appear different but are really the same because of symmetries. how might we amend the learning process described above to take advantage of this? in what ways would this change improve the learning process? now think again. suppose the opponent did not take advantage of symmetries. in that case should we? is it true then that symmetrically equivalent positions should necessarily have the same value? exercise greedy play suppose the reinforcement learning player was greedy that early history of reinforcement learning is it always played the move that brought it to the position that it rated the best. might it learn to play better or worse than a nongreedy player? what problems might occur? exercise learning from exploration suppose learning updates occurred after all moves including exploratory moves. if the step-size parameter is appropriately reduced over time not the tendency to explore then the state values would converge to a set of probabilities. what are the two sets of probabilities computed when we do and when we do not learn from exploratory moves? assuming that we do continue to make exploratory moves which set of probabilities might be better to learn? which would result in more wins? exercise other improvements can you think of other ways to improve the reinforcement learning player? can you think of any better way to solve the tic-tac-toe problem as posed? summary reinforcement learning is a computational approach to understanding and automating goal-directed learning and decision making. it is distinguished from other computational approaches by its emphasis on learning by an agent from direct interaction with its environment without relying on exemplary supervision or complete models of the environment. in our opinion reinforcement learning is the first field to seriously address the computational issues that arise when learning from interaction with an environment in order to achieve long-term goals. reinforcement learning uses the formal framework of markov decision processes to define the interaction between a learning agent and its environment in terms of states actions and rewards. this framework is intended to be a simple way of representing essential features of the artificial intelligence problem. these features include a sense of cause and effect a sense of uncertainty and nondeterminism and the existence of explicit goals. the concepts of value and value function are key to most of the reinforcement learning methods that we consider in this book. we take the position that value functions are important for efficient search in the space of policies. the use of value functions distinguishes reinforcement learning methods from evolutionary methods that search directly in policy space guided by scalar evaluations of entire policies. early history of reinforcement learning the early history of reinforcement learning has two main threads both long and rich that were pursued independently before intertwining in modern reinforcement learning. one thread concerns learning by trial and error that started in the psychology of animal learning. this thread runs through some of the earliest work in artificial intelligence and led to the revival of reinforcement learning in the early the other thread chapter introduction concerns the problem of optimal control and its solution using value functions and dynamic programming. for the most part this thread did not involve learning. although the two threads have been largely independent the exceptions revolve around a third less distinct thread concerning temporal-difference methods such as the one used in the tic-tac-toe example in this chapter. all three threads came together in the late to produce the modern field of reinforcement learning as we present it in this book. the thread focusing on trial-and-error learning is the one with which we are most familiar and about which we have the most to say in this brief history. before doing that however we briefly discuss the optimal control thread. the term optimal control came into use in the late to describe the problem of designing a controller to minimize a measure of a dynamical system s behavior over time. one of the approaches to this problem was developed in the by richard bellman and others through extending a nineteenth century theory of hamilton and jacobi. this approach uses the concepts of a dynamical system s state and of a value function or optimal return function to define a functional equation now often called the bellman equation. the class of methods for solving optimal control problems by solving this equation came to be known as dynamic programming bellman also introduced the discrete stochastic version of the optimal control problem known as markov decision processes and ronald howard devised the policy iteration method for mdps. all of these are essential elements underlying the theory and algorithms of modern reinforcement learning. dynamic programming is widely considered the only feasible way of solving general stochastic optimal control problems. it suffers from what bellman called the curse of dimensionality meaning that its computational requirements grow exponentially with the number of state variables but it is still far more efficient and more widely applicable than any other general method. dynamic programming has been extensively developed since the late including extensions to partially observable mdps by lovejoy many applications by white approximation methods by rust and asynchronous methods many excellent modern treatments of dynamic programming are available bertsekas puterman ross and whittle bryson provides an authoritative history of optimal control. connections between optimal control and dynamic programming on the one hand and learning on the other were slow to be recognized. we cannot be sure about what accounted for this separation but its main cause was likely the separation between the disciplines involved and their different goals. also contributing may have been the prevalent view of dynamic programming as an off-line computation depending essentially on accurate system models and analytic solutions to the bellman equation. further the simplest form of dynamic programming is a computation that proceeds backwards in time making it difficult to see how it could be involved in a learning process that must proceed in a forward direction. some of the earliest work in dynamic programming such as that by bellman and dreyfus might now be classified as following a learning approach. witten s work below certainly qualifies as a combination of learning and dynamic-programming ideas. werbos argued explicitly early history of reinforcement learning for greater interrelation of dynamic programming and learning methods and its relevance to understanding neural and cognitive mechanisms. for us the full integration of dynamic programming methods with online learning did not occur until the work of chris watkins in whose treatment of reinforcement learning using the mdp formalism has been widely adopted. since then these relationships have been extensively developed by many researchers most particularly by dimitri bertsekas and john tsitsiklis who coined the term neurodynamic programming to refer to the combination of dynamic programming and neural networks. another term currently in use is approximate dynamic programming. these various approaches emphasize different aspects of the subject but they all share with reinforcement learning an interest in circumventing the classical shortcomings of dynamic programming. we would consider all of the work in optimal control also to be in a sense work in reinforcement learning. we define a reinforcement learning method as any effective way of solving reinforcement learning problems and it is now clear that these problems are closely related to optimal control problems particularly stochastic optimal control problems such as those formulated as mdps. accordingly we must consider the solution methods of optimal control such as dynamic programming also to be reinforcement learning methods. because almost all of the conventional methods require complete knowledge of the system to be controlled it feels a little unnatural to say that they are part of reinforcement learning. on the other hand many dynamic programming algorithms are incremental and iterative. like learning methods they gradually reach the correct answer through successive approximations. as we show in the rest of this book these similarities are far more than superficial. the theories and solution methods for the cases of complete and incomplete knowledge are so closely related that we feel they must be considered together as part of the same subject matter. let us return now to the other major thread leading to the modern field of reinforcement learning that centered on the idea of trial-and-error learning. we only touch on the major points of contact here taking up this topic in more detail in section according to american psychologist r. s. woodworth the idea of trial-and-error learning goes as far back as the to alexander bain s discussion of learning by groping and experiment and more explicitly to the british ethologist and psychologist conway lloyd morgan s use of the term to describe his observations of animal behavior perhaps the first to succinctly express the essence of trial-and-error learning as a principle of learning was edward thorndike of several responses made to the same situation those which are accompanied or closely followed by satisfaction to the animal will other things being equal be more firmly connected with the situation so that when it recurs they will be more likely to recur those which are accompanied or closely followed by discomfort to the animal will other things being equal have their connections with that situation weakened so that when it recurs they will be less likely to occur. the greater the satisfaction or discomfort the greater the strengthening or weakening of the bond. p. thorndike called this the law of effect because it describes the effect of reinforcing events on the tendency to select actions. thorndike later modified the law to better chapter introduction account for accumulating data on animal learning as differences between the effects of reward and punishment and the law in its various forms has generated considerable controversy among learning theorists see gallistel herrnstein kimble mazur despite this the law of effect in one form or another is widely regarded as a basic principle underlying much behavior hilgard and bower dennett campbell cziko it is the basis of the influential learning theories of clark hull and experimental methods of b. f. skinner hull skinner the term reinforcement in the context of animal learning came into use well after thorndike s expression of the law of effect to the best of our knowledge first appearing in this context in the english translation of pavlov s monograph on conditioned reflexes. reinforcement is the strengthening of a pattern of behavior as a result of an animal receiving a stimulus a reinforcer in an appropriate temporal relationship with another stimulus or with a response. some psychologists extended its meaning to include the process of weakening in addition to strengthening as well applying when the omission or termination of an event changes behavior. reinforcement produces changes in behavior that persist after the reinforcer is withdrawn so that a stimulus that attracts an animal s attention or that energizes its behavior without producing lasting changes is not considered to be a reinforcer. the idea of implementing trial-and-error learning in a computer appeared among the earliest thoughts about the possibility of artificial intelligence. in a report alan turing described a design for a pleasure-pain system that worked along the lines of the law of effect when a configuration is reached for which the action is undetermined a random choice for the missing data is made and the appropriate entry is made in the description tentatively and is applied. when a pain stimulus occurs all tentative entries are cancelled and when a pleasure stimulus occurs they are all made permanent. many ingenious electro-mechanical machines were constructed that demonstrated trialand-error learning. the earliest may have been a machine built by thomas ross that was able to find its way through a simple maze and remember the path through the settings of switches. in w. grey walter already known for his mechanical tortoise built a version capable of a simple form of learning. in claude shannon demonstrated a maze-running mouse named theseus that used trial and error to find its way through a maze with the maze itself remembering the successful directions via magnets and relays under its floor also shannon j. a. deutsch described a maze-solving machine based on his behavior theory that has some properties in common with model-based reinforcement learning in his ph.d. dissertation marvin minsky discussed computational models of reinforcement learning and described his construction of an analog machine composed of components he called snarcs neural-analog reinforcement calculators meant to resemble modifiable synaptic connections in the brain the fascinating web site cyberneticzoo.com contains a wealth of information on these and many other electro-mechanical learning machines. early history of reinforcement learning building electro-mechanical learning machines gave way to programming digital computers to perform various types of learning some of which implemented trial-and-error learning. farley and clark described a digital simulation of a neural-network learning machine that learned by trial and error. but their interests soon shifted from trial-and-error learning to generalization and pattern recognition that is from reinforcement learning to supervised learning and farley this began a pattern of confusion about the relationship between these types of learning. many researchers seemed to believe that they were studying reinforcement learning when they were actually studying supervised learning. for example neural network pioneers such as rosenblatt and widrow and hoff were clearly motivated by reinforcement learning they used the language of rewards and punishments but the systems they studied were supervised learning systems suitable for pattern recognition and perceptual learning. even today some researchers and textbooks minimize or blur the distinction between these types of learning. for example some neural-network textbooks have used the term trial-and-error to describe networks that learn from training examples. this is an understandable confusion because these networks use error information to update connection weights but this misses the essential character of trial-and-error learning as selecting actions on the basis of evaluative feedback that does not rely on knowledge of what the correct action should be. partly as a result of these confusions research into genuine trial-and-error learning became rare in the and although there were notable exceptions. in the the terms reinforcement and reinforcement learning were used in the engineering literature for the first time to describe engineering uses of trial-and-error learning waltz and fu mendel fu mendel and mcclaren particularly influential was minsky s paper steps toward artificial intelligence which discussed several issues relevant to trial-and-error learning including prediction expectation and what he called the basic credit-assignment problem for complex reinforcement learning systems how do you distribute credit for success among the many decisions that may have been involved in producing it? all of the methods we discuss in this book are in a sense directed toward solving this problem. minsky s paper is well worth reading today. in the next few paragraphs we discuss some of the other exceptions and partial exceptions to the relative neglect of computational and theoretical study of genuine trialand-error learning in the and one of these was the work by a new zealand researcher named john andreae. andreae developed a system called stella that learned by trial and error in interaction with its environment. this system included an internal model of the world and later an internal monologue to deal with problems of hidden state andreae s later work placed more emphasis on learning from a teacher but still included learning by trial and error with the generation of novel events being one of the system s goals. a feature of this work was a leakback process elaborated more fully in andreae that implemented a credit-assignment mechanism similar to the backing-up update operations that we describe. unfortunately his pioneering research was not well known and did not greatly impact subsequent reinforcement learning research. chapter introduction more influential was the work of donald michie. in and he described a simple trial-and-error learning system for learning how to play tic-tac-toe naughts and crosses called menace matchbox educable naughts and crosses engine. it consisted of a matchbox for each possible game position each matchbox containing a number of colored beads a different color for each possible move from that position. by drawing a bead at random from the matchbox corresponding to the current game position one could determine menace s move. when a game was over beads were added to or removed from the boxes used during play to reinforce or punish menace s decisions. michie and chambers described another tic-tac-toe reinforcement learner called glee learning expectimaxing engine and a reinforcement learning controller called boxes. they applied boxes to the task of learning to balance a pole hinged to a movable cart on the basis of a failure signal occurring only when the pole fell or the cart reached the end of a track. this task was adapted from the earlier work of widrow and smith who used supervised learning methods assuming instruction from a teacher already able to balance the pole. michie and chambers s version of pole-balancing is one of the best early examples of a reinforcement learning task under conditions of incomplete knowledge. it influenced much later work in reinforcement learning beginning with some of our own studies sutton and anderson sutton michie consistently emphasized the role of trial and error and learning as essential aspects of artificial intelligence widrow gupta and maitra modified the least-mean-square algorithm of widrow and hoff to produce a reinforcement learning rule that could learn from success and failure signals instead of from training examples. they called this form of learning selective bootstrap adaptation and described it as learning with a critic instead of learning with a teacher. they analyzed this rule and showed how it could learn to play blackjack. this was an isolated foray into reinforcement learning by widrow whose contributions to supervised learning were much more influential. our use of the term critic is derived from widrow gupta and maitra s paper. buchanan mitchell smith and johnson independently used the term critic in the context of machine learning also dietterich and buchanan but for them a critic is an expert system able to do more than evaluate performance. research on learning automata had a more direct influence on the trial-and-error thread leading to modern reinforcement learning research. these are methods for solving a nonassociative purely selectional learning problem known as the k-armed bandit by analogy to a slot machine or one-armed bandit except with k levers chapter learning automata are simple low-memory machines for improving the probability of reward in these problems. learning automata originated with work in the of the russian mathematician and physicist m. l. tsetlin and colleagues posthumously in tsetlin and has been extensively developed since then within engineering narendra and thathachar these developments included the study of stochastic learning automata which are methods for updating action probabilities on the basis of reward signals. although not developed in the tradition of stochastic learning automata harth and tzanakou s alopex algorithm algorithm of pattern extraction is a stochastic method for detecting correlations between actions and reinforcement that influenced some of our early research sutton and brouwer early history of reinforcement learning stochastic learning automata were foreshadowed by earlier work in psychology beginning with william estes effort toward a statistical theory of learning and further developed by others most famously by psychologist robert bush and statistician frederick mosteller and mosteller the statistical learning theories developed in psychology were adopted by researchers in economics leading to a thread of research in that field devoted to reinforcement learning. this work began in with the application of bush and mosteller s learning theory to a collection of classical economic models one goal of this research was to study artificial agents that act more like real people than do traditional idealized economic agents this approach expanded to the study of reinforcement learning in the context of game theory. although reinforcement learning in economics developed largely independently of the early work in artificial intelligence reinforcement learning and game theory is a topic of current interest in both fields but one that is beyond the scope of this book. camerer discusses the reinforcement learning tradition in economics and now e et al. provide an overview of the subject from the point of view of multi-agent extensions to the approach that we introduce in this book. reinforcement in the context of game theory is a much different subject than reinforcement learning used in programs to play tic-tac-toe checkers and other recreational games. see for example szita for an overview of this aspect of reinforcement learning and games. john holland outlined a general theory of adaptive systems based on selectional principles. his early work concerned trial and error primarily in its nonassociative form as in evolutionary methods and the k-armed bandit. in and more fully in he introduced classifier systems true reinforcement learning systems including association and value functions. a key component of holland s classifier systems was the bucket-brigade algorithm for credit assignment that is closely related to the temporal difference algorithm used in our tic-tac-toe example and discussed in chapter another key component was a genetic algorithm an evolutionary method whose role was to evolve useful representations. classifier systems have been extensively developed by many researchers to form a major branch of reinforcement learning research by urbanowicz and moore but genetic algorithms which we do not consider to be reinforcement learning systems by themselves have received much more attention as have other approaches to evolutionary computation fogel owens and walsh and koza the individual most responsible for reviving the trial-and-error thread to reinforcement learning within artificial intelligence was harry klopf klopf recognized that essential aspects of adaptive behavior were being lost as learning researchers came to focus almost exclusively on supervised learning. what was missing according to klopf were the hedonic aspects of behavior the drive to achieve some result from the environment to control the environment toward desired ends and away from undesired ends. this is the essential idea of trial-and-error learning. klopf s ideas were especially influential on the authors because our assessment of them and sutton led to our appreciation of the distinction between supervised and reinforcement learning and to our eventual focus on reinforcement learning. much of the early work chapter introduction that we and colleagues accomplished was directed toward showing that reinforcement learning and supervised learning were indeed different sutton and brouwer barto and sutton barto and anandan other studies showed how reinforcement learning could address important problems in neural network learning in particular how it could produce learning algorithms for multilayer networks anderson and sutton barto and anderson barto barto and jordan we say more about reinforcement learning and neural networks in chapter we turn now to the third thread to the history of reinforcement learning that concerning temporal-difference learning. temporal-difference learning methods are distinctive in being driven by the difference between temporally successive estimates of the same quantity for example of the probability of winning in the tic-tac-toe example. this thread is smaller and less distinct than the other two but it has played a particularly important role in the field in part because temporal-difference methods seem to be new and unique to reinforcement learning. the origins of temporal-difference learning are in part in animal learning psychology in particular in the notion of secondary reinforcers. a secondary reinforcer is a stimulus that has been paired with a primary reinforcer such as food or pain and as a result has come to take on similar reinforcing properties. minsky may have been the first to realize that this psychological principle could be important for artificial learning systems. arthur samuel was the first to propose and implement a learning method that included temporal-difference ideas as part of his celebrated checkers-playing program. samuel made no reference to minsky s work or to possible connections to animal learning. his inspiration apparently came from claude shannon s suggestion that a computer could be programmed to use an evaluation function to play chess and that it might be able to improve its play by modifying this function online. is possible that these ideas of shannon s also influenced bellman but we know of no evidence for this. minsky extensively discussed samuel s work in his steps paper suggesting the connection to secondary reinforcement theories both natural and artificial. as we have discussed in the decade following the work of minsky and samuel little computational work was done on trial-and-error learning and apparently no computational work at all was done on temporal-difference learning. in klopf brought trial-and-error learning together with an important component of temporal-difference learning. klopf was interested in principles that would scale to learning in large systems and thus was intrigued by notions of local reinforcement whereby subcomponents of an overall learning system could reinforce one another. he developed the idea of generalized reinforcement whereby every component every neuron views all of its inputs in reinforcement terms excitatory inputs as rewards and inhibitory inputs as punishments. this is not the same idea as what we now know as temporal-difference learning and in retrospect it is farther from it than was samuel s work. on the other hand klopf linked the idea with trial-and-error learning and related it to the massive empirical database of animal learning psychology. sutton developed klopf s ideas further particularly the links to animal learning theories describing learning rules driven by changes in temporally early history of reinforcement learning successive predictions. he and barto refined these ideas and developed a psychological model of classical conditioning based on temporal-difference learning and barto barto and sutton there followed several other influential psychological models of classical conditioning based on temporal-difference learning klopf moore et al. sutton and barto some neuroscience models developed at this time are well interpreted in terms of temporal-difference learning and kandel byrne gingrich and baxter gelperin hopfield and tank tesauro friston et al. although in most cases there was no historical connection. our early work on temporal-difference learning was strongly influenced by animal learning theories and by klopf s work. relationships to minsky s steps paper and to samuel s checkers players appear to have been recognized only afterward. by however we were fully aware of all the prior work mentioned above as part of the temporal-difference and trial-and-error threads. at this time we developed a method for using temporal-difference learning combined with trial-and-error learning known as the actor critic architecture and applied this method to michie and chambers s polebalancing problem sutton and anderson this method was extensively studied in sutton s ph.d. dissertation and extended to use backpropagation neural networks in anderson s ph.d. dissertation. around this time holland incorporated temporal-difference ideas explicitly into his classifier systems in the form of his bucket-brigade algorithm. a key step was taken by sutton in by separating temporal-difference learning from control treating it as a general prediction method. that paper also introduced the td algorithm and proved some of its convergence properties. as we were finalizing our work on the actor critic architecture in we discovered a paper by ian witten which appears to be the earliest publication of a temporal-difference learning rule. he proposed the method that we now call tabular for use as part of an adaptive controller for solving mdps. witten s work was a descendant of andreae s early experiments with stella and other trial-and-error learning systems. thus witten s paper spanned both major threads of reinforcement learning research trial-and-error learning and optimal control while making a distinct early contribution to temporal-difference learning. the temporal-difference and optimal control threads were fully brought together in with chris watkins s development of q-learning. this work extended and integrated prior work in all three threads of reinforcement learning research. paul werbos contributed to this integration by arguing for the convergence of trial-and-error learning and dynamic programming since by the time of watkins s work there had been tremendous growth in reinforcement learning research primarily in the machine learning subfield of artificial intelligence but also in neural networks and artificial intelligence more broadly. in the remarkable success of gerry tesauro s backgammon playing program td-gammon brought additional attention to the field. in the time since publication of the first edition of this book a flourishing subfield of neuroscience developed that focuses on the relationship between reinforcement learning algorithms and reinforcement learning in the nervous system. most responsible for this chapter introduction is an uncanny similarity between the behavior of temporal-difference algorithms and the activity of dopamine producing neurons in the brain as pointed out by a number of researchers et al. barto houk adams and barto montague dayan and sejnowski and schultz dayan and montague chapter provides an introduction to this exciting aspect of reinforcement learning. other important contributions made in the recent history of reinforcement learning are too numerous to mention in this brief account we cite many of these at the end of the individual chapters in which they arise. bibliographical remarks for additional general coverage of reinforcement learning we refer the reader to the books by szepesv ari bertsekas and tsitsiklis kaelbling and sugiyama hachiya and morimura books that take a control or operations research perspective include those of si et al. powell lewis and liu and bertsekas cao s review places reinforcement learning in the context of other approaches to learning and optimization of stochastic dynamic systems. three special issues of the journal machine learning focus on reinforcement learning sutton kaelbling and singh useful surveys are provided by barto kaelbling littman and moore and keerthi and ravindran the volume edited by weiring and van otterlo provides an excellent overview of recent developments. the example of phil s breakfast in this chapter was inspired by agre the temporal-difference method used in the tic-tac-toe example is developed in chapter part i tabular solution methods in this part of the book we describe almost all the core ideas of reinforcement learning algorithms in their simplest forms that in which the state and action spaces are small enough for the approximate value functions to be represented as arrays or tables. in this case the methods can often find exact solutions that is they can often find exactly the optimal value function and the optimal policy. this contrasts with the approximate methods described in the next part of the book which only find approximate solutions but which in return can be applied effectively to much larger problems. the first chapter of this part of the book describes solution methods for the special case of the reinforcement learning problem in which there is only a single state called bandit problems. the second chapter describes the general problem formulation that we treat throughout the rest of the book finite markov decision processes and its main ideas including bellman equations and value functions. the next three chapters describe three fundamental classes of methods for solving finite markov decision problems dynamic programming monte carlo methods and temporaldifference learning. each class of methods has its strengths and weaknesses. dynamic programming methods are well developed mathematically but require a complete and accurate model of the environment. monte carlo methods don t require a model and are conceptually simple but are not well suited for step-by-step incremental computation. finally temporal-difference methods require no model and are fully incremental but are more complex to analyze. the methods also differ in several ways with respect to their efficiency and speed of convergence. the remaining two chapters describe how these three classes of methods can be combined to obtain the best features of each of them. in one chapter we describe how the strengths of monte carlo methods can be combined with the strengths of temporaldifference methods via multi-step bootstrapping methods. in the final chapter of this part of the book we show how temporal-difference learning methods can be combined with model learning and planning methods as dynamic programming for a complete and unified solution to the tabular reinforcement learning problem. chapter multi-armed bandits the most important feature distinguishing reinforcement learning from other types of learning is that it uses training information that evaluates the actions taken rather than instructs by giving correct actions. this is what creates the need for active exploration for an explicit search for good behavior. purely evaluative feedback indicates how good the action taken was but not whether it was the best or the worst action possible. purely instructive feedback on the other hand indicates the correct action to take independently of the action actually taken. this kind of feedback is the basis of supervised learning which includes large parts of pattern classification artificial neural networks and system identification. in their pure forms these two kinds of feedback are quite distinct evaluative feedback depends entirely on the action taken whereas instructive feedback is independent of the action taken. in this chapter we study the evaluative aspect of reinforcement learning in a simplified setting one that does not involve learning to act in more than one situation. this nonassociative setting is the one in which most prior work involving evaluative feedback has been done and it avoids much of the complexity of the full reinforcement learning problem. studying this case enables us to see most clearly how evaluative feedback differs from and yet can be combined with instructive feedback. the particular nonassociative evaluative feedback problem that we explore is a simple version of the k-armed bandit problem. we use this problem to introduce a number of basic learning methods which we extend in later chapters to apply to the full reinforcement learning problem. at the end of this chapter we take a step closer to the full reinforcement learning problem by discussing what happens when the bandit problem becomes associative that is when actions are taken in more than one situation. a k bandit problem consider the following learning problem. you are faced repeatedly with a choice among k different options or actions. after each choice you receive a numerical reward chosen from a stationary probability distribution that depends on the action you selected. your chapter multi-armed bandits objective is to maximize the expected total reward over some time period for example over action selections or time steps. this is the original form of the k-armed bandit problem so named by analogy to a slot machine or one-armed bandit except that it has k levers instead of one. each action selection is like a play of one of the slot machine s levers and the rewards are the payoffs for hitting the jackpot. through repeated action selections you are to maximize your winnings by concentrating your actions on the best levers. another analogy is that of a doctor choosing between experimental treatments for a series of seriously ill patients. each action is the selection of a treatment and each reward is the survival or well-being of the patient. today the term bandit problem is sometimes used for a generalization of the problem described above but in this book we use it to refer just to this simple case. in our k-armed bandit problem each of the k actions has an expected or mean reward given that that action is selected let us call this the value of that action. we denote the action selected on time step t as at and the corresponding reward as rt. the value then of an arbitrary action a denoted q is the expected reward given that a is selected q ert at a if you knew the value of each action then it would be trivial to solve the k-armed bandit problem you would always select the action with highest value. we assume that you do not know the action values with certainty although you may have estimates. we denote the estimated value of action a at time step t as qta. we would like qta to be close to q if you maintain estimates of the action values then at any time step there is at least one action whose estimated value is greatest. we call these the greedy actions. when you select one of these actions we say that you are exploiting your current knowledge of the values of the actions. if instead you select one of the nongreedy actions then we say you are exploring because this enables you to improve your estimate of the nongreedy action s value. exploitation is the right thing to do to maximize the expected reward on the one step but exploration may produce the greater total reward in the long run. for example suppose a greedy action s value is known with certainty while several other actions are estimated to be nearly as good but with substantial uncertainty. the uncertainty is such that at least one of these other actions probably is actually better than the greedy action but you don t know which one. if you have many time steps ahead on which to make action selections then it may be better to explore the nongreedy actions and discover which of them are better than the greedy action. reward is lower in the short run during exploration but higher in the long run because after you have discovered the better actions you can exploit them many times. because it is not possible both to explore and to exploit with any single action selection one often refers to the conflict between exploration and exploitation. in any specific case whether it is better to explore or exploit depends in a complex way on the precise values of the estimates uncertainties and the number of remaining steps. there are many sophisticated methods for balancing exploration and exploitation for particular mathematical formulations of the k-armed bandit and related problems. action-value methods however most of these methods make strong assumptions about stationarity and prior knowledge that are either violated or impossible to verify in applications and in the full reinforcement learning problem that we consider in subsequent chapters. the guarantees of optimality or bounded loss for these methods are of little comfort when the assumptions of their theory do not apply. in this book we do not worry about balancing exploration and exploitation in a sophisticated way we worry only about balancing them at all. in this chapter we present several simple balancing methods for the k-armed bandit problem and show that they work much better than methods that always exploit. the need to balance exploration and exploitation is a distinctive challenge that arises in reinforcement learning the simplicity of our version of the k-armed bandit problem enables us to show this in a particularly clear form. action-value methods we begin by looking more closely at methods for estimating the values of actions and for using the estimates to make action selection decisions which we collectively call actionvalue methods. recall that the true value of an action is the mean reward when that action is selected. one natural way to estimate this is by averaging the rewards actually received qta sum of rewards when a taken prior to t number of times a taken prior to t ri where denotes the random variable that is if predicate is true and if it is not. if the denominator is zero then we instead define qta as some default value such as as the denominator goes to infinity by the law of large numbers qta converges to q we call this the sample-average method for estimating action values because each estimate is an average of the sample of relevant rewards. of course this is just one way to estimate action values and not necessarily the best one. nevertheless for now let us stay with this simple estimation method and turn to the question of how the estimates might be used to select actions. the simplest action selection rule is to select one of the actions with the highest estimated value that is one of the greedy actions as defined in the previous section. if there is more than one greedy action then a selection is made among them in some arbitrary way perhaps randomly. we write this greedy action selection method as at argmax a qta where argmaxa denotes the action a for which the expression that follows is maximized with ties broken arbitrarily. greedy action selection always exploits current knowledge to maximize immediate reward it spends no time at all sampling apparently inferior actions to see if they might really be better. a simple alternative is to behave greedily most of the time but every once in a while say with small probability instead select randomly from among all the actions with equal probability independently chapter multi-armed bandits of the action-value estimates. we call methods using this near-greedy action selection rule methods. an advantage of these methods is that in the limit as the number of steps increases every action will be sampled an infinite number of times thus ensuring that all the qta converge to q this of course implies that the probability of selecting the optimal action converges to greater than that is to near certainty. these are just asymptotic guarantees however and say little about the practical effectiveness of the methods. exercise in action selection for the case of two actions and what is the probability that the greedy action is selected? the testbed to roughly assess the relative effectiveness of the greedy and action-value methods we compared them numerically on a suite of test problems. this was a set of randomly generated k-armed bandit problems with k for each bandit problem such as the one shown in figure the action values q a were selected according to a normal distribution with mean and variance then when figure an example bandit problem from the testbed. the true value q of each of the ten actions was selected according to a normal distribution with mean zero and unit variance and then the actual rewards were selected according to a mean q unit variance normal distribution as suggested by these gray distributions. the testbed a learning method applied to that problem selected action at at time step t the actual reward rt was selected from a normal distribution with mean q and variance these distributions are shown in gray in figure we call this suite of test tasks the testbed. for any learning method we can measure its performance and behavior as it improves with experience over time steps when applied to one of the bandit problems. this makes up one run. repeating this for independent runs each with a different bandit problem we obtained measures of the learning algorithm s average behavior. figure compares a greedy method with two methods and as described above on the testbed. all the methods formed their action-value estimates using the sample-average technique. the upper graph shows the increase in expected reward with experience. the greedy method improved slightly faster than the other methods at the very beginning but then leveled off at a lower level. it achieved a reward-per-step of only about compared with the best possible of about on this testbed. the greedy method performed significantly worse in the long run because it often got stuck performing suboptimal actions. the lower graph shows that the greedy figure average performance of action-value methods on the testbed. these data are averages over runs with different bandit problems. all methods used sample averages as their action-value estimates. chapter multi-armed bandits method found the optimal action in only approximately one-third of the tasks. in the other two-thirds its initial samples of the optimal action were disappointing and it never returned to it. the methods eventually performed better because they continued to explore and to improve their chances of recognizing the optimal action. the method explored more and usually found the optimal action earlier but it never selected that action more than of the time. the method improved more slowly but eventually would perform better than the method on both performance measures shown in the figure. it is also possible to reduce over time to try to get the best of both high and low values. the advantage of over greedy methods depends on the task. for example suppose the reward variance had been larger say instead of with noisier rewards it takes more exploration to find the optimal action and methods should fare even better relative to the greedy method. on the other hand if the reward variances were zero then the greedy method would know the true value of each action after trying it once. in this case the greedy method might actually perform best because it would soon find the optimal action and then never explore. but even in the deterministic case there is a large advantage to exploring if we weaken some of the other assumptions. for example suppose the bandit task were nonstationary that is the true values of the actions changed over time. in this case exploration is needed even in the deterministic case to make sure one of the nongreedy actions has not changed to become better than the greedy one. as we shall see in the next few chapters nonstationarity is the case most commonly encountered in reinforcement learning. even if the underlying task is stationary and deterministic the learner faces a set of banditlike decision tasks each of which changes over time as learning proceeds and the agent s decision-making policy changes. reinforcement learning requires a balance between exploration and exploitation. exercise bandit example consider a k-armed bandit problem with k actions denoted and consider applying to this problem a bandit algorithm using action selection sample-average action-value estimates and initial estimates of for all a. suppose the initial sequence of actions and rewards is on some of these time steps the case may have occurred causing an action to be selected at random. on which time steps did this definitely occur? on which time steps could this possibly have occurred? exercise in the comparison shown in figure which method will perform best in the long run in terms of cumulative reward and probability of selecting the best action? how much better will it be? express your answer quantitatively. incremental implementation the action-value methods we have discussed so far all estimate action values as sample averages of observed rewards. we now turn to the question of how these averages can be computed in a computationally efficient manner in particular with constant memory and constant per-time-step computation. incremental implementation to simplify notation we concentrate on a single action. let ri now denote the reward received after the ith selection of this action and let qn denote the estimate of its action value after it has been selected n times which we can now write simply as qn rn n the obvious implementation would be to maintain a record of all the rewards and then perform this computation whenever the estimated value was needed. however if this is done then the memory and computational requirements would grow over time as more rewards are seen. each additional reward would require additional memory to store it and additional computation to compute the sum in the numerator. as you might suspect this is not really necessary. it is easy to devise incremental formulas for updating averages with small constant computation required to process each new reward. given qn and the nth reward rn the new average of all n rewards can be computed by ri n n nqn n n qn which holds even for n obtaining for arbitrary this implementation requires memory only for qn and n and only the small computation for each new reward. this update rule is of a form that occurs frequently throughout this book. the general form is newestimate oldestimate the is an error in the estimate. it is reduced by taking a step toward the target. the target is presumed to indicate a desirable direction in which to move though it may be noisy. in the case above for example the target is the nth reward. note that the step-size parameter used in the incremental method in processing the nth reward for action a the changes from time step to time step. chapter multi-armed bandits method uses the step-size parameter by or more generally by ta. n in this book we denote the step-size parameter pseudocode for a complete bandit algorithm using incrementally computed sample averages and action selection is shown in the box below. the function bandita is assumed to take an action and return a corresponding reward. a simple bandit algorithm initialize for a to k qa n loop forever a arg maxa qa r bandita n n qa qa n a random action with probability with probability ties randomly tracking a nonstationary problem the averaging methods discussed so far are appropriate for stationary bandit problems that is for bandit problems in which the reward probabilities do not change over time. as noted earlier we often encounter reinforcement learning problems that are effectively nonstationary. in such cases it makes sense to give more weight to recent rewards than to long-past rewards. one of the most popular ways of doing this is to use a constant step-size parameter. for example the incremental update rule for updating an average qn of the n past rewards is modified to be where the step-size parameter is constant. this results in being a weighted average of past rewards and the initial estimate qn qn rn rn rn rn rn rn rn rn iri. optimistic initial values we call this a weighted average because the sum of the weights is i as you can check for yourself. note that the weight i given to the reward ri depends on how many rewards ago n i it was observed. the quantity is less than and thus the weight given to ri decreases as the number of intervening rewards increases. in fact the weight decays exponentially according to the exponent on then all the weight goes on the very last reward rn because of the convention that accordingly this is sometimes called an exponential recency-weighted average. sometimes it is convenient to vary the step-size parameter from step to step. let na denote the step-size parameter used to process the reward received after the nth selection of action a. as we have noted the choice na n results in the sampleaverage method which is guaranteed to converge to the true action values by the law of large numbers. but of course convergence is not guaranteed for all choices of the sequence na. a well-known result in stochastic approximation theory gives us the conditions required to assure convergence with probability na and na the first condition is required to guarantee that the steps are large enough to eventually overcome any initial conditions or random fluctuations. the second condition guarantees that eventually the steps become small enough to assure convergence. note that both convergence conditions are met for the sample-average case na n but not for the case of constant step-size parameter na in the latter case the second condition is not met indicating that the estimates never completely converge but continue to vary in response to the most recently received rewards. as we mentioned above this is actually desirable in a nonstationary environment and problems that are effectively nonstationary are the most common in reinforcement learning. in addition sequences of step-size parameters that meet the conditions often converge very slowly or need considerable tuning in order to obtain a satisfactory convergence rate. although sequences of step-size parameters that meet these convergence conditions are often used in theoretical work they are seldom used in applications and empirical research. exercise if the step-size parameters n are not constant then the estimate qn is a weighted average of previously received rewards with a weighting different from that given by what is the weighting on each prior reward for the general case analogous to in terms of the sequence of step-size parameters? exercise design and conduct an experiment to demonstrate the difficulties that sample-average methods have for nonstationary problems. use a modified version of the testbed in which all the q start out equal and then take independent random walks by adding a normally distributed increment with mean zero and standard deviation to all the q on each step. prepare plots like figure for an action-value method using sample averages incrementally computed and another action-value method using a constant step-size parameter use and longer runs say of steps. chapter multi-armed bandits optimistic initial values all the methods we have discussed so far are dependent to some extent on the initial action-value estimates in the language of statistics these methods are biased by their initial estimates. for the sample-average methods the bias disappears once all actions have been selected at least once but for methods with constant the bias is permanent though decreasing over time as given by in practice this kind of bias is usually not a problem and can sometimes be very helpful. the downside is that the initial estimates become in effect a set of parameters that must be picked by the user if only to set them all to zero. the upside is that they provide an easy way to supply some prior knowledge about what level of rewards can be expected. initial action values can also be used as a simple way to encourage exploration. suppose that instead of setting the initial action values to zero as we did in the testbed we set them all to recall that the q in this problem are selected from a normal distribution with mean and variance an initial estimate of is thus wildly optimistic. but this optimism encourages action-value methods to explore. whichever actions are initially selected the reward is less than the starting estimates the learner switches to other actions being disappointed with the rewards it is receiving. the result is that all actions are tried several times before the value estimates converge. the system does a fair amount of exploration even if greedy actions are selected all the time. figure shows the performance on the bandit testbed of a greedy method using for all a. for comparison also shown is an method with initially the optimistic method performs worse because it explores more but eventually it performs better because its exploration decreases with time. we call this technique for encouraging exploration optimistic initial values. we regard it as a simple trick that can be quite effective on stationary problems but it is far from being a generally useful approach to encouraging exploration. for example it is not well suited to nonstationary problems because its drive for exploration is inherently figure the effect of optimistic initial action-value estimates on the testbed. both methods used a constant step-size parameter upper-confidence-bound action selection temporary. if the task changes creating a renewed need for exploration this method cannot help. indeed any method that focuses on the initial conditions in any special way is unlikely to help with the general nonstationary case. the beginning of time occurs only once and thus we should not focus on it too much. this criticism applies as well to the sample-average methods which also treat the beginning of time as a special event averaging all subsequent rewards with equal weights. nevertheless all of these methods are very simple and one of them or some simple combination of them is often adequate in practice. in the rest of this book we make frequent use of several of these simple exploration techniques. exercise mysterious spikes the results shown in figure should be quite reliable because they are averages over individual randomly chosen bandit tasks. why then are there oscillations and spikes in the early part of the curve for the optimistic method? in other words what might make this method perform particularly better or worse on average on particular early steps? exercise unbiased constant-step-size trick in most of this chapter we have used sample averages to estimate action values because sample averages do not produce the initial bias that constant step sizes do the analysis in however sample averages are not a completely satisfactory solution because they may perform poorly on nonstationary problems. is it possible to avoid the bias of constant step sizes while retaining their advantages on nonstationary problems? one way is to use a step size of ot t where is a conventional constant step size and ot is a trace of one that starts at ot ot for t with carry out an analysis like that in to show that t is an exponential recency-weighted average without initial bias. upper-confidence-bound action selection exploration is needed because there is always uncertainty about the accuracy of the action-value estimates. the greedy actions are those that look best at present but some of the other actions may actually be better. action selection forces the non-greedy actions to be tried but indiscriminately with no preference for those that are nearly greedy or particularly uncertain. it would be better to select among the non-greedy actions according to their potential for actually being optimal taking into account both how close their estimates are to being maximal and the uncertainties in those estimates. one effective way of doing this is to select actions according to at argmax a ln t chapter multi-armed bandits where ln t denotes the natural logarithm of t number that e would have to be raised to in order to equal t nta denotes the number of times that action a has been selected prior to time t denominator in and the number c controls the degree of exploration. if nta then a is considered to be a maximizing action. the idea of this upper confidence bound action selection is that the square-root term is a measure of the uncertainty or variance in the estimate of a s value. the quantity being max ed over is thus a sort of upper bound on the possible true value of action a with c determining the confidence level. each time a is selected the uncertainty is presumably reduced nta increments and as it appears in the denominator the uncertainty term decreases. on the other hand each time an action other than a is selected t increases but nta does not because t appears in the numerator the uncertainty estimate increases. the use of the natural logarithm means that the increases get smaller over time but are unbounded all actions will eventually be selected but actions with lower value estimates or that have already been selected frequently will be selected with decreasing frequency over time. results with ucb on the testbed are shown in figure ucb often performs well as shown here but is more difficult than to extend beyond bandits to the more general reinforcement learning settings considered in the rest of this book. one difficulty is in dealing with nonstationary problems methods more complex than those presented in section would be needed. another difficulty is dealing with large state spaces particularly when using function approximation as developed in part ii of this book. in these more advanced settings the idea of ucb action selection is usually not practical. exercise ucb spikes in figure the ucb algorithm shows a distinct spike in performance on the step. why is this? note that for your answer to be fully satisfactory it must explain both why the reward increases on the step and why it figure average performance of ucb action selection on the testbed. as shown ucb generally performs better than action selection except in the first k steps when it selects randomly among the as-yet-untried actions. c gradient bandit algorithms decreases on the subsequent steps. hint if c then the spike is less prominent. gradient bandit algorithms so far in this chapter we have considered methods that estimate action values and use those estimates to select actions. this is often a good approach but it is not the only one possible. in this section we consider learning a numerical preference for each action a which we denote hta. the larger the preference the more often that action is taken but the preference has no interpretation in terms of reward. only the relative preference of one action over another is important if we add to all the action preferences there is no effect on the action probabilities which are determined according to a soft-max distribution gibbs or boltzmann distribution as follows prat a ehta ehtb ta where here we have also introduced a useful new notation ta for the probability of taking action a at time t. initially all action preferences are the same for all a so that all actions have an equal probability of being selected. exercise show that in the case of two actions the soft-max distribution is the same as that given by the logistic or sigmoid function often used in statistics and artificial neural networks. there is a natural learning algorithm for this setting based on the idea of stochastic gradient ascent. on each step after selecting action at and receiving the reward rt the action preferences are updated by htat hta ta and for all a at where is a step-size parameter and rt r is the average of all the rewards up through and including time t which can be computed incrementally as described in section section if the problem is nonstationary. the rt term serves as a baseline with which the reward is compared. if the reward is higher than the baseline then the probability of taking at in the future is increased and if the reward is below baseline then probability is decreased. the non-selected actions move in the opposite direction. figure shows results with the gradient bandit algorithm on a variant of the testbed in which the true expected rewards were selected according to a normal distribution with a mean of instead of zero with unit variance as before. this shifting up of all the rewards has absolutely no effect on the gradient bandit algorithm because of the reward baseline term which instantaneously adapts to the new level. but if the baseline were omitted is if rt was taken to be constant zero in then performance would be significantly degraded as shown in the figure. chapter multi-armed bandits figure average performance of the gradient bandit algorithm with and without a reward baseline on the testbed when the q are chosen to be near rather than near zero. the bandit gradient algorithm as stochastic gradient ascent one can gain a deeper insight into the gradient bandit algorithm by understanding it as a stochastic approximation to gradient ascent. in exact gradient ascent each action preference hta would be incremented proportional to the increment s effect on performance hta e hta where the measure of performance here is the expected reward ert txq and the measure of the increment s effect is the partial derivative of this performance measure with respect to the action preference. of course it is not possible to implement gradient ascent exactly in our case because by assumption we do not know the q but in fact the updates of our algorithm are equal to in expected value making the algorithm an instance of stochastic gradient ascent. the calculations showing this require only beginning calculus but take baselinewith gradient bandit algorithms several steps. first we take a closer look at the exact performance gradient ert hta txq tx tx hta q hta where bt called the baseline can be any scalar that does not depend on x. we can include a baseline here without changing the equality because the gradient sums tx hta as hta is changed some actions probabilities go up and some go down but the sum of the changes must be zero because the sum of the probabilities is always one. to zero over all the actions next we multiply each term of the sum by tx tx ert hta tx hta tx. the equation is now in the form of an expectation summing over all possible values x of the random variable at then multiplying by the probability of taking those values. thus tat tat hta hta where here we have chosen the baseline bt rt and substituted rt for q which is permitted because ertat q shortly we will establish that hta where is defined to be if a x else assuming that for now we have tx recall that our plan has been to write the performance gradient as an expectation of something that we can sample on each step as we have just done and then update on each step proportional to the sample. substituting a sample of the expectation above for the performance gradient in yields hta for all a which you may recognize as being equivalent to our original algorithm chapter multi-armed bandits thus it remains only to show that tx recall the standard quotient rule for derivatives hta as we assumed. f f x gx f gx x using this we can write tx hta tx hta ehtx ehtx ehty ehtx hta ehty tx tx ta ehtxehta ehty ehtxehta ehty hta the quotient rule ex x ex q.e.d. we have just shown that the expected update of the gradient bandit algorithm is equal to the gradient of expected reward and thus that the algorithm is an instance of stochastic gradient ascent. this assures us that the algorithm has robust convergence properties. note that we did not require any properties of the reward baseline other than that it does not depend on the selected action. for example we could have set it to zero or to and the algorithm would still be an instance of stochastic gradient ascent. the choice of the baseline does not affect the expected update of the algorithm but it does affect the variance of the update and thus the rate of convergence shown e.g. in figure choosing it as the average of the rewards may not be the very best but it is simple and works well in practice. summary associative search bandits so far in this chapter we have considered only nonassociative tasks that is tasks in which there is no need to associate different actions with different situations. in these tasks the learner either tries to find a single best action when the task is stationary or tries to track the best action as it changes over time when the task is nonstationary. however in a general reinforcement learning task there is more than one situation and the goal is to learn a policy a mapping from situations to the actions that are best in those situations. to set the stage for the full problem we briefly discuss the simplest way in which nonassociative tasks extend to the associative setting. as an example suppose there are several different k-armed bandit tasks and that on each step you confront one of these chosen at random. thus the bandit task changes randomly from step to step. this would appear to you as a single nonstationary k-armed bandit task whose true action values change randomly from step to step. you could try using one of the methods described in this chapter that can handle nonstationarity but unless the true action values change slowly these methods will not work very well. now suppose however that when a bandit task is selected for you you are given some distinctive clue about its identity not its action values. maybe you are facing an actual slot machine that changes the color of its display as it changes its action values. now you can learn a policy associating each task signaled by the color you see with the best action to take when facing that task for instance if red select arm if green select arm with the right policy you can usually do much better than you could in the absence of any information distinguishing one bandit task from another. this is an example of an associative search task so called because it involves both trial-and-error learning to search for the best actions and association of these actions with the situations in which they are best. associative search tasks are often now called contextual bandits in the literature. associative search tasks are intermediate between the k-armed bandit problem and the full reinforcement learning problem. they are like the full reinforcement learning problem in that they involve learning a policy but like our version of the k-armed bandit problem in that each action affects only the immediate reward. if actions are allowed to affect the next situation as well as the reward then we have the full reinforcement learning problem. we present this problem in the next chapter and consider its ramifications throughout the rest of the book. exercise suppose you face a bandit task whose true action values change randomly from time step to time step. specifically suppose that for any time step the true values of actions and are respectively and with probability a and and with probability b. if you are not able to tell which case you face at any step what is the best expectation of success you can achieve and how should you behave to achieve it? now suppose that on each step you are told whether you are facing case a or case b you still don t know the true action values. this is an associative search task. what is the best expectation of success you can achieve in this task and how should you behave to achieve it? chapter multi-armed bandits summary we have presented in this chapter several simple ways of balancing exploration and exploitation. the methods choose randomly a small fraction of the time whereas ucb methods choose deterministically but achieve exploration by subtly favoring at each step the actions that have so far received fewer samples. gradient bandit algorithms estimate not action values but action preferences and favor the more preferred actions in a graded probabilistic manner using a soft-max distribution. the simple expedient of initializing estimates optimistically causes even greedy methods to explore significantly. it is natural to ask which of these methods is best. although this is a difficult question to answer in general we can certainly run them all on the testbed that we have used throughout this chapter and compare their performances. a complication is that they all have a parameter to get a meaningful comparison we have to consider their performance as a function of their parameter. our graphs so far have shown the course of learning over time for each algorithm and parameter setting to produce a learning curve for that algorithm and parameter setting. if we plotted learning curves for all algorithms and all parameter settings then the graph would be too complex and crowded to make clear comparisons. instead we summarize a complete learning curve by its average value over the steps this value is proportional to the area under the learning curve. figure shows this measure for the various bandit algorithms from this chapter each as a function of its own parameter shown on a single scale on the x-axis. this kind of graph is called a parameter study. note that the parameter values are varied by factors of two and presented on a log scale. note also the characteristic inverted-u shapes of each algorithm s performance all the algorithms perform best at an intermediate value of their parameter neither too large nor too small. in assessing figure a parameter study of the various bandit algorithms presented in this chapter. each point is the average reward obtained over steps with a particular algorithm at a particular setting of its parameter. averagerewardover first withoptimisticinitialization summary a method we should attend not just to how well it does at its best parameter setting but also to how sensitive it is to its parameter value. all of these algorithms are fairly insensitive performing well over a range of parameter values varying by about an order of magnitude. overall on this problem ucb seems to perform best. despite their simplicity in our opinion the methods presented in this chapter can fairly be considered the state of the art. there are more sophisticated methods but their complexity and assumptions make them impractical for the full reinforcement learning problem that is our real focus. starting in chapter we present learning methods for solving the full reinforcement learning problem that use in part the simple methods explored in this chapter. although the simple methods explored in this chapter may be the best we can do at present they are far from a fully satisfactory solution to the problem of balancing exploration and exploitation. one well-studied approach to balancing exploration and exploitation in k-armed bandit problems is to compute special functions called gittins indices. these provide an optimal solution to a certain kind of bandit problem more general than that considered here but this approach assumes that the prior distribution of possible problems is known. unfortunately neither the theory nor the computational tractability of this method appear to generalize to the full reinforcement learning problem that we consider in the rest of the book. bayesian methods assume a known initial distribution over the action values and then update the distribution exactly after each step that the true action values are stationary. in general the update computations can be very complex but for certain special distributions conjugate priors they are easy. one possibility is to then select actions at each step according to their posterior probability of being the best action. this method sometimes called posterior sampling or thompson sampling often performs similarly to the best of the distribution-free methods we have presented in this chapter. in the bayesian setting it is even conceivable to compute the optimal balance between exploration and exploitation. one can compute for any possible action the probability of each possible immediate reward and the resultant posterior distributions over action values. this evolving distribution becomes the information state of the problem. given a horizon say of steps one can consider all possible actions all possible resulting rewards all possible next actions all next rewards and so on for all steps. given the assumptions the rewards and probabilities of each possible chain of events can be determined and one need only pick the best. but the tree of possibilities grows extremely rapidly even if there were only two actions and two rewards the tree would have leaves. it is generally not feasible to perform this immense computation exactly but perhaps it could be approximated efficiently. this approach would effectively turn the bandit problem into an instance of the full reinforcement learning problem. in the end we may be able to use approximate reinforcement learning methods such as those presented in part ii of this book to approach this optimal solution. but that is a topic for research and beyond the scope of this introductory book. exercise make a figure analogous to figure for the nonstationary chapter multi-armed bandits case outlined in exercise include the constant-step-size algorithm with use runs of steps and as a performance measure for each algorithm and parameter setting use the average reward over the last steps. bibliographical and historical remarks bandit problems have been studied in statistics engineering and psychology. in statistics bandit problems fall under the heading sequential design of experiments introduced by thompson and robbins and studied by bellman berry and fristedt provide an extensive treatment of bandit problems from the perspective of statistics. narendra and thathachar treat bandit problems from the engineering perspective providing a good discussion of the various theoretical traditions that have focused on them. in psychology bandit problems have played roles in statistical learning theory bush and mosteller estes the term greedy is often used in the heuristic search literature pearl the conflict between exploration and exploitation is known in control engineering as the conflict between identification estimation and control witten feldbaum called it the dual control problem referring to the need to solve the two problems of identification and control simultaneously when trying to control a system under uncertainty. in discussing aspects of genetic algorithms holland emphasized the importance of this conflict referring to it as the conflict between the need to exploit and the need for new information. action-value methods for our k-armed bandit problem were first proposed by thathachar and sastry these are often called estimator algorithms in the learning automata literature. the term action value is due to watkins the first to use methods may also have been watkins p. but the idea is so simple that some earlier use seems likely. this material falls under the general heading of stochastic iterative algorithms which is well covered by bertsekas and tsitsiklis optimistic initialization was used in reinforcement learning by sutton early work on using estimates of the upper confidence bound to select actions was done by lai and robbins kaelbling and agrawal the ucb algorithm we present here is called in the literature and was first developed by auer cesa-bianchi and fischer gradient bandit algorithms are a special case of the gradient-based reinforcement learning algorithms introduced by williams and that later developed into the actor critic and policy-gradient algorithms that we treat later in this book. our development here was influenced by that by balaraman ravindran communication. further discussion of the choice of baseline is provided there summary and by greensmith bartlett and baxter and dick early systematic studies of algorithms like this were done by sutton the term soft-max for the action selection rule is due to bridle this rule appears to have been first proposed by luce the term associative search and the corresponding problem were introduced by barto sutton and brouwer the term associative reinforcement learning has also been used for associative search and anandan but we prefer to reserve that term as a synonym for the full reinforcement learning problem in sutton as we noted the modern literature also uses the term contextual bandits for this problem. we note that thorndike s law of effect in chapter describes associative search by referring to the formation of associative links between situations and actions. according to the terminology of operant or instrumental conditioning skinner a discriminative stimulus is a stimulus that signals the presence of a particular reinforcement contingency. in our terms different discriminative stimuli correspond to different states. bellman was the first to show how dynamic programming could be used to compute the optimal balance between exploration and exploitation within a bayesian formulation of the problem. the gittins index approach is due to gittins and jones duff showed how it is possible to learn gittins indices for bandit problems through reinforcement learning. the survey by kumar provides a good discussion of bayesian and non-bayesian approaches to these problems. the term information state comes from the literature on partially observable mdps see e.g. lovejoy other theoretical research focuses on the efficiency of exploration usually expressed as how quickly an algorithm can approach an optimal decision-making policy. one way to formalize exploration efficiency is by adapting to reinforcement learning the notion of sample complexity for a supervised learning algorithm which is the number of training examples the algorithm needs to attain a desired degree of accuracy in learning the target function. a definition of the sample complexity of exploration for a reinforcement learning algorithm is the number of time steps in which the algorithm does not select near-optimal actions li discusses this and several other approaches in a survey of theoretical approaches to exploration efficiency in reinforcement learning. chapter finite markov decision processes in this chapter we introduce the formal problem of finite markov decision processes or finite mdps which we try to solve in the rest of the book. this problem involves evaluative feedback as in bandits but also an associative aspect choosing different actions in different situations. mdps are a classical formalization of sequential decision making where actions influence not just immediate rewards but also subsequent situations or states and through those future rewards. thus mdps involve delayed reward and the need to tradeoff immediate and delayed reward. whereas in bandit problems we estimated the value q of each action a in mdps we estimate the value q a of each action a in each state s or we estimate the value v of each state given optimal action selections. these state-dependent quantities are essential to accurately assigning credit for long-term consequences to individual action selections. mdps are a mathematically idealized form of the reinforcement learning problem for which precise theoretical statements can be made. we introduce key elements of the problem s mathematical structure such as returns value functions and bellman equations. we try to convey the wide range of applications that can be formulated as finite mdps. as in all of artificial intelligence there is a tension between breadth of applicability and mathematical tractability. in this chapter we introduce this tension and discuss some of the trade-offs and challenges that it implies. some ways in which reinforcement learning can be taken beyond mdps are treated in chapter the agent environment interface mdps are meant to be a straightforward framing of the problem of learning from interaction to achieve a goal. the learner and decision maker is called the agent. the thing it interacts with comprising everything outside the agent is called the environment. these interact continually the agent selecting actions and the environment responding to these chapter finite markov decision processes actions and presenting new situations to the the environment also gives rise to rewards special numerical values that the agent seeks to maximize over time through its choice of actions. figure the agent environment interaction in a markov decision process. more specifically the agent and environment interact at each of a sequence of discrete time steps t at each time step t the agent receives some representation of the environment s state st s and on that basis selects an action at one time step later in part as a consequence of its action the agent receives a numerical reward r r and finds itself in a new state the mdp and agent together thereby give rise to a sequence or trajectory that begins like this in a finite mdp the sets of states actions and rewards a and r all have a finite number of elements. in this case the random variables rt and st have well defined discrete probability distributions dependent only on the preceding state and action. that is for particular values of these random variables s and r r there is a probability of those values occurring at time t given particular values of the preceding state and action rs a prst rt r st s at a for all s s r r and a as. the function p defines the dynamics of the mdp. the dot over the equals sign in the equation reminds us that it is a definition this case of the function p rather than a fact that follows from previous definitions. the dynamics function p s r s a is an ordinary deterministic function of four arguments. the in the middle of it comes from the notation for conditional use the terms agent environment and action instead of the engineers terms controller con trolled system plant and control signal because they are meaningful to a wider audience. restrict attention to discrete time to keep things as simple as possible even though many of the ideas can be extended to the continuous-time case see bertsekas and tsitsiklis doya simplify notation we sometimes assume the special case in which the action set is the same in all states and write it simply as a. use instead of rt to denote the reward due to at because it emphasizes that the next reward and next state and are jointly determined. unfortunately both conventions are widely used in the literature. the agent environment interface probability but here it just reminds us that p specifies a probability distribution for each choice of s and a that is that r rs a for all s s a as. in a markov decision process the probabilities given by p completely characterize the environment s dynamics. that is the probability of each possible value for st and rt depends only on the immediately preceding state and action st and at and given them not at all on earlier states and actions. this is best viewed a restriction not on the decision process but on the state. the state must include information about all aspects of the past agent environment interaction that make a difference for the future. if it does then the state is said to have the markov property. we will assume the markov property throughout this book though starting in part ii we will consider approximation methods that do not rely on it and in chapter we consider how a markov state can be learned and constructed from non-markov observations. from the four-argument dynamics function p one can compute anything else one might want to know about the environment such as the state-transition probabilities we denote with a slight abuse of notation as a three-argument function p s s a a prst st s at a r rs a. we can also compute the expected rewards for state action pairs as a two-argument function r s a r rs a ert st s at a r s rs a and the expected rewards for state action next-state triples as a three-argument function r s a s r ert st s at a st r r rs a a rs a in this book we usually use the four-argument p function but each of these other notations are also occasionally convenient. the mdp framework is abstract and flexible and can be applied to many different problems in many different ways. for example the time steps need not refer to fixed intervals of real time they can refer to arbitrary successive stages of decision making and acting. the actions can be low-level controls such as the voltages applied to the motors of a robot arm or high-level decisions such as whether or not to have lunch or to go to graduate school. similarly the states can take a wide variety of forms. they can be completely determined by low-level sensations such as direct sensor readings or they can be more high-level and abstract such as symbolic descriptions of objects in a room. some of what makes up a state could be based on memory of past sensations or chapter finite markov decision processes even be entirely mental or subjective. for example an agent could be in the state of not being sure where an object is or of having just been surprised in some clearly defined sense. similarly some actions might be totally mental or computational. for example some actions might control what an agent chooses to think about or where it focuses its attention. in general actions can be any decisions we want to learn how to make and the states can be anything we can know that might be useful in making them. in particular the boundary between agent and environment is typically not the same as the physical boundary of robot s or animal s body. usually the boundary is drawn closer to the agent than that. for example the motors and mechanical linkages of a robot and its sensing hardware should usually be considered parts of the environment rather than parts of the agent. similarly if we apply the mdp framework to a person or animal the muscles skeleton and sensory organs should be considered part of the environment. rewards too presumably are computed inside the physical bodies of natural and artificial learning systems but are considered external to the agent. the general rule we follow is that anything that cannot be changed arbitrarily by the agent is considered to be outside of it and thus part of its environment. we do not assume that everything in the environment is unknown to the agent. for example the agent often knows quite a bit about how its rewards are computed as a function of its actions and the states in which they are taken. but we always consider the reward computation to be external to the agent because it defines the task facing the agent and thus must be beyond its ability to change arbitrarily. in fact in some cases the agent may know everything about how its environment works and still face a difficult reinforcement learning task just as we may know exactly how a puzzle like rubik s cube works but still be unable to solve it. the agent environment boundary represents the limit of the agent s absolute control not of its knowledge. the agent environment boundary can be located at different places for different purposes. in a complicated robot many different agents may be operating at once each with its own boundary. for example one agent may make high-level decisions which form part of the states faced by a lower-level agent that implements the high-level decisions. in practice the agent environment boundary is determined once one has selected particular states actions and rewards and thus has identified a specific decision making task of interest. the mdp framework is a considerable abstraction of the problem of goal-directed learning from interaction. it proposes that whatever the details of the sensory memory and control apparatus and whatever objective one is trying to achieve any problem of learning goal-directed behavior can be reduced to three signals passing back and forth between an agent and its environment one signal to represent the choices made by the agent actions one signal to represent the basis on which the choices are made states and one signal to define the agent s goal rewards. this framework may not be sufficient to represent all decision-learning problems usefully but it has proved to be widely useful and applicable. of course the particular states and actions vary greatly from task to task and how they are represented can strongly affect performance. in reinforcement learning as in other kinds of learning such representational choices are at present more art than science. the agent environment interface in this book we offer some advice and examples regarding good ways of representing states and actions but our primary focus is on general principles for learning how to behave once the representations have been selected. example bioreactor suppose reinforcement learning is being applied to determine moment-by-moment temperatures and stirring rates for a bioreactor large vat of nutrients and bacteria used to produce useful chemicals. the actions in such an application might be target temperatures and target stirring rates that are passed to lower-level control systems that in turn directly activate heating elements and motors to attain the targets. the states are likely to be thermocouple and other sensory readings perhaps filtered and delayed plus symbolic inputs representing the ingredients in the vat and the target chemical. the rewards might be moment-by-moment measures of the rate at which the useful chemical is produced by the bioreactor. notice that here each state is a list or vector of sensor readings and symbolic inputs and each action is a vector consisting of a target temperature and a stirring rate. it is typical of reinforcement learning tasks to have states and actions with such structured representations. rewards on the other hand are always single numbers. example pick-and-place robot consider using reinforcement learning to control the motion of a robot arm in a repetitive pick-and-place task. if we want to learn movements that are fast and smooth the learning agent will have to control the motors directly and have low-latency information about the current positions and velocities of the mechanical linkages. the actions in this case might be the voltages applied to each motor at each joint and the states might be the latest readings of joint angles and velocities. the reward might be for each object successfully picked up and placed. to encourage smooth movements on each time step a small negative reward can be given as a function of the moment-to-moment jerkiness of the motion. exercise devise three example tasks of your own that fit into the mdp framework identifying for each its states actions and rewards. make the three examples as different from each other as possible. the framework is abstract and flexible and can be applied in many different ways. stretch its limits in some way in at least one of your examples. exercise is the mdp framework adequate to usefully represent all goal-directed learning tasks? can you think of any clear exceptions? exercise consider the problem of driving. you could define the actions in terms of the accelerator steering wheel and brake that is where your body meets the machine. or you could define them farther out say where the rubber meets the road considering your actions to be tire torques. or you could define them farther in say where your brain meets your body the actions being muscle twitches to control your limbs. or you could go to a really high level and say that your actions are your choices of where to drive. what is the right level the right place to draw the line between agent and environment? on what basis is one location of the line to be preferred over another? is there any fundamental reason for preferring one location over another or is it a free choice? chapter finite markov decision processes example recycling robot a mobile robot has the job of collecting empty soda cans in an office environment. it has sensors for detecting cans and an arm and gripper that can pick them up and place them in an onboard bin it runs on a rechargeable battery. the robot s control system has components for interpreting sensory information for navigating and for controlling the arm and gripper. high-level decisions about how to search for cans are made by a reinforcement learning agent based on the current charge level of the battery. to make a simple example we assume that only two charge levels can be distinguished comprising a small state set s low. in each state the agent can decide whether to actively search for a can for a certain period of time remain stationary and wait for someone to bring it a can or head back to its home base to recharge its battery. when the energy level is high recharging would always be foolish so we do not include it in the action set for this state. the action sets are then ahigh wait and alow wait recharge. the rewards are zero most of the time but become positive when the robot secures an empty can or large and negative if the battery runs all the way down. the best way to find cans is to actively search for them but this runs down the robot s battery whereas waiting does not. whenever the robot is searching the possibility exists that its battery will become depleted. in this case the robot must shut down and wait to be rescued a low reward. if the energy level is high then a period of active search can always be completed without risk of depleting the battery. a period of searching that begins with a high energy level leaves the energy level high with probability and reduces it to low with probability on the other hand a period of searching undertaken when the energy level is low leaves it low with probability and depletes the battery with probability in the latter case the robot must be rescued and the battery is then recharged back to high. each can collected by the robot counts as a unit reward whereas a reward of results whenever the robot has to be rescued. let rsearch and rwait with rsearch rwait respectively denote the expected number of cans the robot will collect hence the expected reward while searching and while waiting. finally suppose that no cans can be collected during a run home for recharging and that no cans can be collected on a step in which the battery is depleted. this system is then a finite mdp and we can write down the transition probabilities and the expected rewards with dynamics as indicated in the table on the left s high high low low high high low low low low a search search search search wait wait wait wait recharge recharge high low high low high low high low high low a rs a rsearch rsearch rsearch rwait rwait rwait rwait note that there is a row in the table for each possible combination of current state s action a as and next state another useful way of summarizing the dynamics of a finite mdp is as a transition graph as shown above on the right. there are two kinds of goals and rewards nodes state nodes and action nodes. there is a state node for each possible state large open circle labeled by the name of the state and an action node for each state action pair small solid circle labeled by the name of the action and connected by a line to the state node. starting in state s and taking action a moves you along the line from state node s to action node a. then the environment responds with a transition to the next state s node via one of the arrows leaving action node a. each arrow corresponds to a triple a where is the next state and we label the arrow with the transition probability a and the expected reward for that transition rs a note that the transition probabilities labeling the arrows leaving an action node always sum to exercise give a table analogous to that in example but for rs a. it should have columns for s a r and rs a and a row for every for which rs a goals and rewards in reinforcement learning the purpose or goal of the agent is formalized in terms of a special signal called the reward passing from the environment to the agent. at each time step the reward is a simple number rt r. informally the agent s goal is to maximize the total amount of reward it receives. this means maximizing not immediate reward but cumulative reward in the long run. we can clearly state this informal idea as the reward hypothesis that all of what we mean by goals and purposes can be well thought of as the maximization of the expected value of the cumulative sum of a received scalar signal reward. the use of a reward signal to formalize the idea of a goal is one of the most distinctive features of reinforcement learning. although formulating goals in terms of reward signals might at first appear limiting in practice it has proved to be flexible and widely applicable. the best way to see this is to consider examples of how it has been or could be used. for example to make a robot learn to walk researchers have provided reward on each time step proportional to the robot s forward motion. in making a robot learn how to escape from a maze the reward is often for every time step that passes prior to escape this encourages the agent to escape as quickly as possible. to make a robot learn to find and collect empty soda cans for recycling one might give it a reward of zero most of the time and then a reward of for each can collected. one might also want to give the robot negative rewards when it bumps into things or when somebody yells at it. for an agent to learn to play checkers or chess the natural rewards are for winning for losing and for drawing and for all nonterminal positions. you can see what is happening in all of these examples. the agent always learns to maximize its reward. if we want it to do something for us we must provide rewards to it in such a way that in maximizing them the agent will also achieve our goals. it is thus critical that the rewards we set up truly indicate what we want accomplished. chapter finite markov decision processes in particular the reward signal is not the place to impart to the agent prior knowledge about how to achieve what we want it to for example a chess-playing agent should be rewarded only for actually winning not for achieving subgoals such as taking its opponent s pieces or gaining control of the center of the board. if achieving these sorts of subgoals were rewarded then the agent might find a way to achieve them without achieving the real goal. for example it might find a way to take the opponent s pieces even at the cost of losing the game. the reward signal is your way of communicating to the robot what you want it to achieve not how you want it returns and episodes so far we have discussed the objective of learning informally. we have said that the agent s goal is to maximize the cumulative reward it receives in the long run. how might this be defined formally? if the sequence of rewards received after time step t is denoted then what precise aspect of this sequence do we wish to maximize? in general we seek to maximize the expected return where the return denoted gt is defined as some specific function of the reward sequence. in the simplest case the return is the sum of the rewards gt rt where t is a final time step. this approach makes sense in applications in which there is a natural notion of final time step that is when the agent environment interaction breaks naturally into subsequences which we call such as plays of a game trips through a maze or any sort of repeated interaction. each episode ends in a special state called the terminal state followed by a reset to a standard starting state or to a sample from a standard distribution of starting states. even if you think of episodes as ending in different ways such as winning and losing a game the next episode begins independently of how the previous one ended. thus the episodes can all be considered to end in the same terminal state with different rewards for the different outcomes. tasks with episodes of this kind are called episodic tasks. in episodic tasks we sometimes need to distinguish the set of all nonterminal states denoted s from the set of all states plus the terminal state denoted s. the time of termination t is a random variable that normally varies from episode to episode. on the other hand in many cases the agent environment interaction does not break naturally into identifiable episodes but goes on continually without limit. for example this would be the natural way to formulate an on-going process-control task or an application to a robot with a long life span. we call these continuing tasks. the return formulation is problematic for continuing tasks because the final time step would be t and the return which is what we are trying to maximize could itself easily places for imparting this kind of prior knowledge are the initial policy or initial value function or in influences on these. delves further into the issue of designing effective reward signals. are sometimes called trials in the literature. returns and episodes be infinite. example suppose the agent receives a reward of at each time step. thus in this book we usually use a definition of return that is slightly more complex conceptually but much simpler mathematically. the additional concept that we need is that of discounting. according to this approach the agent tries to select actions so that the sum of the discounted rewards it receives over the future is maximized. in particular it chooses at to maximize the expected discounted return gt where is a parameter called the discount rate. the discount rate determines the present value of future rewards a reward received k time steps in the future is worth only k times what it would be worth if it were received immediately. if the infinite sum in has a finite value as long as the reward sequence is bounded. if the agent is myopic in being concerned its objective in this case is to learn how to only with maximizing immediate rewards choose at so as to maximize only if each of the agent s actions happened to influence only the immediate reward not future rewards as well then a myopic agent could maximize by separately maximizing each immediate reward. but in general acting to maximize immediate reward can reduce access to future rewards so that the return is reduced. as approaches the return objective takes future rewards into account more strongly the agent becomes more farsighted. returns at successive time steps are related to each other in a way that is important for the theory and algorithms of reinforcement learning gt note that this works for all time steps t t even if termination occurs at t if we define gt this often makes it easy to compute returns from reward sequences. note that although the return is a sum of an infinite number of terms it is still finite if the reward is nonzero and constant if for example if the reward is a constant then the return is gt k exercise the equations in section are for the continuing case and need to be modified slightly to apply to episodic tasks. show that you know the modifications needed by giving the modified version of chapter finite markov decision processes example pole-balancing the objective in this task is to apply forces to a cart moving along a track so as to keep a pole hinged to the cart from falling over a failure is said to occur if the pole falls past a given angle from vertical or if the cart runs off the track. the pole is reset to vertical after each failure. this task could be treated as episodic where the natural episodes are the repeated attempts to balance the pole. the reward in this case could be for every time step on which failure did not occur so that the return at each time would be the number of steps until failure. in this case successful balancing forever would mean a return of infinity. alternatively we could treat pole-balancing as a continuing task using discounting. in this case the reward would be on each failure and zero at all other times. the return at each time would then be related to k where k is the number of time steps before failure. in either case the return is maximized by keeping the pole balanced for as long as possible. exercise suppose you treated pole-balancing as an episodic task but also used discounting with all rewards zero except for upon failure. what then would the return be at each time? how does this return differ from that in the discounted continuing formulation of this task? exercise imagine that you are designing a robot to run a maze. you decide to give it a reward of for escaping from the maze and a reward of zero at all other times. the task seems to break down naturally into episodes the successive runs through the maze so you decide to treat it as an episodic task where the goal is to maximize expected total reward after running the learning agent for a while you find that it is showing no improvement in escaping from the maze. what is going wrong? have you effectively communicated to the agent what you want it to achieve? exercise suppose and the following sequence of rewards is received and with t what are hint work backwards. exercise suppose and the reward sequence is followed by an infinite sequence of what are and exercise prove unified notation for episodic and continuing tasks unified notation for episodic and continuing tasks in the preceding section we described two kinds of reinforcement learning tasks one in which the agent environment interaction naturally breaks down into a sequence of separate episodes tasks and one in which it does not tasks. the former case is mathematically easier because each action affects only the finite number of rewards subsequently received during the episode. in this book we consider sometimes one kind of problem and sometimes the other but often both. it is therefore useful to establish one notation that enables us to talk precisely about both cases simultaneously. to be precise about episodic tasks requires some additional notation. rather than one long sequence of time steps we need to consider a series of episodes each of which consists of a finite sequence of time steps. we number the time steps of each episode starting anew from zero. therefore we have to refer not just to st the state representation at time t but to sti the state representation at time t of episode i similarly for ati rti ti ti etc.. however it turns out that when we discuss episodic tasks we almost never have to distinguish between different episodes. we are almost always considering a particular single episode or stating something that is true for all episodes. accordingly in practice we almost always abuse notation slightly by dropping the explicit reference to episode number. that is we write st to refer to sti and so on. we need one other convention to obtain a single notation that covers both episodic and continuing tasks. we have defined the return as a sum over a finite number of terms in one case and as a sum over an infinite number of terms in the other these can be unified by considering episode termination to be the entering of a special absorbing state that transitions only to itself and that generates only rewards of zero. for example consider the state transition diagram here the solid square represents the special absorbing state corresponding to the end of an episode. starting from we get the reward sequence summing these we get the same return whether we sum over the first t rewards t or over the full infinite sequence. this remains true even if we introduce discounting. thus we can define the return in general according to using the convention of omitting episode numbers when they are not needed and including the possibility that if the sum remains defined because all episodes terminate. alternatively we can also write the return as gt k t including the possibility that t or not both. we use these conventions throughout the rest of the book to simplify notation and to express the close parallels between episodic and continuing tasks. in chapter we will introduce a chapter finite markov decision processes formulation that is both continuing and undiscounted. policies and value functions almost all reinforcement learning algorithms involve estimating value functions functions of states of state action pairs that estimate how good it is for the agent to be in a given state how good it is to perform a given action in a given state. the notion of how good here is defined in terms of future rewards that can be expected or to be precise in terms of expected return. of course the rewards the agent can expect to receive in the future depend on what actions it will take. accordingly value functions are defined with respect to particular ways of acting called policies. formally a policy is a mapping from states to probabilities of selecting each possible action. if the agent is following policy at time t then is the probability that at a if st s. like p is an ordinary function the in the middle of merely reminds that it defines a probability distribution over a as for each s s. reinforcement learning methods specify how the agent s policy is changed as a result of its experience. exercise if the current state is st and actions are selected according to stochastic policy then what is the expectation of in terms of and the four-argument function p the value function of a state s under a policy denoted v is the expected return when starting in s and following thereafter. for mdps we can define v formally by v e st s e st for all s s where e denotes the expected value of a random variable given that the agent follows policy and t is any time step. note that the value of the terminal state if any is always zero. we call the function v the state-value function for policy similarly we define the value of taking action a in state s under a policy denoted q a as the expected return starting from s taking the action a and thereafter following policy q a e st s at a e we call q the action-value function for policy st s at the value functions v and q can be estimated from experience. for example if an agent follows policy and maintains an average for each state encountered of the actual returns that have followed that state then the average will converge to the state s value v as the number of times that state is encountered approaches infinity. if separate averages are kept for each action taken in each state then these averages will similarly converge to the action values q a. we call estimation methods of this kind monte carlo methods because they involve averaging over many random samples of unified notation for episodic and continuing tasks actual returns. these kinds of methods are presented in chapter of course if there are very many states then it may not be practical to keep separate averages for each state individually. instead the agent would have to maintain v and q as parameterized functions fewer parameters than states and adjust the parameters to better match the observed returns. this can also produce accurate estimates although much depends on the nature of the parameterized function approximator. these possibilities are discussed in part ii of the book. a fundamental property of value functions used throughout reinforcement learning and dynamic programming is that they satisfy recursive relationships similar to that which we have already established for the return for any policy and any state s the following consistency condition holds between the value of s and the value of its possible successor states v e st s e st s rs e rs v for all s s where it is implicit that the actions a are taken from the set as that the next states are taken from the set s from s in the case of an episodic problem and that the rewards r are taken from the set r. note also how in the last equation we have merged the two sums one over all the values of and the other over all the values of r into one sum over all the possible values of both. we use this kind of merged sum often to simplify formulas. note how the final expression can be read easily as an expected value. it is really a sum over all values of the three variables a and r. for each triple we compute its probability rs a weight the quantity in brackets by that probability then sum over all possibilities to get an expected value. equation is the bellman equation for v it expresses a relationship between the value of a state and the values of its successor states. think of looking ahead from a state to its possible successor states as suggested by the diagram to the right. each open circle represents a state and each solid circle represents a state action pair. starting from state s the root node at the top the agent could take any of some set of actions three are shown in the diagram based on its policy from each of these the environment could respond with one of several next states are shown in the figure along with a reward r depending on its dynamics given by the function p. the bellman equation averages over all the possibilities weighting each by its probability of occurring. it states that the value of the start state must equal the value of the expected next state plus the reward expected along the way. backup diagram for v the value function v is the unique solution to its bellman equation. we show in rpa chapter finite markov decision processes subsequent chapters how this bellman equation forms the basis of a number of ways to compute approximate and learn v we call diagrams like that above backup diagrams because they diagram relationships that form the basis of the update or backup operations that are at the heart of reinforcement learning methods. these operations transfer value information back to a state a state action pair from its successor states state action pairs. we use backup diagrams throughout the book to provide graphical summaries of the algorithms we discuss. that unlike transition graphs the state nodes of backup diagrams do not necessarily represent distinct states for example a state might be its own successor. example gridworld figure shows a rectangular gridworld representation of a simple finite mdp. the cells of the grid correspond to the states of the environment. at each cell four actions are possible north south east and west which deterministically cause the agent to move one cell in the respective direction on the grid. actions that would take the agent off the grid leave its location unchanged but also result in a reward of other actions result in a reward of except those that move the agent out of the special states a and b. from state a all four actions yield a reward of and take the agent to from state b all actions yield a reward of and take the agent to figure gridworld example exceptional reward dynamics and state-value function for the equiprobable random policy suppose the agent selects all four actions with equal probability in all states. figure shows the value function v for this policy for the discounted reward case with this value function was computed by solving the system of linear equations notice the negative values near the lower edge these are the result of the high probability of hitting the edge of the grid there under the random policy. state a is the best state to be in under this policy but its expected return is less than its immediate reward because from a the agent is taken to from which it is likely to run into the edge of the grid. state b on the other hand is valued more than its immediate reward because from b the agent is taken to which has a positive value. from the expected penalty reward for possibly running into an edge is more than compensated for by the expected gain for possibly stumbling onto a or b. exercise the bellman equation must hold for each state for the value function v shown in figure of example show numerically that this equation holds for the center state valued at with respect to its four neighboring states valued at and numbers are accurate only to one decimal place. andbq unified notation for episodic and continuing tasks exercise what is the bellman equation for action values that is for q it must give the action value q a in terms of the action values q of possible successors to the state action pair a. hint the backup diagram to the right corresponds to this equation. show the sequence of equations analogous to but for action values. example golf to formulate playing a hole of golf as a reinforcement learning task we count a penalty reward of for each stroke until we hit the ball into the hole. the state is the location of the ball. the value of a state is the negative of the number of strokes to the hole from that location. our actions are how we aim and swing at the ball of course and which club we select. let us take the former as given and consider just the choice of club which we assume is either a putter or a driver. the upper part of figure shows a possible state-value function vputts for the policy that always uses the putter. the terminal state in-the-hole has a value of from anywhere on the green we assume we can make a putt these states have value off the green we cannot reach the hole by putting and the value is greater. if we can reach the green from a state by putting then that state must have value one less than the green s value that is for simplicity let us assume we can putt very precisely and deterministically but with a limited range. this gives us the sharp contour line labeled in the figure all locations between that line and the green require exactly two strokes to complete the hole. similarly any location within putting range of the contour line must have a value of and so on to get all the contour lines shown in the figure. putting doesn t get us out of sand traps so they have a value of overall it takes us six strokes to get from the tee to the hole by putting. figure a golf example the state-value function for putting and the optimal action-value function for using the driver exercise in the gridworld example rewards are positive for goals negative for running into the edge of the world and zero the rest of the time. are the signs of these rewards important or only the intervals between them? prove using that adding a constant c to all the rewards adds a constant vc to the values of all states and thus does not affect the relative values of any states under any policies. what is vc in terms pq chapter finite markov decision processes of c and exercise now consider adding a constant c to all the rewards in an episodic task such as maze running. would this have any effect or would it leave the task unchanged as in the continuing task above? why or why not? give an example. exercise the value of a state depends on the values of the actions possible in that state and on how likely each action is to be taken under the current policy. we can think of this in terms of a small backup diagram rooted at the state and considering each possible action give the equation corresponding to this intuition and diagram for the value at the root node v in terms of the value at the expected leaf node q a given st s. this equation should include an expectation conditioned on following the policy then give a second equation in which the expected value is written out explicitly in terms of such that no expected value notation appears in the equation. exercise the value of an action q a depends on the expected next reward and the expected sum of the remaining rewards. again we can think of this in terms of a small backup diagram this one rooted at an action action pair and branching to the possible next states give the equation corresponding to this intuition and diagram for the action value q a in terms of the expected next reward and the expected next state value v given that st s and at a. this equation should include an expectation but not one conditioned on following the policy. then give a second equation writing out the expected value explicitly in terms of rs a defined by such that no expected value notation appears in the equation. optimal policies and optimal value functions solving a reinforcement learning task means roughly finding a policy that achieves a lot of reward over the long run. for finite mdps we can precisely define an optimal policy in the following way. value functions define a partial ordering over policies. a policy is defined to be better than or equal to a policy if its expected return is greater than or equal to that of for all states. in other words if and only if v v for all s s. there is always at least one policy that is better than or equal to all other policies. this is an optimal policy. although there may be more than one we denote all the optimal policies by they share the same state-value function called the optimal stakenwithprobability optimal policies and optimal value functions state-value function denoted v and defined as max v v for all s s. defined as optimal policies also share the same optimal action-value function denoted q and q a max q a for all s s and a as. for the state action pair a this function gives the expected return for taking action a in state s and thereafter following an optimal policy. thus we can write q in terms of v as follows q a v st s at a example optimal value functions for golf the lower part of figure shows the contours of a possible optimal action-value function q driver. these are the values of each state if we first play a stroke with the driver and afterward select either the driver or the putter whichever is better. the driver enables us to hit the ball farther but with less accuracy. we can reach the hole in one shot using the driver only if we are already very close thus the contour for q driver covers only a small portion of the green. if we have two strokes however then we can reach the hole from much farther away as shown by the contour. in this case we don t have to drive all the way to within the small contour but only to anywhere on the green from there we can use the putter. the optimal action-value function gives the values after committing to a particular first action in this case to the driver but afterward using whichever actions are best. the contour is still farther out and includes the starting tee. from the tee the best sequence of actions is two drives and one putt sinking the ball in three strokes. because v is the value function for a policy it must satisfy the self-consistency condition given by the bellman equation for state values because it is the optimal value function however v s consistency condition can be written in a special form without reference to any specific policy. this is the bellman equation for v or the bellman optimality equation. intuitively the bellman optimality equation expresses the fact that the value of a state under an optimal policy must equal the expected return for the best action from that state v max a as max a a a q e st s at a e st s at a v st s at a a rs v a max max max chapter finite markov decision processes the last two equations are two forms of the bellman optimality equation for v the bellman optimality equation for q is q a max q st s at q rs max the backup diagrams in figure show graphically the spans of future states and actions considered in the bellman optimality equations for v and q these are the same as the backup diagrams for v and q presented earlier except that arcs have been added at the agent s choice points to represent that the maximum over that choice is taken rather than the expected value given some policy. the backup diagram on the left graphically represents the bellman optimality equation and the backup diagram on the right graphically represents figure backup diagrams for v and q for finite mdps the bellman optimality equation for v has a unique solution independent of the policy. the bellman optimality equation is actually a system of equations one for each state so if there are n states then there are n equations in n unknowns. if the dynamics p of the environment are known then in principle one can solve this system of equations for v using any one of a variety of methods for solving systems of nonlinear equations. one can solve a related set of equations for q once one has v it is relatively easy to determine an optimal policy. for each state s there will be one or more actions at which the maximum is obtained in the bellman optimality equation. any policy that assigns nonzero probability only to these actions is an optimal policy. you can think of this as a one-step search. if you have the optimal value function v then the actions that appear best after a one-step search will be optimal actions. another way of saying this is that any policy that is greedy with respect to the optimal evaluation function v is an optimal policy. the term greedy is used in computer science to describe any search or decision procedure that selects alternatives based only on local or immediate considerations without considering the possibility that such a selection may prevent future access to even better alternatives. consequently it describes policies that select actions based only on their short-term consequences. the beauty of v is that if one uses it to evaluate the short-term consequences of actions specifically the one-step consequences then a greedy policy is actually optimal in the long-term sense in which we are interested because v already takes into account the reward consequences of all possible future behavior. by means of v the optimal expected optimal policies and optimal value functions long-term return is turned into a quantity that is locally and immediately available for each state. hence a one-step-ahead search yields the long-term optimal actions. having q makes choosing optimal actions even easier. with q the agent does not even have to do a one-step-ahead search for any state s it can simply find any action that maximizes q a. the action-value function effectively caches the results of all one-step-ahead searches. it provides the optimal expected long-term return as a value that is locally and immediately available for each state action pair. hence at the cost of representing a function of state action pairs instead of just of states the optimal actionvalue function allows optimal actions to be selected without having to know anything about possible successor states and their values that is without having to know anything about the environment s dynamics. example solving the gridworld suppose we solve the bellman equation for v for the simple grid task introduced in example and shown again in figure recall that state a is followed by a reward of and transition to state while state b is followed by a reward of and transition to state figure shows the optimal value function and figure shows the corresponding optimal policies. where there are multiple arrows in a cell all of the corresponding actions are optimal. figure optimal solutions to the gridworld example. example bellman optimality equations for the recycling robot using we can explicitly give the bellman optimality equation for the recycling robot example. to make things more compact we abbreviate the states high and low and the actions search wait and recharge respectively by h l s w and re. because there are only two states the bellman optimality equation consists of two equations. the equation for v can be written as follows v phh srh s h v plh srh s l v phh wrh w h v plh wrh w l v v v rs v v v rw v a gridworldb vc v max rs v rw v v chapter finite markov decision processes following the same procedure for v yields the equation for any choice of rs rw and with there is exactly one pair of numbers v and v that simultaneously satisfy these two nonlinear equations. explicitly solving the bellman optimality equation provides one route to finding an optimal policy and thus to solving the reinforcement learning problem. however this solution is rarely directly useful. it is akin to an exhaustive search looking ahead at all possibilities computing their probabilities of occurrence and their desirabilities in terms of expected rewards. this solution relies on at least three assumptions that are rarely true in practice we accurately know the dynamics of the environment we have enough computational resources to complete the computation of the solution and the markov property. for the kinds of tasks in which we are interested one is generally not able to implement this solution exactly because various combinations of these assumptions are violated. for example although the first and third assumptions present no problems for the game of backgammon the second is a major impediment. because the game has about states it would take thousands of years on today s fastest computers to solve the bellman equation for v and the same is true for finding q in reinforcement learning one typically has to settle for approximate solutions. many different decision-making methods can be viewed as ways of approximately solving the bellman optimality equation. for example heuristic search methods can be viewed as expanding the right-hand side of several times up to some depth forming a tree of possibilities and then using a heuristic evaluation function to approximate v at the leaf nodes. search methods such as a are almost always based on the episodic case. the methods of dynamic programming can be related even more closely to the bellman optimality equation. many reinforcement learning methods can be clearly understood as approximately solving the bellman optimality equation using actual experienced transitions in place of knowledge of the expected transitions. we consider a variety of such methods in the following chapters. exercise draw or describe the optimal state-value function for the golf example. exercise draw or describe the contours of the optimal action-value function for putting q putter for the golf example. exercise consider the continuing mdp shown on to the right. the only decision to be made is that in the top state where two actions are available left and right. the numbers show the rewards that are received deterministically after each action. there are exactly two deterministic policies left and right. what policy is optimal if if if optimality and approximation exercise give the bellman equation for q for the recycling robot. exercise figure gives the optimal value of the best state of the gridworld as to one decimal place. use your knowledge of the optimal policy and to express this value symbolically and then to compute it to three decimal places. exercise give an equation for v in terms of q exercise give an equation for q in terms of v and the world s dynamics rs a. exercise give an equation for in terms of q exercise give an equation for in terms of v and the world s dynamics rs a. optimality and approximation we have defined optimal value functions and optimal policies. clearly an agent that learns an optimal policy has done very well but in practice this rarely happens. for the kinds of tasks in which we are interested optimal policies can be generated only with extreme computational cost. a well-defined notion of optimality organizes the approach to learning we describe in this book and provides a way to understand the theoretical properties of various learning algorithms but it is an ideal that agents can only approximate to varying degrees. as we discussed above even if we have a complete and accurate model of the environment s dynamics it is usually not possible to simply compute an optimal policy by solving the bellman optimality equation. for example board games such as chess are a tiny fraction of human experience yet large customdesigned computers still cannot compute the optimal moves. a critical aspect of the problem facing the agent is always the computational power available to it in particular the amount of computation it can perform in a single time step. the memory available is also an important constraint. a large amount of memory is often required to build up approximations of value functions policies and models. in tasks with small finite state sets it is possible to form these approximations using arrays or tables with one entry for each state state action pair. this we call the tabular case and the corresponding methods we call tabular methods. in many cases of practical interest however there are far more states than could possibly be entries in a table. in these cases the functions must be approximated using some sort of more compact parameterized function representation. our framing of the reinforcement learning problem forces us to settle for approximations. however it also presents us with some unique opportunities for achieving useful approximations. for example in approximating optimal behavior there may be many states that the agent faces with such a low probability that selecting suboptimal actions for them has little impact on the amount of reward the agent receives. tesauro s backgammon player for example plays with exceptional skill even though it might make very bad decisions on board configurations that never occur in games against experts. in fact it is possible that td-gammon makes bad decisions for a large fraction of the chapter finite markov decision processes game s state set. the online nature of reinforcement learning makes it possible to approximate optimal policies in ways that put more effort into learning to make good decisions for frequently encountered states at the expense of less effort for infrequently encountered states. this is one key property that distinguishes reinforcement learning from other approaches to approximately solving mdps. summary let us summarize the elements of the reinforcement learning problem that we have presented in this chapter. reinforcement learning is about learning from interaction how to behave in order to achieve a goal. the reinforcement learning agent and its environment interact over a sequence of discrete time steps. the specification of their interface defines a particular task the actions are the choices made by the agent the states are the basis for making the choices and the rewards are the basis for evaluating the choices. everything inside the agent is completely known and controllable by the agent everything outside is incompletely controllable but may or may not be completely known. a policy is a stochastic rule by which the agent selects actions as a function of states. the agent s objective is to maximize the amount of reward it receives over time. when the reinforcement learning setup described above is formulated with well defined transition probabilities it constitutes a markov decision process a finite mdp is an mdp with finite state action and we formulate it here reward sets. much of the current theory of reinforcement learning is restricted to finite mdps but the methods and ideas apply more generally. the return is the function of future rewards that the agent seeks to maximize expected value. it has several different definitions depending upon the nature of the task and whether one wishes to discount delayed reward. the undiscounted formulation is appropriate for episodic tasks in which the agent environment interaction breaks naturally into episodes the discounted formulation is appropriate for continuing tasks in which the interaction does not naturally break into episodes but continues without limit. we try to define the returns for the two kinds of tasks such that one set of equations can apply to both the episodic and continuing cases. a policy s value functions assign to each state or state action pair the expected return from that state or state action pair given that the agent uses the policy. the optimal value functions assign to each state or state action pair the largest expected return achievable by any policy. a policy whose value functions are optimal is an optimal policy. whereas the optimal value functions for states and state action pairs are unique for a given mdp there can be many optimal policies. any policy that is greedy with respect to the optimal value functions must be an optimal policy. the bellman optimality equations are special consistency conditions that the optimal value functions must satisfy and that can in principle be solved for the optimal value functions from which an optimal policy can be determined with relative ease. a reinforcement learning problem can be posed in a variety of different ways depending on assumptions about the level of knowledge initially available to the agent. in problems of complete knowledge the agent has a complete and accurate model of the environment s summary dynamics. if the environment is an mdp then such a model consists of the complete fourargument dynamics function p in problems of incomplete knowledge a complete and perfect model of the environment is not available. even if the agent has a complete and accurate environment model the agent is typically unable to perform enough computation per time step to fully use it. the memory available is also an important constraint. memory may be required to build up accurate approximations of value functions policies and models. in most cases of practical interest there are far more states than could possibly be entries in a table and approximations must be made. a well-defined notion of optimality organizes the approach to learning we describe in this book and provides a way to understand the theoretical properties of various learning algorithms but it is an ideal that reinforcement learning agents can only approximate to varying degrees. in reinforcement learning we are very much concerned with cases in which optimal solutions cannot be found but must be approximated in some way. bibliographical and historical remarks the reinforcement learning problem is deeply indebted to the idea of markov decision processes from the field of optimal control. these historical influences and other major influences from psychology are described in the brief history given in chapter reinforcement learning adds to mdps a focus on approximation and incomplete information for realistically large problems. mdps and the reinforcement learning problem are only weakly linked to traditional learning and decision-making problems in artificial intelligence. however artificial intelligence is now vigorously exploring mdp formulations for planning and decision making from a variety of perspectives. mdps are more general than previous formulations used in artificial intelligence in that they permit more general kinds of goals and uncertainty. the theory of mdps is treated by e.g. bertsekas white whittle and puterman a particularly compact treatment of the finite case is given by ross mdps are also studied under the heading of stochastic optimal control where adaptive optimal control methods are most closely related to reinforcement learning kumar kumar and varaiya the theory of mdps evolved from efforts to understand the problem of making sequences of decisions under uncertainty where each decision can depend on the previous decisions and their outcomes. it is sometimes called the theory of multistage decision processes or sequential decision processes and has roots in the statistical literature on sequential sampling beginning with the papers by thompson and robbins that we cited in chapter in connection with bandit problems are prototypical mdps if formulated as multiple-situation problems. the earliest instance of which we are aware in which reinforcement learning was discussed using the mdp formalism is andreae s description of a unified view of learning machines. witten and corbin experimented with a reinforcement learning system later analyzed by witten using the mdp formalism. although he did not explicitly mention mdps werbos suggested approximate solution methods chapter finite markov decision processes for stochastic optimal control problems that are related to modern reinforcement learning methods also werbos although werbos s ideas were not widely recognized at the time they were prescient in emphasizing the importance of approximately solving optimal control problems in a variety of domains including artificial intelligence. the most influential integration of reinforcement learning and mdps is due to watkins our characterization of the dynamics of an mdp in terms of rs a is it is more common in the mdp literature to describe the slightly unusual. dynamics in terms of the state transition probabilities a and expected next rewards rs a. in reinforcement learning however we more often have to refer to individual actual or sample rewards than just their expected values. our notation also makes it plainer that st and rt are in general jointly determined and thus must have the same time index. in teaching reinforcement learning we have found our notation to be more straightforward conceptually and easier to understand. for a good intuitive discussion of the system-theoretic concept of state see minsky the bioreactor example is based on the work of ungar and miller and williams the recycling robot example was inspired by the can-collecting robot built by jonathan connell kober and peters present a collection of robotics applications of reinforcement learning. the reward hypothesis was suggested by michael littman communication. the terminology of episodic and continuing tasks is different from that usually used in the mdp literature. in that literature it is common to distinguish three types of tasks finite-horizon tasks in which interaction terminates after a particular fixed number of time steps indefinite-horizon tasks in which interaction can last arbitrarily long but must eventually terminate and infinite-horizon tasks in which interaction does not terminate. our episodic and continuing tasks are similar to indefinite-horizon and infinite-horizon tasks respectively but we prefer to emphasize the difference in the nature of the interaction. this difference seems more fundamental than the difference in the objective functions emphasized by the usual terms. often episodic tasks use an indefinite-horizon objective function and continuing tasks an infinite-horizon objective function but we see this as a common coincidence rather than a fundamental difference. the pole-balancing example is from michie and chambers and barto sutton and anderson assigning value on the basis of what is good or bad in the long run has ancient roots. in control theory mapping states to numerical values representing the long-term consequences of control decisions is a key part of optimal control summary theory which was developed in the by extending nineteenth century statefunction theories of classical mechanics e.g. schultz and melsa in describing how a computer could be programmed to play chess shannon suggested using an evaluation function that took into account the long-term advantages and disadvantages of chess positions. watkins s q-learning algorithm for estimating q made actionvalue functions an important part of reinforcement learning and consequently these functions are often called q-functions. but the idea of an action-value function is much older than this. shannon suggested that a function hp m could be used by a chess-playing program to decide whether a move m in position p is worth exploring. michie s menace system and michie and chambers s boxes system can be understood as estimating action-value functions. in classical physics hamilton s principal function is an action-value function newtonian dynamics are greedy with respect to this function goldstein action-value functions also played a central role in denardo s theoretical treatment of dynamic programming in terms of contraction mappings. the bellman optimality equation v was popularized by richard bellman who called it the basic functional equation. the counterpart of the bellman optimality equation for continuous time and state problems is known as the hamilton jacobi bellman equation often just the hamilton jacobi equation indicating its roots in classical physics schultz and melsa the golf example was suggested by chris watkins. chapter dynamic programming the term dynamic programming refers to a collection of algorithms that can be used to compute optimal policies given a perfect model of the environment as a markov decision process classical dp algorithms are of limited utility in reinforcement learning both because of their assumption of a perfect model and because of their great computational expense but they are still important theoretically. dp provides an essential foundation for the understanding of the methods presented in the rest of this book. in fact all of these methods can be viewed as attempts to achieve much the same effect as dp only with less computation and without assuming a perfect model of the environment. starting with this chapter we usually assume that the environment is a finite mdp. that is we assume that its state action and reward sets s a and r are finite and that its dynamics are given by a set of probabilities rs a for all s s a as r r and s is s plus a terminal state if the problem is episodic. although dp ideas can be applied to problems with continuous state and action spaces exact solutions are possible only in special cases. a common way of obtaining approximate solutions for tasks with continuous states and actions is to quantize the state and action spaces and then apply finite-state dp methods. the methods we explore in chapter are applicable to continuous problems and are a significant extension of that approach. the key idea of dp and of reinforcement learning generally is the use of value functions to organize and structure the search for good policies. in this chapter we show how dp can be used to compute the value functions defined in chapter as discussed there we can easily obtain optimal policies once we have found the optimal value functions v or q which satisfy the bellman optimality equations v max max a v st s at a rs v a or chapter dynamic programming q a max q st s at q rs max for all s s a as and s. as we shall see dp algorithms are obtained by turning bellman equations such as these into assignments that is into update rules for improving approximations of the desired value functions. policy evaluation first we consider how to compute the state-value function v for an arbitrary policy this is called policy evaluation in the dp literature. we also refer to it as the prediction problem. recall from chapter that for all s s v e st s e st s e v st s rs v where is the probability of taking action a in state s under policy and the expectations are subscripted by to indicate that they are conditional on being followed. the existence and uniqueness of v are guaranteed as long as either or eventual termination is guaranteed from all states under the policy if the environment s dynamics are completely known then is a system of simultaneous linear equations in unknowns v s s. in principle its solution is a straightforward if tedious computation. for our purposes iterative solution methods are most suitable. consider a sequence of approximate value functions each mapping s to r real numbers. the initial approximation is chosen arbitrarily that the terminal state if any must be given value and each successive approximation is obtained by using the bellman equation for v as an update rule e st s rs for all s s. clearly vk v is a fixed point for this update rule because the bellman equation for v assures us of equality in this case. indeed the sequence can be shown in general to converge to v as k under the same conditions that guarantee the existence of v this algorithm is called iterative policy evaluation. to produce each successive approximation from vk iterative policy evaluation applies the same operation to each state s it replaces the old value of s with a new value policy evaluation obtained from the old values of the successor states of s and the expected immediate rewards along all the one-step transitions possible under the policy being evaluated. we call this kind of operation an expected update. each iteration of iterative policy evaluation updates the value of every state once to produce the new approximate value function there are several different kinds of expected updates depending on whether a state here or a state action pair is being updated and depending on the precise way the estimated values of the successor states are combined. all the updates done in dp algorithms are called expected updates because they are based on an expectation over all possible next states rather than on a sample next state. the nature of an update can be expressed in an equation as above or in a backup diagram like those introduced in chapter for example the backup diagram corresponding to the expected update used in iterative policy evaluation is shown on page to write a sequential computer program to implement iterative policy evaluation as given by you would have to use two arrays one for the old values vks and one for the new values with two arrays the new values can be computed one by one from the old values without the old values being changed. of course it is easier to use one array and update the values in place that is with each new value immediately overwriting the old one. then depending on the order in which the states are updated sometimes new values are used instead of old ones on the right-hand side of this in-place algorithm also converges to v in fact it usually converges faster than the two-array version as you might expect because it uses new data as soon as they are available. we think of the updates as being done in a sweep through the state space. for the in-place algorithm the order in which states have their values updated during the sweep has a significant influence on the rate of convergence. we usually have the in-place version in mind when we think of dp algorithms. a complete in-place version of iterative policy evaluation is shown in pseudocode in the box below. note how it handles termination. formally iterative policy evaluation converges only in the limit but in practice it must be halted short of this. the pseudocode tests the quantity maxs s vks after each sweep and stops when it is sufficiently small. iterative policy evaluation for estimating v v input the policy to be evaluated algorithm parameter a small threshold determining accuracy of estimation initialize v for all s s arbitrarily except that v loop loop for each s s until v v max v v rs v chapter dynamic programming example consider the gridworld shown below. the nonterminal states are s there are four actions possible in each state a down right left which deterministically cause the corresponding state transitions except that actions that would take the agent off the grid in fact leave the state unchanged. thus for instance right right and right for all r r. this is an undiscounted episodic task. the reward is on all transitions until the terminal state is reached. the terminal state is shaded in the figure it is shown in two places it is formally one state. the expected reward function is thus rs a for all states s and actions a. suppose the agent follows the equiprobable random policy actions equally likely. the left side of figure shows the sequence of value functions computed by iterative policy evaluation. the final estimate is in fact v which in this case gives for each state the negation of the expected number of steps from that state until termination. exercise in example if is the equiprobable random policy what is q down? what is q down? exercise in example suppose a new state is added to the gridworld just below state and its actions left up right and down take the agent to states and respectively. assume that the transitions from the original states are unchanged. what then is v for the equiprobable random policy? now suppose the dynamics of state are also changed such that action down from state takes the agent to the new state what is v for the equiprobable random policy in this case? exercise what are the equations analogous to and for the actionvalue function q and its successive approximation by a sequence of functions policy improvement our reason for computing the value function for a policy is to help find better policies. suppose we have determined the value function v for an arbitrary deterministic policy for some state s we would like to know whether or not we should change the policy to deterministically choose an action a we know how good it is to follow the current policy from s that is v but would it be better or worse to change to the new policy? one way to answer this question is to consider selecting a in s and thereafter actionsr all policy improvement figure convergence of iterative policy evaluation on a small gridworld. the left column is the sequence of approximations of the state-value function for the random policy actions equal. the right column is the sequence of greedy policies corresponding to the value function estimates are shown for all actions achieving the maximum. the last policy is guaranteed only to be an improvement over the random policy but in this case it and all policies after the third iteration are optimal. for therandom policygreedy policyw.r.t. vkk policyrandom policy for therandom policyvkgreedy policy w.r.t.vk chapter dynamic programming following the existing policy the value of this way of behaving is q a v st s at a rs v the key criterion is whether this is greater than or less than v if it is greater that is if it is better to select a once in s and thereafter follow than it would be to follow all the time then one would expect it to be better still to select a every time s is encountered and that the new policy would in fact be a better one overall. that this is true is a special case of a general result called the policy improvement theorem. let and be any pair of deterministic policies such that for all s s q v then the policy must be as good as or better than that is it must obtain greater or equal expected return from all states s s v v moreover if there is strict inequality of at any state then there must be strict inequality of at at least one state. this result applies in particular to the two policies that we considered in the previous paragraph an original deterministic policy and a changed policy that is identical to except that a obviously holds at all states other than s. thus if q a v then the changed policy is indeed better than the idea behind the proof of the policy improvement theorem is easy to understand. starting from we keep expanding the q side with and reapplying until we get v v q v st s at e v st s e q st s e e v st s e st e st e st v so far we have seen how given a policy and its value function we can easily evaluate a change in the policy at a single state to a particular action. it is a natural extension policy improvement to consider changes at all states and to all possible actions selecting at each state the action that appears best according to q a. in other words to consider the new greedy policy given by argmax a argmax argmax q a v st s at a rs v a a where argmaxa denotes the value of a at which the expression that follows is maximized ties broken arbitrarily. the greedy policy takes the action that looks best in the short term after one step of lookahead according to v by construction the greedy policy meets the conditions of the policy improvement theorem so we know that it is as good as or better than the original policy. the process of making a new policy that improves on an original policy by making it greedy with respect to the value function of the original policy is called policy improvement. suppose the new greedy policy is as good as but not better than the old policy then v v and from it follows that for all s s v max max a v st s at a rs v a but this is the same as the bellman optimality equation and therefore v must be v and both and must be optimal policies. policy improvement thus must give us a strictly better policy except when the original policy is already optimal. so far in this section we have considered the special case of deterministic policies. in the general case a stochastic policy specifies probabilities for taking each action a in each state s. we will not go through the details but in fact all the ideas of this section extend easily to stochastic policies. in particular the policy improvement theorem carries through as stated for the stochastic case. in addition if there are ties in policy improvement steps such as that is if there are several actions at which the maximum is achieved then in the stochastic case we need not select a single action from among them. instead each maximizing action can be given a portion of the probability of being selected in the new greedy policy. any apportioning scheme is allowed as long as all submaximal actions are given zero probability. the last row of figure shows an example of policy improvement for stochastic policies. here the original policy is the equiprobable random policy and the new policy is greedy with respect to v the value function v is shown in the bottomleft diagram and the set of possible is shown in the bottom-right diagram. the states with multiple arrows in the diagram are those in which several actions achieve the maximum in any apportionment of probability among these actions is permitted. the value function of any such policy v can be seen by inspection to be either or at all states s s whereas v is at most thus v v for all chapter dynamic programming s s illustrating policy improvement. although in this case the new policy happens to be optimal in general only an improvement is guaranteed. policy iteration once a policy has been improved using v to yield a better policy we can then compute v and improve it again to yield an even better we can thus obtain a sequence of monotonically improving policies and value functions i i e v e v e v e e denotes a policy evaluation and i i denotes a policy improvement. each where policy is guaranteed to be a strict improvement over the previous one it is already optimal. because a finite mdp has only a finite number of policies this process must converge to an optimal policy and optimal value function in a finite number of iterations. this way of finding an optimal policy is called policy iteration. a complete algorithm is given in the box below. note that each policy evaluation itself an iterative computation is started with the value function for the previous policy. this typically results in a great increase in the speed of convergence of policy evaluation because the value function changes little from one policy to the next. policy iteration iterative policy evaluation for estimating initialization v r and as arbitrarily for all s s policy evaluation loop loop for each s s v v max v v rs v until small positive number determining the accuracy of estimation policy improvement policy-stable true for each s s old-action if old-action then policy-stable f alse rs v if policy-stable then stop and return v v and else go to policy iteration policy iteration often converges in surprisingly few iterations. this is illustrated by the example in figure the bottom-left diagram shows the value function for the equiprobable random policy and the bottom-right diagram shows a greedy policy for this value function. the policy improvement theorem assures us that these policies are better than the original random policy. in this case however these policies are not just better but optimal proceeding to the terminal states in the minimum number of steps. in this example policy iteration would find the optimal policy after just one iteration. exercise the policy iteration algorithm on the previous page has a subtle bug in that it may never terminate if the policy continually switches between two or more policies that are equally good. this is ok for pedagogy but not for actual use. modify the pseudocode so that convergence is guaranteed. exercise how would policy iteration be defined for action values? give a complete algorithm for computing q analogous to that on page for computing v please pay special attention to this exercise because the ideas involved will be used throughout the rest of the book. exercise suppose you are restricted to considering only policies that are meaning that the probability of selecting each action in each state s is at least describe qualitatively the changes that would be required in each of the steps and in that order of the policy iteration algorithm for v example jack s car rental jack manages two locations for a nationwide car rental company. each day some number of customers arrive at each location to rent cars. if jack has a car available he rents it out and is credited by the national company. if he is out of cars at that location then the business is lost. cars become available for renting the day after they are returned. to help ensure that cars are available where they are needed jack can move them between the two locations overnight at a cost of per car moved. we assume that the number of cars requested and returned at each location are poisson random variables meaning that the probability that the number is n is n n! e where is the expected number. suppose is and for rental requests at the first and second locations and and for returns. to simplify the problem slightly we assume that there can be no more than cars at each location additional cars are returned to the nationwide company and thus disappear from the problem and a maximum of five cars can be moved from one location to the other in one night. we take the discount rate to be and formulate this as a continuing finite mdp where the time steps are days the state is the number of cars at each location at the end of the day and the actions are the net numbers of cars moved between the two locations overnight. figure shows the sequence of policies found by policy iteration starting from the policy that never moves any cars. exercise write a program for policy iteration and re-solve jack s car rental problem with the following changes. one of jack s employees at the first location rides a bus home each night and lives near the second location. she is happy to shuttle one car to the second location for free. each additional car still costs as do all cars moved in the other direction. in addition jack has limited parking space at each location. if more than cars are kept overnight at a location any moving of cars then an chapter dynamic programming figure the sequence of policies found by policy iteration on jack s car rental problem and the final state-value function. the first five diagrams show for each number of cars at each location at the end of the day the number of cars to be moved from the first location to the second numbers indicate transfers from the second location to the first. each successive policy is a strict improvement over the previous policy and the last policy is optimal. additional cost of must be incurred to use a second parking lot of how many cars are kept there. these sorts of nonlinearities and arbitrary dynamics often occur in real problems and cannot easily be handled by optimization methods other than dynamic programming. to check your program first replicate the results given for the original problem. if your computer is too slow for the full problem cut all the numbers of cars in half. value iteration one drawback to policy iteration is that each of its iterations involves policy evaluation which may itself be a protracted iterative computation requiring multiple sweeps through the state set. if policy evaluation is done iteratively then convergence exactly to v occurs only in the limit. must we wait for exact convergence or can we stop short of that? the example in figure certainly suggests that it may be possible to truncate policy evaluation. in that example policy evaluation iterations beyond the first three have no effect on the corresponding greedy policy. at second at first at second locationcars at first value iteration in fact the policy evaluation step of policy iteration can be truncated in several ways without losing the convergence guarantees of policy iteration. one important special case is when policy evaluation is stopped after just one sweep update of each state. this algorithm is called value iteration. it can be written as a particularly simple update operation that combines the policy improvement and truncated policy evaluation steps max max a st s at a rs a for all s s. for arbitrary the sequence can be shown to converge to v under the same conditions that guarantee the existence of v another way of understanding value iteration is by reference to the bellman optimality equation note that value iteration is obtained simply by turning the bellman optimality equation into an update rule. also note how the value iteration update is identical to the policy evaluation update except that it requires the maximum to be taken over all actions. another way of seeing this close relationship is to compare the backup diagrams for these algorithms on page evaluation and on the left of figure iteration. these two are the natural backup operations for computing v and v finally let us consider how value iteration terminates. like policy evaluation value iteration formally requires an infinite number of iterations to converge exactly to v in practice we stop once the value function changes by only a small amount in a sweep. the box below shows a complete algorithm with this kind of termination condition. value iteration for estimating algorithm parameter a small threshold determining accuracy of estimation initialize v for all s s arbitrarily except that v loop loop for each s s until output a deterministic policy such that v rs v rs v v v max v value iteration effectively combines in each of its sweeps one sweep of policy evaluation and one sweep of policy improvement. faster convergence is often achieved by interposing multiple policy evaluation sweeps between each policy improvement sweep. in general the entire class of truncated policy iteration algorithms can be thought of chapter dynamic programming as sequences of sweeps some of which use policy evaluation updates and some of which use value iteration updates. because the max operation in is the only difference between these updates this just means that the max operation is added to some sweeps of policy evaluation. all of these algorithms converge to an optimal policy for discounted finite mdps. example gambler s problem a gambler has the opportunity to make bets on the outcomes of a sequence of coin flips. if the coin comes up heads he wins as many dollars as he has staked on that flip if it is tails he loses his stake. the game ends when the gambler wins by reaching his goal of or loses by running out of money. on each flip the gambler must decide what portion of his capital to stake in integer numbers of dollars. this problem can be formulated as an undiscounted episodic finite mdp. the state is the gambler s capital s and the actions are stakes a mins s. the reward is zero on all transitions except those on which the gambler reaches his goal when it is the statevalue function then gives the probability of winning from each state. a policy is a mapping from levels of capital to stakes. the optimal policy maximizes the probability of reaching the goal. let ph denote the probability of the coin coming up heads. if ph is known then the entire problem is known and it can be solved for instance by value iteration. figure shows the change in the value function over successive sweeps of value iteration and the final policy found for the case of ph this policy is optimal but not unique. in fact there is a whole family of optimal policies all corresponding to ties for the argmax action selection with respect to the optimal value function. can you guess what the entire family looks like? figure the solution to the gambler s problem for ph the upper graph shows the value function found by successive sweeps of value iteration. the lower graph shows the final policy. exercise why does the optimal policy for the gambler s problem have such a curious form? in particular for capital of it bets it all on one flip but for capital of it does not. why is this a good policy? exercise implement value iteration for the gambler s problem and solve it for ph and ph in programming you may find it convenient valuefunction asynchronous dynamic programming to introduce two dummy states corresponding to termination with capital of and giving them values of and respectively. show your results graphically as in figure are your results stable as exercise what is the analog of the value iteration update for action values a? asynchronous dynamic programming a major drawback to the dp methods that we have discussed so far is that they involve operations over the entire state set of the mdp that is they require sweeps of the state set. if the state set is very large then even a single sweep can be prohibitively expensive. for example the game of backgammon has over states. even if we could perform the value iteration update on a million states per second it would take over a thousand years to complete a single sweep. asynchronous dp algorithms are in-place iterative dp algorithms that are not organized in terms of systematic sweeps of the state set. these algorithms update the values of states in any order whatsoever using whatever values of other states happen to be available. the values of some states may be updated several times before the values of others are updated once. to converge correctly however an asynchronous algorithm must continue to update the values of all the states it can t ignore any state after some point in the computation. asynchronous dp algorithms allow great flexibility in selecting states to update. for example one version of asynchronous value iteration updates the value in place of only one state sk on each step k using the value iteration update if asymptotic convergence to v is guaranteed given only that all states occur in the sequence an infinite number of times sequence could even be stochastic. the undiscounted episodic case it is possible that there are some orderings of updates that do not result in convergence but it is relatively easy to avoid these. similarly it is possible to intermix policy evaluation and value iteration updates to produce a kind of asynchronous truncated policy iteration. although the details of this and other more unusual dp algorithms are beyond the scope of this book it is clear that a few different updates form building blocks that can be used flexibly in a wide variety of sweepless dp algorithms. of course avoiding sweeps does not necessarily mean that we can get away with less computation. it just means that an algorithm does not need to get locked into any hopelessly long sweep before it can make progress improving a policy. we can try to take advantage of this flexibility by selecting the states to which we apply updates so as to improve the algorithm s rate of progress. we can try to order the updates to let value information propagate from state to state in an efficient way. some states may not need their values updated as often as others. we might even try to skip updating some states entirely if they are not relevant to optimal behavior. some ideas for doing this are discussed in chapter asynchronous algorithms also make it easier to intermix computation with real-time chapter dynamic programming interaction. to solve a given mdp we can run an iterative dp algorithm at the same time that an agent is actually experiencing the mdp. the agent s experience can be used to determine the states to which the dp algorithm applies its updates. at the same time the latest value and policy information from the dp algorithm can guide the agent s decision making. for example we can apply updates to states as the agent visits them. this makes it possible to focus the dp algorithm s updates onto parts of the state set that are most relevant to the agent. this kind of focusing is a repeated theme in reinforcement learning. generalized policy iteration policy iteration consists of two simultaneous interacting processes one making the value function consistent with the current policy evaluation and the other making the policy greedy with respect to the current value function improvement. in policy iteration these two processes alternate each completing before the other begins but this is not really necessary. in value iteration for example only a single iteration of policy evaluation is performed in between each policy improvement. in asynchronous dp methods the evaluation and improvement processes are interleaved at an even finer grain. in some cases a single state is updated in one process before returning to the other. as long as both processes continue to update all states the ultimate result is typically the same convergence to the optimal value function and an optimal policy. we use the term generalized policy iteration to refer to the general idea of letting policy evaluation and policy improvement processes interact independent of the granularity and other details of the two processes. almost all reinforcement learning methods are well described as gpi. that is all have identifiable policies and value functions with the policy always being improved with respect to the value function and the value function always being driven toward the value function for the policy as suggested by the diagram to the right. it is easy to see that if both the evaluation process and the improvement process stabilize that is no longer produce changes then the value function and policy must be optimal. the value function stabilizes only when it is consistent with the current policy and the policy stabilizes only when it is greedy with respect to the current value function. thus both processes stabilize only when a policy has been found that is greedy with respect to its own evaluation function. this implies that the bellman optimality equation holds and thus that the policy and the value function are optimal. the evaluation and improvement processes in gpi can be viewed as both competing and cooperating. they compete in the sense that they pull in opposing directions. making the policy greedy with respect to the value function typically makes the value function incorrect for the changed policy and making the value function consistent with the policy typically causes that policy no longer to be greedy. in the long run however evaluationimprovement greedyvv v v v efficiency of dynamic programming these two processes interact to find a single joint solution the optimal value function and an optimal policy. one might also think of the interaction between the evaluation and improvement processes in gpi in terms of two constraints or goals for example as two lines in two-dimensional space as suggested by the diagram to the right. although the real geometry is much more complicated than this the diagram suggests what happens in the real case. each process drives the value function or policy toward one of the lines representing a solution to one of the two goals. the goals interact because the two lines are not orthogonal. driving directly toward one goal causes some movement away from the other goal. inevitably however the joint process is brought closer to the overall goal of optimality. the arrows in this diagram correspond to the behavior of policy iteration in that each takes the system all the way to achieving one of the two goals completely. in gpi one could also take smaller incomplete steps toward each goal. in either case the two processes together achieve the overall goal of optimality even though neither is attempting to achieve it directly. efficiency of dynamic programming dp may not be practical for very large problems but compared with other methods for solving mdps dp methods are actually quite efficient. if we ignore a few technical details then the case time dp methods take to find an optimal policy is polynomial in the number of states and actions. if n and k denote the number of states and actions this means that a dp method takes a number of computational operations that is less than some polynomial function of n and k. a dp method is guaranteed to find an optimal policy in polynomial time even though the total number of policies is kn. in this sense dp is exponentially faster than any direct search in policy space could be because direct search would have to exhaustively examine each policy to provide the same guarantee. linear programming methods can also be used to solve mdps and in some cases their worst-case convergence guarantees are better than those of dp methods. but linear programming methods become impractical at a much smaller number of states than do dp methods a factor of about for the largest problems only dp methods are feasible. dp is sometimes thought to be of limited applicability because of the curse of dimensionality the fact that the number of states often grows exponentially with the number of state variables. large state sets do create difficulties but these are inherent difficulties of the problem not of dp as a solution method. in fact dp is comparatively better suited to handling large state spaces than competing methods such as direct search and linear programming. in practice dp methods can be used with today s computers to solve mdps with millions of states. both policy iteration and value iteration are widely used and it is not v vv chapter dynamic programming clear which if either is better in general. in practice these methods usually converge much faster than their theoretical worst-case run times particularly if they are started with good initial value functions or policies. on problems with large state spaces asynchronous dp methods are often preferred. to complete even one sweep of a synchronous method requires computation and memory for every state. for some problems even this much memory and computation is impractical yet the problem is still potentially solvable because relatively few states occur along optimal solution trajectories. asynchronous methods and other variations of gpi can be applied in such cases and may find good or optimal policies much faster than synchronous methods can. summary in this chapter we have become familiar with the basic ideas and algorithms of dynamic programming as they relate to solving finite mdps. policy evaluation refers to the iterative computation of the value functions for a given policy. policy improvement refers to the computation of an improved policy given the value function for that policy. putting these two computations together we obtain policy iteration and value iteration the two most popular dp methods. either of these can be used to reliably compute optimal policies and value functions for finite mdps given complete knowledge of the mdp. classical dp methods operate in sweeps through the state set performing an expected update operation on each state. each such operation updates the value of one state based on the values of all possible successor states and their probabilities of occurring. expected updates are closely related to bellman equations they are little more than these equations turned into assignment statements. when the updates no longer result in any changes in value convergence has occurred to values that satisfy the corresponding bellman equation. just as there are four primary value functions v q and q there are four corresponding bellman equations and four corresponding expected updates. an intuitive view of the operation of dp updates is given by their backup diagrams. insight into dp methods and in fact into almost all reinforcement learning methods can be gained by viewing them as generalized policy iteration gpi is the general idea of two interacting processes revolving around an approximate policy and an approximate value function. one process takes the policy as given and performs some form of policy evaluation changing the value function to be more like the true value function for the policy. the other process takes the value function as given and performs some form of policy improvement changing the policy to make it better assuming that the value function is its value function. although each process changes the basis for the other overall they work together to find a joint solution a policy and value function that are unchanged by either process and consequently are optimal. in some cases gpi can be proved to converge most notably for the classical dp methods that we have presented in this chapter. in other cases convergence has not been proved but still the idea of gpi improves our understanding of the methods. it is not necessary to perform dp methods in complete sweeps through the state summary set. asynchronous dp methods are in-place iterative methods that update states in an arbitrary order perhaps stochastically determined and using out-of-date information. many of these methods can be viewed as fine-grained forms of gpi. finally we note one last special property of dp methods. all of them update estimates of the values of states based on estimates of the values of successor states. that is they update estimates on the basis of other estimates. we call this general idea bootstrapping. many reinforcement learning methods perform bootstrapping even those that do not require as dp requires a complete and accurate model of the environment. in the next chapter we explore reinforcement learning methods that do not require a model and do not bootstrap. in the chapter after that we explore methods that do not require a model but do bootstrap. these key features and properties are separable yet can be mixed in interesting combinations. bibliographical and historical remarks the term dynamic programming is due to bellman who showed how these methods could be applied to a wide range of problems. extensive treatments of dp can be found in many texts including bertsekas bertsekas and tsitsiklis dreyfus and law ross white and whittle our interest in dp is restricted to its use in solving mdps but dp also applies to other types of problems. kumar and kanal provide a more general look at dp. to the best of our knowledge the first connection between dp and reinforcement learning was made by minsky in commenting on samuel s checkers player. in a footnote minsky mentioned that it is possible to apply dp to problems in which samuel s backing-up process can be handled in closed analytic form. this remark may have misled artificial intelligence researchers into believing that dp was restricted to analytically tractable problems and therefore largely irrelevant to artificial intelligence. andreae mentioned dp in the context of reinforcement learning specifically policy iteration although he did not make specific connections between dp and learning algorithms. werbos suggested an approach to approximating dp called heuristic dynamic programming that emphasizes gradient-descent methods for continuous-state problems these methods are closely related to the reinforcement learning algorithms that we discuss in this book. watkins was explicit in connecting reinforcement learning to dp characterizing a class of reinforcement learning methods as incremental dynamic programming. these sections describe well-established dp algorithms that are covered in any of the general dp references cited above. the policy improvement theorem and the policy iteration algorithm are due to bellman and howard our presentation was influenced by the local view of policy improvement taken by watkins our discussion of value iteration as a form of truncated policy iteration is based on the approach of puterman and shin who presented a class of algorithms called modified policy iteration which includes policy iteration and value iteration as special cases. an analysis showing how chapter dynamic programming value iteration can be made to find an optimal policy in finite time is given by bertsekas iterative policy evaluation is an example of a classical successive approximation algorithm for solving a system of linear equations. the version of the algorithm that uses two arrays one holding the old values while the other is updated is often called a jacobi-style algorithm after jacobi s classical use of this method. it is also sometimes called a synchronous algorithm because the effect is as if all the values are updated at the same time. the second array is needed to simulate this parallel computation sequentially. the in-place version of the algorithm is often called a gauss seidel-style algorithm after the classical gauss seidel algorithm for solving systems of linear equations. in addition to iterative policy evaluation other dp algorithms can be implemented in these different versions. bertsekas and tsitsiklis provide excellent coverage of these variations and their performance differences. asynchronous dp algorithms are due to bertsekas who also called them distributed dp algorithms. the original motivation for asynchronous dp was its implementation on a multiprocessor system with communication delays between processors and no global synchronizing clock. these algorithms are extensively discussed by bertsekas and tsitsiklis jacobi-style and gauss seidel-style dp algorithms are special cases of the asynchronous version. williams and baird presented dp algorithms that are asynchronous at a finer grain than the ones we have discussed the update operations themselves are broken into steps that can be performed asynchronously. this section written with the help of michael littman is based on littman dean and kaelbling the phrase curse of dimensionality is due to bellman chapter monte carlo methods in this chapter we consider our first learning methods for estimating value functions and discovering optimal policies. unlike the previous chapter here we do not assume complete knowledge of the environment. monte carlo methods require only experience sample sequences of states actions and rewards from actual or simulated interaction with an environment. learning from actual experience is striking because it requires no prior knowledge of the environment s dynamics yet can still attain optimal behavior. learning from simulated experience is also powerful. although a model is required the model need only generate sample transitions not the complete probability distributions of all possible transitions that is required for dynamic programming in surprisingly many cases it is easy to generate experience sampled according to the desired probability distributions but infeasible to obtain the distributions in explicit form. monte carlo methods are ways of solving the reinforcement learning problem based on averaging sample returns. to ensure that well-defined returns are available here we define monte carlo methods only for episodic tasks. that is we assume experience is divided into episodes and that all episodes eventually terminate no matter what actions are selected. only on the completion of an episode are value estimates and policies changed. monte carlo methods can thus be incremental in an episode-by-episode sense but not in a step-by-step sense. the term monte carlo is often used more broadly for any estimation method whose operation involves a significant random component. here we use it specifically for methods based on averaging complete returns opposed to methods that learn from partial returns considered in the next chapter. monte carlo methods sample and average returns for each state action pair much like the bandit methods we explored in chapter sample and average rewards for each action. the main difference is that now there are multiple states each acting like a different bandit problem an associative-search or contextual bandit and the different bandit problems are interrelated. that is the return after taking an action in one state depends on the actions taken in later states in the same episode. because all the action selections are undergoing learning the problem becomes nonstationary from the point of view of the earlier state. chapter monte carlo methods to handle the nonstationarity we adapt the idea of general policy iteration developed in chapter for dp. whereas there we computed value functions from knowledge of the mdp here we learn value functions from sample returns with the mdp. the value functions and corresponding policies still interact to attain optimality in essentially the same way as in the dp chapter first we consider the prediction problem computation of v and q for a fixed arbitrary policy then policy improvement and finally the control problem and its solution by gpi. each of these ideas taken from dp is extended to the monte carlo case in which only sample experience is available. monte carlo prediction we begin by considering monte carlo methods for learning the state-value function for a given policy. recall that the value of a state is the expected return expected cumulative future discounted reward starting from that state. an obvious way to estimate it from experience then is simply to average the returns observed after visits to that state. as more returns are observed the average should converge to the expected value. this idea underlies all monte carlo methods. in particular suppose we wish to estimate v the value of a state s under policy given a set of episodes obtained by following and passing through s. each occurrence of state s in an episode is called a visit to s. of course s may be visited multiple times in the same episode let us call the first time it is visited in an episode the first visit to s. the first-visit mc method estimates v as the average of the returns following first visits to s whereas the every-visit mc method averages the returns following all visits to s. these two monte carlo methods are very similar but have slightly different theoretical properties. first-visit mc has been most widely studied dating back to the and is the one we focus on in this chapter. every-visit mc extends more naturally to function approximation and eligibility traces as discussed in chapters and first-visit mc is shown in procedural form in the box. every-visit mc would be the same except without the check for st having occurred earlier in the episode. first-visit mc prediction for estimating v v input a policy to be evaluated initialize v r arbitrarily for all s s returnss an empty list for all s s loop forever each episode generate an episode following st at rt g loop for each step of episode t t t g g unless st appears in st append g to returnsst v averagereturnsst monte carlo prediction both first-visit mc and every-visit mc converge to v as the number of visits first visits to s goes to infinity. this is easy to see for the case of first-visit mc. in this case each return is an independent identically distributed estimate of v with finite variance. by the law of large numbers the sequence of averages of these estimates converges to their expected value. each average is itself an unbiased estimate and the standard deviation of its error falls as n where n is the number of returns averaged. every-visit mc is less straightforward but its estimates also converge quadratically to v and sutton the use of monte carlo methods is best illustrated through an example. example blackjack the object of the popular casino card game of blackjack is to obtain cards the sum of whose numerical values is as great as possible without exceeding all face cards count as and an ace can count either as or as we consider the version in which each player competes independently against the dealer. the game begins with two cards dealt to both dealer and player. one of the dealer s cards is face up and the other is face down. if the player has immediately ace and a it is called a natural. he then wins unless the dealer also has a natural in which case the game is a draw. if the player does not have a natural then he can request additional cards one by one until he either stops or exceeds bust. if he goes bust he loses if he sticks then it becomes the dealer s turn. the dealer hits or sticks according to a fixed strategy without choice he sticks on any sum of or greater and hits otherwise. if the dealer goes bust then the player wins otherwise the outcome win lose or draw is determined by whose final sum is closer to playing blackjack is naturally formulated as an episodic finite mdp. each game of blackjack is an episode. rewards of and are given for winning losing and drawing respectively. all rewards within a game are zero and we do not discount therefore these terminal rewards are also the returns. the player s actions are to hit or to stick. the states depend on the player s cards and the dealer s showing card. we assume that cards are dealt from an infinite deck with replacement so that there is no advantage to keeping track of the cards already dealt. if the player holds an ace that he could count as without going bust then the ace is said to be usable. in this case it is always counted as because counting it as would make the sum or less in which case there is no decision to be made because obviously the player should always hit. thus the player makes decisions on the basis of three variables his current sum the dealer s one showing card and whether or not he holds a usable ace. this makes for a total of states. consider the policy that sticks if the player s sum is or and otherwise hits. to find the state-value function for this policy by a monte carlo approach one simulates many blackjack games using the policy and averages the returns following each state. in this way we obtained the estimates of the state-value function shown in figure the estimates for states with a usable ace are less certain and less regular because these states are less common. in any event after games the value function is very well approximated. chapter monte carlo methods figure approximate state-value functions for the blackjack policy that sticks only on or computed by monte carlo policy evaluation. exercise consider the diagrams on the right in figure why does the estimated value function jump up for the last two rows in the rear? why does it drop off for the whole last row on the left? why are the frontmost values higher in the upper diagrams than in the lower? exercise suppose every-visit mc was used instead of first-visit mc on the blackjack task. would you expect the results to be very different? why or why not? although we have complete knowledge of the environment in the blackjack task it would not be easy to apply dp methods to compute the value function. dp methods require the distribution of next events in particular they require the environments dynamics as given by the four-argument function p and it is not easy to determine this for blackjack. for example suppose the player s sum is and he chooses to stick. what is his probability of terminating with a reward of as a function of the dealer s showing card? all of the probabilities must be computed before dp can be applied and such computations are often complex and error-prone. in contrast generating the sample games required by monte carlo methods is easy. this is the case surprisingly often the ability of monte carlo methods to work with sample episodes alone can be a significant advantage even when one has complete knowledge of the environment s dynamics. can we generalize the idea of backup diagrams to monte carlo algorithms? the general idea of a backup diagram is to show at the top the root node to be updated and to show below all the transitions and leaf nodes whose rewards and estimated values contribute to the update. for monte carlo estimation of v the root is a state node and below it is the entire trajectory of transitions along a particular single episode ending episodesafter episodesusableacenousableace monte carlo prediction at the terminal state as shown to the right. whereas the dp diagram shows all possible transitions the monte carlo diagram shows only those sampled on the one episode. whereas the dp diagram includes only one-step transitions the monte carlo diagram goes all the way to the end of the episode. these differences in the diagrams accurately reflect the fundamental differences between the algorithms. an important fact about monte carlo methods is that the estimates for each state are independent. the estimate for one state does not build upon the estimate of any other state as is the case in dp. in other words monte carlo methods do not bootstrap as we defined it in the previous chapter. in particular note that the computational expense of estimating the value of a single state is independent of the number of states. this can make monte carlo methods particularly attractive when one requires the value of only one or a subset of states. one can generate many sample episodes starting from the states of interest averaging returns from only these states ignoring all others. this is a third advantage monte carlo methods can have over dp methods the ability to learn from actual experience and from simulated experience. example soap bubble suppose a wire frame forming a closed loop is dunked in soapy water to form a soap surface or bubble conforming at its edges to the wire frame. if the geometry of the wire frame is irregular but known how can you compute the shape of the surface? the shape has the property that the total force on each point exerted by neighboring points is zero else the shape would change. this means that the surface s height at any point is the average of its heights at points in a small circle around that point. in addition the surface must meet at its boundaries with the wire frame. the usual approach to problems of this kind is to put a grid over the area covered by the surface and solve for its height at the grid points by an iterative computation. grid points at the boundary are forced to the wire frame and all others are adjusted toward the average of the heights of their four nearest neighbors. this process then iterates much like dp s iterative policy evaluation and ultimately converges to a close approximation to the desired surface. from hersh and griego reproduced with permission. copyright scientific american a division of nature america inc. a bubble on a wire loop. all rights reserved. this is similar to the kind of problem for which monte carlo methods were originally designed. instead of the iterative computation described above imagine standing on the surface and taking a random walk stepping randomly from grid point to neighboring grid point with equal probability until you reach the boundary. it turns out that the expected value of the height at the boundary is a close approximation to the height of the desired surface at the starting point fact it is exactly the value computed by the chapter monte carlo methods iterative method described above. thus one can closely approximate the height of the surface at a point by simply averaging the boundary heights of many walks started at the point. if one is interested in only the value at one point or any fixed small set of points then this monte carlo method can be far more efficient than the iterative method based on local consistency. monte carlo estimation of action values if a model is not available then it is particularly useful to estimate action values values of state action pairs rather than state values. with a model state values alone are sufficient to determine a policy one simply looks ahead one step and chooses whichever action leads to the best combination of reward and next state as we did in the chapter on dp. without a model however state values alone are not sufficient. one must explicitly estimate the value of each action in order for the values to be useful in suggesting a policy. thus one of our primary goals for monte carlo methods is to estimate q to achieve this we first consider the policy evaluation problem for action values. the policy evaluation problem for action values is to estimate q a the expected return when starting in state s taking action a and thereafter following policy the monte carlo methods for this are essentially the same as just presented for state values except now we talk about visits to a state action pair rather than to a state. a state action pair s a is said to be visited in an episode if ever the state s is visited and action a is taken in it. the every-visit mc method estimates the value of a state action pair as the average of the returns that have followed all the visits to it. the first-visit mc method averages the returns following the first time in each episode that the state was visited and the action was selected. these methods converge quadratically as before to the true expected values as the number of visits to each state action pair approaches infinity. the only complication is that many state action pairs may never be visited. if is a deterministic policy then in following one will observe returns only for one of the actions from each state. with no returns to average the monte carlo estimates of the other actions will not improve with experience. this is a serious problem because the purpose of learning action values is to help in choosing among the actions available in each state. to compare alternatives we need to estimate the value of all the actions from each state not just the one we currently favor. this is the general problem of maintaining exploration as discussed in the context of the k-armed bandit problem in chapter for policy evaluation to work for action values we must assure continual exploration. one way to do this is by specifying that the episodes start in a state action pair and that every pair has a nonzero probability of being selected as the start. this guarantees that all state action pairs will be visited an infinite number of times in the limit of an infinite number of episodes. we call this the assumption of exploring starts. the assumption of exploring starts is sometimes useful but of course it cannot be relied upon in general particularly when learning directly from actual interaction with an environment. in that case the starting conditions are unlikely to be so helpful. the monte carlo control most common alternative approach to assuring that all state action pairs are encountered is to consider only policies that are stochastic with a nonzero probability of selecting all actions in each state. we discuss two important variants of this approach in later sections. for now we retain the assumption of exploring starts and complete the presentation of a full monte carlo control method. exercise what is the backup diagram for monte carlo estimation of q monte carlo control we are now ready to consider how monte carlo estimation can be used in control that is to approximate optimal policies. the overall idea is to proceed according to the same pattern as in the dp chapter that is according to the idea of generalized policy iteration in gpi one maintains both an approximate policy and an approximate value function. the value function is repeatedly altered to more closely approximate the value function for the current policy and the policy is repeatedly improved with respect to the current value function as suggested by the diagram to the right. these two kinds of changes work against each other to some extent as each creates a moving target for the other but together they cause both policy and value function to approach optimality. to begin let us consider a monte carlo version of classical policy iteration. in this method we perform alternating complete steps of policy evaluation and policy improvement beginning with an arbitrary policy and ending with the optimal policy and optimal action-value function e q e i i e q i e denotes a complete policy evaluation and e q i denotes a complete policy where improvement. policy evaluation is done exactly as described in the preceding section. many episodes are experienced with the approximate action-value function approaching the true function asymptotically. for the moment let us assume that we do indeed observe an infinite number of episodes and that in addition the episodes are generated with exploring starts. under these assumptions the monte carlo methods will compute each q k exactly for arbitrary k. policy improvement is done by making the policy greedy with respect to the current value function. in this case we have an action-value function and therefore no model is needed to construct the greedy policy. for any action-value function q the corresponding greedy policy is the one that for each s s deterministically chooses an action with maximal action-value arg max a qs a. policy improvement then can be done by constructing each as the greedy policy with respect to q k the policy improvement theorem then applies to k evaluationimprovement q greedyqq q chapter monte carlo methods and because for all s s q k q k argmax a q k a a max q k a q k ks v k as we discussed in the previous chapter the theorem assures us that each is uniformly better than k or just as good as k in which case they are both optimal policies. this in turn assures us that the overall process converges to the optimal policy and optimal value function. in this way monte carlo methods can be used to find optimal policies given only sample episodes and no other knowledge of the environment s dynamics. we made two unlikely assumptions above in order to easily obtain this guarantee of convergence for the monte carlo method. one was that the episodes have exploring starts and the other was that policy evaluation could be done with an infinite number of episodes. to obtain a practical algorithm we will have to remove both assumptions. we postpone consideration of the first assumption until later in this chapter. for now we focus on the assumption that policy evaluation operates on an infinite number of episodes. this assumption is relatively easy to remove. in fact the same issue arises even in classical dp methods such as iterative policy evaluation which also converge only asymptotically to the true value function. in both dp and monte carlo cases there are two ways to solve the problem. one is to hold firm to the idea of approximating q k in each policy evaluation. measurements and assumptions are made to obtain bounds on the magnitude and probability of error in the estimates and then sufficient steps are taken during each policy evaluation to assure that these bounds are sufficiently small. this approach can probably be made completely satisfactory in the sense of guaranteeing correct convergence up to some level of approximation. however it is also likely to require far too many episodes to be useful in practice on any but the smallest problems. there is a second approach to avoiding the infinite number of episodes nominally required for policy evaluation in which we give up trying to complete policy evaluation before returning to policy improvement. on each evaluation step we move the value function toward q k but we do not expect to actually get close except over many steps. we used this idea when we first introduced the idea of gpi in section one extreme form of the idea is value iteration in which only one iteration of iterative policy evaluation is performed between each step of policy improvement. the in-place version of value iteration is even more extreme there we alternate between improvement and evaluation steps for single states. for monte carlo policy evaluation it is natural to alternate between evaluation and improvement on an episode-by-episode basis. after each episode the observed returns are used for policy evaluation and then the policy is improved at all the states visited in the episode. a complete simple algorithm along these lines which we call monte carlo es for monte carlo with exploring starts is given in the box on the next page. monte carlo control without exploring starts monte carlo es starts for estimating initialize as for all s s qs a r for all s s a as returnss a empty list for all s s a as loop forever each episode choose s and such that all pairs have probability generate an episode from following st at rt g loop for each step of episode t t t g g unless the pair st at appears in st at append g to returnsst at qst at averagereturnsst at argmaxa qst a in monte carlo es all the returns for each state action pair are accumulated and averaged irrespective of what policy was in force when they were observed. it is easy to see that monte carlo es cannot converge to any suboptimal policy. if it did then the value function would eventually converge to the value function for that policy and that in turn would cause the policy to change. stability is achieved only when both the policy and the value function are optimal. convergence to this optimal fixed point seems inevitable as the changes to the action-value function decrease over time but has not yet been formally proved. in our opinion this is one of the most fundamental open theoretical questions in reinforcement learning a partial solution see tsitsiklis example solving blackjack it is straightforward to apply monte carlo es to blackjack. because the episodes are all simulated games it is easy to arrange for exploring starts that include all possibilities. in this case one simply picks the dealer s cards the player s sum and whether or not the player has a usable ace all at random with equal probability. as the initial policy we use the policy evaluated in the previous blackjack example that which sticks only on or the initial action-value function can be zero for all state action pairs. figure shows the optimal policy for blackjack found by monte carlo es. this policy is the same as the basic strategy of thorp with the sole exception of the leftmost notch in the policy for a usable ace which is not present in thorp s strategy. we are uncertain of the reason for this discrepancy but confident that what is shown here is indeed the optimal policy for the version of blackjack we have described. chapter monte carlo methods figure the optimal policy and state-value function for blackjack found by monte carlo es. the state-value function shown was computed from the action-value function found by monte carlo es. monte carlo control without exploring starts how can we avoid the unlikely assumption of exploring starts? the only general way to ensure that all actions are selected infinitely often is for the agent to continue to select them. there are two approaches to ensuring this resulting in what we call on-policy methods and off-policy methods. on-policy methods attempt to evaluate or improve the policy that is used to make decisions whereas off-policy methods evaluate or improve a policy different from that used to generate the data. the monte carlo es method developed above is an example of an on-policy method. in this section we show how an on-policy monte carlo control method can be designed that does not use the unrealistic assumption of exploring starts. off-policy methods are considered in the next section. in on-policy control methods the policy is generally soft meaning that for all s s and all a as but gradually shifted closer and closer to a deterministic optimal policy. many of the methods discussed in chapter provide mechanisms for this. the on-policy method we present in this section uses policies meaning that most of the time they choose an action that has maximal estimated action value but with probability they instead select an action at random. that is all nongreedy and the remaining bulk of actions are given the minimal probability of selection the probability is given to the greedy action. the policies are examples of policies defined as policies for which for all states and actions for some among policies policies are in some sense those that are closest to greedy. showingplayer showingplayer showingplayer showingplayer showingplayer showingplayer showingplayer sum monte carlo control without exploring starts the overall idea of on-policy monte carlo control is still that of gpi. as in monte carlo es we use first-visit mc methods to estimate the action-value function for the current policy. without the assumption of exploring starts however we cannot simply improve the policy by making it greedy with respect to the current value function because that would prevent further exploration of nongreedy actions. fortunately gpi does not require that the policy be taken all the way to a greedy policy only that it be moved toward a greedy policy. in our on-policy method we will move it only to an policy. for any policy any policy with respect to q is guaranteed to be better than or equal to the complete algorithm is given in the box below. on-policy first-visit mc control policies estimates algorithm parameter small initialize an arbitrary policy qs a r for all s s a as returnss a empty list for all s s a as repeat forever each episode generate an episode following st at rt g loop for each step of episode t t t g g unless the pair st at appears in st at append g to returnsst at qst at averagereturnsst at a arg maxa qst a for all a ast ties broken arbitrarily if a a if a a that any policy with respect to q is an improvement over any policy is assured by the policy improvement theorem. let be the policy. the conditions of the policy improvement theorem apply because for any s s q a q a max a q a q a q a sum is a weighted average with nonnegative weights summing to and as such it chapter monte carlo methods must be less than or equal to the largest number averaged q a q a a v thus by the policy improvement theorem v v for all s s. we now prove that equality can hold only when both and are optimal among the policies that is when they are better than or equal to all other policies. consider a new environment that is just like the original environment except with the requirement that policies be moved inside the environment. the new environment has the same action and state set as the original and behaves as follows. if in state s and taking action a then with probability the new environment behaves exactly like the old environment. with probability it repicks the action at random with equal probabilities and then behaves like the old environment with the new random action. the best one can do in this new environment with general policies is the same as the the optimal value functions for the new environment. then a policy is optimal among best one could do in the original environment with policies. and denote policies if and only if v from the definition of we know that it is the unique solution to v max a q a max a however this equation is the same as the previous one except for the substitution of v rs v is the unique solution it must be that v in essence we have shown in the last few pages that policy iteration works for policies. using the natural notion of greedy policy for policies one is assured of improvement on every step except when the best policy has been found among the policies. this analysis is independent of how the action-value functions are determined at each stage but it does assume that they are computed exactly. this brings us to max a a a max a rs rs rs v q a when equality holds and the policy is no longer improved then we also know from that off-policy prediction via importance sampling roughly the same point as in the previous section. now we only achieve the best policy among the policies but on the other hand we have eliminated the assumption of exploring starts. off-policy prediction via importance sampling all learning control methods face a dilemma they seek to learn action values conditional on subsequent optimal behavior but they need to behave non-optimally in order to explore all actions find the optimal actions. how can they learn about the optimal policy while behaving according to an exploratory policy? the on-policy approach in the preceding section is actually a compromise it learns action values not for the optimal policy but for a near-optimal policy that still explores. a more straightforward approach is to use two policies one that is learned about and that becomes the optimal policy and one that is more exploratory and is used to generate behavior. the policy being learned about is called the target policy and the policy used to generate behavior is called the behavior policy. in this case we say that learning is from data off the target policy and the overall process is termed off-policy learning. throughout the rest of this book we consider both on-policy and off-policy methods. on-policy methods are generally simpler and are considered first. off-policy methods require additional concepts and notation and because the data is due to a different policy off-policy methods are often of greater variance and are slower to converge. on the other hand off-policy methods are more powerful and general. they include onpolicy methods as the special case in which the target and behavior policies are the same. off-policy methods also have a variety of additional uses in applications. for example they can often be applied to learn from data generated by a conventional nonlearning controller or from a human expert. off-policy learning is also seen by some as key to learning multi-step predictive models of the world s dynamics section sutton sutton et al. in this section we begin the study of off-policy methods by considering the prediction problem in which both target and behavior policies are fixed. that is suppose we wish to estimate v or q but all we have are episodes following another policy b where b in this case is the target policy b is the behavior policy and both policies are considered fixed and given. in order to use episodes from b to estimate values for we require that every action taken under is also taken at least occasionally under b. that is we require that implies bas this is called the assumption of coverage. it follows from coverage that b must be stochastic in states where it is not identical to the target policy on the other hand may be deterministic and in fact this is a case of particular interest in control applications. in control the target policy is typically the deterministic greedy policy with respect to the current estimate of the action-value function. this policy becomes a deterministic optimal policy while the behavior policy remains stochastic and more exploratory for example an policy. in this section however we consider the prediction problem in which is unchanging and given. almost all off-policy methods utilize importance sampling a general technique for chapter monte carlo methods estimating expected values under one distribution given samples from another. we apply importance sampling to off-policy learning by weighting returns according to the relative probability of their trajectories occurring under the target and behavior policies called the importance-sampling ratio. given a starting state st the probability of the subsequent state action trajectory at st occurring under any policy is prat st st att at pst at ak t where p here is the state-transition probability function defined by thus the relative probability of the trajectory under the target and behavior policies importancesampling ratio is tt kt ak kt ak t baksk although the trajectory probabilities depend on the mdp s transition probabilities which are generally unknown they appear identically in both the numerator and denominator and thus cancel. the importance sampling ratio ends up depending only on the two policies and the sequence not on the mdp. recall that we wish to estimate the expected returns under the target policy but all we have are returns gt due to the behavior policy. these returns have the wrong expectation egtst s vbs and so cannot be averaged to obtain v this is where importance sampling comes in. the ratio tt transforms the returns to have the right expected value e tt st s v now we are ready to give a monte carlo algorithm that averages returns from a batch of observed episodes following policy b to estimate v it is convenient here to number time steps in a way that increases across episode boundaries. that is if the first episode of the batch ends in a terminal state at time then the next episode begins at time t this enables us to use time-step numbers to refer to particular steps in particular episodes. in particular we can define the set of all time steps in which state s is visited denoted ts. this is for an every-visit method for a first-visit method ts would only include time steps that were first visits to s within their episodes. also let t denote the first time of termination following time t and gt denote the return after t up through t then ts are the returns that pertain to state s and tt ts are the corresponding importance-sampling ratios. to estimate v we simply scale the returns by the ratios and average the results v ts tt off-policy prediction via importance sampling when importance sampling is done as a simple average in this way it is called ordinary importance sampling. an important alternative is weighted importance sampling which uses a weighted av erage defined as v ts tt ts tt or zero if the denominator is zero. to understand these two varieties of importance sampling consider their estimates after observing a single return. in the weightedaverage estimate the ratio tt for the single return cancels in the numerator and denominator so that the estimate is equal to the observed return independent of the ratio the ratio is nonzero. given that this return was the only one observed this is a reasonable estimate but its expectation is vbs rather than v and in this statistical sense it is biased. in contrast the simple average is always v in expectation is unbiased but it can be extreme. suppose the ratio were ten indicating that the trajectory observed is ten times as likely under the target policy as under the behavior policy. in this case the ordinary importance-sampling estimate would be ten times the observed return. that is it would be quite far from the observed return even though the episode s trajectory is considered very representative of the target policy. formally the difference between the two kinds of importance sampling is expressed in their biases and variances. the ordinary importance-sampling estimator is unbiased whereas the weighted importance-sampling estimator is biased bias converges asymptotically to zero. on the other hand the variance of the ordinary importancesampling estimator is in general unbounded because the variance of the ratios can be unbounded whereas in the weighted estimator the largest weight on any single return is one. in fact assuming bounded returns the variance of the weighted importancesampling estimator converges to zero even if the variance of the ratios themselves is infinite sutton and dasgupta in practice the weighted estimator usually has dramatically lower variance and is strongly preferred. nevertheless we will not totally abandon ordinary importance sampling as it is easier to extend to the approximate methods using function approximation that we explore in the second part of this book. a complete every-visit mc algorithm for off-policy policy evaluation using weighted importance sampling is given in the next section on page example off-policy estimation of a blackjack state value we applied both ordinary and weighted importance-sampling methods to estimate the value of a single blackjack state from off-policy data. recall that one of the advantages of monte carlo methods is that they can be used to evaluate a single state without forming estimates for any other states. in this example we evaluated the state in which the dealer is showing a deuce the sum of the player s cards is and the player has a usable ace is the player holds an ace and a deuce or equivalently three aces. the data was generated by starting in this state then choosing to hit or stick at random with equal probability behavior policy. the target policy was to stick only on a sum of or as in example the value of this state under the target policy chapter monte carlo methods is approximately was determined by separately generating one-hundred million episodes using the target policy and averaging their returns. both off-policy methods closely approximated this value after off-policy episodes using the random policy. to make sure they did this reliably we performed independent runs each starting from estimates of zero and learning for episodes. figure shows the resultant learning curves the squared error of the estimates of each method as a function of number of episodes averaged over the runs. the error approaches zero for both algorithms but the weighted importance-sampling method has much lower error at the beginning as is typical in practice. figure weighted importance sampling produces lower error estimates of the value of a single blackjack state from off-policy episodes example example infinite variance the estimates of ordinary importance sampling will typically have infinite variance and thus unsatisfactory convergence properties whenever the scaled returns have infinite variance and this can easily happen in off-policy learning when trajectories contain loops. a simple example is shown inset in figure there is only one nonterminal state s and two actions right and left. the right action causes a deterministic transition to termination whereas the left action transitions with probability back to s or with probability on to termination. the rewards are on the latter transition and otherwise zero. consider the target policy that always selects left. all episodes under this policy consist of some number zero of transitions back to s followed by termination with a reward and return of thus the value of s under the target policy is suppose we are estimating this value from off-policy data using the behavior policy that selects right and left with equal probability. the lower part of figure shows ten independent runs of the first-visit mc algorithm using ordinary importance sampling. even after millions of episodes the estimates fail to converge to the correct value of in contrast the weighted importance-sampling algorithm would give an estimate of exactly forever after the first episode that ended with the left action. all returns not equal to is ending with the right action would be inconsistent with the target policy and thus would have a tt of zero and contribute neither to the numerator nor denominator of the weighted importance ordinary importance samplingweighted importance samplingepisodes off-policy prediction via importance sampling figure ordinary importance sampling produces surprisingly unstable estimates on the one-state mdp shown inset the correct estimate here is and even though this is the expected value of a sample return importance sampling the variance of the samples is infinite and the estimates do not converge to this value. these results are for off-policy first-visit mc. sampling algorithm produces a weighted average of only the returns consistent with the target policy and all of these would be exactly we can verify that the variance of the importance-sampling-scaled returns is infinite in this example by a simple calculation. the variance of any random variable x is the expected value of the deviation from its mean x which can be written varx x x x thus if the mean is finite as it is in our case the variance is infinite if and only if the expectation of the square of the random variable is infinite. thus we need only show that the expected square of the importance-sampling-scaled return is infinite eb batst to compute this expectation we break it down into cases based on episode length and termination. first note that for any episode ending with the right action the importance sampling ratio is zero because the target policy would never take this action these episodes thus contribute nothing to the expectation quantity in parenthesis will be zero and can be ignored. we need only consider episodes that involve some number zero of left actions that transition back to the nonterminal state followed by estimate of with ordinaryimportance samplingten runsepisodes chapter monte carlo methods a left action transitioning to termination. all of these episodes have a return of so the factor can be ignored. to get the expected square we need only consider each length of episode multiplying the probability of the episode s occurrence by the square of its importance-sampling ratio and add these up length episode length episode length episode exercise what is the equation analogous to for action values qs a instead of state values v again given returns generated using b? exercise in learning curves such as those shown in figure error generally decreases with training as indeed happened for the ordinary importance-sampling method. but for the weighted importance-sampling method error first increased and then decreased. why do you think this happened? exercise the results with example and shown in figure used a first-visit mc method. suppose that instead an every-visit mc method was used on the same problem. would the variance of the estimator still be infinite? why or why not? incremental implementation monte carlo prediction methods can be implemented incrementally on an episode-byepisode basis using extensions of the techniques described in chapter whereas in chapter we averaged rewards in monte carlo methods we average returns. in all other respects exactly the same methods as used in chapter can be used for on-policy monte carlo methods. for off-policy monte carlo methods we need to separately consider those that use ordinary importance sampling and those that use weighted importance sampling. in ordinary importance sampling the returns are scaled by the importance sampling ratio tt then simply averaged. for these methods we can again use the incremental methods of chapter but using the scaled returns in place of the rewards of that chapter. this leaves the case of off-policy methods using weighted importance sampling. here we have to form a weighted average of the returns and a slightly different incremental algorithm is required. suppose we have a sequence of returns gn all starting in the same state and each with a corresponding random weight wi wi tt we wish to off-policy monte carlo control form the estimate wkgk wk vn n and keep it up-to-date as we obtain a single additional return gn. in addition to keeping track of vn we must maintain for each state the cumulative sum cn of the weights given to the first n returns. the update rule for vn is vn wn n and cn where is arbitrary and thus need not be specified. the box below contains a complete episode-by-episode incremental algorithm for monte carlo policy evaluation. the algorithm is nominally for the off-policy case using weighted importance sampling but applies as well to the on-policy case just by choosing the target and behavior policies as the same which case b w is always the approximation q converges to q all encountered state action pairs while actions are selected according to a potentially different policy b. off-policy mc prediction evaluation for estimating q q input an arbitrary target policy initialize for all s s a as qs a r cs a loop forever each episode b any policy with coverage of generate an episode following b st at rt g w loop for each step of episode t t t g g cst at cst at w qst at qst at w w w batst if w then exit for loop cstat qst at exercise modify the algorithm for first-visit mc policy evaluation to use the incremental implementation for sample averages described in section exercise derive the weighted-average update rule from follow the pattern of the derivation of the unweighted rule chapter monte carlo methods off-policy monte carlo control we are now ready to present an example of the second class of learning control methods we consider in this book off-policy methods. recall that the distinguishing feature of on-policy methods is that they estimate the value of a policy while using it for control. in off-policy methods these two functions are separated. the policy used to generate behavior called the behavior policy may in fact be unrelated to the policy that is evaluated and improved called the target policy. an advantage of this separation is that the target policy may be deterministic greedy while the behavior policy can continue to sample all possible actions. off-policy monte carlo control methods use one of the techniques presented in the preceding two sections. they follow the behavior policy while learning about and improving the target policy. these techniques require that the behavior policy has a nonzero probability of selecting all actions that might be selected by the target policy to explore all possibilities we require that the behavior policy be soft that it select all actions in all states with nonzero probability. the box below shows an off-policy monte carlo control method based on gpi and weighted importance sampling for estimating and q the target policy is the greedy policy with respect to q which is an estimate of q the behavior policy b can be anything but in order to assure convergence of to the optimal policy an infinite number of returns must be obtained for each pair of state and action. this can be assured by choosing b to be the policy converges to optimal at all encountered states even though actions are selected according to a different soft policy b which may change between or even within episodes. off-policy mc control for estimating initialize for all s s a as qs a r cs a argmaxa qs a loop forever each episode ties broken consistently b any soft policy generate an episode using b st at rt g w loop for each step of episode t t t g g cst at cst at w qst at qst at w argmaxa qst a if at then exit for loop w w batst cstat qst at ties broken consistently off-policy monte carlo control a potential problem is that this method learns only from the tails of episodes when all of the remaining actions in the episode are greedy. if nongreedy actions are common then learning will be slow particularly for states appearing in the early portions of long episodes. potentially this could greatly slow learning. there has been insufficient experience with off-policy monte carlo methods to assess how serious this problem is. if it is serious the most important way to address it is probably by incorporating temporaldifference learning the algorithmic idea developed in the next chapter. alternatively if is less than then the idea developed in the next section may also help significantly. batst why is this nevertheless correct? exercise in the boxed algorithm for off-policy mc control you may have been expecting the w update to have involved the importance-sampling ratio batst but instead it involves exercise racetrack consider driving a race car around a turn like those shown in figure you want to go as fast as possible but not so fast as to run off the track. in our simplified racetrack the car is at one of a discrete set of grid positions the cells in the diagram. the velocity is also discrete a number of grid cells moved horizontally and vertically per time step. the actions are increments to the velocity components. each may be changed by or in each step for a total of nine actions. both velocity components are restricted to be nonnegative and less than and they cannot both be zero except at the starting line. each episode begins in one of the randomly selected start states with both velocity components zero and ends when the car crosses the finish line. the rewards are for each step until the car crosses the finish line. if the car hits the track boundary it is moved back to a random position on the starting line both velocity components are reduced to zero and the episode continues. before updating the car s location at each time step check to see if the projected path of the car intersects the track boundary. if it intersects the finish line the episode ends if it intersects anywhere else the car is considered to have figure a couple of right turns for the racetrack task. starting linefinishlinestarting linefinishline chapter monte carlo methods hit the track boundary and is sent back to the starting line. to make the task more challenging with probability at each time step the velocity increments are both zero independently of the intended increments. apply a monte carlo control method to this task to compute the optimal policy from each starting state. exhibit several trajectories following the optimal policy turn the noise off for these trajectories. importance sampling the off-policy methods that we have considered so far are based on forming importancesampling weights for returns considered as unitary wholes without taking into account the returns internal structures as sums of discounted rewards. we now briefly consider cutting-edge research ideas for using this structure to significantly reduce the variance of off-policy estimators. for example consider the case where episodes are long and is significantly less than for concreteness say that episodes last steps and that the return from time will then be just but its importance sampling ratio will be a product of factors in ordinary importance sampling the return will be scaled by the entire product but it is really only necessary to scale by the first factor by are irrelevant because after the first reward the return has already been determined. these later factors are all independent of the return and of expected value they do not change the expected update but they add enormously to its variance. in some cases they could even make the variance infinite. let us now consider an idea for avoiding this large extraneous variance. the other factors the essence of the idea is to think of discounting as determining a probability of termination or equivalently a degree of partial termination. for any we can think of the return as partly terminating in one step to the degree producing a return of just the first reward and as partly terminating after two steps to the degree producing a return of and so on. the latter degree corresponds to terminating on the second step and not having already terminated on the first step the degree of termination on the third step is thus with the reflecting that termination did not occur on either of the first two steps. the partial returns here are called flat partial returns gth rh t h t where flat denotes the absence of discounting and partial denotes that these returns do not extend all the way to termination but instead stop at h called the horizon t is the time of termination of the episode. the conventional full return gt can be per-decision importance sampling viewed as a sum of flat partial returns as suggested above as follows gt t t t t rt t t rt h t gth t t gtt t now we need to scale the flat partial returns by an importance sampling ratio that is similarly truncated. as gth only involves rewards up to a horizon h we only need the ratio of the probabilities up to h. we define an ordinary importance-sampling estimator analogous to as v h t th gth t t tt gtt and a weighted importance-sampling estimator analogous to as v h t th gth t t tt h t th t t tt gtt we call these two estimators discounting-aware importance sampling estimators. they take into account the discount rate but have no effect the same as the off-policy estimators from section if importance sampling there is one more way in which the structure of the return as a sum of rewards can be taken into account in off-policy importance sampling a way that may be able to reduce variance even in the absence of discounting is even if in the off-policy estimators and each term of the sum in the numerator is itself a sum tt tt t t tt tt t t tt chapter monte carlo methods the off-policy estimators rely on the expected values of these terms let us see if we can write them in a simpler way. note that each sub-term of is a product of a random reward and a random importance-sampling ratio. for example the first sub-term can be written using as tt batst bat now notice that of all these factors only the first and the last reward are correlated all the other ratios are independent random variables whose expected value is one bask bask thus because the expectation of the product of independent random variables is the product of their expectations all the ratios except the first drop out in expectation leaving just e tt e if we repeat this analysis for the kth term of we get e tt e ttk it follows then that the expectation of our original term can be written where e tt gt t t tt we call this idea per-decision importance sampling. it follows immediately that there is an alternate importance-sampling estimator with the same unbiased expectation as the ordinary-importance-sampling estimator using gt v ts gt which we might expect to sometimes be of lower variance. is there a per-decision version of weighted importance sampling? this is less clear. so far all the estimators that have been proposed for this that we know of are not consistent is they do not converge to the true value with infinite data. exercise modify the algorithm for off-policy monte carlo control to use the idea of the truncated weighted-average estimator note that you will first need to convert this equation to action values. summary summary the monte carlo methods presented in this chapter learn value functions and optimal policies from experience in the form of sample episodes. this gives them at least three kinds of advantages over dp methods. first they can be used to learn optimal behavior directly from interaction with the environment with no model of the environment s dynamics. second they can be used with simulation or sample models. for surprisingly many applications it is easy to simulate sample episodes even though it is difficult to construct the kind of explicit model of transition probabilities required by dp methods. third it is easy and efficient to focus monte carlo methods on a small subset of the states. a region of special interest can be accurately evaluated without going to the expense of accurately evaluating the rest of the state set explore this further in chapter a fourth advantage of monte carlo methods which we discuss later in the book is that they may be less harmed by violations of the markov property. this is because they do not update their value estimates on the basis of the value estimates of successor states. in other words it is because they do not bootstrap. in designing monte carlo control methods we have followed the overall schema of generalized policy iteration introduced in chapter gpi involves interacting processes of policy evaluation and policy improvement. monte carlo methods provide an alternative policy evaluation process. rather than use a model to compute the value of each state they simply average many returns that start in the state. because a state s value is the expected return this average can become a good approximation to the value. in control methods we are particularly interested in approximating action-value functions because these can be used to improve the policy without requiring a model of the environment s transition dynamics. monte carlo methods intermix policy evaluation and policy improvement steps on an episode-by-episode basis and can be incrementally implemented on an episode-by-episode basis. maintaining sufficient exploration is an issue in monte carlo control methods. it is not enough just to select the actions currently estimated to be best because then no returns will be obtained for alternative actions and it may never be learned that they are actually better. one approach is to ignore this problem by assuming that episodes begin with state action pairs randomly selected to cover all possibilities. such exploring starts can sometimes be arranged in applications with simulated episodes but are unlikely in learning from real experience. in on-policy methods the agent commits to always exploring and tries to find the best policy that still explores. in off-policy methods the agent also explores but learns a deterministic optimal policy that may be unrelated to the policy followed. off-policy prediction refers to learning the value function of a target policy from data generated by a different behavior policy. such learning methods are based on some form of importance sampling that is on weighting returns by the ratio of the probabilities of taking the observed actions under the two policies thereby transforming their expectations from the behavior policy to the target policy. ordinary importance sampling uses a simple average of the weighted returns whereas weighted importance sampling uses chapter monte carlo methods a weighted average. ordinary importance sampling produces unbiased estimates but has larger possibly infinite variance whereas weighted importance sampling always has finite variance and is preferred in practice. despite their conceptual simplicity off-policy monte carlo methods for both prediction and control remain unsettled and are a subject of ongoing research. the monte carlo methods treated in this chapter differ from the dp methods treated in the previous chapter in two major ways. first they operate on sample experience and thus can be used for direct learning without a model. second they do not bootstrap. that is they do not update their value estimates on the basis of other value estimates. these two differences are not tightly linked and can be separated. in the next chapter we consider methods that learn from experience like monte carlo methods but also bootstrap like dp methods. bibliographical and historical remarks the term monte carlo dates from the when physicists at los alamos devised games of chance that they could study to help understand complex physical phenomena relating to the atom bomb. coverage of monte carlo methods in this sense can be found in several textbooks kalos and whitlock rubinstein singh and sutton distinguished between every-visit and first-visit mc methods and proved results relating these methods to reinforcement learning algorithms. the blackjack example is based on an example used by widrow gupta and maitra the soap bubble example is a classical dirichlet problem whose monte carlo solution was first proposed by kakutani see hersh and griego doyle and snell barto and duff discussed policy evaluation in the context of classical monte carlo algorithms for solving systems of linear equations. they used the analysis of curtiss to point out the computational advantages of monte carlo policy evaluation for large problems. monte carlo es was introduced in the edition of this book. that may have been the first explicit connection between monte carlo estimation and control methods based on policy iteration. an early use of monte carlo methods to estimate action values in a reinforcement learning context was by michie and chambers in pole balancing they used averages of episode durations to assess the worth balancing life of each possible action in each state and then used these assessments to control action selections. their method is similar in spirit to monte carlo es with every-visit mc estimates. narendra and wheeler studied a monte carlo method for ergodic finite markov chains that used the return accumulated between successive visits to the same state as a reward for adjusting a learning automaton s action probabilities. efficient off-policy learning has become recognized as an important challenge that arises in several fields. for example it is closely related to the idea of in summary terventions and counterfactuals in probabalistic graphical models pearl balke and pearl off-policy methods using importance sampling have a long history and yet still are not well understood. weighted importance sampling which is also sometimes called normalized importance sampling koller and friedman is discussed by rubinstein hesterberg shelton and liu among others. the target policy in off-policy learning is sometimes referred to in the literature as the estimation policy as it was in the first edition of this book. the racetrack exercise is adapted from barto bradtke and singh and from gardner our treatment of the idea of discounting-aware importance sampling is based on the analysis of sutton mahmood precup and van hasselt it has been worked out most fully to date by mahmood mahmood van hasselt and sutton per-decision importance sampling was introduced by precup sutton and singh they also combined off-policy learning with temporal-difference learning eligibility traces and approximation methods introducing subtle issues that we consider in later chapters. chapter temporal-difference learning if one had to identify one idea as central and novel to reinforcement learning it would undoubtedly be temporal-difference learning. td learning is a combination of monte carlo ideas and dynamic programming ideas. like monte carlo methods td methods can learn directly from raw experience without a model of the environment s dynamics. like dp td methods update estimates based in part on other learned estimates without waiting for a final outcome bootstrap. the relationship between td dp and monte carlo methods is a recurring theme in the theory of reinforcement learning this chapter is the beginning of our exploration of it. before we are done we will see that these ideas and methods blend into each other and can be combined in many ways. in particular in chapter we introduce n-step algorithms which provide a bridge from td to monte carlo methods and in chapter we introduce the td algorithm which seamlessly unifies them. as usual we start by focusing on the policy evaluation or prediction problem the problem of estimating the value function v for a given policy for the control problem an optimal policy dp td and monte carlo methods all use some variation of generalized policy iteration the differences in the methods are primarily differences in their approaches to the prediction problem. td prediction both td and monte carlo methods use experience to solve the prediction problem. given some experience following a policy both methods update their estimate v of v for the nonterminal states st occurring in that experience. roughly speaking monte carlo methods wait until the return following the visit is known then use that return as a target for v a simple every-visit monte carlo method suitable for nonstationary environments is v v v chapter temporal-difference learning where gt is the actual return following time t and is a constant step-size parameter equation let us call this method constant- mc. whereas monte carlo methods must wait until the end of the episode to determine the increment to v then is gt known td methods need to wait only until the next time step. at time t they immediately form a target and make a useful update using the observed reward and the estimate v the simplest td method makes the update v v v v immediately on transition to and receiving in effect the target for the monte carlo update is gt whereas the target for the td update is v this td method is called or one-step td because it is a special case of the td and n-step td methods developed in chapter and chapter the box below specifies completely in procedural form. tabular for estimating v input the policy to be evaluated algorithm parameter step size initialize v for all s s arbitrarily except that v loop for each episode initialize s loop for each step of episode a action given by for s take action a observe r v v v v s until s is terminal because bases its update in part on an existing estimate we say that it is a bootstrapping method like dp. we know from chapter that v e st s e st s e v st s roughly speaking monte carlo methods use an estimate of as a target whereas dp methods use an estimate of as a target. the monte carlo target is an estimate because the expected value in is not known a sample return is used in place of the real expected return. the dp target is an estimate not because of the expected values which are assumed to be completely provided by a model of the environment but because v is not known and the current estimate v is used instead. the td target is an estimate for both reasons it samples the expected values in and it uses the current estimate v instead of the true v thus td methods combine td prediction the sampling of monte carlo with the bootstrapping of dp. as we shall see with care and imagination this can take us a long way toward obtaining the advantages of both monte carlo and dp methods. shown to the right is the backup diagram for tabular the value estimate for the state node at the top of the backup diagram is updated on the basis of the one sample transition from it to the immediately following state. we refer to td and monte carlo updates as sample updates because they involve looking ahead to a sample successor state state action pair using the value of the successor and the reward along the way to compute a backed-up value and then updating the value of the original state state action pair accordingly. sample updates differ from the expected updates of dp methods in that they are based on a single sample successor rather than on a complete distribution of all possible successors. finally note that the quantity in brackets in the update is a sort of error measuring the difference between the estimated value of st and the better estimate v this quantity called the td error arises in various forms throughout reinforcement learning t v v notice that the td error at each time is the error in the estimate made at that time. because the td error depends on the next state and next reward it is not actually available until one time step later. that is t is the error in v available at time t also note that if the array v does not change during the episode it does not in monte carlo methods then the monte carlo error can be written as a sum of td errors gt v v v v t v t v t t t t t v t t t t t t k t k. this identity is not exact if v is updated during the episode it is in but if the step size is small then it may still hold approximately. generalizations of this identity play an important role in the theory and algorithms of temporal-difference learning. exercise if v changes during the episode then only holds approximately what would the difference be between the two sides? let vt denote the array of state values used at time t in the td error and in the td update redo the derivation above to determine the additional amount that must be added to the sum of td errors in order to equal the monte carlo error. chapter temporal-difference learning example driving home each day as you drive home from work you try to predict how long it will take to get home. when you leave your office you note the time the day of week the weather and anything else that might be relevant. say on this friday you are leaving at exactly o clock and you estimate that it will take minutes to get home. as you reach your car it is and you notice it is starting to rain. traffic is often slower in the rain so you reestimate that it will take minutes from then or a total of minutes. fifteen minutes later you have completed the highway portion of your journey in good time. as you exit onto a secondary road you cut your estimate of total travel time to minutes. unfortunately at this point you get stuck behind a slow truck and the road is too narrow to pass. you end up having to follow the truck until you turn onto the side street where you live at three minutes later you are home. the sequence of states times and predictions is thus as follows state leaving office friday at reach car raining exiting highway road behind truck entering home street arrive home elapsed time predicted predicted time to go total time the rewards in this example are the elapsed times on each leg of the we are not discounting and thus the return for each state is the actual time to go from that state. the value of each state is the expected time to go. the second column of numbers gives the current estimated value for each state encountered. a simple way to view the operation of monte carlo methods is to plot the predicted total time last column over the sequence as in figure the red arrows show the changes in predictions recommended by the constant- mc method for these are exactly the errors between the estimated value time to go in each state and the actual return time to go. for example when you exited the highway you thought it would take only minutes more to get home but in fact it took minutes. equation applies at this point and determines an increment in the estimate of time to go after exiting the highway. the error gt v at this time is eight minutes. suppose the step-size parameter is then the predicted time to go after exiting the highway would be revised upward by four minutes as a result of this experience. this is probably too large a change in this case the truck was probably just an unlucky break. in any event the change can only be made off-line that is after you have reached home. only at this point do you know any of the actual returns. is it necessary to wait until the final outcome is known before learning can begin? suppose on another day you again estimate when leaving your office that it will take minutes to drive home but then you become stuck in a massive traffic jam. twenty-five minutes after leaving the office you are still bumper-to-bumper on the highway. you now this were a control problem with the objective of minimizing travel time then we would of course make the rewards the negative of the elapsed time. but because we are concerned here only with prediction evaluation we can keep things simple by using positive numbers. advantages of td prediction methods figure changes recommended in the driving home example by monte carlo methods and td methods estimate that it will take another minutes to get home for a total of minutes. as you wait in traffic you already know that your initial estimate of minutes was too optimistic. must you wait until you get home before increasing your estimate for the initial state? according to the monte carlo approach you must because you don t yet know the true return. according to a td approach on the other hand you would learn immediately shifting your initial estimate from minutes toward in fact each estimate would be shifted toward the estimate that immediately follows it. returning to our first day of driving figure shows the changes in the predictions recommended by the td rule are the changes made by the rule if each error is proportional to the change over time of the prediction that is to the temporal differences in predictions. besides giving you something to do while waiting in traffic there are several computational reasons why it is advantageous to learn based on your current predictions rather than waiting until termination when you know the actual return. we briefly discuss some of these in the next section. exercise this is an exercise to help develop your intuition about why td methods are often more efficient than monte carlo methods. consider the driving home example and how it is addressed by td and monte carlo methods. can you imagine a scenario in which a td update would be better on average than a monte carlo update? give an example scenario a description of past experience and a current state in which you would expect the td update to be better. here s a hint suppose you have lots of experience driving home from work. then you move to a new building and a new parking lot you still enter the highway at the same place. now you are starting to learn predictions for the new building. can you see why td updates are likely to be much better at least initially in this case? might the same sort of thing happen in the original task? chapter temporal-difference learning advantages of td prediction methods td methods update their estimates based in part on other estimates. they learn a guess from a guess they bootstrap. is this a good thing to do? what advantages do td methods have over monte carlo and dp methods? developing and answering such questions will take the rest of this book and more. in this section we briefly anticipate some of the answers. obviously td methods have an advantage over dp methods in that they do not require a model of the environment of its reward and next-state probability distributions. the next most obvious advantage of td methods over monte carlo methods is that they are naturally implemented in an online fully incremental fashion. with monte carlo methods one must wait until the end of an episode because only then is the return known whereas with td methods one need wait only one time step. surprisingly often this turns out to be a critical consideration. some applications have very long episodes so that delaying all learning until the end of the episode is too slow. other applications are continuing tasks and have no episodes at all. finally as we noted in the previous chapter some monte carlo methods must ignore or discount episodes on which experimental actions are taken which can greatly slow learning. td methods are much less susceptible to these problems because they learn from each transition regardless of what subsequent actions are taken. but are td methods sound? certainly it is convenient to learn one guess from the next without waiting for an actual outcome but can we still guarantee convergence to the correct answer? happily the answer is yes. for any fixed policy has been proved to converge to v in the mean for a constant step-size parameter if it is sufficiently small and with probability if the step-size parameter decreases according to the usual stochastic approximation conditions most convergence proofs apply only to the table-based case of the algorithm presented above but some also apply to the case of general linear function approximation. these results are discussed in a more general setting in chapter if both td and monte carlo methods converge asymptotically to the correct predictions then a natural next question is which gets there first? in other words which method learns faster? which makes the more efficient use of limited data? at the current time this is an open question in the sense that no one has been able to prove mathematically that one method converges faster than the other. in fact it is not even clear what is the most appropriate formal way to phrase this question! in practice however td methods have usually been found to converge faster than constant- mc methods on stochastic tasks as illustrated in example advantages of td prediction methods example random walk in this example we empirically compare the prediction abilities of and constant- mc when applied to the following markov reward process a markov reward process or mrp is a markov decision process without actions. we will often use mrps when focusing on the prediction problem in which there is no need to distinguish the dynamics due to the environment from those due to the agent. in this mrp all episodes start in the center state c then proceed either left or right by one state on each step with equal probability. episodes terminate either on the extreme left or the extreme right. when an episode terminates on the right a reward of occurs all other rewards are zero. for example a typical episode might consist of the following state-and-reward sequence c b c d e because this task is undiscounted the true value of each state is the probability of terminating on the right if starting from that state. thus the true value of the center state is v the true values of all the states a through e are and the left graph above shows the values learned after various numbers of episodes on a single run of the estimates after episodes are about as close as they ever come to the true values with a constant step-size parameter in this example the values fluctuate indefinitely in response to the outcomes of the most recent episodes. the right graph shows learning curves for the two methods for various values of the performance measure shown is the root mean-squared error between the value function learned and the true value function averaged over the five states then averaged over runs. in all cases the approximate value function was initialized to the intermediate value v for all s. the td method was consistently better than the mc method on this task. episodestdmcrms erroraveragedover states rms error averaged over states chapter temporal-difference learning exercise from the results shown in the left graph of the random walk example it appears that the first episode results in a change in only v what does this tell you about what happened on the first episode? why was only the estimate for this one state changed? by exactly how much was it changed? exercise the specific results shown in the right graph of the random walk example are dependent on the value of the step-size parameter do you think the conclusions about which algorithm is better would be affected if a wider range of values were used? is there a different fixed value of at which either algorithm would have performed significantly better than shown? why or why not? exercise in the right graph of the random walk example the rms error of the td method seems to go down and then up again particularly at high s. what could have caused this? do you think this always occurs or might it be a function of how the approximate value function was initialized? exercise in example we stated that the true values for the random walk example are for states a through e. describe at least two different ways that these could have been computed. which would you guess we actually used? why? and optimality of suppose there is available only a finite amount of experience say episodes or time steps. in this case a common approach with incremental learning methods is to present the experience repeatedly until the method converges upon an answer. given an approximate value function v the increments specified by or are computed for every time step t at which a nonterminal state is visited but the value function is changed only once by the sum of all the increments. then all the available experience is processed again with the new value function to produce a new overall increment and so on until the value function converges. we call this batch updating because updates are made only after processing each complete batch of training data. under batch updating converges deterministically to a single answer independent of the step-size parameter as long as is chosen to be sufficiently small. the constant- mc method also converges deterministically under the same conditions but to a different answer. understanding these two answers will help us understand the difference between the two methods. under normal updating the methods do not move all the way to their respective batch answers but in some sense they take steps in these directions. before trying to understand the two answers in general for all possible tasks we first look at a few examples. example random walk under batch updating batch-updating versions of and constant- mc were applied as follows to the random walk prediction example after each new episode all episodes seen so far were treated as a batch. they were repeatedly presented to the algorithm either or constant- mc with sufficiently small that the value function converged. the resulting value function was then compared with v and the average root mean-squared error across the five states across independent repetitions of the whole experiment was plotted to obtain optimality of the learning curves shown in figure note that the batch td method was consistently better than the batch monte carlo method. under batch training constant- mc converges to values v that are sample averages of the actual returns experienced after visiting each state s. these are optimal estimates in the sense that they minimize the mean-squared error from the actual returns in the training set. in this sense it is surprising that the batch td method was able to perform better according to the root mean-squared error measure shown in the figure to the right. how is it that batch td was able to perform better than this optimal method? the answer is that the monte carlo method is optimal only in a limited way and that td is optimal in a way that is more relevant to predicting returns. figure performance of and constant- mc under batch training on the random walk task. example you are the predictor place yourself now in the role of the predictor of returns for an unknown markov reward process. suppose you observe the following eight episodes a b b b b b b b b this means that the first episode started in state a transitioned to b with a reward of and then terminated from b with a reward of the other seven episodes were even shorter starting from b and terminating immediately. given this batch of data what would you say are the optimal predictions the best values for the estimates v and v everyone would probably agree that the optimal value for v is because six out of the eight times in state b the process terminated immediately with a return of and the other two times in b the process terminated immediately with a return of but what is the optimal value for the estimate v given this data? here there are two reasonable answers. one is to observe that of the times the process was in state a it traversed immediately to b a reward of and because we have already decided that b has value therefore a must have value as well. one way of viewing this answer is that it is based on first modeling the markov process in this case as shown to the right and then computing the correct estimates given the model which indeed in this case gives v this is trainingwalks episodesrms erroraveragedover statesabr chapter temporal-difference learning also the answer that batch gives. the other reasonable answer is simply to observe that we have seen a once and the return that followed it was we therefore estimate v as this is the answer that batch monte carlo methods give. notice that it is also the answer that gives minimum squared error on the training data. in fact it gives zero error on the data. but still we expect the first answer to be better. if the process is markov we expect that the first answer will produce lower error on future data even though the monte carlo answer is better on the existing data. example illustrates a general difference between the estimates found by batch and batch monte carlo methods. batch monte carlo methods always find the estimates that minimize mean-squared error on the training set whereas batch always finds the estimates that would be exactly correct for the maximum-likelihood model of the markov process. in general the maximum-likelihood estimate of a parameter is the parameter value whose probability of generating the data is greatest. in this case the maximum-likelihood estimate is the model of the markov process formed in the obvious way from the observed episodes the estimated transition probability from i to j is the fraction of observed transitions from i that went to j and the associated expected reward is the average of the rewards observed on those transitions. given this model we can compute the estimate of the value function that would be exactly correct if the model were exactly correct. this is called the certainty-equivalence estimate because it is equivalent to assuming that the estimate of the underlying process was known with certainty rather than being approximated. in general batch converges to the certainty-equivalence estimate. this helps explain why td methods converge more quickly than monte carlo methods. in batch form is faster than monte carlo methods because it computes the true certainty-equivalence estimate. this explains the advantage of shown in the batch results on the random walk task the relationship to the certaintyequivalence estimate may also explain in part the speed advantage of nonbatch example page right graph. although the nonbatch methods do not achieve either the certainty-equivalence or the minimum squared-error estimates they can be understood as moving roughly in these directions. nonbatch may be faster than constant- mc because it is moving toward a better estimate even though it is not getting all the way there. at the current time nothing more definite can be said about the relative efficiency of online td and monte carlo methods. finally it is worth noting that although the certainty-equivalence estimate is in some sense an optimal solution it is almost never feasible to compute it directly. if n is the number of states then just forming the maximum-likelihood estimate of the process may require on the order of memory and computing the corresponding value function requires on the order of computational steps if done conventionally. in these terms it is indeed striking that td methods can approximate the same solution using memory no more than order n and repeated computations over the training set. on tasks with large state spaces td methods may be the only feasible way of approximating the certainty-equivalence solution. exercise design an off-policy version of the update that can be used with arbi sarsa on-policy td control trary target policy and covering behavior policy b using at each step t the importance sampling ratio tt sarsa on-policy td control we turn now to the use of td prediction methods for the control problem. as usual we follow the pattern of generalized policy iteration only this time using td methods for the evaluation or prediction part. as with monte carlo methods we face the need to trade off exploration and exploitation and again approaches fall into two main classes on-policy and off-policy. in this section we present an on-policy td control method. the first step is to learn an action-value function rather than a state-value function. in particular for an on-policy method we must estimate q a for the current behavior policy and for all states s and actions a. this can be done using essentially the same td method described above for learning v recall that an episode consists of an alternating sequence of states and state action pairs in the previous section we considered transitions from state to state and learned the values of states. now we consider transitions from state action pair to state action pair and learn the values of state action pairs. formally these cases are identical they are both markov chains with a reward process. the theorems assuring the convergence of state values under also apply to the corresponding algorithm for action values qst at qst at qst if this update is done after every transition from a nonterminal state st. is terminal then is defined as zero. this rule uses every element of the quintuple of events at that make up a transition from one state action pair to the next. this quintuple gives rise to the name sarsa for the algorithm. the backup diagram for sarsa is as shown to the right. sarsa exercise show that an action-value version of holds for the action-value form of the td error t qst at again assuming that the values don t change from step to step. it is straightforward to design an on-policy control algorithm based on the sarsa prediction method. as in all on-policy methods we continually estimate q for the behavior policy and at the same time change toward greediness with respect to q the general form of the sarsa control algorithm is given in the box on the next page. the convergence properties of the sarsa algorithm depend on the nature of the policy s dependence on q. for example one could use or policies. sarsa converges with probability to an optimal policy and action-value function as long as all state action pairs are visited an infinite number of times and the policy converges in the limit to the greedy policy can be arranged for example with policies by setting chapter temporal-difference learning sarsa td control for estimating q q algorithm parameters step size small initialize qs a for all s s a as arbitrarily except that qterminal loop for each episode initialize s choose a from s using policy derived from q loop for each step of episode take action a observe r choose from using policy derived from q qs a qs a qs s a until s is terminal example windy gridworld shown inset below is a standard gridworld with start and goal states but with one difference there is a crosswind running upward through the middle of the grid. the actions are the standard four up down right and left but in the middle region the resultant next states are shifted upward by a wind the strength of which varies from column to column. the strength of the wind is given below each column in number of cells shifted upward. for example if you are one cell to the right of the goal then the action left takes you to the cell just above the goal. this is an undiscounted episodic task with constant rewards of until the goal state is reached. the graph shows the results of applying sarsa to this task with and the initial values qs a for all s a. the increasing slope of the graph shows that the goal was reached more quickly over time. by time steps the greedy policy was long since optimal trajectory from it is shown inset continued exploration kept the average episode length at about steps two more than the minimum of note that monte carlo methods cannot easily be used on this task because termination is not guaranteed for all policies. if a policy was ever found that caused the agent to stay in the same state then the next episode would never end. step-by-step learning methods such as sarsa do not have this problem because they quickly learn during the episode that such policies are poor and switch to something else. exercise windy gridworld with king s moves re-solve the windy gridworld assum q-learning off-policy td control ing eight possible actions including the diagonal moves rather than the usual four. how much better can you do with the extra actions? can you do even better by including a ninth action that causes no movement at all other than that caused by the wind? exercise stochastic wind re-solve the windy gridworld task with king s moves assuming that the effect of the wind if there is any is stochastic sometimes varying by from the mean values given for each column. that is a third of the time you move exactly according to these values as in the previous exercise but also a third of the time you move one cell above that and another third of the time you move one cell below that. for example if you are one cell to the right of the goal and you move left then one-third of the time you move one cell above the goal one-third of the time you move two cells above the goal and one-third of the time you move to the goal. q-learning off-policy td control one of the early breakthroughs in reinforcement learning was the development of an off-policy td control algorithm known as q-learning defined by qst at qst at max a a qst in this case the learned action-value function q directly approximates q the optimal action-value function independent of the policy being followed. this dramatically simplifies the analysis of the algorithm and enabled early convergence proofs. the policy still has an effect in that it determines which state action pairs are visited and updated. however all that is required for correct convergence is that all pairs continue to be updated. as we observed in chapter this is a minimal requirement in the sense that any method guaranteed to find optimal behavior in the general case must require it. under this assumption and a variant of the usual stochastic approximation conditions on the sequence of step-size parameters q has been shown to converge with probability to q the q-learning algorithm is shown below in procedural form. q-learning td control for estimating algorithm parameters step size small initialize qs a for all s s a as arbitrarily except that qterminal loop for each episode initialize s loop for each step of episode choose a from s using policy derived from q take action a observe r qs a qs a maxa a qs s until s is terminal chapter temporal-difference learning what is the backup diagram for q-learning? the rule updates a state action pair so the top node the root of the update must be a small filled action node. the update is also from action nodes maximizing over all those actions possible in the next state. thus the bottom nodes of the backup diagram should be all these action nodes. finally remember that we indicate taking the maximum of these next action nodes with an arc across them can you guess now what the diagram is? if so please do make a guess before turning to the answer in figure on page example cliff walking this gridworld example compares sarsa and q-learning highlighting the difference between on-policy and off-policy methods. consider the gridworld shown to the right. this is a standard undiscounted episodic task with start and goal states and the usual actions causing movement up down right and left. reward is on all transitions except those into the region marked the cliff. stepping into this region incurs a reward of and sends the agent instantly back to the start. the graph to the right shows the performance of the sarsa and qlearning methods with action selection after an initial transient q-learning learns values for the optimal policy that which travels right along the edge of the cliff. unfortunately this results in its occasionally falling off the cliff because of the action selection. sarsa on the other hand takes the action selection into account and learns the longer but safer path through the upper part of the grid. although q-learning actually learns the values of the optimal policy its online performance is worse than that of sarsa which learns the roundabout policy. of course if were gradually reduced then both methods would asymptotically converge to the optimal policy. exercise why is q-learning considered an off-policy control method? exercise suppose action selection is greedy. is q-learning then exactly the same algorithm as sarsa? will they make exactly the same action selections and weight updates? rewardperepsiode!! episodessarsaq-learningsg the cliff rsum of rewardsduringepisoder pathoptimal pathr the cliffr of rewardsduringepisoder pathoptimal pathr expected sarsa expected sarsa consider the learning algorithm that is just like q-learning except that instead of the maximum over next state action pairs it uses the expected value taking into account how likely each action is under the current policy. that is consider the algorithm with the update rule qst at qst at qst a qst qst at but that otherwise follows the schema of q-learning. given the next state this algorithm moves deterministically in the same direction as sarsa moves in expectation and accordingly it is called expected sarsa. its backup diagram is shown on the right in figure expected sarsa is more complex computationally than sarsa but in return it eliminates the variance due to the random selection of given the same amount of experience we might expect it to perform slightly better than sarsa and indeed it generally does. figure shows summary results on the cliff-walking task with expected sarsa compared to sarsa and q-learning. expected sarsa retains the significant advantage of sarsa over q-learning on this problem. in addition expected sarsa shows a figure interim and asymptotic performance of td control methods on the cliff-walking task as a function of all algorithms used an policy with asymptotic performance is an average over episodes whereas interim performance is an average over the first episodes. these data are averages of over and runs for the interim and asymptotic cases respectively. the solid circles mark the best interim performance of each method. adapted from van seijen et al. usingan valuesincaseofexpectedsarsaandq-learning.thisindicatesthatthealgorithmshaveconvergedlongbeforetheendoftherunforall valuessincewedonotseeanyeffectoftheinitiallearningphase.forsarsatheperformancecomesclosetotheperformanceofexpectedsarsaonlyfor return n sarsan q learningn expected sarsan sarsan q learningn expected up up directioncorrespondingwiththewindstrength.forexamplewhentheagentisinthesquarerightofthegoalandtakesa left sarsasarsaq-learningasymptotic performanceinterim performanceq-learningsum of rewardsper episode chapter temporal-difference learning q-learning expected sarsa figure the backup diagrams for q-learning and expected sarsa. significant improvement over sarsa over a wide range of values for the step-size parameter in cliff walking the state transitions are all deterministic and all randomness comes from the policy. in such cases expected sarsa can safely set without suffering any degradation of asymptotic performance whereas sarsa can only perform well in the long run at a small value of at which short-term performance is poor. in this and other examples there is a consistent empirical advantage of expected sarsa over sarsa. in these cliff walking results expected sarsa was used on-policy but in general it might use a policy different from the target policy to generate behavior in which case it becomes an off-policy algorithm. for example suppose is the greedy policy while behavior is more exploratory then expected sarsa is exactly q-learning. in this sense expected sarsa subsumes and generalizes q-learning while reliably improving over sarsa. except for the small additional computational cost expected sarsa may completely dominate both of the other more-well-known td control algorithms. maximization bias and double learning all the control algorithms that we have discussed so far involve maximization in the construction of their target policies. for example in q-learning the target policy is the greedy policy given the current action values which is defined with a max and in sarsa the policy is often which also involves a maximization operation. in these algorithms a maximum over estimated values is used implicitly as an estimate of the maximum value which can lead to a significant positive bias. to see why consider a single state s where there are many actions a whose true values qs a are all zero but whose estimated values qs a are uncertain and thus distributed some above and some below zero. the maximum of the true values is zero but the maximum of the estimates is positive a positive bias. we call this maximization bias. example maximization bias example the small mdp shown inset in figure provides a simple example of how maximization bias can harm the performance of td control algorithms. the mdp has two non-terminal states a and b. episodes always start in a with a choice between two actions left and right. the right action transitions immediately to the terminal state with a reward and return of zero. the left action transitions to b also with a reward of zero from which there are many possible actions all of which cause immediate termination with a reward drawn from a normal distribution with mean and variance thus the expected return for any trajectory starting with left is and thus taking left in state a is always a mistake. nevertheless our maximization bias and double learning figure comparison of q-learning and double q-learning on a simple episodic mdp inset. q-learning initially learns to take the left action much more often than the right action and always takes it significantly more often than the minimum probability enforced by action selection with in contrast double q-learning is essentially unaffected by maximization bias. these data are averaged over runs. the initial actionvalue estimates were zero. any ties in action selection were broken randomly. control methods may favor left because of maximization bias making b appear to have a positive value. figure shows that q-learning with action selection initially learns to strongly favor the left action on this example. even at asymptote q-learning takes the left action about more often than is optimal at our parameter settings and are there algorithms that avoid maximization bias? to start consider a bandit case in which we have noisy estimates of the value of each of many actions obtained as sample averages of the rewards received on all the plays with each action. as we discussed above there will be a positive maximization bias if we use the maximum of the estimates as an estimate of the maximum of the true values. one way to view the problem is that it is due to using the same samples both to determine the maximizing action and to estimate its value. suppose we divided the plays in two sets and used them to learn two independent estimates call them and each an estimate of the true value qa for all a a. we could then use one estimate say to determine the maximizing action a argmaxa and the other to provide the estimate of its value this estimate will then be unbiased in the sense that qa we can also repeat the process with the role of the two estimates reversed to yield a second unbiased estimate this is the idea of double learning. note that although we learn two estimates only one estimate is updated on each play double learning doubles the memory requirements but does not increase the amount of computation per step. the idea of double learning extends naturally to algorithms for full mdps. for example the double learning algorithm analogous to q-learning called double q-learning divides the time steps in two perhaps by flipping a coin on each step. if the coin comes leftactionsfrom chapter temporal-difference learning up heads the update is at at argmax a if the coin comes up tails then the same update is done with and switched so that is updated. the two approximate value functions are treated completely symmetrically. the behavior policy can use both action-value estimates. for example an policy for double q-learning could be based on the average sum of the two action-value estimates. a complete algorithm for double q-learning is given in the box below. this is the algorithm used to produce the results in figure in that example double learning seems to eliminate the harm caused by maximization bias. of course there are also double versions of sarsa and expected sarsa. double q-learning for estimating q algorithm parameters step size small initialize a and a for all s s a as such that qterminal loop for each episode initialize s loop for each step of episode choose a from s using the policy in take action a observe r with probabilility else a a argmaxa a a argmaxa s until s is terminal exercise what are the update equations for double expected sarsa with an greedy target policy? games afterstates and other special cases in this book we try to present a uniform approach to a wide class of tasks but of course there are always exceptional tasks that are better treated in a specialized way. for example our general approach involves learning an action-value function but in chapter we presented a td method for learning to play tic-tac-toe that learned something much more like a state-value function. if we look closely at that example it becomes apparent that the function learned there is neither an action-value function nor a state-value function in the usual sense. a conventional state-value function evaluates states in which the agent has the option of selecting an action but the state-value function used in tictac-toe evaluates board positions after the agent has made its move. let us call these summary afterstates and value functions over these afterstate value functions. afterstates are useful when we have knowledge of an initial part of the environment s dynamics but not necessarily of the full dynamics. for example in games we typically know the immediate effects of our moves. we know for each possible chess move what the resulting position will be but not how our opponent will reply. afterstate value functions are a natural way to take advantage of this kind of knowledge and thereby produce a more efficient learning method. the reason it is more efficient to design algorithms in terms of afterstates is apparent from the tic-tac-toe example. a conventional action-value function would map from positions and moves to an estimate of the value. but many position move pairs produce the same resulting position as in the example shown to the right. in such cases the position move pairs are different but produce the same afterposition and thus must have the same value. a conventional action-value function would have to separately assess both pairs whereas an afterstate value function would immediately assess both equally. any learning about the position move pair on the left would immediately transfer to the pair on the right. afterstates arise in many tasks not just games. for example in queuing tasks there are actions such as assigning customers to servers rejecting customers or discarding information. in such cases the actions are in fact defined in terms of their immediate effects which are completely known. it is impossible to describe all the possible kinds of specialized problems and corresponding specialized learning algorithms. however the principles developed in this book should apply widely. for example afterstate methods are still aptly described in terms of generalized policy iteration with a policy and value function interacting in essentially the same way. in many cases one will still face the choice between on-policy and off-policy methods for managing the need for persistent exploration. exercise describe how the task of jack s car rental could be reformulated in terms of afterstates. why in terms of this specific task would such a reformulation be likely to speed convergence? summary in this chapter we introduced a new kind of learning method temporal-difference learning and showed how it can be applied to the reinforcement learning problem. as usual we divided the overall problem into a prediction problem and a control problem. td methods are alternatives to monte carlo methods for solving the prediction problem. in both cases the extension to the control problem is via the idea of generalized policy iteration that we abstracted from dynamic programming. this is the idea that xoxxoxoxx chapter temporal-difference learning approximate policy and value functions should interact in such a way that they both move toward their optimal values. one of the two processes making up gpi drives the value function to accurately predict returns for the current policy this is the prediction problem. the other process drives the policy to improve locally to be with respect to the current value function. when the first process is based on experience a complication arises concerning maintaining sufficient exploration. we can classify td control methods according to whether they deal with this complication by using an on-policy or off-policy approach. sarsa is an on-policy method and q-learning is an off-policy method. expected sarsa is also an off-policy method as we present it here. there is a third way in which td methods can be extended to control which we did not include in this chapter called actor critic methods. these methods are covered in full in chapter the methods presented in this chapter are today the most widely used reinforcement learning methods. this is probably due to their great simplicity they can be applied online with a minimal amount of computation to experience generated from interaction with an environment they can be expressed nearly completely by single equations that can be implemented with small computer programs. in the next few chapters we extend these algorithms making them slightly more complicated and significantly more powerful. all the new algorithms will retain the essence of those introduced here they will be able to process experience online with relatively little computation and they will be driven by td errors. the special cases of td methods introduced in the present chapter should rightly be called one-step tabular model-free td methods. in the next two chapters we extend them to n-step forms link to monte carlo methods and forms that include a model of the environment link to planning and dynamic programming. then in the second part of the book we extend them to various forms of function approximation rather than tables link to deep learning and artificial neural networks. finally in this chapter we have discussed td methods entirely within the context of reinforcement learning problems but td methods are actually more general than this. they are general methods for learning to make long-term predictions about dynamical systems. for example td methods may be relevant to predicting financial data life spans election outcomes weather patterns animal behavior demands on power stations or customer purchases. it was only when td methods were analyzed as pure prediction methods independent of their use in reinforcement learning that their theoretical properties first came to be well understood. even so these other potential applications of td learning methods have not yet been extensively explored. summary bibliographical and historical remarks as we outlined in chapter the idea of td learning has its early roots in animal learning psychology and artificial intelligence most notably the work of samuel and klopf samuel s work is described as a case study in section also related to td learning are holland s early ideas about consistency among value predictions. these influenced one of the authors who was a graduate student from to at the university of michigan where holland was teaching. holland s ideas led to a number of td-related systems including the work of booker and the bucket brigade of holland which is related to sarsa as discussed below. most of the specific material from these sections is from sutton including the algorithm the random walk example and the term temporaldifference learning. the characterization of the relationship to dynamic programming and monte carlo methods was influenced by watkins werbos and others. the use of backup diagrams was new to the first edition of this book. tabular was proved to converge in the mean by sutton and with probability by dayan based on the work of watkins and dayan these results were extended and strengthened by jaakkola jordan and singh and tsitsiklis by using extensions of the powerful existing theory of stochastic approximation. other extensions and generalizations are covered in later chapters. the optimality of the td algorithm under batch training was established by sutton illuminating this result is barnard s derivation of the td algorithm as a combination of one step of an incremental method for learning a model of the markov chain and one step of a method for computing predictions from the model. the term certainty equivalence is from the adaptive control literature goodwin and sin the sarsa algorithm was introduced by rummery and niranjan they explored it in conjunction with neural networks and called it modified connectionist q-learning the name sarsa was introduced by sutton the convergence of one-step tabular sarsa form treated in this chapter has been proved by singh jaakkola littman and szepesv ari the windy gridworld example was suggested by tom kalt. holland s bucket brigade idea evolved into an algorithm closely related to sarsa. the original idea of the bucket brigade involved chains of rules triggering each other it focused on passing credit back from the current rule to the rules that triggered it. over time the bucket brigade came to be more like td learning in passing credit back to any temporally preceding rule not just to the ones that triggered the current rule. the modern form of the bucket brigade when simplified in various natural ways is nearly identical to one-step sarsa as detailed by wilson chapter temporal-difference learning q-learning was introduced by watkins whose outline of a convergence proof was made rigorous by watkins and dayan more general convergence results were proved by jaakkola jordan and singh and tsitsiklis the expected sarsa algorithm was introduced by george john who called it q-learning and stressed its advantages over q-learning as an offpolicy algorithm. john s work was not known to us when we presented expected sarsa in the first edition of this book as an exercise or to van seijen van hasselt whiteson and weiring when they established expected sarsa s convergence properties and conditions under which it will outperform regular sarsa and q-learning. our figure is adapted from their results. van seijen et al. defined expected sarsa to be an on-policy method exclusively we did in the first edition whereas now we use this name for the general algorithm in which the target and behavior policies may differ. the general off-policy view of expected sarsa was noted by van hasselt who called it general q-learning. maximization bias and double learning were introduced and extensively investigated by van hasselt the example mdp in figure was adapted from that in his figure hasselt the notion of an afterstate is the same as that of a post-decision state roy bertsekas lee and tsitsiklis powell chapter n-step bootstrapping in this chapter we unify the monte carlo methods and the one-step temporaldifference methods presented in the previous two chapters. neither mc methods nor one-step td methods are always the best. in this chapter we present n-step td methods that generalize both methods so that one can shift from one to the other smoothly as needed to meet the demands of a particular task. n-step methods span a spectrum with mc methods at one end and one-step td methods at the other. the best methods are often intermediate between the two extremes. another way of looking at the benefits of n-step methods is that they free you from the tyranny of the time step. with one-step td methods the same time step determines how often the action can be changed and the time interval over which bootstrapping is done. in many applications one wants to be able to update the action very fast to take into account anything that has changed but bootstrapping works best if it is over a length of time in which a significant and recognizable state change has occurred. with one-step td methods these time intervals are the same and so a compromise must be made. n-step methods enable bootstrapping to occur over multiple steps freeing us from the tyranny of the single time step. the idea of n-step methods is usually used as an introduction to the algorithmic idea of eligibility traces which enable bootstrapping over multiple time intervals simultaneously. here we instead consider the n-step bootstrapping idea on its own postponing the treatment of eligibility-trace mechanisms until later. this allows us to separate the issues better dealing with as many of them as possible in the simpler n-step setting. as usual we first consider the prediction problem and then the control problem. that is we first consider how n-step methods can help in predicting returns as a function of state for a fixed policy in estimating v then we extend the ideas to action values and control methods. chapter n-step bootstrapping n-step td prediction what is the space of methods lying between monte carlo and td methods? consider estimating v from sample episodes generated using monte carlo methods perform an update for each state based on the entire sequence of observed rewards from that state until the end of the episode. the update of one-step td methods on the other hand is based on just the one next reward bootstrapping from the value of the state one step later as a proxy for the remaining rewards. one kind of intermediate method then would perform an update based on an intermediate number of rewards more than one but less than all of them until termination. for example a two-step update would be based on the first two rewards and the estimated value of the state two steps later. similarly we could have three-step updates four-step updates and so on. figure shows the backup diagrams of the spectrum of n-step updates for v with the one-step td update on the left and the up-until-termination monte carlo update on the right. figure the backup diagrams of n-step methods. these methods form a spectrum ranging from one-step td methods to monte carlo methods. the methods that use n-step updates are still td methods because they still change an earlier estimate based on how it differs from a later estimate. now the later estimate is not one step later but n steps later. methods in which the temporal difference extends over n steps are called n-step td methods. the td methods introduced in the previous chapter all used one-step updates which is why we called them one-step td methods. more formally consider the update of the estimated value of state st as a result of the state reward sequence st rt st the actions. we know that in monte carlo updates the estimate of v is updated in the direction of tdand tdn-step td tdand monte carlo n-step td prediction the complete return gt t t where t is the last time step of the episode. let us call this quantity the target of the update. whereas in monte carlo updates the target is the return in one-step updates the target is the first reward plus the discounted estimated value of the next state which we call the one-step return where vt s r here is the estimate at time t of v the subscripts on indicate that it is a truncated return for time t using rewards up until time t with the discounted estimate taking the place of the other terms t t of the full return as discussed in the previous chapter. our point now is that this idea makes just as much sense after two steps as it does after one. the target for a two-step update is the two-step return where now corrects for the absence of the terms t t similarly the target for an arbitrary n-step update is the n-step return gttn n nvtn for all n t such that n and t t n. all n-step returns can be considered approximations to the full return truncated after n steps and then corrected for the remaining missing terms by vtn if t n t the n-step return extends to or beyond termination then all the missing terms are taken as zero and the n-step return defined to be equal to the ordinary full return gt if t n t note that n-step returns for n involve future rewards and states that are not available at the time of transition from t to t no real algorithm can use the nstep return until after it has seen rtn and computed vtn the first time these are available is t n. the natural state-value learning algorithm for using n-step returns is thus vtnst vtn vtn t t while the values of all other states remain unchanged vtns vtn for all st. we call this algorithm n-step td. note that no changes at all are made during the first n steps of each episode. to make up for that an equal number of additional updates are made at the end of the episode after termination and before starting the next episode. complete pseudocode is given in the box on the next page. exercise in chapter we noted that the monte carlo error can be written as the sum of td errors if the value estimates don t change from step to step. show that the n-step error used in can also be written as a sum td errors if the value estimates don t change generalizing the earlier result. exercise with an n-step method the value estimates do change from step to step so an algorithm that used the sum of td errors previous exercise in chapter n-step bootstrapping n-step td for estimating v v input a policy algorithm parameters step size a positive integer n initialize v arbitrarily for all s s all store and access operations st and rt can take their index mod n loop for each episode take an action according to observe and store the next reward as and the next state as if is terminal then t t is the time whose state s estimate is being updated if t t then initialize and store terminal t loop for t until t g t n if i i if n t then g g nv v v v place of the error in would actually be a slightly different algorithm. would it be a better algorithm or a worse one? devise and program a small experiment to answer this question empirically. the n-step return uses the value function vtn to correct for the missing rewards beyond rtn. an important property of n-step returns is that their expectation is guaranteed to be a better estimate of v than vtn is in a worst-state sense. that is the worst error of the expected n-step return is guaranteed to be less than or equal to n times the worst error under vtn max s s v n max s v for all n this is called the error reduction property of n-step returns. because of the error reduction property one can show formally that all n-step td methods converge to the correct predictions under appropriate technical conditions. the n-step td methods thus form a family of sound methods with one-step td methods and monte carlo methods as extreme members. example n-step td methods on the random walk consider using n-step td methods on the random walk task described in example suppose the first episode progressed directly from the center state c to the right through d and e and then terminated on the right with a return of recall that the estimated values of all the states started at an intermediate value v as a result of this experience a one-step method would change only the estimate for the last state n-step sarsa v which would be incremented toward the observed return. a two-step method on the other hand would increment the values of the two states preceding termination v and v both would be incremented toward a three-step method or any n-step method for n would increment the values of all three of the visited states toward all by the same amount. figure performance of n-step td methods as a function of for various values of n on a random walk task which value of n is better? figure shows the results of a simple empirical test for a larger random walk process with states instead of with a outcome on the left all values initialized to which we use as a running example in this chapter. results are shown for n-step td methods with a range of values for n and the performance measure for each parameter setting shown on the vertical axis is the square-root of the average squared error between the predictions at the end of the episode for the states and their true values then averaged over the first episodes and repetitions of the whole experiment same sets of walks were used for all parameter settings. note that methods with an intermediate value of n worked best. this illustrates how the generalization of td and monte carlo methods to n-step methods can potentially perform better than either of the two extreme methods. exercise why do you think a larger random walk task states instead of was used in the examples of this chapter? would a smaller walk have shifted the advantage to a different value of n? how about the change in left-side outcome from to made in the larger walk? do you think that made any difference in the best value of n? n-step sarsa how can n-step methods be used not just for prediction but for control? in this section we show how n-step methods can be combined with sarsa in a straightforward way to averagerms errorover statesand first chapter n-step bootstrapping produce an on-policy td control method. the n-step version of sarsa we call n-step sarsa and the original version presented in the previous chapter we henceforth call one-step sarsa or the main idea is to simply switch states for actions action pairs and then use an policy. the backup diagrams for n-step sarsa in figure like those of n-step td are strings of alternating states and actions except that the sarsa ones all start and end with an action rather a state. we redefine n-step returns targets in terms of estimated action values gttn n nqtn atn n t t n with gttn gt if t n t the natural algorithm is then qtnst at qtn at qtn at t t while the values of all other states remain unchanged qtns a qtn a for all s a such that s st or a at. this is the algorithm we call n-step sarsa. pseudocode is shown in the box on the next page and an example of why it can speed up learning compared to one-step methods is given in figure figure the backup diagrams for the spectrum of n-step methods for state action values. they range from the one-step update of to the up-until-termination update of the monte carlo method. in between are the n-step updates based on n steps of real rewards and the estimated value of the nth next state action pair all appropriately discounted. on the far right is the backup diagram for n-step expected sarsa. sarsaaka sarsan-step sarsa sarsaaka monte carlon-step expected sarsa n-step sarsa n-step sarsa for estimating q q or q initialize qs a arbitrarily for all s s a a initialize to be with respect to q or to a fixed given policy algorithm parameters step size small a positive integer n all store and access operations st at and rt can take their index mod n loop for each episode if t t then initialize and store terminal select and store an action t loop for t until t g t n if i i else t t select and store an action is the time whose estimate is being updated take action at observe and store the next reward as and the next state as if is terminal then if n t then g g nqs a qs a qs a qs a if is being learned then ensure that is wrt q figure gridworld example of the speedup of policy learning due to the use of n-step methods. the first panel shows the path taken by an agent in a single episode ending at a location of high reward marked by the g. in this example the values were all initially and all rewards were zero except for a positive reward at g. the arrows in the other two panels show which action values were strengthened as a result of this path by one-step and n-step sarsa methods. the one-step method strengthens only the last action of the sequence of actions that led to the high reward whereas the n-step method strengthens the last n actions of the sequence so that much more is learned from the one episode. path takenaction values increasedby one-step sarsaaction values increased by sarsaggg chapter n-step bootstrapping exercise prove that the n-step return of sarsa can be written exactly in terms of a novel td error as mintnt gttn qt at k t qk ak what about expected sarsa? the backup diagram for the n-step version of expected sarsa is shown on the far right in figure it consists of a linear string of sample actions and states just as in n-step sarsa except that its last element is a branch over all action possibilities weighted as always by their probability under this algorithm can be described by the same equation as n-step sarsa except with the n-step return redefined as gttn vts gttn s using the estimated action values at time t under the target policy n n vtn gt for t n t where vts is the expected approximate value of state a for all s s. expected approximate values are used in developing many of the action-value methods in the rest of this book. if s is terminal then its expected approximate value is defined to be t n t n-step off-policy learning by importance sam pling recall that off-policy learning is learning the value function for one policy while following another policy b. often is the greedy policy for the current action-valuefunction estimate and b is a more exploratory policy perhaps in order to use the data from b we must take into account the difference between the two policies using their relative probability of taking the actions that were taken section in n-step methods returns are constructed over n steps so we are interested in the relative probability of just those n actions. for example to make a simple off-policy version of n-step td the update for time t made at time t n can simply be weighted by ttn vtn ttn vtn where ttn called the importance sampling ratio is the relative probability under the two policies of taking the n actions from at to atn eq. t t vtnst th minht baksk n-step off-policy learning by importance sampling for example if any one of the actions would never be taken by then the n-step return should be given zero weight and be totally ignored. on the other hand if by chance an action is taken that would take with much greater probability than b does then this will increase the weight that would otherwise be given to the return. this makes sense because that action is characteristic of therefore we want to learn about it but is selected only rarely by b and thus rarely appears in the data. to make up for this we have to over-weight it when it does occur. note that if the two policies are actually the same on-policy case then the importance sampling ratio is always thus our new update generalizes and can completely replace our earlier n-step td update. similarly our previous n-step sarsa update can be completely replaced by a simple off-policy form qtnst at qtn at qtn at for t t note that the importance sampling ratio here starts one step later than for n-step td this is because here we are updating a state action pair. we do not have to care how likely we were to select the action now that we have selected it we want to learn fully from what happens with importance sampling only for subsequent actions. pseudocode for the full algorithm is shown in the box below. off-policy n-step sarsa for estimating q q or q input an arbitrary behavior policy b such that bas for all s s a a initialize qs a arbitrarily for all s s a a initialize to be greedy with respect to q or as a fixed given policy algorithm parameters step size a positive integer n all store and access operations st at and rt can take their index mod n take action at observe and store the next reward as and the next state as if is terminal then t t select and store an action b else is the time whose estimate is being updated loop for each episode if t t then initialize and store terminal select and store an action b t loop for t until t g t n if baisi i i i if n t then g g nqs a qs a qs a qs a if is being learned then ensure that is greedy wrt q chapter n-step bootstrapping the off-policy version of n-step expected sarsa would use the same update as above for n-step sarsa except that the importance sampling ratio would have one less factor in it. that is the above equation would use instead of and of course it would use the expected sarsa version of the n-step return this is because in expected sarsa all possible actions are taken into account in the last state the one actually taken has no effect and does not have to be corrected for. off-policy methods with control variates the multi-step off-policy methods presented in the previous section are simple and conceptually clear but are probably not the most efficient. a more sophisticated approach would use per-decision importance sampling ideas such as were introduced in section to understand this approach first note that the ordinary n-step return like all returns can be written recursively. for the n steps ending at horizon h the n-step return can be written gth t h t where ghh vh that this return is used at time h previously denoted t n. now consider the effect of following a behavior policy b that is not the same as the target policy all of the resulting experience including the first reward and the next state must be weighted by the importance sampling ratio for time t t batst one might be tempted to simply weight the righthand side of the above equation but one can do better. suppose the action at time t would never be selected by so that t is zero. then a simple weighting would result in the n-step return being zero which could result in high variance when it was used as a target. instead in this more sophisticated approach one uses an alternate off-policy definition of the n-step return ending at horizon h as gth t tvh t h t where again ghh vh in this approach if t is zero then instead of the target being zero and causing the estimate to shrink the target is the same as the estimate and causes no change. the importance sampling ratio being zero means we should ignore the sample so leaving the estimate unchanged seems appropriate. the second additional term in is called a control variate obscure reasons. notice that the control variate does not change the expected update the importance sampling ratio has expected value one and is uncorrelated with the estimate so the expected value of the control variate is zero. also note that the off-policy definition is a strict generalization of the earlier on-policy definition of the n-step return as the two are identical in the on-policy case in which t is always for a conventional n-step method the learning rule to use in conjunction with is the n-step td update which has no explicit importance sampling ratios other per-decision off-policy methods with control variates than those embedded in the return. exercise write the pseudocode for the off-policy state-value prediction algorithm described above. for action values the off-policy definition of the n-step return is a little different because the first action does not play a role in the importance sampling. that first action is the one being learned it does not matter if it was unlikely or even impossible under the target policy it has been taken and now full unit weight must be given to the reward and state that follows it. importance sampling will apply only to the actions that follow it. first note that for action values the n-step on-policy return ending at horizon h expectation form can be written recursively just as in except that for vh as in an off-policy form action values the recursion ends with ghh with control variates is gth vh qh vh t h t. if h t then the recursion ends with ghh sion ends with and gt with is analogous to expected sarsa. qh ah whereas if h t the recur. rt the resultant prediction algorithm combining exercise prove that the control variate in the above equations does not change the expected value of the return. exercise write the pseudocode for the off-policy action-value prediction algorithm described immediately above. pay particular attention to the termination conditions for the recursion upon hitting the horizon or the end of episode. exercise show that the general version of the n-step return can still be written exactly and compactly as the sum of state-based td errors if the approximate state value function does not change. exercise repeat the above exercise for the action version of the off-policy n-step return and the expected sarsa td error quantity in brackets in equation exercise devise a small off-policy prediction problem and use it to show that the off-policy learning algorithm using and is more data efficient than the simpler algorithm using and the importance sampling that we have used in this section the previous section and in chapter enables sound off-policy learning but also results in high variance updates forcing the use of a small step-size parameter and thereby causing learning to be slow. it is probably inevitable that off-policy training is slower than on-policy training after all the data is less relevant to what is being learned. however it is probably also true that these methods can be improved on. the control variates are one way of reducing the variance. another is to rapidly adapt the step sizes to the observed variance as in the chapter n-step bootstrapping autostep method sutton degris and pilarski yet another promising approach is the invariant updates of karampatziakis and langford as extended to td by tian preparation. the usage technique of mahmood mahmood and sutton may also be part of the solution. in the next section we consider an off-policy learning method that does not use importance sampling. off-policy learning without importance sampling the n-step tree backup algorithm is off-policy learning possible without importance sampling? q-learning and expected sarsa from chapter do this for the one-step case but is there a corresponding multi-step algorithm? in this section we present just such an n-step method called the tree-backup algorithm. the idea of the algorithm is suggested by the tree-backup backup diagram shown to the right. down the central spine and labeled in the diagram are three sample states and rewards and two sample actions. these are the random variables representing the events occurring after the initial state action pair st at. hanging off to the sides of each state are the actions that were not selected. the last state all the actions are considered to have not been selected. because we have no sample data for the unselected actions we bootstrap and use the estimates of their values in forming the target for the update. this slightly extends the idea of a backup diagram. so far we have always updated the estimated value of the node at the top of the diagram toward a target combining the rewards along the way discounted and the estimated values of the nodes at the bottom. in the tree-backup update the target includes all these things plus the estimated values of the dangling action nodes hanging off the sides at all levels. this is why it is called a tree-backup update it is an update from the entire tree of estimated action values. the tree-backup update more precisely the update is from the estimated action values of the leaf nodes of the tree. the action nodes in the interior corresponding to the actual actions taken do not participate. each leaf node contributes to the target with a weight proportional to its probability of occurring under the target policy thus each first-level action a contributes with a weight of except that the action actually taken does not contribute at all. its probability is used to weight all the second-level action values. thus each non-selected secondlevel action contributes with weight each third-level action contributes with weight and so on. it is as if each arrow to an action node in the diagram is weighted by the action s probability of being selected under the target policy and if there is a tree below the action then that weight applies to all the leaf nodes in the tree. off-policy learning without importance sampling n-step tree backup we can think of the tree-backup update as consisting of half-steps alternating between sample half-steps from an action to a subsequent state and expected half-steps considering from that state all possible actions with their probabilities of occuring under the policy. now let us develop the detailed equations for the n-step tree-backup algorithm. the one-step return is the same as that of expected sarsa a t t and the two-step tree-backup return is a a t t the latter form suggests the general recursive definition of the tree-backup n-step return gttn a t t with the n case handled by gt the usual action-value update rule from n-step sarsa rt and this target is then used with qtnst at qtn at qtn at t t while the values of all other state action pairs remain unchanged qtns a qtn a for all s a such that st or at. pseudocode for this algorithm is shown in the box on the next page. exercise show that if the approximate action values are unchanging then the tree-backup return can be written as a sum of expectation-based td errors gttn qst at mintn k where t qst at and vt is given by chapter n-step bootstrapping n-step tree backup for estimating q q or q initialize qs a arbitrarily for all s s a a initialize to be greedy with respect to q or as a fixed given policy algorithm parameters step size a positive integer n all store and access operations can take their index mod n loop for each episode if t t take action at observe and store the next reward and state as if is terminal else t t choose an action arbitrarily as a function of store initialize and store terminal choose an action arbitrarily as a function of store t loop for t until t g a g rk t n if if t t g rt else loop for k mint t down through qs a qs a qs a if is being learned then ensure that is greedy wrt q a is the time whose estimate is being updated unifying algorithm n-step q so far in this chapter we have considered three different kinds of action-value algorithms corresponding to the first three backup diagrams shown in figure n-step sarsa has all sample transitions the tree-backup algorithm has all state-to-action transitions fully branched without sampling and n-step expected sarsa has all sample transitions except for the last state-to-action one which is fully branched with an expected value. to what extent can these algorithms be unified? one idea for unification is suggested by the fourth backup diagram in figure this is the idea that one might decide on a step-by-step basis whether one wanted to take the action as a sample as in sarsa or consider the expectation over all actions instead as in the tree-backup update. then if one chose always to sample one would obtain sarsa whereas if one chose never to sample one would get the tree-backup algorithm. expected sarsa would be the case where one chose to sample for all steps except for a unifying algorithm n-step q figure the backup diagrams of the three kinds of n-step action-value updates considered so far in this chapter case plus the backup diagram of a fourth kind of update that unifies them all. the s indicate half transitions on which importance sampling is required in the off-policy case. the fourth kind of update unifies all the others by choosing on a state-by-state basis whether to sample t or not t the last one. and of course there would be many other possibilities as suggested by the last diagram in the figure. to increase the possibilities even further we can consider a continuous variation between sampling and expectation. let t denote the degree of sampling on step t with denoting full sampling and denoting a pure expectation with no sampling. the random variable t might be set as a function of the state action or state action pair at time t. we call this proposed new algorithm n-step q now let us develop the equations of n-step q first we write the tree-backup n-step return in terms of the horizon h t n and then the expected approximate value v gth a vh qh vh after which it is exactly like the n-step return for sarsa with control variates except with the action probability substituted for the importance-sampling ratio q chapter n-step bootstrapping for q we slide linearly between these two cases gth qh vh for t h t the recursion ends with ghh rt if h t then we the usual general update for n-step sarsa a complete algorithm is given in the box. if h t or with gt off-policy n-step q for estimating q q or q input an arbitrary behavior policy b such that bas for all s s a a initialize qs a arbitrarily for all s s a a initialize to be with respect to q or as a fixed given policy algorithm parameters step size small a positive integer n all store and access operations can take their index mod n loop for each episode take action at observe and store the next reward and state as if is terminal else t t choose and store an action b select and store store if t t initialize and store terminal choose and store an action b t loop for t until t as g rt if k t is the time whose estimate is being updated t n if g loop for k mint t down through else v a g rk k k k qsk v qs a qs a qs a if is being learned then ensure that is greedy wrt q summary summary in this chapter we have developed a range of temporal-difference learning methods that lie in between the one-step td methods of the previous chapter and the monte carlo methods of the chapter before. methods that involve an intermediate amount of bootstrapping are important because they will typically perform better than either extreme. our focus in this chapter has been on n-step methods which look ahead to the next n rewards states and actions. the two backup diagrams to the right together summarize most of the methods introduced. the state-value update shown is for nstep td with importance sampling and the action-value update is for n-step q which generalizes expected sarsa and q-learning. all n-step methods involve a delay of n time steps before updating as only then are all the required future events known. a further drawback is that they involve more computation per time step than previous methods. compared to one-step methods n-step methods also require more memory to record the states actions rewards and sometimes other variables over the last n time steps. eventually in chapter we will see how multi-step td methods can be implemented with minimal memory and computational complexity using eligibility traces but there will always be some additional computation beyond one-step methods. such costs can be well worth paying to escape the tyranny of the single time step. although n-step methods are more complex than those using eligibility traces they have the great benefit of being conceptually clear. we have sought to take advantage of this by developing two approaches to off-policy learning in the n-step case. one based on importance sampling is conceptually simple but can be of high variance. if the target and behavior policies are very different it probably needs some new algorithmic ideas before it can be efficient and practical. the other based on tree-backup updates is the natural extension of q-learning to the multi-step case with stochastic target policies. it involves no importance sampling but again if the target and behavior policies are substantially different the bootstrapping may span only a few steps even if n is large. q chapter n-step bootstrapping bibliographical and historical remarks the notion of n-step returns is due to watkins who also first discussed their error reduction property. n-step algorithms were explored in the first edition of this book in which they were treated as of conceptual interest but not feasible in practice. the work of cichosz and particularly van seijen showed that they are actually completely practical algorithms. given this and their conceptual clarity and simplicity we have chosen to highlight them here in the second edition. in particular we now postpone all discussion of the backward view and of eligibility traces until chapter the results in the random walk examples were made for this text based on work of sutton and singh and sutton the use of backup diagrams to describe these and other algorithms in this chapter is new. the developments in these sections are based on the work of precup sutton and singh precup sutton and dasgupta and sutton mahmood precup and van hasselt the tree-backup algorithm is due to precup sutton and singh but the presentation of it here is new. the q algorithm is new to this text but closely related algorithms have been explored further by de asis hernandez-garcia holland and sutton chapter planning and learning with tabular methods in this chapter we develop a unified view of reinforcement learning methods that require a model of the environment such as dynamic programming and heuristic search and methods that can be used without a model such as monte carlo and temporal-difference methods. these are respectively called model-based and model-free reinforcement learning methods. model-based methods rely on planning as their primary component while model-free methods primarily rely on learning. although there are real differences between these two kinds of methods there are also great similarities. in particular the heart of both kinds of methods is the computation of value functions. moreover all the methods are based on looking ahead to future events computing a backed-up value and then using it as an update target for an approximate value function. earlier in this book we presented monte carlo and temporal-difference methods as distinct alternatives then showed how they can be unified by n-step methods. our goal in this chapter is a similar integration of model-based and model-free methods. having established these as distinct in earlier chapters we now explore the extent to which they can be intermixed. models and planning by a model of the environment we mean anything that an agent can use to predict how the environment will respond to its actions. given a state and an action a model produces a prediction of the resultant next state and next reward. if the model is stochastic then there are several possible next states and next rewards each with some probability of occurring. some models produce a description of all possibilities and their probabilities these we call distribution models. other models produce just one of the possibilities sampled according to the probabilities these we call sample models. for example consider modeling the sum of a dozen dice. a distribution model would produce all possible sums and their probabilities of occurring whereas a sample model chapter planning and learning with tabular methods would produce an individual sum drawn according to this probability distribution. the kind of model assumed in dynamic programming estimates of the mdp s dynamics rs a is a distribution model. the kind of model used in the blackjack example in chapter is a sample model. distribution models are stronger than sample models in that they can always be used to produce samples. however in many applications it is much easier to obtain sample models than distribution models. the dozen dice are a simple example of this. it would be easy to write a computer program to simulate the dice rolls and return the sum but harder and more error-prone to figure out all the possible sums and their probabilities. models can be used to mimic or simulate experience. given a starting state and action a sample model produces a possible transition and a distribution model generates all possible transitions weighted by their probabilities of occurring. given a starting state and a policy a sample model could produce an entire episode and a distribution model could generate all possible episodes and their probabilities. in either case we say the model is used to simulate the environment and produce simulated experience. the word planning is used in several different ways in different fields. we use the term to refer to any computational process that takes a model as input and produces or improves a policy for interacting with the modeled environment in artificial intelligence there are two distinct approaches to planning according to our definition. state-space planning which includes the approach we take in this book is viewed primarily as a search through the state space for an optimal policy or an optimal path to a goal. actions cause transitions from state to state and value functions are computed over states. in what we call plan-space planning planning is instead a search through the space of plans. operators transform one plan into another and value functions if any are defined over the space of plans. plan-space planning includes evolutionary methods and partial-order planning a common kind of planning in artificial intelligence in which the ordering of steps is not completely determined at all stages of planning. plan-space methods are difficult to apply efficiently to the stochastic sequential decision problems that are the focus in reinforcement learning and we do not consider them further see e.g. russell and norvig the unified view we present in this chapter is that all state-space planning methods share a common structure a structure that is also present in the learning methods presented in this book. it takes the rest of the chapter to develop this view but there are two basic ideas all state-space planning methods involve computing value functions as a key intermediate step toward improving the policy and they compute value functions by updates or backup operations applied to simulated experience. this common structure can be diagrammed as follows dynamic programming methods clearly fit this structure they make sweeps through the space of states generating for each state the distribution of possible transitions. each planningmodelpolicyvaluesbackupsmodelsimulatedexperiencepolicyupdatesbackups dyna integrated planning acting and learning distribution is then used to compute a backed-up value target and update the state s estimated value. in this chapter we argue that various other state-space planning methods also fit this structure with individual methods differing only in the kinds of updates they do the order in which they do them and in how long the backed-up information is retained. viewing planning methods in this way emphasizes their relationship to the learning methods that we have described in this book. the heart of both learning and planning methods is the estimation of value functions by backing-up update operations. the difference is that whereas planning uses simulated experience generated by a model learning methods use real experience generated by the environment. of course this difference leads to a number of other differences for example in how performance is assessed and in how flexibly experience can be generated. but the common structure means that many ideas and algorithms can be transferred between planning and learning. in particular in many cases a learning algorithm can be substituted for the key update step of a planning method. learning methods require only experience as input and in many cases they can be applied to simulated experience just as well as to real experience. the box below shows a simple example of a planning method based on one-step tabular q-learning and on random samples from a sample model. this method which we call random-sample one-step tabular q-planning converges to the optimal policy for the model under the same conditions that one-step tabular q-learning converges to the optimal policy for the real environment state action pair must be selected an infinite number of times in step and must decrease appropriately over time. random-sample one-step tabular q-planning loop forever select a state s s and an action a as at random send s a to a sample model and obtain a sample next reward r and a sample next state apply one-step tabular q-learning to s a r qs a qs a maxa a qs in addition to the unified view of planning and learning methods a second theme in this chapter is the benefits of planning in small incremental steps. this enables planning to be interrupted or redirected at any time with little wasted computation which appears to be a key requirement for efficiently intermixing planning with acting and with learning of the model. planning in very small steps may be the most efficient approach even on pure planning problems if the problem is too large to be solved exactly. dyna integrated planning acting and learning when planning is done online while interacting with the environment a number of interesting issues arise. new information gained from the interaction may change the model and thereby interact with planning. it may be desirable to customize the planning process in some way to the states or decisions currently under consideration or expected chapter planning and learning with tabular methods in the near future. if decision making and model learning are both computation-intensive processes then the available computational resources may need to be divided between them. to begin exploring these issues in this section we present dyna-q a simple architecture integrating the major functions needed in an online planning agent. each function appears in dyna-q in a simple almost trivial form. in subsequent sections we elaborate some of the alternate ways of achieving each function and the trade-offs between them. for now we seek merely to illustrate the ideas and stimulate your intuition. within a planning agent there are at least two roles for real experience it can be used to improve the model make it more accurately match the real environment and it can be used to directly improve the value function and policy using the kinds of reinforcement learning methods we have discussed in previous chapters. the former we call modellearning and the latter we call direct reinforcement learning rl. the possible relationships between experience model values and policy are summarized in the diagram to the right. each arrow shows a relationship of influence and presumed improvement. note how experience can improve value functions and policies either directly or indirectly via the model. it is the latter which is sometimes called indirect reinforcement learning that is involved in planning. both direct and indirect methods have advantages and disadvantages. indirect methods often make fuller use of a limited amount of experience and thus achieve a better policy with fewer environmental interactions. on the other hand direct methods are much simpler and are not affected by biases in the design of the model. some have argued that indirect methods are always superior to direct ones while others have argued that direct methods are responsible for most human and animal learning. related debates in psychology and artificial intelligence concern the relative importance of cognition as opposed to trial-and-error learning and of deliberative planning as opposed to reactive decision making chapter for discussion of some of these issues from the perspective of psychology. our view is that the contrast between the alternatives in all these debates has been exaggerated that more insight can be gained by recognizing the similarities between these two sides than by opposing them. for example in this book we have emphasized the deep similarities between dynamic programming and temporal-difference methods even though one was designed for planning and the other for model-free learning. dyna-q includes all of the processes shown in the diagram above planning acting model-learning and direct rl all occurring continually. the planning method is the random-sample one-step tabular q-planning method on page the direct rl method is one-step tabular q-learning. the model-learning method is also table-based and assumes the environment is deterministic. after each transition st at the model records in its table entry for st at the prediction that will deterministically follow. thus if the model is queried with a state action pair that has been planningvaluepolicyexperiencemodelmodellearningactingdirectrl dyna integrated planning acting and learning experienced before it simply returns the last-observed next state and next reward as its prediction. during planning the q-planning algorithm randomly samples only from state action pairs that have previously been experienced step so the model is never queried with a pair about which it has no information. the overall architecture of dyna agents of which the dyna-q algorithm is one example is shown in figure the central column represents the basic interaction between agent and environment giving rise to a trajectory of real experience. the arrow on the left of the figure represents direct reinforcement learning operating on real experience to improve the value function and the policy. on the right are model-based processes. the model is learned from real experience and gives rise to simulated experience. we use the term search control to refer to the process that selects the starting states and actions for the simulated experiences generated by the model. finally planning is achieved by applying reinforcement learning methods to the simulated experiences just as if they had really happened. typically as in dyna-q the same reinforcement learning method is used both for learning from real experience and for planning from simulated experience. the reinforcement learning method is thus the final common path for both learning and planning. learning and planning are deeply integrated in the sense that they share almost all the same machinery differing only in the source of their experience. figure the general dyna architecture. real experience passing back and forth between the environment and the policy affects policy and value functions in much the same way as does simulated experience generated by the model of the environment. conceptually planning acting model-learning and direct rl occur simultaneously and in parallel in dyna agents. for concreteness and implementation on a serial computer however we fully specify the order in which they occur within a time step. in dyna-q the acting model-learning and direct rl processes require little computation and we assume they consume just a fraction of the time. the remaining time in each step can be devoted to the planning process which is inherently computation-intensive. realdirect rlupdatemodelplanning updatesearchcontrolpolicyvalue functionsexperiencemodellearningenvironmentsimulatedexperience chapter planning and learning with tabular methods let us assume that there is time in each step after acting model-learning and direct rl to complete n iterations of the q-planning algorithm. in the pseudocode algorithm for dyna-q in the box below m odels a denotes the contents of the next state and reward for state action pair a. direct reinforcement learning model-learning and planning are implemented by steps and respectively. if and were omitted the remaining algorithm would be one-step tabular q-learning. tabular dyna-q initialize qs a and m odels a for all s s and a as loop forever s current state a q take action a observe resultant reward r and state qs a qs a maxa a qs m odels a r deterministic environment loop repeat n times s random previously observed state a random action previously taken in s r m odels a qs a qs a maxa a qs example dyna maze consider the simple maze shown inset in figure in each of the states there are four actions up down right and left which take the agent deterministically to the corresponding neighboring states except when movement is blocked by an obstacle or the edge of the maze in which case the agent remains where it is. reward is zero on all transitions except those into the goal state on which it is after reaching the goal state the agent returns to the start state to begin a new episode. this is a discounted episodic task with the main part of figure shows average learning curves from an experiment in which dyna-q agents were applied to the maze task. the initial action values were zero the step-size parameter was and the exploration parameter was when selecting greedily among actions ties were broken randomly. the agents varied in the number of planning steps n they performed per real step. for each n the curves show the number of steps taken by the agent to reach the goal in each episode averaged over repetitions of the experiment. in each repetition the initial seed for the random number generator was held constant across algorithms. because of this the first episode was exactly the same steps for all values of n and its data are not shown in the figure. after the first episode performance improved for all values of n but much more rapidly for larger values. recall that the n agent is a nonplanning agent using only direct reinforcement learning tabular q-learning. this was by far the slowest agent on this problem despite the fact that the parameter values and were optimized for it. the nonplanning agent took about episodes to reach performance whereas the n agent took about five episodes and the n agent took only three episodes. dyna integrated planning acting and learning figure a simple maze and the average learning curves for dyna-q agents varying in their number of planning steps per real step. the task is to travel from s to g as quickly as possible. figure shows why the planning agents found the solution so much faster than the nonplanning agent. shown are the policies found by the n and n agents halfway through the second episode. without planning each episode adds only one additional step to the policy and so only one step last has been learned so far. with planning again only one step is learned during the first episode but here during the second episode an extensive policy has been developed that by the end of the episode will reach almost back to the start state. this policy is built by the planning process while the agent is still wandering near the start state. by the end of the third episode a complete optimal policy will have been found and perfect performance attained. figure policies found by planning and nonplanning dyna-q agents halfway through the second episode. the arrows indicate the greedy action in each state if no arrow is shown for a state then all of its action values were equal. the black square indicates the location of the agent. rl planning steps planning planning chapter planning and learning with tabular methods in dyna-q learning and planning are accomplished by exactly the same algorithm operating on real experience for learning and on simulated experience for planning. because planning proceeds incrementally it is trivial to intermix planning and acting. both proceed as fast as they can. the agent is always reactive and always deliberative responding instantly to the latest sensory information and yet always planning in the background. also ongoing in the background is the model-learning process. as new information is gained the model is updated to better match reality. as the model changes the ongoing planning process will gradually compute a different way of behaving to match the new model. exercise the nonplanning method looks particularly poor in figure because it is a one-step method a method using multi-step bootstrapping would do better. do you think one of the multi-step bootstrapping methods from chapter could do as well as the dyna method? explain why or why not. when the model is wrong in the maze example presented in the previous section the changes in the model were relatively modest. the model started out empty and was then filled only with exactly correct information. in general we cannot expect to be so fortunate. models may be incorrect because the environment is stochastic and only a limited number of samples have been observed or because the model was learned using function approximation that has generalized imperfectly or simply because the environment has changed and its new behavior has not yet been observed. when the model is incorrect the planning process is likely to compute a suboptimal policy. in some cases the suboptimal policy computed by planning quickly leads to the discovery and correction of the modeling error. this tends to happen when the model is optimistic in the sense of predicting greater reward or better state transitions than are actually possible. the planned policy attempts to exploit these opportunities and in doing so discovers that they do not exist. example blocking maze a maze example illustrating this relatively minor kind of modeling error and recovery from it is shown in figure initially there is a short path from start to goal to the right of the barrier as shown in the upper left of the figure. after time steps the short path is blocked and a longer path is opened up along the left-hand side of the barrier as shown in upper right of the figure. the graph shows average cumulative reward for a dyna-q agent and an enhanced dyna-q agent to be described shortly. the first part of the graph shows that both dyna agents found the short path within steps. when the environment changed the graphs become flat indicating a period during which the agents obtained no reward because they were wandering around behind the barrier. after a while however they were able to find the new opening and the new optimal behavior. greater difficulties arise when the environment changes to become better than it was before and yet the formerly correct policy does not reveal the improvement. in these cases the modeling error may not be detected for a long time if ever. when the model is wrong figure average performance of dyna agents on a blocking task. the left environment was used for the first steps the right environment for the rest. dyna-q is dyna-q with an exploration bonus that encourages exploration. example shortcut maze the problem caused by this kind of environmental change is illustrated by the maze example shown in figure initially the optimal path is to go around the left side of the barrier left. after steps however a shorter path is opened up along the right side without disturbing the longer path right. the graph shows that the regular dyna-q agent never switched to the shortcut. in fact it never realized that it existed. its model said that there was no shortcut so the more it planned the less likely it was to step to the right and discover it. even with an policy it is very unlikely that an agent will take so many exploratory actions as to discover the shortcut. figure average performance of dyna agents on a shortcut task. the left environment was used for the first steps the right environment for the rest. the general problem here is another version of the conflict between exploration and exploitation. in a planning context exploration means trying actions that improve the model whereas exploitation means behaving in the optimal way given the current model. chapter planning and learning with tabular methods we want the agent to explore to find changes in the environment but not so much that performance is greatly degraded. as in the earlier explorationexploitation conflict there probably is no solution that is both perfect and practical but simple heuristics are often effective. the dyna-q agent that did solve the shortcut maze uses one such heuristic. this agent keeps track for each state action pair of how many time steps have elapsed since the pair was last tried in a real interaction with the environment. the more time that has elapsed the greater might presume the chance that the dynamics of this pair has changed and that the model of it is incorrect. to encourage behavior that tests longuntried actions a special bonus reward is given on simulated experiences involving these actions. in particular if the modeled reward for a transition is r and the transition has not been tried in time steps then planning updates are done as if that transition produced a reward of r for some small this encourages the agent to keep testing all accessible state transitions and even to find long sequences of actions in order to carry out such of course all this testing has its cost but in many cases as in the shortcut maze this kind of computational curiosity is well worth the extra exploration. exercise why did the dyna agent with exploration bonus dyna-q perform better in the first phase as well as in the second phase of the blocking and shortcut experiments? exercise careful inspection of figure reveals that the difference between dynaq and dyna-q narrowed slightly over the first part of the experiment. what is the reason for this? exercise the exploration bonus described above actually changes the estimated values of states and actions. is this necessary? suppose the bonus was used not in updates but solely in action selection. that is suppose the action selected was always that for which qst a a was maximal. carry out a gridworld experiment that tests and illustrates the strengths and weaknesses of this alternate approach. exercise how might the tabular dyna-q algorithm shown on page be modified to handle stochastic environments? how might this modification perform poorly on changing environments such as considered in this section? how could the algorithm be modified to handle stochastic environments and changing environments? prioritized sweeping in the dyna agents presented in the preceding sections simulated transitions are started in state action pairs selected uniformly at random from all previously experienced pairs. but a uniform selection is usually not the best planning can be much more efficient if simulated transitions and updates are focused on particular state action pairs. for dyna-q agent was changed in two other ways as well. first actions that had never been tried before from a state were allowed to be considered in the planning step of the tabular dyna-q algorithm in the box above. second the initial model for such actions was that they would lead back to the same state with a reward of zero. prioritized sweeping example consider what happens during the second episode of the first maze task at the beginning of the second episode only the state action pair leading directly into the goal has a positive value the values of all other pairs are still zero. this means that it is pointless to perform updates along almost all transitions because they take the agent from one zero-valued state to another and thus the updates would have no effect. only an update along a transition into the state just prior to the goal or from it will change any values. if simulated transitions are generated uniformly then many wasteful updates will be made before stumbling onto one of these useful ones. as planning progresses the region of useful updates grows but planning is still far less efficient than it would be if focused where it would do the most good. in the much larger problems that are our real objective the number of states is so large that an unfocused search would be extremely inefficient. this example suggests that search might be usefully focused by working backward from goal states. of course we do not really want to use any methods specific to the idea of goal state. we want methods that work for general reward functions. goal states are just a special case convenient for stimulating intuition. in general we want to work back not just from goal states but from any state whose value has changed. suppose that the values are initially correct given the model as they were in the maze example prior to discovering the goal. suppose now that the agent discovers a change in the environment and changes its estimated value of one state either up or down. typically this will imply that the values of many other states should also be changed but the only useful one-step updates are those of actions that lead directly into the one state whose value has been changed. if the values of these actions are updated then the values of the predecessor states may change in turn. if so then actions leading into them need to be updated and then their predecessor states may have changed. in this way one can work backward from arbitrary states that have changed in value either performing useful updates or terminating the propagation. this general idea might be termed backward focusing of planning computations. as the frontier of useful updates propagates backward it often grows rapidly producing many state action pairs that could usefully be updated. but not all of these will be equally useful. the values of some states may have changed a lot whereas others may have changed little. the predecessor pairs of those that have changed a lot are more likely to also change a lot. in a stochastic environment variations in estimated transition probabilities also contribute to variations in the sizes of changes and in the urgency with which pairs need to be updated. it is natural to prioritize the updates according to a measure of their urgency and perform them in order of priority. this is the idea behind prioritized sweeping. a queue is maintained of every state action pair whose estimated value would change nontrivially if updated prioritized by the size of the change. when the top pair in the queue is updated the effect on each of its predecessor pairs is computed. if the effect is greater than some small threshold then the pair is inserted in the queue with the new priority there is a previous entry of the pair in the queue then insertion results in only the higher priority entry remaining in the queue. in this way the effects of changes are efficiently propagated backward until quiescence. the full algorithm for the case of deterministic environments is given in the box on the next page. chapter planning and learning with tabular methods prioritized sweeping for a deterministic environment initialize qs a m odels a for all s a and p queue to empty loop forever s current state a policys q take action a observe resultant reward r and state m odels a r p maxa a qs a. if p then insert s a into p queue with priority p loop repeat n times while p queue is not empty s a f irstp queue r m odels a qs a qs a maxa a qs loop for all s a predicted to lead to s r predicted reward for s a s p r maxa qs a q s a. if p then insert s a into p queue with priority p example prioritized sweeping on mazes prioritized sweeping has been found to dramatically increase the speed at which optimal solutions are found in maze tasks often by a factor of to a typical example is shown to the right. these data are for a sequence of maze tasks of exactly the same structure as the one shown in figure except that they vary in the grid resolution. prioritized sweeping maintained a decisive advantage over unprioritized dynaq. both systems made at most n updates per environmental interaction. adapted from peng and williams extensions of prioritized sweeping to stochastic environments are straightforward. the model is maintained by keeping counts of the number of times each state action pair has been experienced and of what the next states were. it is natural then to update each pair not with a sample update as we have been using so far but with an expected update taking into account all possible next states and their probabilities of occurring. prioritized sweeping is just one way of distributing computations to improve planning efficiency and probably not the best way. one of prioritized sweeping s limitations is that it uses expected updates which in stochastic environments may waste lots of computation on low-probability transitions. as we show in the following section sample updates can in many cases get closer to the true value function with less computation despite the variance introduced by sampling. sample updates can win because they size expected vs. sample updates example prioritized sweeping for rod maneuvering the objective in this task is to maneuver a rod around some awkwardly placed obstacles within a limited rectangular work space to a goal position in the fewest number of steps. the rod can be translated along its long axis or perpendicular to that axis or it can be rotated in either direction around its center. the distance of each movement is approximately of the work space and the rotation increment is degrees. translations are deterministic and quantized to one of positions. to the right is shown the obstacles and the shortest solution from start to goal found by prioritized sweeping. this problem is deterministic but has four actions and potential states of these are unreachable because of the obstacles. this problem is probably too large to be solved with unprioritized methods. figure reprinted from moore and atkeson break the overall backing-up computation into smaller pieces those corresponding to individual transitions which then enables it to be focused more narrowly on the pieces that will have the largest impact. this idea was taken to what may be its logical limit in the small backups introduced by van seijen and sutton these are updates along a single transition like a sample update but based on the probability of the transition without sampling as in an expected update. by selecting the order in which small updates are done it is possible to greatly improve planning efficiency beyond that possible with prioritized sweeping. we have suggested in this chapter that all kinds of state-space planning can be viewed as sequences of value updates varying only in the type of update expected or sample large or small and in the order in which the updates are done. in this section we have emphasized backward focusing but this is just one strategy. for example another would be to focus on states according to how easily they can be reached from the states that are visited frequently under the current policy which might be called forward focusing. peng and williams and barto bradtke and singh have explored versions of forward focusing and the methods introduced in the next few sections take it to an extreme form. startgoal chapter planning and learning with tabular methods expected vs. sample updates the examples in the previous sections give some idea of the range of possibilities for combining methods of learning and planning. in the rest of this chapter we analyze some of the component ideas involved starting with the relative advantages of expected and sample updates. much of this book has been about different kinds of value-function updates and we have considered a great many varieties. focusing for the moment on one-step updates they vary primarily along three binary dimensions. the first two dimensions are whether they update state values or action values and whether they estimate the value for the optimal policy or for an arbitrary given policy. these two dimensions give rise to four classes of updates for approximating the four value functions q v q and v the other binary dimension is whether the updates are expected updates considering all possible events that might happen or sample updates considering a single sample of what might happen. these three binary dimensions give rise to eight cases seven of which correspond to specific algorithms as shown in the figure to the right. eighth case does not seem to correspond to any useful update. any of these one-step updates can be used in planning methods. the dyna-q agents discussed earlier use q sample updates but they could just as well use q expected updates or either expected or sample q updates. the dyna-ac system uses v sample updates together with a learning policy structure in chapter for stochastic problems prioritized sweeping is always done using one of the expected updates. when we introduced one-step sample updates in chapter we presented them as substitutes for expected updates. in the absence of a distribution model expected updates are not possible but sample updates can be done using sample transitions from the environment or a sample model. implicit in that point of view is that expected updates if possible are preferable to sample updates. but are they? expected figure backup diagrams for all the one-step updates considered in this book. valueestimatedexpected updatesdpsample updates td rpaq evaluationvalue pq-policy expected vs. sample updates updates certainly yield a better estimate because they are uncorrupted by sampling error but they also require more computation and computation is often the limiting resource in planning. to properly assess the relative merits of expected and sample updates for planning we must control for their different computational requirements. for concreteness consider the expected and sample updates for approximating q and the special case of discrete states and actions a table-lookup representation of the approximate value function q and a model in the form of estimated dynamics rs a. the expected update for a state action pair s a is qs a rs max the corresponding sample update for s a given a sample next state and reward and r the model is the q-learning-like update qs a qs a max qs where is the usual positive step-size parameter. the difference between these expected and sample updates is significant to the extent that the environment is stochastic specifically to the extent that given a state and action many possible next states may occur with various probabilities. if only one next state is possible then the expected and sample updates given above are identical if there are many possible next states then there may be significant differences. in favor of the expected update is that it is an exact computation resulting in a new qs a whose correctness is limited only by the correctness of the at successor states. the sample update is in addition affected by sampling error. on the other hand the sample update is cheaper computationally because it considers only one next state not all possible next states. in practice the computation required by update operations is usually dominated by the number of state action pairs at which q is evaluated. for a particular starting pair s a let b be the branching factor the number of possible next states for which a then an expected update of this pair requires roughly b times as much computation as a sample update. if there is enough time to complete an expected update then the resulting estimate is generally better than that of b sample updates because of the absence of sampling error. but if there is insufficient time to complete an expected update then sample updates are always preferable because they at least make some improvement in the value estimate with fewer than b updates. in a large problem with many state action pairs we are often in the latter situation. with so many state action pairs expected updates of all of them would take a very long time. before that we may be much better off with a few sample updates at many state action pairs than with expected updates at a few pairs. given a unit of computational effort is it better devoted to a few expected updates or to b times as many sample updates? figure shows the results of an analysis that suggests an answer to this question. it shows the estimation error as a function of computation time for expected and sample updates for a variety of branching factors b. the case considered is that in which all b chapter planning and learning with tabular methods figure comparison of efficiency of expected and sample updates. b successor states are equally likely and in which the error in the initial estimate is the values at the next states are assumed correct so the expected update reduces the error to zero upon its completion. in this case sample updates reduce the error according bt where t is the number of sample updates that have been performed sample averages i.e. the key observation is that for moderately large b the error falls dramatically with a tiny fraction of b updates. for these cases many state action pairs could have their values improved dramatically to within a few percent of the effect of an expected update in the same time that a single state action pair could undergo an expected update. the advantage of sample updates shown in figure is probably an underestimate of the real effect. in a real problem the values of the successor states would be estimates that are themselves updated. by causing estimates to be more accurate sooner sample updates will have a second advantage in that the values backed up from the successor states will be more accurate. these results suggest that sample updates are likely to be superior to expected updates on problems with large stochastic branching factors and too many states to be solved exactly. exercise the analysis above assumed that all of the b possible next states were equally likely to occur. suppose instead that the distribution was highly skewed that some of the b states were much more likely to occur than most. would this strengthen or weaken the case for sample updates over expected updates? support your answer. trajectory sampling in this section we compare two ways of distributing updates. the classical approach from dynamic programming is to perform sweeps through the entire state state action space updating each state state action pair once per sweep. this is problematic b factorb errorin valueestimatenumber of trajectory sampling on large tasks because there may not be time to complete even one sweep. in many tasks the vast majority of the states are irrelevant because they are visited only under very poor policies or with very low probability. exhaustive sweeps implicitly devote equal time to all parts of the state space rather than focusing where it is needed. as we discussed in chapter exhaustive sweeps and the equal treatment of all states that they imply are not necessary properties of dynamic programming. in principle updates can be distributed any way one likes assure convergence all states or state action pairs must be visited in the limit an infinite number of times although an exception to this is discussed in section below but in practice exhaustive sweeps are often used. the second approach is to sample from the state or state action space according to some distribution. one could sample uniformly as in the dyna-q agent but this would suffer from some of the same problems as exhaustive sweeps. more appealing is to distribute updates according to the on-policy distribution that is according to the distribution observed when following the current policy. one advantage of this distribution is that it is easily generated one simply interacts with the model following the current policy. in an episodic task one starts in a start state according to the starting-state distribution and simulates until the terminal state. in a continuing task one starts anywhere and just keeps simulating. in either case sample state transitions and rewards are given by the model and sample actions are given by the current policy. in other words one simulates explicit individual trajectories and performs updates at the state or state action pairs encountered along the way. we call this way of generating experience and updates trajectory sampling. it is hard to imagine any efficient way of distributing updates according to the onpolicy distribution other than by trajectory sampling. if one had an explicit representation of the on-policy distribution then one could sweep through all states weighting the update of each according to the on-policy distribution but this leaves us again with all the computational costs of exhaustive sweeps. possibly one could sample and update individual state action pairs from the distribution but even if this could be done efficiently what benefit would this provide over simulating trajectories? even knowing the on-policy distribution in an explicit form is unlikely. the distribution changes whenever the policy changes and computing the distribution requires computation comparable to a complete policy evaluation. consideration of such other possibilities makes trajectory sampling seem both efficient and elegant. is the on-policy distribution of updates a good one? intuitively it seems like a good choice at least better than the uniform distribution. for example if you are learning to play chess you study positions that might arise in real games not random positions of chess pieces. the latter may be valid states but to be able to accurately value them is a different skill from evaluating positions in real games. we will also see in part ii that the on-policy distribution has significant advantages when function approximation is used. whether or not function approximation is used one might expect on-policy focusing to significantly improve the speed of planning. focusing on the on-policy distribution could be beneficial because it causes vast uninteresting parts of the space to be ignored or it could be detrimental because it causes the same old parts of the space to be updated over and over. we conducted a small experi chapter planning and learning with tabular methods ment to assess the effect empirically. to isolate the effect of the update distribution we used entirely one-step expected tabular updates as defined by in the uniform case we cycled through all state action pairs updating each in place and in the on-policy case we simulated episodes all starting in the same state updating each state action pair that occurred under the current policy the tasks were undiscounted episodic tasks generated randomly as follows. from each of the states two actions were possible each of which resulted in one of b next states all equally likely with a different random selection of b states for each state action pair. the branching factor b was the same for all state action pairs. in addition on all transitions there was a probability of transition to the terminal state ending the episode. the expected reward on each transition was selected from a gaussian distribution with mean and variance at any point in the planning process one can stop and exhaustively compute v the true value of the start state under the greedy policy given the current action-value function q as an indication of how well the agent would do on a new episode on which it acted greedily the while assuming the model is correct. the upper part of the figure to the right shows results averaged over sample tasks with states and branching factors of and the quality of the policies found is plotted as a function of the number of expected updates completed. in all cases sampling according to the on-policy distribution resulted in faster planning initially and retarded planning in the long run. the effect was stronger and the initial period of faster planning was longer at smaller branching factors. in other experiments we found that these effects also became stronger as the number of states increased. for example the lower part of the figure shows results for a branching factor of for tasks with states. in this case the advantage of on-policy focusing is large and long-lasting. all of these results make sense. in the short term sampling according to the on-policy distribution helps by focusing on states that are near descen figure relative efficiency of updates distributed uniformly across the state space versus focused on simulated on-policy trajectories each starting in the same state. results are for randomly generated tasks of two sizes and various branching factors b. ofstart time in full ofstart time in full backupsuniformuniformon-policyon-policyexpected updatesexpected states real-time dynamic programming if there are dants of the start state. many states and a small branching factor this effect will be large and long-lasting. in the long run focusing on the on-policy distribution may hurt because the commonly occurring states all already have their correct values. sampling them is useless whereas sampling other states may actually perform some useful work. this presumably is why the exhaustive unfocused approach does better in the long run at least for small problems. these results are not conclusive because they are only for problems generated in a particular random way but they do suggest that sampling according to the on-policy distribution can be a great advantage for large problems in particular for problems in which a small subset of the state action space is visited under the on-policy distribution. exercise some of the graphs in figure seem to be scalloped in their early portions particularly the upper graph for b and the uniform distribution. why do you think this is? what aspects of the data shown support your hypothesis? exercise replicate the experiment whose results are shown in the lower part of figure then try the same experiment but with b discuss the meaning of your results. real-time dynamic programming real-time dynamic programming or rtdp is an on-policy trajectory-sampling version of the value-iteration algorithm of dynamic programming because it is closely related to conventional sweep-based policy iteration rtdp illustrates in a particularly clear way some of the advantages that on-policy trajectory sampling can provide. rtdp updates the values of states visited in actual or simulated trajectories by means of expected tabular value-iteration updates as defined by it is basically the algorithm that produced the on-policy results shown in figure the close connection between rtdp and conventional dp makes it possible to derive some theoretical results by adapting existing theory. rtdp is an example of an asynchronous dp algorithm as described in section asynchronous dp algorithms are not organized in terms of systematic sweeps of the state set they update state values in any order whatsoever using whatever values of other states happen to be available. in rtdp the update order is dictated by the order states are visited in real or simulated trajectories. if trajectories can start only from a designated set of start states and if you are interested in the prediction problem for a given policy then on-policy trajectory sampling allows the algorithm to completely skip states that cannot be reached by the given policy from any of the start states unreachable states are irrelevant to the prediction problem. for a control problem where the goal is to find an optimal policy instead of evaluating a given policy there might well be states that cannot be reached by any optimal policy from any of the start states and there is no need to specify optimal actions for these irrelevant states. what is needed is an optimal partial policy meaning a policy that is optimal for the relevant states but can specify arbitrary actions or even be undefined chapter planning and learning with tabular methods for the irrelevant states illustration to the right. but finding such an optimal partial policy with an on-policy trajectory-sampling control method such as sarsa in general requires visiting all state action pairs even those that will turn out to be irrelevant an infinite number of times. this can be done for example by using exploring starts this is true for rtdp as well for episodic tasks with exploring starts rtdp is an asynchronous value-iteration algorithm that converges to optimal polices for discounted finite mdps for the undiscounted case under certain conditions. unlike the situation for a prediction problem it is generally not possible to stop updating any state or state action pair if convergence to an optimal policy is important. the most interesting result for rtdp is that for certain types of problems satisfying reasonable conditions rtdp is guaranteed to find a policy that is optimal on the relevant states without visiting every state infinitely often or even without visiting some states at all. indeed in some problems only a small fraction of the states need to be visited. this can be a great advantage for problems with very large state sets where even a single sweep may not be feasible. the tasks for which this result holds are undiscounted episodic tasks for mdps with absorbing goal states that generate zero rewards as described in section at every step of a real or simulated trajectory rtdp selects a greedy action ties randomly and applies the expected value-iteration update operation to the current state. it can also update the values of an arbitrary collection of other states at each step for example it can update the values of states visited in a limited-horizon look-ahead search from the current state. for these problems with each episode beginning in a state randomly chosen from the set of start states and ending at a goal state rtdp converges with probability one to a policy that is optimal for all the relevant states provided the initial value of every goal state is zero there exists at least one policy that guarantees that a goal state will be reached with probability one from any start state all rewards for transitions from non-goal states are strictly negative and all the initial values are equal to or greater than their optimal values can be satisfied by simply setting the initial values of all states to zero. this result was proved by barto bradtke and singh by combining results for asynchronous dp with results about a heuristic search algorithm known as learning real-time a due to korf tasks having these properties are examples of stochastic optimal path problems which are usually stated in terms of cost minimization instead of as reward maximization as we do here. maximizing the negative returns in our version is equivalent to minimizing the costs of paths from a start state to a goal state. examples of this kind of task are minimum-time control tasks where each time step required to reach a goal produces a start statesirrelevant states unreachable from any start stateunder any optimal policyrelevant statesreachable from some start state under some optimal policy real-time dynamic programming reward of or problems like the golf example in section whose objective is to hit the hole with the fewest strokes. example rtdp on the racetrack the racetrack problem of exercise is a stochastic optimal path problem. comparing rtdp and the conventional dp value iteration algorithm on an example racetrack problem illustrates some of the advantages of on-policy trajectory sampling. recall from the exercise that an agent has to learn how to drive a car around a turn like those shown in figure and cross the finish line as quickly as possible while staying on the track. start states are all the zero-speed states on the starting line the goal states are all the states that can be reached in one time step by crossing the finish line from inside the track. unlike exercise here there is no limit on the car s speed so the state set is potentially infinite. however the set of states that can be reached from the set of start states via any policy is finite and can be considered to be the state set of the problem. each episode begins in a randomly selected start state and ends when the car crosses the finish line. the rewards are for each step until the car crosses the finish line. if the car hits the track boundary it is moved back to a random start state and the episode continues. a racetrack similar to the small racetrack on the left of figure has states reachable from start states by any policy only of which are relevant meaning that they are reachable from some start state via some optimal policy. number of relevant states was estimated by counting the states visited while executing optimal actions for episodes. the table below compares solving this task by conventional dp and by rtdp. these results are averages over runs each begun with a different random number seed. conventional dp in this case is value iteration using exhaustive sweeps of the state set with values updated one state at a time in place meaning that the update for each state uses the most recent values of the other states is the gauss-seidel version of value iteration which was found to be approximately twice as fast as the jacobi version on this problem. see section no special attention was paid to the ordering of the updates other orderings could have produced faster convergence. initial values were all zero for each run of both methods. dp was judged to have converged when the maximum change in a state value over a sweep was less than and rtdp was judged to have converged when the average time to cross the finish line over episodes appeared to stabilize at an asymptotic number of steps. this version of rtdp updated only the value of the current state on each step. average computation to convergence average number of updates to convergence average number of updates per episode of states updated times of states updated times of states updated times dp sweeps rtdp episodes both methods produced policies averaging between and steps to cross the finish chapter planning and learning with tabular methods line but rtdp required only roughly half of the updates that dp did. this is the result of rtdp s on-policy trajectory sampling. whereas the value of every state was updated in each sweep of dp rtdp focused updates on fewer states. in an average run rtdp updated the values of of the states no more than times and of the states no more than times the values of about states were not updated at all in an average run. another advantage of rtdp is that as the value function approaches the optimal value function v the policy used by the agent to generate trajectories approaches an optimal policy because it is always greedy with respect to the current value function. this is in contrast to the situation in conventional value iteration. in practice value iteration terminates when the value function changes by only a small amount in a sweep which is how we terminated it to obtain the results in the table above. at this point the value function closely approximates v and a greedy policy is close to an optimal policy. however it is possible that policies that are greedy with respect to the latest value function were optimal or nearly so long before value iteration terminates. from chapter that optimal policies can be greedy with respect to many different value functions not just v checking for the emergence of an optimal policy before value iteration converges is not a part of the conventional dp algorithm and requires considerable additional computation. in the racetrack example by running many test episodes after each dp sweep with actions selected greedily according to the result of that sweep it was possible to estimate the earliest point in the dp computation at which the approximated optimal evaluation function was good enough so that the corresponding greedy policy was nearly optimal. for this racetrack a close-to-optimal policy emerged after sweeps of value iteration or after value-iteration updates. this is considerably less than the updates dp needed to converge to v but sill more than the updates rtdp required. although these simulations are certainly not definitive comparisons of the rtdp with conventional sweep-based value iteration they illustrate some of advantages of on-policy trajectory sampling. whereas conventional value iteration continued to update the value of all the states rtdp strongly focused on subsets of the states that were relevant to the problem s objective. this focus became increasingly narrow as learning continued. because the convergence theorem for rtdp applies to the simulations we know that rtdp eventually would have focused only on relevant states i.e. on states making up optimal paths. rtdp achieved nearly optimal control with about of the computation required by sweep-based value iteration. planning at decision time planning can be used in at least two ways. the one we have considered so far in this chapter typified by dynamic programming and dyna is to use planning to gradually improve a policy or value function on the basis of simulated experience obtained from a model a sample or a distribution model. selecting actions is then a matter of comparing the current state s action values obtained from a table in the tabular case we have thus far considered or by evaluating a mathematical expression in the heuristic search approximate methods we consider in part ii below. well before an action is selected for any current state st planning has played a part in improving the table entries or the mathematical expression needed to select the action for many states including st. used this way planning is not focussed on the current state. we call planning used in this way background planning. the other way to use planning is to begin and complete it after encountering each new state st as a computation whose output is the selection of a single action at on the next step planning begins anew with to produce and so on. the simplest and almost degenerate example of this use of planning is when only state values are available and an action is selected by comparing the values of model-predicted next states for each action by comparing the values of afterstates as in the tic-tac-toe example in chapter more generally planning used in this way can look much deeper than one-step-ahead and evaluate action choices leading to many different predicted state and reward trajectories. unlike the first use of planning here planning focuses on a particular state. we call this decision-time planning. these two ways of thinking about planning using simulated experience to gradually improve a policy or value function or using simulated experience to select an action for the current state can blend together in natural and interesting ways but they have tended to be studied separately and that is a good way to first understand them. let us now take a closer look at decision-time planning. even when planning is only done at decision time we can still view it as we did in section as proceeding from simulated experience to updates and values and ultimately to a policy. it is just that now the values and policy are specific to the current state and the action choices available there so much so that the values and policy created by the planning process are typically discarded after being used to select the current action. in many applications this is not a great loss because there are very many states and we are unlikely to return to the same state for a long time. in general one may want to do a mix of both focus planning on the current state and store the results of planning so as to be that much farther along should one return to the same state later. decision-time planning is most useful in applications in which fast responses are not required. in chess playing programs for example one may be permitted seconds or minutes of computation for each move and strong programs may plan dozens of moves ahead within this time. on the other hand if low latency action selection is the priority then one is generally better off doing planning in the background to compute a policy that can then be rapidly applied to each newly encountered state. heuristic search the classical state-space planning methods in artificial intelligence are decision-time planning methods collectively known as heuristic search. in heuristic search for each state encountered a large tree of possible continuations is considered. the approximate value function is applied to the leaf nodes and then backed up toward the current state at the root. the backing up within the search tree is just the same as in the expected updates with maxes for v and q discussed throughout this book. the backing chapter planning and learning with tabular methods up stops at the state action nodes for the current state. once the backed-up values of these nodes are computed the best of them is chosen as the current action and then all backed-up values are discarded. in conventional heuristic search no effort is made to save the backed-up values by changing the approximate value function. in fact the value function is generally designed by people and never changed as a result of search. however it is natural to consider allowing the value function to be improved over time using either the backed-up values computed during heuristic search or any of the other methods presented throughout this book. in a sense we have taken this approach all along. our greedy and ucb action-selection methods are not unlike heuristic search albeit on a smaller scale. for example to compute the greedy action given a model and a state-value function we must look ahead from each possible action to each possible next state take into account the rewards and estimated values and then pick the best action. just as in conventional heuristic search this process computes backed-up values of the possible actions but does not attempt to save them. thus heuristic search can be viewed as an extension of the idea of a greedy policy beyond a single step. the point of searching deeper than one step is to obtain better action selections. if one has a perfect model and an imperfect action-value function then in fact deeper search will usually yield better certainly if the search is all the way to the end of the episode then the effect of the imperfect value function is eliminated and the action determined in this way must be optimal. if the search is of sufficient depth k such that k is very small then the actions will be correspondingly near optimal. on the other hand the deeper the search the more computation is required usually resulting in a slower response time. a good example is provided by tesauro s grandmaster-level backgammon player td-gammon this system used td learning to learn an afterstate value function through many games of self-play using a form of heuristic search to make its moves. as a model td-gammon used a priori knowledge of the probabilities of dice rolls and the assumption that the opponent always selected the actions that td-gammon rated as best for it. tesauro found that the deeper the heuristic search the better the moves made by td-gammon but the longer it took to make each move. backgammon has a large branching factor yet moves must be made within a few seconds. it was only feasible to search ahead selectively a few steps but even so the search resulted in significantly better action selections. we should not overlook the most obvious way in which heuristic search focuses updates on the current state. much of the effectiveness of heuristic search is due to its search tree being tightly focused on the states and actions that might immediately follow the current state. you may spend more of your life playing chess than checkers but when you play checkers it pays to think about checkers and about your particular checkers position your likely next moves and successor positions. no matter how you select actions it is these states and actions that are of highest priority for updates and where you most urgently want your approximate value function to be accurate. not only should your computation be preferentially devoted to imminent events but so should your limited memory resources. in chess for example there are far too many possible are interesting exceptions to this. see e.g. pearl rollout algorithms positions to store distinct value estimates for each of them but chess programs based on heuristic search can easily store distinct estimates for the millions of positions they encounter looking ahead from a single position. this great focusing of memory and computational resources on the current decision is presumably the reason why heuristic search can be so effective. the distribution of updates can be altered in similar ways to focus on the current state and its likely successors. as a limiting case we might use exactly the methods of heuristic search to construct a search tree and then perform the individual one-step updates from bottom up as suggested by figure if the updates are ordered in this way and a tabular representation is used then exactly the same overall update would be achieved as in depth-first heuristic search. any state-space search can be viewed in this way as the piecing together of a large number of individual one-step updates. thus the performance improvement observed with deeper searches is not due to the use of multistep updates as such. instead it is due to the focus and concentration of updates on states and actions immediately downstream from the current state. by devoting a large amount of computation specifically relevant to the candidate actions decision-time planning can produce better decisions than can be produced by relying on unfocused updates. figure heuristic search can be implemented as a sequence of one-step updates here outlined in blue backing up values from the leaf nodes toward the root. the ordering shown here is for a selective depth-first search. rollout algorithms rollout algorithms are decision-time planning algorithms based on monte carlo control applied to simulated trajectories that all begin at the current environment state. they estimate action values for a given policy by averaging the returns of many simulated chapter planning and learning with tabular methods trajectories that start with each possible action and then follow the given policy. when the action-value estimates are considered to be accurate enough the action one of the actions having the highest estimated value is executed after which the process is carried out anew from the resulting next state. as explained by tesauro and galperin who experimented with rollout algorithms for playing backgammon the term rollout comes from estimating the value of a backgammon position by playing out i.e. rolling out the position many times to the game s end with randomly generated sequences of dice rolls where the moves of both players are made by some fixed policy. unlike the monte carlo control algorithms described in chapter the goal of a rollout algorithm is not to estimate a complete optimal action-value function q or a complete action-value function q for a given policy instead they produce monte carlo estimates of action values only for each current state and for a given policy usually called the rollout policy. as decision-time planning algorithms rollout algorithms make immediate use of these action-value estimates then discard them. this makes rollout algorithms relatively simple to implement because there is no need to sample outcomes for every state-action pair and there is no need to approximate a function over either the state space or the state-action space. what then do rollout algorithms accomplish? the policy improvement theorem described in section tells us that given any two policies and that are identical except that a for some state s if q a v then policy is as good as or better than moreover if the inequality is strict then is in fact better than this applies to rollout algorithms where s is the current state and is the rollout policy. averaging the returns of the simulated trajectories produces estimates of q for each action as. then the policy that selects an action in s that maximizes these estimates and thereafter follows is a good candidate for a policy that improves over the result is like one step of the policy-iteration algorithm of dynamic programming discussed in section it is more like one step of asynchronous value iteration described in section because it changes the action for just the current state. in other words the aim of a rollout algorithm is to improve upon the rollout policy not to find an optimal policy. experience has shown that rollout algorithms can be surprisingly effective. for example tesauro and galperin were surprised by the dramatic improvements in backgammon playing ability produced by the rollout method. in some applications a rollout algorithm can produce good performance even if the rollout policy is completely random. but the performance of the improved policy depends on properties of the rollout policy and the ranking of actions produced by the monte carlo value estimates. intuition suggests that the better the rollout policy and the more accurate the value estimates the better the policy produced by a rollout algorithm is likely be see gelly and silver this involves important tradeoffs because better rollout policies typically mean that more time is needed to simulate enough trajectories to obtain good value estimates. as decision-time planning methods rollout algorithms usually have to meet strict time constraints. the computation time needed by a rollout algorithm depends on the number of actions that have to be evaluated for each decision the number of time steps in the monte carlo tree search simulated trajectories needed to obtain useful sample returns the time it takes the rollout policy to make decisions and the number of simulated trajectories needed to obtain good monte carlo action-value estimates. balancing these factors is important in any application of rollout methods though there are several ways to ease the challenge. because the monte carlo trials are independent of one another it is possible to run many trials in parallel on separate processors. another approach is to truncate the simulated trajectories short of complete episodes correcting the truncated returns by means of a stored evaluation function brings into play all that we have said about truncated returns and updates in the preceding chapters. it is also possible as tesauro and galperin suggest to monitor the monte carlo simulations and prune away candidate actions that are unlikely to turn out to be the best or whose values are close enough to that of the current best that choosing them instead would make no real difference tesauro and galperin point out that this would complicate a parallel implementation. we do not ordinarily think of rollout algorithms as learning algorithms because they do not maintain long-term memories of values or policies. however these algorithms take advantage of some of the features of reinforcement learning that we have emphasized in this book. as instances of monte carlo control they estimate action values by averaging the returns of a collection of sample trajectories in this case trajectories of simulated interactions with a sample model of the environment. in this way they are like reinforcement learning algorithms in avoiding the exhaustive sweeps of dynamic programming by trajectory sampling and in avoiding the need for distribution models by relying on sample instead of expected updates. finally rollout algorithms take advantage of the policy improvement property by acting greedily with respect to the estimated action values. monte carlo tree search monte carlo tree search is a recent and strikingly successful example of decision-time planning. at its base mcts is a rollout algorithm as described above but enhanced by the addition of a means for accumulating value estimates obtained from the monte carlo simulations in order to successively direct simulations toward more highlyrewarding trajectories. mcts is largely responsible for the improvement in computer go from a weak amateur level in to a grandmaster level dan or more in many variations of the basic algorithm have been developed including a variant that we discuss in section that was critical for the stunning victories of the program alphago over an world champion go player. mcts has proved to be effective in a wide variety of competitive settings including general game playing see finnsson and bj ornsson genesereth and thielscher but it is not limited to games it can be effective for single-agent sequential decision problems if there is an environment model simple enough for fast multistep simulation. mcts is executed after encountering each new state to select the agent s action for that state it is executed again to select the action for the next state and so on. as in a rollout algorithm each execution is an iterative process that simulates many trajectories chapter planning and learning with tabular methods starting from the current state and running to a terminal state until discounting makes any further reward negligible as a contribution to the return. the core idea of mcts is to successively focus multiple simulations starting at the current state by extending the initial portions of trajectories that have received high evaluations from earlier simulations. mcts does not have to retain approximate value functions or policies from one action selection to the next though in many implementations it retains selected action values likely to be useful for its next execution. for the most part the actions in the simulated trajectories are generated using a simple policy usually called a rollout policy as it is for simpler rollout algorithms. when both the rollout policy and the model do not require a lot of computation many simulated trajectories can be generated in a short period of time. as in any tabular monte carlo method the value of a state action pair is estimated as the average of the returns from that pair. monte carlo value estimates are maintained only for the subset of state action pairs that are most likely to be reached in a few steps which form a tree rooted at the current state as illustrated in figure mcts incrementally extends the tree by adding nodes representing states that look promising based on the results of the simulated trajectories. any simulated trajectory will pass through the tree and then exit it at some leaf node. outside the tree and at the leaf nodes the rollout policy is used for action selections but at the states inside the tree something better is possible. for these states we have value estimates for of at least some of the actions so we can pick among them using an informed policy called the tree policy that balances exploration and exploitation. for example the tree policy could select actions using an or ucb selection rule in more detail each iteration of a basic version of mcts consists of the following four steps as illustrated in figure selection. starting at the root node a tree policy based on the action values attached to the edges of the tree traverses the tree to select a leaf node. expansion. on some iterations on details of the application the tree is expanded from the selected leaf node by adding one or more child nodes reached from the selected node via unexplored actions. simulation. from the selected node or from one of its newly-added child nodes any simulation of a complete episode is run with actions selected by the rollout policy. the result is a monte carlo trial with actions selected first by the tree policy and beyond the tree by the rollout policy. backup. the return generated by the simulated episode is backed up to update or to initialize the action values attached to the edges of the tree traversed by the tree policy in this iteration of mcts. no values are saved for the states and actions visited by the rollout policy beyond the tree. figure illustrates this by showing a backup from the terminal state of the simulated trajectory directly to the state action node in the tree where the rollout policy began in general the entire return over the simulated trajectory is backed up to this state action node. monte carlo tree search figure monte carlo tree search. when the environment changes to a new state mcts executes as many iterations as possible before an action needs to be selected incrementally building a tree whose root node represents the current state. each iteration consists of the four operations selection expansion possibly skipped on some iterations simulation and backup as explained in the text and illustrated by the bold arrows in the trees. adapted from chaslot bakkes szita and spronck mcts continues executing these four steps starting each time at the tree s root node until no more time is left or some other computational resource is exhausted. then finally an action from the root node still represents the current state of the environment is selected according to some mechanism that depends on the accumulated statistics in the tree for example it may be an action having the largest action value of all the actions available from the root state or perhaps the action with the largest visit count to avoid selecting outliers. this is the action mcts actually selects. after the environment transitions to a new state mcts is run again sometimes starting with a tree of a single root node representing the new state but often starting with a tree containing any descendants of this node left over from the tree constructed by the previous execution of mcts all the remaining nodes are discarded along with the action values associated with them. mcts was first proposed to select moves in programs playing two-person competitive games such as go. for game playing each simulated episode is one complete play of the game in which both players select actions by the tree and rollout policies. section describes an extension of mcts used in the alphago program that combines the monte selectionsimulationexpansionbackuprepeat while time remains tree policyrolloutpolicy chapter planning and learning with tabular methods carlo evaluations of mcts with action values learned by a deep ann via self-play reinforcement learning. relating mcts to the reinforcement learning principles we describe in this book provides some insight into how it achieves such impressive results. at its base mcts is a decision-time planning algorithm based on monte carlo control applied to simulations that start from the root state that is it is a kind of rollout algorithm as described in the previous section. it therefore benefits from online incremental sample-based value estimation and policy improvement. beyond this it saves action-value estimates attached to the tree edges and updates them using reinforcement learning s sample updates. this has the effect of focusing the monte carlo trials on trajectories whose initial segments are common to high-return trajectories previously simulated. further by incrementally expanding the tree mcts effectively grows a lookup table to store a partial action-value function with memory allocated to the estimated values of state action pairs visited in the initial segments of high-yielding sample trajectories. mcts thus avoids the problem of globally approximating an action-value function while it retains the benefit of using past experience to guide exploration. the striking success of decision-time planning by mcts has deeply influenced artificial intelligence and many researchers are studying modifications and extensions of the basic procedure for use in both games and single-agent applications. summary of the chapter planning requires a model of the environment. a distribution model consists of the probabilities of next states and rewards for possible actions a sample model produces single transitions and rewards generated according to these probabilities. dynamic programming requires a distribution model because it uses expected updates which involve computing expectations over all the possible next states and rewards. a sample model on the other hand is what is needed to simulate interacting with the environment during which sample updates like those used by many reinforcement learning algorithms can be used. sample models are generally much easier to obtain than distribution models. we have presented a perspective emphasizing the surprisingly close relationships between planning optimal behavior and learning optimal behavior. both involve estimating the same value functions and in both cases it is natural to update the estimates incrementally in a long series of small backing-up operations. this makes it straightforward to integrate learning and planning processes simply by allowing both to update the same estimated value function. in addition any of the learning methods can be converted into planning methods simply by applying them to simulated experience rather than to real experience. in this case learning and planning become even more similar they are possibly identical algorithms operating on two different sources of experience. it is straightforward to integrate incremental planning methods with acting and modellearning. planning acting and model-learning interact in a circular fashion in the diagram on page each producing what the other needs to improve no other interaction among them is either required or prohibited. the most natural approach is for all summary of part i dimensions processes to proceed asynchronously and in parallel. if the processes must share computational resources then the division can be handled almost arbitrarily by whatever organization is most convenient and efficient for the task at hand. in this chapter we have touched upon a number of dimensions of variation among state-space planning methods. one dimension is the variation in the size of updates. the smaller the updates the more incremental the planning methods can be. among the smallest updates are one-step sample updates as in dyna. another important dimension is the distribution of updates that is of the focus of search. prioritized sweeping focuses backward on the predecessors of states whose values have recently changed. on-policy trajectory sampling focuses on states or state action pairs that the agent is likely to encounter when controlling its environment. this can allow computation to skip over parts of the state space that are irrelevant to the prediction or control problem. realtime dynamic programming an on-policy trajectory sampling version of value iteration illustrates some of the advantages this strategy has over conventional sweep-based policy iteration. planning can also focus forward from pertinent states such as states actually encountered during an agent-environment interaction. the most important form of this is when planning is done at decision time that is as part of the action-selection process. classical heuristic search as studied in artificial intelligence is an example of this. other examples are rollout algorithms and monte carlo tree search that benefit from online incremental sample-based value estimation and policy improvement. summary of part i dimensions this chapter concludes part i of this book. in it we have tried to present reinforcement learning not as a collection of individual methods but as a coherent set of ideas cutting across methods. each idea can be viewed as a dimension along which methods vary. the set of such dimensions spans a large space of possible methods. by exploring this space at the level of dimensions we hope to obtain the broadest and most lasting understanding. in this section we use the concept of dimensions in method space to recapitulate the view of reinforcement learning developed so far in this book. all of the methods we have explored so far in this book have three key ideas in common first they all seek to estimate value functions second they all operate by backing up values along actual or possible state trajectories and third they all follow the general strategy of generalized policy iteration meaning that they maintain an approximate value function and an approximate policy and they continually try to improve each on the basis of the other. these three ideas are central to the subjects covered in this book. we suggest that value functions backing up value updates and gpi are powerful organizing principles potentially relevant to any model of intelligence whether artificial or natural. two of the most important dimensions along which the methods vary are shown in figure these dimensions have to do with the kind of update used to improve the value function. the horizontal dimension is whether they are sample updates on a sample trajectory or expected updates on a distribution of possible trajectories. chapter planning and learning with tabular methods figure a slice through the space of reinforcement learning methods highlighting the two of the most important dimensions explored in part i of this book the depth and width of the updates. expected updates require a distribution model whereas sample updates need only a sample model or can be done from actual experience with no model at all dimension of variation. the vertical dimension of figure corresponds to the depth of updates that is to the degree of bootstrapping. at three of the four corners of the space are the three primary methods for estimating values dynamic programming td and monte carlo. along the left edge of the space are the sample-update methods ranging from one-step td updates to full-return monte carlo updates. between these is a spectrum including methods based on n-step updates in chapter we will extend this to mixtures of n-step updates such as the implemented by eligibility traces. dynamic programming methods are shown in the extreme upper-right corner of the space because they involve one-step expected updates. the lower-right corner is the extreme case of expected updates so deep that they run all the way to terminal states in a continuing task until discounting has reduced the contribution of any further rewards to a negligible level. this is the case of exhaustive search. intermediate methods along this dimension include heuristic search and related methods that search and update up to a limited depth perhaps selectively. there are also methods that are intermediate widthof updatedepthlengthof updatetemporal-differencelearningdynamicprogrammingmontecarlo...exhaustivesearch summary of part i dimensions along the horizontal dimension. these include methods that mix expected and sample updates as well as the possibility of methods that mix samples and distributions within a single update. the interior of the square is filled in to represent the space of all such intermediate methods. a third dimension that we have emphasized in this book is the binary distinction between on-policy and off-policy methods. in the former case the agent learns the value function for the policy it is currently following whereas in the latter case it learns the value function for the policy for a different policy often the one that the agent currently thinks is best. the policy generating behavior is typically different from what is currently thought best because of the need to explore. this third dimension might be visualized as perpendicular to the plane of the page in figure in addition to the three dimensions just discussed we have identified a number of others throughout the book definition of return is the task episodic or continuing discounted or undiscounted? action values vs. state values vs. afterstate values what kind of values should be estimated? if only state values are estimated then either a model or a separate policy in actor critic methods is required for action selection. action selectionexploration how are actions selected to ensure a suitable tradeoff between exploration and exploitation? we have considered only the simplest ways to do this optimistic initialization of values soft-max and upper confidence bound. synchronous vs. asynchronous are the updates for all states performed simultane ously or one by one in some order? real vs. simulated should one update based on real experience or simulated experi ence? if both how much of each? location of updates what states or state action pairs should be updated? modelfree methods can choose only among the states and state action pairs actually encountered but model-based methods can choose arbitrarily. there are many possibilities here. timing of updates should updates be done as part of selecting actions or only after ward? memory for updates how long should updated values be retained? should they be retained permanently or only while computing an action selection as in heuristic search? of course these dimensions are neither exhaustive nor mutually exclusive. individual algorithms differ in many other ways as well and many algorithms lie in several places along several dimensions. for example dyna methods use both real and simulated experience to affect the same value function. it is also perfectly sensible to maintain multiple value functions computed in different ways or over different state and action chapter planning and learning with tabular methods representations. these dimensions do however constitute a coherent set of ideas for describing and exploring a wide space of possible methods. the most important dimension not mentioned here and not covered in part i of this book is that of function approximation. function approximation can be viewed as an orthogonal spectrum of possibilities ranging from tabular methods at one extreme through state aggregation a variety of linear methods and then a diverse set of nonlinear methods. this dimension is explored in part ii. bibliographical and historical remarks the overall view of planning and learning presented here has developed gradually over a number of years in part by the authors barto bradtke and singh sutton and pinette sutton and barto it has been strongly influenced by agre and chapman agre bertsekas and tsitsiklis singh and others. the authors were also strongly influenced by psychological studies of latent learning and by psychological views of the nature of thought galanter and gerstenhaber craik campbell dennett in part iii of the book section relates model-based and model-free methods to psychological theories of learning and behavior and section discusses ideas about how the brain might implement these types of methods. the terms direct and indirect which we use to describe different kinds of reinforcement learning are from the adaptive control literature goodwin and sin where they are used to make the same kind of distinction. the term system identification is used in adaptive control for what we call modellearning goodwin and sin ljung and s oderstrom young the dyna architecture is due to sutton and the results in this and the next section are based on results reported there. barto and singh consider some of the issues in comparing direct and indirect reinforcement learning methods. there have been several works with model-based reinforcement learning that take the idea of exploration bonuses and optimistic initialization to its logical extreme in which all incompletely explored choices are assumed maximally rewarding and optimal paths are computed to test them. the algorithm of kearns and singh and the r-max algorithm of brafman and tennenholtz are guaranteed to find a near-optimal solution in time polynomial in the number of states and actions. this is usually too slow for practical algorithms but is probably the best that can be done in the worst case. prioritized sweeping was developed simultaneously and independently by moore and atkeson and peng and williams the results in the box on page are due to peng and williams the results in the box on page are due to moore and atkeson. key subsequent work in this area summary of part i dimensions includes that by mcmahan and gordon and by van seijen and sutton this section was strongly influenced by the experiments of singh trajectory sampling has implicitly been a part of reinforcement learning from the outset but it was most explicitly emphasized by barto bradtke and singh in their introduction of rtdp. they recognized that korf s learning real-time a algorithm is an asynchronous dp algorithm that applies to stochastic problems as well as the deterministic problems on which korf focused. beyond lrta rtdp includes the option of updating the values of many states in the time intervals between the execution of actions. barto et al. proved the convergence result described here by combining korf s convergence proof for lrta with the result of bertsekas bertsekas and tsitsiklis ensuring convergence of asynchronous dp for stochastic shortest path problems in the undiscounted case. combining model-learning with rtdp is called adaptive rtdp also presented by barto et al. and discussed by barto for further reading on heuristic search the reader is encouraged to consult texts and surveys such as those by russell and norvig and korf peng and williams explored a forward focusing of updates much as is suggested in this section. abramson s expected-outcome model is a rollout algorithm applied to two-person games in which the play of both simulated players is random. he argued that even with random play it is a powerful heuristic that is precise accurate easily estimable efficiently calculable and domain-independent. tesauro and galperin demonstrated the effectiveness of rollout algorithms for improving the play of backgammon programs adopting the term rollout from its use in evaluating backgammon positions by playing out positions with different randomly generating sequences of dice rolls. bertsekas tsitsiklis and wu examine rollout algorithms applied to combinatorial optimization problems and bertsekas surveys their use in discrete deterministic optimization problems remarking that they are often surprisingly effective. the central ideas of mcts were introduced by coulom and by kocsis and szepesv ari they built upon previous research with monte carlo planning algorithms as reviewed by these authors. browne powley whitehouse lucas cowling rohlfshagen tavener perez samothrakis and colton is an excellent survey of mcts methods and their applications. david silver contributed to the ideas and presentation in this section. part ii approximate solution methods in the second part of the book we extend the tabular methods presented in the first part to apply to problems with arbitrarily large state spaces. in many of the tasks to which we would like to apply reinforcement learning the state space is combinatorial and enormous the number of possible camera images for example is much larger than the number of atoms in the universe. in such cases we cannot expect to find an optimal policy or the optimal value function even in the limit of infinite time and data our goal instead is to find a good approximate solution using limited computational resources. in this part of the book we explore such approximate solution methods. the problem with large state spaces is not just the memory needed for large tables but the time and data needed to fill them accurately. in many of our target tasks almost every state encountered will never have been seen before. to make sensible decisions in such states it is necessary to generalize from previous encounters with different states that are in some sense similar to the current one. in other words the key issue is that of generalization. how can experience with a limited subset of the state space be usefully generalized to produce a good approximation over a much larger subset? fortunately generalization from examples has already been extensively studied and we do not need to invent totally new methods for use in reinforcement learning. to some extent we need only combine reinforcement learning methods with existing generalization methods. the kind of generalization we require is often called function approximation because it takes examples from a desired function a value function and attempts to generalize from them to construct an approximation of the entire function. function approximation is an instance of supervised learning the primary topic studied in machine learning artificial neural networks pattern recognition and statistical curve fitting. in theory any of the methods studied in these fields can be used in the role of function approximator within reinforcement learning algorithms although in practice some fit more easily into this role than others. reinforcement learning with function approximation involves a number of new issues that do not normally arise in conventional supervised learning such as nonstationarity bootstrapping and delayed targets. we introduce these and other issues successively over the five chapters of this part. initially we restrict attention to on-policy training treating in chapter the prediction case in which the policy is given and only its value function is approximated and then in chapter the control case in which an approximation to the optimal policy is found. the challenging problem of off-policy learning with function approximation is treated in chapter in each of these three chapters we will have to return to first principles and re-examine the objectives of the learning to take into account function approximation. chapter introduces and analyzes the algorithmic mechanism of eligibility traces which dramatically improves the computational properties of multi-step reinforcement learning methods in many cases. the final chapter of this part explores a different approach to control policy-gradient methods which approximate the optimal policy directly and need never form an approximate value function they may be much more efficient if they do approximate a value function as well the policy. chapter on-policy prediction with approximation in this chapter we begin our study of function approximation in reinforcement learning by considering its use in estimating the state-value function from on-policy data that is in approximating v from experience generated using a known policy the novelty in this chapter is that the approximate value function is represented not as a table but as a parameterized functional form with weight vector w rd. we will write vsw v for the approximate value of state s given weight vector w. for example v might be a linear function in features of the state with w the vector of feature weights. more generally v might be the function computed by a multi-layer artificial neural network with w the vector of connection weights in all the layers. by adjusting the weights any of a wide range of different functions can be implemented by the network. or v might be the function computed by a decision tree where w is all the numbers defining the split points and leaf values of the tree. typically the number of weights dimensionality of w is much less than the number of states and changing one weight changes the estimated value of many states. consequently when a single state is updated the change generalizes from that state to affect the values of many other states. such generalization makes the learning potentially more powerful but also potentially more difficult to manage and understand. perhaps surprisingly extending reinforcement learning to function approximation also makes it applicable to partially observable problems in which the full state is not available to the agent. if the parameterized function form for v does not allow the estimated value to depend on certain aspects of the state then it is just as if those aspects are unobservable. in fact all the theoretical results for methods using function approximation presented in this part of the book apply equally well to cases of partial observability. what function approximation can t do however is augment the state representation with memories of past observations. some such possible further extensions are discussed briefly in section chapter on-policy prediction with approximation value-function approximation all of the prediction methods covered in this book have been described as updates to an estimated value function that shift its value at particular states toward a backedup value or update target for that state. let us refer to an individual update by the notation s u where s is the state updated and u is the update target that s s estimated value is shifted toward. for example the monte carlo update for value prediction is st gt the update is st and the n-step td update is st gttn. in the dp programming policy-evaluation update s e st s an arbitrary state s is updated whereas in the other cases the state encountered in actual experience st is updated. it is natural to interpret each update as specifying an example of the desired input output behavior of the value function. in a sense the update s u means that the estimated value for state s should be more like the update target u. up to now the actual update has been trivial the table entry for s s estimated value has simply been shifted a fraction of the way toward u and the estimated values of all other states were left unchanged. now we permit arbitrarily complex and sophisticated methods to implement the update and updating at s generalizes so that the estimated values of many other states are changed as well. machine learning methods that learn to mimic input output examples in this way are called supervised learning methods and when the outputs are numbers like u the process is often called function approximation. function approximation methods expect to receive examples of the desired input output behavior of the function they are trying to approximate. we use these methods for value prediction simply by passing to them the s g of each update as a training example. we then interpret the approximate function they produce as an estimated value function. viewing each update as a conventional training example in this way enables us to use any of a wide range of existing function approximation methods for value prediction. in principle we can use any method for supervised learning from examples including artificial neural networks decision trees and various kinds of multivariate regression. however not all function approximation methods are equally well suited for use in reinforcement learning. the most sophisticated neural network and statistical methods all assume a static training set over which multiple passes are made. in reinforcement learning however it is important that learning be able to occur online while the agent interacts with its environment or with a model of its environment. to do this requires methods that are able to learn efficiently from incrementally acquired data. in addition reinforcement learning generally requires function approximation methods able to handle nonstationary target functions functions that change over time. for example in control methods based on gpi policy iteration we often seek to learn q while changes. even if the policy remains the same the target values of training examples are nonstationary if they are generated by bootstrapping methods and td learning. methods that cannot easily handle such nonstationarity are less suitable for reinforcement learning. the prediction objective the prediction objective up to now we have not specified an explicit objective for prediction. in the tabular case a continuous measure of prediction quality was not necessary because the learned value function could come to equal the true value function exactly. moreover the learned values at each state were decoupled an update at one state affected no other. but with genuine approximation an update at one state affects many others and it is not possible to get the values of all states exactly correct. by assumption we have far more states than weights so making one state s estimate more accurate invariably means making others less accurate. we are obligated then to say which states we care most about. we must specify a state distribution representing how much we care about the error in each state s. by the error in a state s we mean the square of the difference between the approximate value vsw and the true value v weighting this over the state space by we obtain a natural objective function the mean squared value error denoted ve vew s the square root of this measure the root ve gives a rough measure of how much the approximate values differ from the true values and is often used in plots. often is chosen to be the fraction of time spent in s. under on-policy training this is called the on-policy distribution we focus entirely on this case in this chapter. in continuing tasks the on-policy distribution is the stationary distribution under the on-policy distribution in episodic tasks in an episodic task the on-policy distribution is a little different in that it depends on how the initial states of episodes are chosen. let hs denote the probability that an episode begins in each state s and let denote the number of time steps spent on average in state s in a single episode. time is spent in a state s if episodes start in s or if transitions are made into s from a preceding state s in which time is spent hs s sps s a for all s s. this system of equations can be solved for the expected number of visits the on-policy distribution is then the fraction of time spent in each state normalized to sum to one for all s s. this is the natural choice without discounting. if there is discounting it should be treated as a form of termination which can be done simply by including a factor of in the second term of chapter on-policy prediction with approximation the two cases continuing and episodic behave similarly but with approximation they must be treated separately in formal analyses as we will see repeatedly in this part of the book. this completes the specification of the learning objective. but it is not completely clear that the ve is the right performance objective for reinforcement learning. remember that our ultimate purpose the reason we are learning a value function is to find a better policy. the best value function for this purpose is not necessarily the best for minimizing ve. nevertheless it is not yet clear what a more useful alternative goal for value prediction might be. for now we will focus on ve. an ideal goal in terms of ve would be to find a global optimum a weight vector w for which vew vew for all possible w. reaching this goal is sometimes possible for simple function approximators such as linear ones but is rarely possible for complex function approximators such as artificial neural networks and decision trees. short of this complex function approximators may seek to converge instead to a local optimum a weight vector w for which vew vew for all w in some neighborhood of w although this guarantee is only slightly reassuring it is typically the best that can be said for nonlinear function approximators and often it is enough. still for many cases of interest in reinforcement learning there is no guarantee of convergence to an optimum or even to within a bounded distance of an optimum. some methods may in fact diverge with their ve approaching infinity in the limit. in the last two sections we outlined a framework for combining a wide range of reinforcement learning methods for value prediction with a wide range of function approximation methods using the updates of the former to generate training examples for the latter. we also described a ve performance measure which these methods may aspire to minimize. the range of possible function approximation methods is far too large to cover all and anyway too little is known about most of them to make a reliable evaluation or recommendation. of necessity we consider only a few possibilities. in the rest of this chapter we focus on function approximation methods based on gradient principles and on linear gradient-descent methods in particular. we focus on these methods in part because we consider them to be particularly promising and because they reveal key theoretical issues but also because they are simple and our space is limited. stochastic-gradient and semi-gradient methods we now develop in detail one class of learning methods for function approximation in value prediction those based on stochastic gradient descent sgd methods are among the most widely used of all function approximation methods and are particularly well suited to online reinforcement learning. in gradient-descent methods the weight vector is a column vector with a fixed number and the approximate value function of real valued components w vsw is a differentiable function of w for all s s. we will be updating w at each of a series of discrete time steps t so we will need a notation wt for the denotes transpose needed here to turn the horizontal row vector in the text into a vertical column vector in this book vectors are generally taken to be column vectors unless explicitly written out horizontally or transposed. stochastic-gradient and semi-gradient methods weight vector at each step. for now let us assume that on each step we observe a new example st v consisting of a randomly selected state st and its true value under the policy. these states might be successive states from an interaction with the environment but for now we do not assume so. even though we are given the exact correct values v for each st there is still a difficult problem because our function approximator has limited resources and thus limited resolution. in particular there is generally no w that gets all the states or even all the examples exactly correct. in addition we must generalize to all the other states that have not appeared in examples. we assume that states appear in examples with the same distribution over which we are trying to minimize the ve as given by a good strategy in this case is to try to minimize error on the observed examples. stochastic gradient-descent methods do this by adjusting the weight vector after each example by a small amount in the direction that would most reduce the error on that example wt wt vstwt where is a positive step-size parameter and f for any scalar expression f that is a function of a vector w denotes the column vector of partial derivatives of the expression with respect to the components of the vector f f f f wd this derivative vector is the gradient of f with respect to w. sgd methods are gradient descent methods because the overall step in wt is proportional to the negative gradient of the example s squared error this is the direction in which the error falls most rapidly. gradient descent methods are called stochastic when the update is done as here on only a single example which might have been selected stochastically. over many examples making small steps the overall effect is to minimize an average performance measure such as the ve. it may not be immediately apparent why sgd takes only a small step in the direction of the gradient. could we not move all the way in this direction and completely eliminate the error on the example? in many cases this could be done but usually it is not desirable. remember that we do not seek or expect to find a value function that has zero error for all states but only an approximation that balances the errors in different states. if we completely corrected each example in one step then we would not find such a balance. in fact the convergence results for sgd methods assume that decreases over time. if it decreases in such a way as to satisfy the standard stochastic approximation conditions then the sgd method is guaranteed to converge to a local optimum. we turn now to the case in which the target output here denoted ut r of the tth training example st ut is not the true value v but some possibly random approximation to it. for example ut might be a noise-corrupted version of v or it might be one of the bootstrapping targets using v mentioned in the previous section. in chapter on-policy prediction with approximation these cases we cannot perform the exact update because v is unknown but we can approximate it by substituting ut in place of v this yields the following general sgd method for state-value prediction wt vstwt. if ut is an unbiased estimate that is if eutst s v for each t then wt is guaranteed to converge to a local optimum under the usual stochastic approximation conditions for decreasing for example suppose the states in the examples are the states generated by interaction simulated interaction with the environment using policy because the true value of a state is the expected value of the return following it the monte carlo target ut gt is by definition an unbiased estimate of v with this choice the general sgd method converges to a locally optimal approximation to v thus the gradient-descent version of monte carlo state-value prediction is guaranteed to find a locally optimal solution. pseudocode for a complete algorithm is shown in the box below. gradient monte carlo algorithm for estimating v v input the policy to be evaluated input a differentiable function v s rd r algorithm parameter step size initialize value-function weights w rd arbitrarily w loop forever each episode generate an episode rt st using loop for each step of episode t t w w vstw one does not obtain the same guarantees if a bootstrapping estimate of v is used as the target ut in bootstrapping targets such as n-step returns gttn or the dp rst ar all depend on the current value of the weight vector wt which implies that they will be biased and that they will not produce a true gradient-descent method. one way to look at this is that the key step from to relies on the target being independent of wt. this step would not be valid if a bootstrapping estimate were used in place of v bootstrapping methods are not in fact instances of true gradient descent they take into account the effect of changing the weight vector wt on the estimate but ignore its effect on the target. they include only a part of the gradient and accordingly we call them semi-gradient methods. although semi-gradient methods do not converge as robustly as gradient methods they do converge reliably in important cases such as the linear case discussed in the next section. moreover they offer important advantages that make them often clearly preferred. one reason for this is that they typically enable significantly faster learning as we have seen in chapters and another is that they enable learning stochastic-gradient and semi-gradient methods to be continual and online without waiting for the end of an episode. this enables them to be used on continuing problems and provides computational advantages. a prototyp. ical semi-gradient method is semi-gradient which uses ut as its target. complete pseudocode for this method is given in the box below. semi-gradient for estimating v v input the policy to be evaluated input a differentiable function v s rd r such that vterminal algorithm parameter step size initialize value-function weights w rd arbitrarily w loop for each episode initialize s loop for each step of episode choose a take action a observe r w w vsw s until is terminal state aggregation is a simple form of generalizing function approximation in which states are grouped together with one estimated value component of the weight vector w for each group. the value of a state is estimated as its group s component and when the state is updated that component alone is updated. state aggregation is a special case of sgd in which the gradient vstwt is for st s group s component and for the other components. example state aggregation on the random walk consider a version of the random walk task and on pages and the states are numbered from to left to right and all episodes begin near the center in state state transitions are from the current state to one of the neighboring states to its left or to one of the neighboring states to its right all with equal probability. of course if the current state is near an edge then there may be fewer than neighbors on that side of it. in this case all the probability that would have gone into those missing neighbors goes into the probability of terminating on that side state has a chance of terminating on the left and state has a chance of terminating on the right. as usual termination on the left produces a reward of and termination on the right produces a reward of all other transitions have a reward of zero. we use this task as a running example throughout this section. figure shows the true value function v for this task. it is nearly a straight line but curving slightly toward the horizontal for the last states at each end. also shown is the final approximate value function learned by the gradient monte-carlo algorithm with state aggregation after episodes with a step size of for the state aggregation the states were partitioned into groups of states each states were one group states were another and so on. the chapter on-policy prediction with approximation figure function approximation by state aggregation on the random walk task using the gradient monte carlo algorithm staircase effect shown in the figure is typical of state aggregation within each group the approximate value is constant and it changes abruptly from one group to the next. these approximate values are close to the global minimum of the ve some of the details of the approximate values are best appreciated by reference to the state distribution for this task shown in the lower portion of the figure with a rightside scale. state in the center is the first state of every episode but is rarely visited again. on average about of the time steps are spent in the start state. the states reachable in one step from the start state are the second most visited with about of the time steps being spent in each of them. from there falls off almost linearly reaching about at the extreme states and the most visible effect of the distribution is on the leftmost groups whose values are clearly shifted higher than the unweighted average of the true values of states within the group and on the rightmost groups whose values are clearly shifted lower. this is due to the states in these areas having the greatest asymmetry in their weightings by for example in the leftmost group state is weighted more than times more strongly than state thus the estimate for the group is biased toward the true value of state which is higher than the true value of state linear methods one of the most important special cases of function approximation is that in which the approximate function v is a linear function of the weight vector w. corresponding with the to every state s there is a real-valued vector xs same number of components as w. linear methods approximate state-value function by true valuev approximate mc value v state distribution linear methods the inner product between w and xs vsw wixis. in this case the approximate value function is said to be linear in the weights or simply linear. the vector xs is called a feature vector representing state s. each component xis of xs is the value of a function xi s r. we think of a feature as the entirety of one of these functions and we call its value for a state s a feature of s. for linear methods features are basis functions because they form a linear basis for the set of approximate functions. constructing d-dimensional feature vectors to represent states is the same as selecting a set of d basis functions. features may be defined in many different ways we cover a few possibilities in the next sections. it is natural to use sgd updates with linear function approximation. the gradient of the approximate value function with respect to w in this case is vsw xs. thus in the linear case the general sgd update reduces to a particularly simple form wt because it is so simple the linear sgd case is one of the most favorable for mathematical analysis. almost all useful convergence results for learning systems of all kinds are for linear simpler function approximation methods. in particular in the linear case there is only one optimum in degenerate cases one set of equally good optima and thus any method that is guaranteed to converge to or near a local optimum is automatically guaranteed to converge to or near the global optimum. for example the gradient monte carlo algorithm presented in the previous section converges to the global optimum of the ve under linear function approximation if is reduced over time according to the usual conditions. the semi-gradient algorithm presented in the previous section also converges under linear function approximation but this does not follow from general results on sgd a separate theorem is necessary. the weight vector converged to is also not the global optimum but rather a point near the local optimum. it is useful to consider this important case in more detail specifically for the continuing case. the update at each time t is wt wt where here we have used the notational shorthand xt xst. once the system has reached steady state for any given wt the expected next weight vector can be written wt awt chapter on-policy prediction with approximation rd rd where b rd and a from it is clear that if the system converges it must converge to the weight vector wtd at which b awtd b awtd a wtd this quantity is called the td fixed point. in fact linear semi-gradient converges to this point. some of the theory proving its convergence and the existence of the inverse above is given in the box. proof of convergence of linear what properties assure convergence of the linear algorithm some insight can be gained by rewriting as awt b. note that the matrix a multiplies the weight vector wt and not b only a is important to convergence. to develop intuition consider the special case in which a is a diagonal matrix. if any of the diagonal elements are negative then the corresponding diagonal element of i a will be greater than one and the corresponding component of wt will be amplified which will lead to divergence if continued. on the other hand if the diagonal elements of a are all positive then can be chosen smaller than one over the largest of them such that i a is diagonal with all diagonal elements between and in this case the first term of the update tends to shrink wt and stability is assured. in general case wt will be reduced toward zero whenever a is positive definite meaning for real vector y. positive definiteness also ensures that the inverse a exists. for linear in the continuing case with the a matrix can be written pr a px where is the stationary distribution under is the probability of linear methods transition from s to under policy p is the matrix of these probabilities d is the diagonal matrix with the on its diagonal and x is the d matrix with xs as its rows. from here it is clear that the inner matrix di p is key to determining the positive definiteness of a. for a key matrix of this type positive definiteness is assured if all of its columns sum to a nonnegative number. this was shown by sutton p. based on two previously established theorems. one theorem says that any matrix m is positive definite if and only if the symmetric matrix s is positive definite appendix. the second theorem says that any symmetric real matrix s is positive definite if all of its diagonal entries are positive and greater than the sum of the absolute values of the corresponding off-diagonal entries p. for our key matrix di p the diagonal entries are positive and the off-diagonal entries are negative so all we have to show is that each row sum plus the corresponding column sum is positive. the row sums are all positive because p is a stochastic matrix and thus it only remains to show that the column sums are nonnegative. note that the row vector of the column sums of any matrix m can be written as where is the column vector with all components equal to let denote the of the where by virtue of being the stationary distribution. the column sums of our key matrix then are p p is the stationary distribution all components of which are positive. thus the key matrix and its a matrix are positive definite and on-policy is stable. conditions and a schedule for reducing over time are needed to prove convergence with probability one. at the td fixed point it has also been proven the continuing case that the ve is within a bounded expansion of the lowest possible error vewtd min w vew. that is the asymptotic error of the td method is no more than times the smallest possible error that attained in the limit by the monte carlo method. because is often near one this expansion factor can be quite large so there is substantial potential loss in asymptotic performance with the td method. on the other hand recall that the td methods are often of vastly reduced variance compared to monte carlo methods and thus faster as we saw in chapters and which method will be best depends on the nature of the approximation and problem and on how long learning continues. chapter on-policy prediction with approximation a bound analogous to applies to other on-policy bootstrapping methods as well. for example linear semi-gradient dp with ut with updates according to the on-policy distribution will also converge to the td fixed point. one-step semi-gradient action-value methods such as semi-gradient covered in the next chapter converge to an analogous fixed point and an analogous bound. for episodic tasks there is a slightly different but related bound bertsekas and tsitsiklis there are also a few technical conditions on the rewards features and decrease in the step-size parameter which we have omitted here. the full details can be found in the original paper and van roy rst ar critical to the these convergence results is that states are updated according to the on-policy distribution. for other update distributions bootstrapping methods using function approximation may actually diverge to infinity. examples of this and a discussion of possible solution methods are given in chapter example bootstrapping on the random walk state aggregation is a special case of linear function approximation so let s return to the random walk to illustrate some of the observations made in this chapter. the left panel of figure shows the final value function learned by the semi-gradient algorithm using the same state aggregation as in example we see that the near-asymptotic td approximation is indeed farther from the true values than the monte carlo approximation shown in figure nevertheless td methods retain large potential advantages in learning rate and generalize monte carlo methods as we investigated fully with n-step td methods in chapter the right panel of figure shows results with an n-step semi-gradient td method using state aggregation on the random walk that are strikingly similar to those we obtained earlier with tabular methods and the random walk to obtain such quantitatively similar results we switched the state aggregation to groups of states each. the groups were then quantitatively close figure bootstrapping with state aggregation on the random walk task. left asymptotic values of semi-gradient td are worse than the asymptotic monte carlo values in figure right performance of n-step methods with state-aggregation are strikingly similar to those with tabular representations figure these data are averages over runs. averagerms errorover statesand first true valuev approximate td v feature construction for linear methods to the states of the tabular problem. in particular recall that state transitions were up to states to the left or right. a typical transition would then be of states to the right or left which is quantitively analogous to the single-state state transitions of the tabular system. to complete the match we use here the same performance measure an unweighted average of the rms error over all states and over the first episodes rather than a ve objective as is otherwise more appropriate when using function approximation. the semi-gradient n-step td algorithm used in this example is the natural extension of the tabular n-step td algorithm presented in chapter to semi-gradient function approximation. pseudocode is given in the box below. n-step semi-gradient td for estimating v v input the policy to be evaluated input a differentiable function v s rd r such that vterminal algorithm parameters step size a positive integer n initialize value-function weights w arbitrarily w all store and access operations and rt can take their index mod n loop for each episode if t t then initialize and store terminal t loop for t until t g t n if i i if n t then g g n vs w w vs vs take an action according to observe and store the next reward as and the next state as if is terminal then t t is the time whose state s estimate is being updated the key equation of this algorithm analogous to is wtn wtn vstwtn vstwtn t t where the n-step return is generalized from to gttn n n vstnwtn t t n. exercise show that tabular methods such as presented in part i of this book are a special case of linear function approximation. what would the feature vectors be? chapter on-policy prediction with approximation feature construction for linear methods linear methods are interesting because of their convergence guarantees but also because in practice they can be very efficient in terms of both data and computation. whether or not this is so depends critically on how the states are represented in terms of features which we investigate in this large section. choosing features appropriate to the task is an important way of adding prior domain knowledge to reinforcement learning systems. intuitively the features should correspond to the aspects of the state space along which generalization may be appropriate. if we are valuing geometric objects for example we might want to have features for each possible shape color size or function. if we are valuing states of a mobile robot then we might want to have features for locations degrees of remaining battery power recent sonar readings and so on. a limitation of the linear form is that it cannot take into account any interactions between features such as the presence of feature i being good only in the absence of feature j. for example in the pole-balancing task high angular velocity can be either good or bad depending on the angle. if the angle is high then high angular velocity means an imminent danger of falling a bad state whereas if the angle is low then high angular velocity means the pole is righting itself a good state. a linear value function could not represent this if its features coded separately for the angle and the angular velocity. it needs instead or in addition features for combinations of these two underlying state dimensions. in the following subsections we consider a variety of general ways of doing this. polynomials the states of many problems are initially expressed as numbers such as positions and velocities in the pole-balancing task the number of cars in each lot in the jack s car rental problem or the gambler s capital in the gambler problem in these types of problems function approximation for reinforcement learning has much in common with the familiar tasks of interpolation and regression. various families of features commonly used for interpolation and regression can also be used in reinforcement learning. polynomials make up one of the simplest families of features used for interpolation and regression. while the basic polynomial features we discuss here do not work as well as other types of features in reinforcement learning they serve as a good introduction because they are simple and familiar. as an example suppose a reinforcement learning problem has states with two numerical dimensions. for a single representative state s let its two numbers be r and r. you might choose to represent s simply by its two state dimensions so that xs but then you would not be able to take into account any interactions between these dimensions. in addition if both and were zero then the approximate value would have to also be zero. both limitations can be overcome by instead representing s by the four-dimensional feature vector xs the initial feature allows the representation of affine functions in the original state numbers and the final product feature enables interactions to be taken into account. or you might choose to use higher-dimensional feature vectors like xs feature construction for linear methods to take more complex interactions into account. such feature vectors enable approximations as arbitrary quadratic functions of the state numbers even though the approximation is still linear in the weights that have to be learned. generalizing this example from two to k numbers we can represent highlycomplex interactions among a problem s state dimensions suppose each state s corresponds to k numbers sk with each si r. for this k-dimensional state space each order-n polynomial-basis feature xi can be written as xis k j where each cij is an integer in the set n for an integer n these features make up the order-n polynomial basis for dimension k which contains different features. higher-order polynomial bases allow for more accurate approximations of more complicated functions. but because the number of features in an order-n polynomial basis grows exponentially with the dimension k of the natural state space n it is generally necessary to select a subset of them for function approximation. this can be done using prior beliefs about the nature of the function to be approximated and some automated selection methods developed for polynomial regression can be adapted to deal with the incremental and nonstationary nature of reinforcement learning. exercise why does define distinct features for dimension k? exercise what n and cij produce the feature vectors xs fourier basis another linear function approximation method is based on the time-honored fourier series which expresses periodic functions as weighted sums of sine and cosine basis functions of different frequencies. function f is periodic if f f for all x and some period the fourier series and the more general fourier transform are widely used in applied sciences in part because if a function to be approximated is known then the basis function weights are given by simple formulae and further with enough basis functions essentially any function can be approximated as accurately as desired. in reinforcement learning where the functions to be approximated are unknown fourier basis functions are of interest because they are easy to use and can perform well in a range of reinforcement learning problems. first consider the one-dimensional case. the usual fourier series representation of a function of one dimension having period represents the function as a linear combination of sine and cosine functions that are each periodic with periods that evenly divide other words whose frequencies are integer multiples of a fundamental frequency but if you are interested in approximating an aperiodic function defined over a bounded interval then you can use these fourier basis featues with set to the length the interval. chapter on-policy prediction with approximation the function of interest is then just one period of the periodic linear combination of the sine and cosine features. furthermore if you set to twice the length of the interval of interest and restrict attention to the approximation over the half interval then you can use just the cosine features. this is possible because you can represent any even function that is any function that is symmetric about the origin with just the cosine basis. so any function over the half-period can be approximated as closely as desired with enough cosine features. any function is not exactly correct because the function has to be mathematically well-behaved but we skip this technicality here. alternatively it is possible to use just sine features linear combinations of which are always odd functions that is functions that are anti-symmetric about the origin. but it is generally better to keep just the cosine features because half-even functions tend to be easier to approximate than half-odd functions because the latter are often discontinuous at the origin. of course this does not rule out using both sine and cosine features to approximate over the interval which might be advantageous in some circumstances. following this logic and letting so that the features are defined over the half interval the one-dimensional order-n fourier cosine basis consists of the n features xis cosi s s for i n. figure shows one-dimensional fourier cosine features xi for i is a constant function. figure one-dimensional fourier cosine-basis features xi i for approximating functions over the interval after konidaris et al. this same reasoning applies to the fourier cosine series approximation in the multi dimensional case as described in the box below. suppose each state s corresponds to a vector of k numbers s with each si the ith feature in the order-n fourier cosine basis can then be written xis ci where ci j n for j k and i this defines a feature for each of the possible integer vectors ci. with ci fourier basis function fourier basis function fourier basis function fourier basis function feature construction for linear methods the inner product has the effect of assigning an integer in n to each dimension of s. as in the one-dimensional case this integer determines the feature s frequency along that dimension. the features can of course be shifted and scaled to suit the bounded state space of a particular application. as an example consider the k case in which s where each ci figure shows a selection of six fourier cosine features each labeled by the vector ci that defines it is the horizontal axis and ci is shown as a row vector with the index i omitted. any zero in c means the feature is constant along that state dimension. so if c the feature is constant over both dimensions if c the feature is constant over the second dimension and varies over the first with frequency depending on and similarly for c when c with neither cj the feature varies along both dimensions and represents an interaction between the two state variables. the values of and determine the frequency along each dimension and their ratio gives the direction of the interaction. ci figure a selection of six two-dimensional fourier cosine features each labeled by the vector ci that defines it is the horizontal axis and ci is shown with the index i omitted. after konidaris et al. when using fourier cosine features with a learning algorithm such as semigradient or semi-gradient sarsa it may be helpful to use a different step-size parameter for each feature. if is the basic step-size parameter then konidaris osentoski and thomas suggest setting the step-size parameter for feature xi to when each ci j in which case i i fourier cosine features with sarsa can produce good performance compared to several c chapter on-policy prediction with approximation other collections of basis functions including polynomial and radial basis functions. not surprisingly however fourier features have trouble with discontinuities because it is difficult to avoid ringing around points of discontinuity unless very high frequency basis functions are included. the number of features in the order-n fourier basis grows exponentially with the dimension of the state space but if that dimension is small enough k then one can select n so that all of the order-n fourier features can be used. this makes the selection of features more-or-less automatic. for high dimension state spaces however it is necessary to select a subset of these features. this can be done using prior beliefs about the nature of the function to be approximated and some automated selection methods can be adapted to deal with the incremental and nonstationary nature of reinforcement learning. an advantage of fourier basis features in this regard is that it is easy to select features by setting the ci vectors to account for suspected interactions among the state variables and by limiting the values in the cj vectors so that the approximation can filter out high frequency components considered to be noise. on the other hand because fourier features are non-zero over the entire state space the few zeros excepted they represent global properties of states which can make it difficult to find good ways to represent local properties. figure shows learning curves comparing the fourier and polynomial bases on the random walk example. in general we do not recommend using polynomials for online figure fourier basis vs polynomials on the random walk. shown are learning curves for the gradient monte carlo method with fourier and polynomial bases of order and the step-size parameters were roughly optimized for each case for the polynomial basis and for the fourier basis. the performance measure is the root mean squared value error are families of polynomials more complicated than those we have discussed for example different families of orthogonal polynomials and these might work better but at present there is little experience with them in reinforcement learning. basisfourier basispve averagedover runs feature construction for linear methods coarse coding consider a task in which the natural representation of the state set is a continuous twodimensional space. one kind of representation for this case is made up of features corresponding to circles in state space as shown to the right. if the state is inside a circle then the corresponding feature has the value and is said to be present otherwise the feature is and is said to be absent. this kind of feature is called a binary feature. given a state which binary features are present indicate within which circles the state lies and thus coarsely code for its location. representing a state with features that overlap in this way they need not be circles or binary is known as coarse coding. figure coarse coding. generalization from state s to state depends on the number of their features whose receptive fields this case circles overlap. these states have one feature in common so there will be slight generalization between them. assuming linear gradient-descent function approximation consider the effect of the size and density of the circles. corresponding to each circle is a single weight component of w that is affected by learning. if we train at one state a point in the space then the weights of all circles intersecting that state will be affected. thus by the approximate value function will be affected at all states within the union of the circles with a greater effect the more circles a point has in common with the state as shown in figure if the circles are small then the generalization will be over a short distance as in figure whereas if they are large it will be over a large distance as in figure figure generalization in linear function approximation methods is determined by the sizes and shapes of the features receptive fields. all three of these cases have roughly the same number and density of features. narrow generalizationb broad generalizationc asymmetric generalization chapter on-policy prediction with approximation dle. moreover the shape of the features will determine the nature of the generalization. for example if they are not strictly circular but are elongated in one direction then generalization will be similarly affected as in figure features with large receptive fields give broad generalization but might also seem to limit the learned function to a coarse approximation unable to make discriminations much finer than the width of the receptive fields. happily this is not the case. initial generalization from one point to another is indeed controlled by the size and shape of the receptive fields but acuity the finest discrimination ultimately possible is controlled more by the total number of features. example coarseness of coarse coding this example illustrates the effect on learning of the size of the receptive fields in coarse coding. linear function approximation based on coarse coding and was used to learn a one-dimensional square-wave function at the top of figure the values of this function were used as the targets ut. with just one dimension the receptive fields were intervals rather than circles. learning was repeated with three different sizes of the intervals narrow medium and broad as shown at the bottom of the figure. all three cases had the same density of features about over the extent of the function being learned. training examples were generated uniformly at random over this extent. the step-size parameter was n where n is the number of features that were present at one time. figure shows the functions learned in all three cases over the course of learning. note that the width of the features had a strong effect early in learning. with broad features the generalization tended to be broad with narrow features only the close neighbors of each trained point were changed causing the function learned to be more bumpy. however the final function learned was affected only slightly by the width of the features. receptive field shape figure example of feature width s strong effect on initial generalization row and weak effect on asymptotic accuracy row. feature construction for linear methods tends to have a strong effect on generalization but little effect on asymptotic solution quality. tile coding tile coding is a form of coarse coding for multi-dimensional continuous spaces that is flexible and computationally efficient. it may be the most practical feature representation for modern sequential digital computers. open-source software is available for many kinds of tile coding. in tile coding the receptive fields of the features are grouped into partitions of the state space. each such partition is called a tiling and each element of the partition is called a tile. for example the simplest tiling of a two-dimensional state space is a uniform grid such as that shown on the left side of figure the tiles or receptive field here are squares rather than the circles in figure if just this single tiling were used then the state indicated by the white spot would be represented by the single feature whose tile it falls within generalization would be complete to all states within the same tile and nonexistent to states outside it. with just one tiling we would not have coarse coding but just a case of state aggregation. figure multiple overlapping grid-tilings on a limited two-dimensional space. these tilings are offset from one another by a uniform amount in each dimension. to get the strengths of coarse coding requires overlapping receptive fields and by definition the tiles of a partition do not overlap. to get true coarse coding with tile coding multiple tilings are used each offset by a fraction of a tile width. a simple case with four tilings is shown on the right side of figure every state such as that indicated by the white spot falls in exactly one tile in each of the four tilings. these four tiles correspond to four features that become active when the state occurs. specifically the feature vector xs has one component for each tile in each tiling. in this example there are components all of which will be except for the four corresponding to the tiles that s falls within. figure shows the advantage of multiple offset tilings coding over a single tiling on the random walk example. point in state spaceto berepresentedtiling state spacefour activetilesfeatures overlap the pointand are used to represent it chapter on-policy prediction with approximation figure why we use coarse coding. shown are learning curves on the random walk example for the gradient monte carlo algorithm with a single tiling and with multiple tilings. the space of states was treated as a single continuous dimension covered with tiles each states wide. the multiple tilings were offset from each other by states. the step-size parameter was set so that the initial learning rate in the two cases was the same for the single tiling and for the tilings. an immediate practical advantage of tile coding is that because it works with partitions the overall number of features that are active at one time is the same for any state. exactly one feature is present in each tiling so the total number of features present is always the same as the number of tilings. this allows the step-size parameter to be set in an easy intuitive way. for example choosing n where n is the number of tilings results in exact one-trial learning. if the example s v is trained on then whatever the prior estimate vswt the new estimate will be v. usually one wishes to change more slowly than this to allow for generalization and stochastic variation in target outputs. for example one might choose in which case the estimate for the trained state would move one-tenth of the way to the target in one update and neighboring states will be moved less proportional to the number of tiles they have in common. tile coding also gains computational advantages from its use of binary feature vectors. because each component is either or the weighted sum making up the approximate value function is almost trivial to compute. rather than performing d multiplications and additions one simply computes the indices of the n d active features and then adds up the n corresponding components of the weight vector. generalization occurs to states other than the one trained if those states fall within any of the same tiles proportional to the number of tiles in common. even the choice of how to offset the tilings from each other affects generalization. if they are offset uniformly in each dimension as they were in figure then different states can generalize in qualitatively different ways as shown in the upper half of figure each of the eight subfigures show the pattern of generalization from a trained state to nearby points. in this example there are eight tilings thus subregions within a tile that generalize distinctly but all according to one of these eight patterns. note how uniform offsets averagedover aggregationone tilingtile coding tilingspve feature construction for linear methods figure why tile asymmetrical offsets are preferred in tile coding. shown is the strength of generalization from a trained state indicated by the small black plus to nearby states for the case of eight tilings. if the tilings are uniformly offset then there are diagonal artifacts and substantial variations in the generalization whereas with asymmetrically offset tilings the generalization is more spherical and homogeneous. result in a strong effect along the diagonal in many patterns. these artifacts can be avoided if the tilings are offset asymmetrically as shown in the lower half of the figure. these lower generalization patterns are better because they are all well centered on the trained state with no obvious asymmetries. tilings in all cases are offset from each other by a fraction of a tile width in each dimension. if w denotes the tile width and n the number of tilings then w n is a fundamental unit. within small squares w n on a side all states activate the same tiles have the same feature representation and the same approximated value. if a state is moved by w n in any cartesian direction the feature representation changes by one componenttile. uniformly offset tilings are offset from each other by exactly this unit distance. for a two-dimensional space we say that each tiling is offset by the displacement vector meaning that it is offset from the previous tiling by w n times this vector. in these terms possible generalizations for uniformly offset tilingspossible generalizationsfor asymmetrically offset tilings chapter on-policy prediction with approximation the asymmetrically offset tilings shown in the lower part of figure are offset by a displacement vector of extensive studies have been made of the effect of different displacement vectors on the generalization of tile coding and militzer an an miller and parks miller an glanz and carter assessing their homegeneity and tendency toward diagonal artifacts like those seen for the displacement vectors. based on this work miller and glanz recommend using displacement vectors consisting of the first odd integers. in particular for a continuous space of dimension k a good choice is to use the first odd integers with n number of tilings set to an integer power of greater than or equal to this is what we have done to produce the tilings in the lower half of figure in which k n and the displacement vector is in a three-dimensional case the first four tilings would be offset in total from a base position by and opensource software that can efficiently make tilings like this for any k is readily available. in choosing a tiling strategy one has to pick the number of the tilings and the shape of the tiles. the number of tilings along with the size of the tiles determines the resolution or fineness of the asymptotic approximation as in general coarse coding and illustrated in figure the shape of the tiles will determine the nature of generalization as in figure square tiles will generalize roughly equally in each dimension as indicated in figure tiles that are elongated along one dimension such as the stripe tilings in figure will promote generalization along that dimension. the tilings in figure are also denser and thinner on the left promoting discrimination along the horizonal dimension at lower values along that dimension. the diagonal stripe tiling in figure will promote generalization along one diagonal. in higher dimensions axis-aligned stripes correspond to ignoring some of the dimensions in some of the tilings that is to hyperplanar slices. irregular tilings such as shown in figure are also possible though rare in practice and beyond the standard software. figure tilings need not be grids. they can be arbitrarily shaped and non-uniform while still in many cases being computationally efficient to compute. in practice it is often desirable to use different shaped tiles in different tilings. for example one might use some vertical stripe tilings and some horizontal stripe tilings. this would encourage generalization along either dimension. however with stripe tilings alone it is not possible to learn that a particular conjunction of horizontal and vertical a irregularb log stripesc diagonal stripes feature construction for linear methods coordinates has a distinctive value is learned for it will bleed into states with the same horizontal and vertical coordinates. for this one needs the conjunctive rectangular tiles such as originally shown in figure with multiple tilings some horizontal some vertical and some conjunctive one can get everything a preference for generalizing along each dimension yet the ability to learn specific values for conjunctions sutton for examples. the choice of tilings determines generalization and until this choice can be effectively automated it is important that tile coding enables the choice to be made flexibly and in a way that makes sense to people. another useful trick for reducing memory requirements is hashing a consistent pseudorandom collapsing of a large tiling into a much smaller set of tiles. hashing produces tiles consisting of noncontiguous disjoint regions randomly spread throughout the state space but that still form an exhaustive partition. for example one tile might consist of the four subtiles shown to the right. through hashing memory requirements are often reduced by large factors with little loss of performance. this is possible because high resolution is needed in only a small fraction of the state space. hashing frees us from the curse of dimensionality in the sense that memory requirements need not be exponential in the number of dimensions but need merely match the real demands of the task. good open-source implementations of tile coding including hashing are widely available. exercise suppose we believe that one of two state dimensions is more likely to have an effect on the value function than is the other that generalization should be primarily across this dimension rather than along it. what kind of tilings could be used to take advantage of this prior knowledge? radial basis functions radial basis functions are the natural generalization of coarse coding to continuousvalued features. rather than each feature being either or it can be anything in the interval reflecting various degrees to which the feature is present. a typical rbf feature xi has a gaussian response xis dependent only on the distance between the state s and the feature s prototypical or center state ci and relative to the feature s width i xis i the norm or distance metric of course can be chosen in whatever way seems most appropriate to the states and task at hand. figure shows a one-dimensional example with a euclidean distance metric. the primary advantage of rbfs over binary features is that they produce approximate functions that vary smoothly and are differentiable. although this is appealing in most cases it has no practical significance. nevertheless extensive studies have been made of graded response functions such as rbfs in the context of tile coding miller onetile chapter on-policy prediction with approximation figure one-dimensional radial basis functions. et al. an et al. lane handelman and gelfand all of these methods require substantial additional computational complexity tile coding and often reduce performance when there are more than two state dimensions. in high dimensions the edges of tiles are much more important and it has proven difficult to obtain well controlled graded tile activations near the edges. an rbf network is a linear function approximator using rbfs for its features. learning is defined by equations and exactly as in other linear function approximators. in addition some learning methods for rbf networks change the centers and widths of the features as well bringing them into the realm of nonlinear function approximators. nonlinear methods may be able to fit target functions much more precisely. the downside to rbf networks and to nonlinear rbf networks especially is greater computational complexity and often more manual tuning before learning is robust and efficient. selecting step-size parameters manually most sgd methods require the designer to select an appropriate step-size parameter ideally this selection would be automated and in some cases it has been but for most cases it is still common practice to set it manually. to do this and to better understand the algorithms it is useful to develop some intuitive sense of the role of the step-size parameter. can we say in general how it should be set? theoretical considerations are unfortunately of little help. the theory of stochastic approximation gives us conditions on a slowly decreasing step-size sequence that are sufficient to guarantee convergence but these tend to result in learning that is too slow. the classical choice t which produces sample averages in tabular mc methods is not appropriate for td methods for nonstationary problems or for any method using function approximation. for linear methods there are recursive least-squares methods that set an optimal matrix step size and these methods can be extended to temporaldifference learning as in the lstd method described in section but these require step-size parameters or d times more parameters than we are learning. for this reason we rule them out for use on large problems where function approximation is most needed. to get some intuitive feel for how to set the step-size parameter manually it is best to go back momentarily to the tabular case. there we can understand that a step size of will result in a complete elimination of the sample error after one target nonlinear function approximation artificial neural networks with a step size of one. as discussed on page we usually want to learn slower than this. in the tabular case a step size of would take about experiences to converge approximately to their mean target and if we wanted to learn in experiences we would use then the tabular estimate for a state will approach the mean of its targets with the most recent targets having the greatest effect after about experiences with the state. in general if with general function approximation there is not such a clear notion of number of experiences with a state as each state may be similar to and dissimilar from all the others to various degrees. however there is a similar rule that gives similar behavior in the case of linear function approximation. suppose you wanted to learn in about experiences with substantially the same feature vector. a good rule of thumb for setting the step-size parameter of linear sgd methods is then where x is a random feature vector chosen from the same distribution as input vectors will be in the sgd. this method works best if the feature vectors do not vary greatly in length ideally is a constant. exercise suppose you are using tile coding to transform a seven-dimensional continuous state space into binary feature vectors to estimate a state value function vsw v you believe that the dimensions do not interact strongly so you decide to use eight tilings of each dimension separately tilings for tilings. in addition in case there are some pairwise interactions between the dimensions you also take all pairs of dimensions and tile each pair conjunctively with rectangular tiles. you make two tilings for each pair of dimensions making a grand total of tilings. given these feature vectors you suspect that you still have to average out some noise so you decide that you want learning to be gradual taking about presentations with the same feature vector before learning nears its asymptote. what step-size parameter should you use? why? nonlinear function approximation artificial neu ral networks artificial neural networks are widely used for nonlinear function approximation. an ann is a network of interconnected units that have some of the properties of neurons the main components of nervous systems. anns have a long history with the latest advances in training deeply-layered anns learning being responsible for some of the most impressive abilities of machine learning systems including reinforcement learning systems. in chapter we describe several impressive examples of reinforcement learning systems that use ann function approximation. figure shows a generic feedforward ann meaning that there are no loops in the network that is there are no paths within the network by which a unit s output can influence its input. the network in the figure has an output layer consisting of two output units an input layer with four input units and two hidden layers layers that chapter on-policy prediction with approximation figure a generic feedforward neural network with four input units two output units and two hidden layers. are neither input nor output layers. a real-valued weight is associated with each link. a weight roughly corresponds to the efficacy of a synaptic connection in a real neural network section if an ann has at least one loop in its connections it is a recurrent rather than a feedforward ann. although both feedforward and recurrent anns have been used in reinforcement learning here we look only at the simpler feedforward case. the units circles in figure are typically semi-linear units meaning that they compute a weighted sum of their input signals and then apply to the result a nonlinear function called the activation function to produce the unit s output or activation. different activation functions are used but they are typically s-shaped or sigmoid functions such as the logistic function f e x though sometimes the rectifier nonlinearity f x is used. a step function like f if x and otherwise results in a binary unit with threshold the units in a network s input layer are somewhat different in having their activations set to externally-supplied values that are the inputs to the function the network is approximating. the activation of each output unit of a feedforward ann is a nonlinear function of the activation patterns over the network s input units. the functions are parameterized by the network s connection weights. an ann with no hidden layers can represent only a very small fraction of the possible input-output functions. however an ann with a single hidden layer containing a large enough finite number of sigmoid units can approximate any continuous function on a compact region of the network s input space to any degree of accuracy this is also true for other nonlinear activation functions that satisfy mild conditions but nonlinearity is essential if all the units in a multi-layer feedforward ann have linear activation functions the entire network is equivalent to a network with no hidden layers linear functions of linear functions are themselves linear. nonlinear function approximation artificial neural networks despite this universal approximation property of one-hidden-layer anns both experience and theory show that approximating the complex functions needed for many artificial intelligence tasks is made easier indeed may require abstractions that are hierarchical compositions of many layers of lower-level abstractions that is abstractions produced by deep architectures such as anns with many hidden layers. bengio for a thorough review. the successive layers of a deep ann compute increasingly abstract representations of the network s raw input with each unit providing a feature contributing to a hierarchical representation of the overall input-output function of the network. training the hidden layers of an ann is therefore a way to automatically create features appropriate for a given problem so that hierarchical representations can be produced without relying exclusively on hand-crafted features. this has been an enduring challenge for artificial intelligence and explains why learning algorithms for anns with hidden layers have received so much attention over the years. anns typically learn by a stochastic gradient method each weight is adjusted in a direction aimed at improving the network s overall performance as measured by an objective function to be either minimized or maximized. in the most common supervised learning case the objective function is the expected error or loss over a set of labeled training examples. in reinforcement learning anns can use td errors to learn value functions or they can aim to maximize expected reward as in a gradient bandit or a policygradient algorithm in all of these cases it is necessary to estimate how a change in each connection weight would influence the network s overall performance in other words to estimate the partial derivative of an objective function with respect to each weight given the current values of all the network s weights. the gradient is the vector of these partial derivatives. the most successful way to do this for anns with hidden layers the units have differentiable activation functions is the backpropagation algorithm which consists of alternating forward and backward passes through the network. each forward pass computes the activation of each unit given the current activations of the network s input units. after each forward pass a backward pass efficiently computes a partial derivative for each weight. in other stochastic gradient learning algorithms the vector of these partial derivatives is an estimate of the true gradient. in section we discuss methods for training anns with hidden layers that use reinforcement learning principles instead of backpropagation. these methods are less efficient than the backpropagation algorithm but they may be closer to how real neural networks learn. the backpropagation algorithm can produce good results for shallow networks having or hidden layers but it may not work well for deeper anns. in fact training a network with k hidden layers can actually result in poorer performance than training a network with k hidden layers even though the deeper network can represent all the functions that the shallower network can explaining results like these is not easy but several factors are important. first the large number of weights in a typical deep ann makes it difficult to avoid the problem of overfitting that is the problem of failing to generalize correctly to cases on which the network has not been trained. second backpropagation does not work well for deep anns because the partial chapter on-policy prediction with approximation derivatives computed by its backward passes either decay rapidly toward the input side of the network making learning by deep layers extremely slow or the partial derivatives grow rapidly toward the input side of the network making learning unstable. methods for dealing with these problems are largely responsible for many impressive recent results achieved by systems that use deep anns. overfitting is a problem for any function approximation method that adjusts functions with many degrees of freedom on the basis of limited training data. it is less of a problem for online reinforcement learning that does not rely on limited training sets but generalizing effectively is still an important issue. overfitting is a problem for anns in general but especially so for deep anns because they tend to have very large numbers of weights. many methods have been developed for reducing overfitting. these include stopping training when performance begins to decrease on validation data different from the training data validation modifying the objective function to discourage complexity of the approximation and introducing dependencies among the weights to reduce the number of degrees of freedom weight sharing. a particularly effective method for reducing overfitting by deep anns is the dropout method introduced by srivastava hinton krizhevsky sutskever and salakhutdinov during training units are randomly removed from the network out along with their connections. this can be thought of as training a large number of thinned networks. combining the results of these thinned networks at test time is a way to improve generalization performance. the dropout method efficiently approximates this combination by multiplying each outgoing weight of a unit by the probability that that unit was retained during training. srivastava et al. found that this method significantly improves generalization performance. it encourages individual hidden units to learn features that work well with random collections of other features. this increases the versatility of the features formed by the hidden units so that the network does not overly specialize to rarely-occurring cases. hinton osindero and teh took a major step toward solving the problem of training the deep layers of a deep ann in their work with deep belief networks layered networks closely related to the deep anns discussed here. in their method the deepest layers are trained one at a time using an unsupervised learning algorithm. without relying on the overall objective function unsupervised learning can extract features that capture statistical regularities of the input stream. the deepest layer is trained first then with input provided by this trained layer the next deepest layer is trained and so on until the weights in all or many of the network s layers are set to values that now act as initial values for supervised learning. the network is then fine-tuned by backpropagation with respect to the overall objective function. studies show that this approach generally works much better than backpropagation with weights initialized with random values. the better performance of networks trained with weights initialized this way could be due to many factors but one idea is that this method places the network in a region of weight space from which a gradient-based algorithm can make good progress. batch normalization and szegedy is another technique that makes it easier to train deep anns. it has long been known that ann learning is easier if the network input is normalized for example by adjusting each input variable to have zero nonlinear function approximation artificial neural networks mean and unit variance. batch normalization for training deep anns normalizes the output of deep layers before they feed into the following layer. ioffe and szegedy used statistics from subsets or mini-batches of training examples to normalize these between-layer signals to improve the learning rate of deep anns. another technique useful for training deep anns is deep residual learning zhang ren and sun sometimes it is easier to learn how a function differs from the identity function than to learn the function itself. then adding this difference or residual function to the input produces the desired function. in deep anns a block of layers can be made to learn a residual function simply by adding shortcut or skip connections around the block. these connections add the input to the block to its output and no additional weights are needed. he et al. evaluated this method using deep convolutional networks with skip connections around every pair of adjacent layers finding substantial improvement over networks without the skip connections on benchmark image classification tasks. both batch normalization and deep residual learning were used in the reinforcement learning application to the game of go that we describe in chapter a type of deep ann that has proven to be very successful in applications including impressive reinforcement learning applications is the deep convolutional network. this type of network is specialized for processing high-dimensional data arranged in spatial arrays such as images. it was inspired by how early visual processing works in the brain bottou bengio and haffner because of its special architecture a deep convolutional network can be trained by backpropagation without resorting to methods like those described above to train the deep layers. figure illustrates the architecture of a deep convolutional network. this instance from lecun et al. was designed to recognize hand-written characters. it consists of alternating convolutional and subsampling layers followed by several fully connected final layers. each convolutional layer produces a number of feature maps. a feature map is a pattern of activity over an array of units where each unit performs the same figure deep convolutional network. republished with permission of proceedings of the ieee from gradient-based learning applied to document recognition lecun bottou bengio and haffner volume permission conveyed through copyright clearance center inc. chapter on-policy prediction with approximation operation on data in its receptive field which is the part of the data it sees from the preceding layer from the external input in the case of the first convolutional layer. the units of a feature map are identical to one another except that their receptive fields which are all the same size and shape are shifted to different locations on the arrays of incoming data. units in the same feature map share the same weights. this means that a feature map detects the same feature no matter where it is located in the input array. in the network in figure for example the first convolutional layer produces feature maps each consisting of units. each unit in each feature map has a receptive field and these receptive fields overlap this case by four columns and four rows. consequently each of the feature maps is specified by just adjustable weights. the subsampling layers of a deep convolutional network reduce the spatial resolution of the feature maps. each feature map in a subsampling layer consists of units that average over a receptive field of units in the feature maps of the preceding convolutional layer. for example each unit in each of the feature maps in the first subsampling layer of the network of figure averages over a non-overlapping receptive field over one of the feature maps produced by the first convolutional layer resulting in six feature maps. subsampling layers reduce the network s sensitivity to the spatial locations of the features detected that is they help make the network s responses spatially invariant. this is useful because a feature detected at one place in an image is likely to be useful at other places as well. advances in the design and training of anns of which we have only mentioned a few all contribute to reinforcement learning. although current reinforcement learning theory is mostly limited to methods using tabular or linear function approximation methods the impressive performances of notable reinforcement learning applications owe much of their success to nonlinear function approximation by multi-layer anns. we discuss several of these applications in chapter least-squares td all the methods we have discussed so far in this chapter have required computation per time step proportional to the number of parameters. with more computation however one can do better. in this section we present a method for linear function approximation that is arguably the best that can be done for this case. as we established in section with linear function approximation converges asymptotically appropriately decreasing step sizes to the td fixed point wtd a where a and b why one might ask must we compute this solution iteratively? this is wasteful of data! could one not do better by computing estimates of a and b and then directly least-squares td computing the td fixed point? the least-squares td algorithm commonly known as lstd does exactly this. it forms the natural estimates t xkxk i and t where i is the identity matrix and i for some small ensures that is always invertible. it might seem that these estimates should both be divided by t and indeed they should as defined here these are really estimates of t times a and t times b. however the t factor will not matter as when we use these estimates we will be effectively dividing one by the other. lstd estimates the td fixed point as wt t this algorithm is the most data efficient form of linear but it is also more expensive computationally. recall that semi-gradient requires memory and per-step computation that is only od. how complex is lstd? as it is written above the complexity seems to increase with t but the two approximations in could be implemented incrementally using the techniques we have covered earlier in chapter so that they can be done in would be column vector times a row vector and thus would be a matrix update its computational constant time per step. even so the update for would involve an outer product complexity would be and of course the memory required to hold the matrix of and the computational complexity of a general inverse computation is fortunately an inverse of a matrix of our special form a sum of outer products can also be updated incrementally with only computations as a potentially greater problem is that our final computation uses the inverse t t xtxt t for t with multiplications and thus is only thus we can store the inverse matrix i. although the identity known as the sherman-morrison formula is superficially complicated it involves only vector-matrix and vector-vector maintain it with and then use it in all with only memory and per-step computation. the complete algorithm is given in the box on the next page. t t t of course is still significantly more expensive than the od of semi-gradient td. whether the greater data efficiency of lstd is worth this computational expense depends on how large d is how important it is to learn quickly and the expense of other parts of the system. the fact that lstd requires no step-size parameter is sometimes also touted but the advantage of this is probably overstated. lstd does not require a chapter on-policy prediction with approximation lstd for estimating v v version input feature representation x s rd such that xterminal algorithm parameter small loop for each episode a d d matrix a d-dimensional vector initialize s x xs loop for each step of episode choose and take action a observe r v rx w s x until is terminal step size but it does requires if is chosen too small the sequence of inverses can vary wildly and if is chosen too large then learning is slowed. in addition lstd s lack of a step-size parameter means that it never forgets. this is sometimes desirable but it is problematic if the target policy changes as it does in reinforcement learning and gpi. in control applications lstd typically has to be combined with some other mechanism to induce forgeting mooting any initial advantage of not requiring a step-size parameter. memory-based function approximation so far we have discussed the parametric approach to approximating value functions. in this approach a learning algorithm adjusts the parameters of a functional form intended to approximate the value function over a problem s entire state space. each update s g is a training example used by the learning algorithm to change the parameters with the aim of reducing the approximation error. after the update the training example can be discarded it might be saved to be used again. when an approximate value of a state we will call the query state is needed the function is simply evaluated at that state using the latest parameters produced by the learning algorithm. memory-based function approximation methods are very different. they simply save training examples in memory as they arrive at least save a subset of the examples without updating any parameters. then whenever a query state s value estimate is needed a set of examples is retrieved from memory and used to compute a value estimate for the query state. this approach is sometimes called lazy learning because processing training examples is postponed until the system is queried to provide an output. memory-based function approximation methods are prime examples of nonparametric memory-based function approximation methods. unlike parametric methods the approximating function s form is not limited to a fixed parameterized class of functions such as linear functions or polynomials but is instead determined by the training examples themselves together with some means for combining them to output estimated values for query states. as more training examples accumulate in memory one expects nonparametric methods to produce increasingly accurate approximations of any target function. there are many different memory-based methods depending on how the stored training examples are selected and how they are used to respond to a query. here we focus on local-learning methods that approximate a value function only locally in the neighborhood of the current query state. these methods retrieve a set of training examples from memory whose states are judged to be the most relevant to the query state where relevance usually depends on the distance between states the closer a training example s state is to the query state the more relevant it is considered to be where distance can be defined in many different ways. after the query state is given a value the local approximation is discarded. the simplest example of the memory-based approach is the nearest neighbor method which simply finds the example in memory whose state is closest to the query state and returns that example s value as the approximate value of the query state. in other words if the query state is s and g is the example in memory in which is the closest state to s then g is returned as the approximate value of s. slightly more complicated are weighted average methods that retrieve a set of nearest neighbor examples and return a weighted average of their target values where the weights generally decrease with increasing distance between their states and the query state. locally weighted regression is similar but it fits a surface to the values of a set of nearest states by means of a parametric approximation method that minimizes a weighted error measure like where the weights depend on distances from the query state. the value returned is the evaluation of the locally-fitted surface at the query state after which the local approximation surface is discarded. being nonparametric memory-based methods have the advantage over parametric methods of not limiting approximations to pre-specified functional forms. this allows accuracy to improve as more data accumulates. memory-based local approximation methods have other properties that make them well suited for reinforcement learning. because trajectory sampling is of such importance in reinforcement learning as discussed in section memory-based local methods can focus function approximation on local neighborhoods of states state action pairs visited in real or simulated trajectories. there may be no need for global approximation because many areas of the state space will never almost never be reached. in addition memory-based methods allow an agent s experience to have a relatively immediate affect on value estimates in the neighborhood of the current state in contrast with a parametric method s need to incrementally adjust parameters of a global approximation. avoiding global approximation is also a way to address the curse of dimensionality. for example for a state space with k dimensions a tabular method storing a global approximation requires memory exponential in k. on the other hand in storing examples for a memory-based method each example requires memory proportional to k and the chapter on-policy prediction with approximation memory required to store say n examples is linear in n. nothing is exponential in k or n. of course the critical remaining issue is whether a memory-based method can answer queries quickly enough to be useful to an agent. a related concern is how speed degrades as the size of the memory grows. finding nearest neighbors in a large database can take too long to be practical in many applications. proponents of memory-based methods have developed ways to accelerate the nearest neighbor search. using parallel computers or special purpose hardware is one approach another is the use of special multi-dimensional data structures to store the training data. one data structure studied for this application is the k-d tree for k-dimensional tree which recursively splits a k-dimensional space into regions arranged as nodes of a binary tree. depending on the amount of data and how it is distributed over the state space nearest-neighbor search using k-d trees can quickly eliminate large regions of the space in the search for neighbors making the searches feasible in some problems where naive searches would take too long. locally weighted regression additionally requires fast ways to do the local regression computations which have to be repeated to answer each query. researchers have developed many ways to address these problems including methods for forgetting entries in order to keep the size of the database within bounds. the bibliographic and historical comments section at the end of this chapter points to some of the relevant literature including a selection of papers describing applications of memory-based learning to reinforcement learning. kernel-based function approximation memory-based methods such as the weighted average and locally weighted regression methods described above depend on assigning weights to examples g in the database depending on the distance between and a query states s. the function that assigns these weights is called a kernel function or simply a kernel. in the weighted average and locally weighted regressions methods for example a kernel function k r r assigns weights to distances between states. more generally weights do not have to depend on distances they can depend on some other measure of similarity between states. in this case k s s r so that ks is the weight given to data about in its influence on answering queries about s. viewed slightly differently ks is a measure of the strength of generalization from to s. kernel functions numerically express how relevant knowledge about any state is to any other state. as an example the strengths of generalization for tile coding shown in figure correspond to different kernel functions resulting from uniform and asymmetrical tile offsets. although tile coding does not explicitly use a kernel function in its operation it generalizes according to one. in fact as we discuss more below the strength of generalization resulting from linear parametric function approximation can always be described by a kernel function. kernel regression is the memory-based method that computes a kernel weighted average of the targets of all examples stored in memory assigning the result to the query state. if d is the set of stored examples and denotes the target for state in a looking deeper at on-policy learning interest and emphasis stored example then kernel regression approximates the target function in this case a value function depending on d as ks vsd d the weighted average method described above is a special case in which ks is nonzero only when s and are close to one another so that the sum need not be computed over all of d. a common kernel is the gaussian radial basis function used in rbf function approximation as described in section in the method described there rbfs are features whose centers and widths are either fixed from the start with centers presumably concentrated in areas where many examples are expected to fall or are adjusted in some way during learning. barring methods that adjust centers and widths this is a linear parametric method whose parameters are the weights of each rbf which are typically learned by stochastic gradient or semi-gradient descent. the form of the approximation is a linear combination of the pre-determined rbfs. kernel regression with an rbf kernel differs from this in two ways. first it is memory-based the rbfs are centered on the states of the stored examples. second it is nonparametric there are no parameters to learn the response to a query is given by of course many issues have to be addressed for practical implementation of kernel regression issues that are beyond the scope or our brief discussion. however it turns out that any linear parametric regression method like those we described in section with states represented by feature vectors xs can be recast as kernel regression where ks is the inner product of the feature vector representations of s and that is ks kernel regression with this kernel function produces the same approximation that a linear parametric method would if it used these feature vectors and learned with the same training data. we skip the mathematical justification for this which can be found in any modern machine learning text such as bishop and simply point out an important implication. instead of constructing features for linear parametric function approximators one can instead construct kernel functions directly without referring at all to feature vectors. not all kernel functions can be expressed as inner products of feature vectors as in but a kernel function that can be expressed like this can offer significant advantages over the equivalent parametric method. for many sets of feature vectors has a compact functional form that can be evaluated without any computation taking place in the d-dimensional feature space. in these cases kernel regression is much less complex than directly using a linear parametric method with states represented by these feature vectors. this is the so-called kernel trick that allows effectively working in the high-dimension of an expansive feature space while actually working only with the set of stored training examples. the kernel trick is the basis of many machine learning methods and researchers have shown how it can sometimes benefit reinforcement learning. chapter on-policy prediction with approximation looking deeper at on-policy learning interest and emphasis the algorithms we have considered so far in this chapter have treated all the states encountered equally as if they were all equally important. in some cases however we are more interested in some states than others. in discounted episodic problems for example we may be more interested in accurately valuing early states in the episode than in later states where discounting may have made the rewards much less important to the value of the start state. or if an action-value function is being learned it may be less important to accurately value poor actions whose value is much less than the greedy action. function approximation resources are always limited and if they were used in a more targeted way then performance could be improved. one reason we have treated all states encountered equally is that then we are updating according to the on-policy distribution for which stronger theoretical results are available for semi-gradient methods. recall that the on-policy distribution was defined as the distribution of states encountered in an mdp while following the target policy. now we will generalize this concept significantly. rather than having one on-policy distribution for the mdp we will have many. all of them will have in common that they are a distribution of states encountered in trajectories while following the target policy but they will vary in how the trajectories are in a sense initiated. we now introduce some new concepts. first we introduce a non-negative scalar measure a random variable it called interest indicating the degree to which we are interested in accurately valuing the state state action pair at time t. if we don t care at all about the state then the interest should be zero if we fully care it might be one though it is formally allowed take any non-negative value. the interest can be set in any causal way for example it may depend on the trajectory up to time t or the learned parameters at time t. the distribution in the ve is then defined as the distribution of states encountered while following the target policy weighted by the interest. second we introduce another non-negative scalar random variable the emphasis mt. this scalar multiplies the learning update and thus emphasizes or de-emphasizes the learning done at time t. the general n-step learning rule replacing is wtn wtn mt vstwtn vstwtn t t with the n-step return given by and the emphasis determined recursively from the interest by mt it nmt n t t with mt for all t these equations are taken to include the monte carlo case for which gttn gt all the updates are made at end of the episode n t t and mt it. summary example illustrates how interest and emphasis can result in more accurate value estimates. example interest and emphasis to see the potential benefits of using interest and emphasis consider the four-state markov reward process shown below episodes start in the leftmost state then transition one state to the right with a reward of on each step until the terminal state is reached. the true value of the first state is thus of the second state and so on as shown below each state. these are the true values the estimated values can only approximate these because they are constrained by the parameterization. there are two components to the parameter vector w and the parameterization is as written inside each state. the estimated values of the first two states are given by alone and thus must be the same even though their true values are different. similarly the estimated values of the third and fourth states are given by alone and must be the same even though their true values are different. suppose that we are interested in accurately valuing only the leftmost state we assign it an interest of while all the other states are assigned an interest of as indicated above the states. first consider applying gradient monte carlo algorithms to this problem. the algorithms presented earlier in this chapter that do not take into account interest and emphasis and the box on page will converge decreasing step sizes to the parameter vector w which gives the first state the only one we are interested in a value of intermediate between the true values of the first and second states. the methods presented in this section that do use interest and emphasis on the other hand will learn the value of the first state exactly correctly will converge to while will never be updated because the emphasis is zero in all states save the leftmost. now consider applying two-step semi-gradient td methods. the methods from earlier in this chapter without interest and emphasis and and the box on page will again converge to w while the methods with interest and emphasis converge to w the latter produces the exactly correct values for the first state and for the third state the first state bootstraps from while never making any updates corresponding to the second or fourth states. chapter on-policy prediction with approximation summary reinforcement learning systems must be capable of generalization if they are to be applicable to artificial intelligence or to large engineering applications. to achieve this any of a broad range of existing methods for supervised-learning function approximation can be used simply by treating each update as a training example. perhaps the most suitable supervised learning methods are those using parameterized function approximation in which the policy is parameterized by a weight vector w. although the weight vector has many components the state space is much larger still and we must settle for an approximate solution. we defined the mean squared value error vew as a measure of the error in the values v w for a weight vector w under the on-policy distribution the ve gives us a clear way to rank different value-function approximations in the on-policy case. to find a good weight vector the most popular methods are variations of stochastic gradient descent in this chapter we have focused on the on-policy case with a fixed policy also known as policy evaluation or prediction a natural learning algorithm for this case is n-step semi-gradient td which includes gradient monte carlo and semi-gradient algorithms as the special cases when n and n respectively. semi-gradient td methods are not true gradient methods. in such bootstrapping methods dp the weight vector appears in the update target yet this is not taken into account in computing the gradient thus they are semi methods. as such they cannot rely on classical sgd results. nevertheless good results can be obtained for semi-gradient methods in the special case of linear function approximation in which the value estimates are sums of features times corresponding weights. the linear case is the most well understood theoretically and works well in practice when provided with appropriate features. choosing the features is one of the most important ways of adding prior domain knowledge to reinforcement learning systems. they can be chosen as polynomials but this case generalizes poorly in the online learning setting typically considered in reinforcement learning. better is to choose features according the fourier basis or according to some form of coarse coding with sparse overlapping receptive fields. tile coding is a form of coarse coding that is particularly computationally efficient and flexible. radial basis functions are useful for one- or two-dimensional tasks in which a smoothly varying response is important. lstd is the most data-efficient linear td prediction method but requires computation proportional to the square of the number of weights whereas all the other methods are of complexity linear in the number of weights. nonlinear methods include artificial neural networks trained by backpropagation and variations of sgd these methods have become very popular in recent years under the name deep reinforcement learning. linear semi-gradient n-step td is guaranteed to converge under standard conditions for all n to a ve that is within a bound of the optimal error asymptotically by monte carlo methods. this bound is always tighter for higher n and approaches zero as n however in practice very high n results in very slow learning and some degree of bootstrapping n is usually preferrable just as we saw in comparisons of tabular n-step methods in chapter and in comparisons of tabular td and monte carlo methods in chapter summary bibliographical and historical remarks generalization and function approximation have always been an integral part of reinforcement learning. bertsekas and tsitsiklis bertsekas and sugiyama et al. present the state of the art in function approximation in reinforcement learning. some of the early work with function approximation in reinforcement learning is discussed at the end of this section. gradient-descent methods for minimizing mean-squared error in supervised learning are well known. widrow and hoff introduced the least-mean-square algorithm which is the prototypical incremental gradient-descent algorithm. details of this and related algorithms are provided in many texts widrow and stearns bishop duda and hart semi-gradient was first explored by sutton as part of the linear td algorithm that we will treat in chapter the term semigradient to describe these bootstrapping methods is new to the second edition of this book. the earliest use of state aggregation in reinforcement learning may have been michie and chambers s boxes system the theory of state aggregation in reinforcement learning has been developed by singh jaakkola and jordan and tsitsiklis and van roy state aggregation has been used in dynamic programming from its earliest days bellman sutton proved convergence of linear in the mean to the minimal ve solution for the case in which the feature vectors s s are linearly independent. convergence with probability was proved by several researchers at about the same time dayan and sejnowski tsitsiklis gurvits lin and hanson in addition jaakkola jordan and singh proved convergence under online updating. all of these results assumed linearly independent feature vectors which implies at least as many components to wt as there are states. convergence for the more important case of general feature vectors was first shown by dayan a significant generalization and strengthening of dayan s result was proved by tsitsiklis and van roy they proved the main result presented in this section the bound on the asymptotic error of linear bootstrapping methods. our presentation of the range of possibilities for linear function approximation is based on that by barto konidaris osentoski and thomas introduced the fourier basis in a simple form suitable for reinforcement learning problems with multi-dimensional continuous state spaces and functions that do not have to be periodic. the term coarse coding is due to hinton and our figure is based on one of his figures. waltz and fu provide an early example of this type of function approximation in a reinforcement learning system. chapter on-policy prediction with approximation tile coding including hashing was introduced by albus he described it in terms of his cerebellar model articulator controller or cmac as tile coding is sometimes known in the literature. the term tile coding was new to the first edition of this book though the idea of describing cmac in these terms is taken from watkins tile coding has been used in many reinforcement learning systems shewchuk and dean lin and kim miller scalera and kim sofge and white tham sutton watkins as well as in other types of learning control systems kraft and campagna kraft miller and dietz this section draws heavily on the work of miller and glanz general software for tile coding is available on the web in several languages see function approximation using radial basis functions has received wide attention ever since being related to neural networks by broomhead and lowe powell reviewed earlier uses of rbfs and poggio and girosi extensively developed and applied this approach. automatic methods for adapting the step-size parameter include rmsprop and hinton adam and ba stochastic meta-descent methods such as delta-bar-delta its incremental generalization c mahmood et al. and nonlinear generalizations methods explicitly designed for reinforcement learning include alphabound and barto sid and nosid tidbd et al. in preparation and the application of stochastic metadescent to policy gradient learning yu and aberdeen the introduction of the threshold logic unit as an abstract model neuron by mcculloch and pitts was the beginning of artificial neural networks. the history of anns as learning methods for classification or regression has passed through several stages roughly the perceptron and adaline linear element and hoff stage of learning by single-layer anns the error-backpropagation stage rumelhart hinton and williams of learning by multi-layer anns and the current deep-learning stage with its emphasis on representation learning bengio courville and vincent goodfellow bengio and courville examples of the many books on anns are haykin bishop and ripley anns as function approximation for reinforcement learning goes back to the early neural networks of farley and clark who used reinforcement-like learning to modify the weights of linear threshold functions representing policies. widrow gupta and maitra presented a neuron-like linear threshold unit implementing a learning process they called learning with a critic or selective bootstrap adaptation a reinforcement-learning variant of the adaline algorithm. werbos developed an approach to prediction and control summary that uses anns trained by error backpropation to learn policies and value functions using td-like algorithms. barto sutton and brouwer and barto and sutton extended the idea of an associative memory network kohonen anderson silverstein ritz and jones to reinforcement learning. barto anderson and sutton used a two-layer ann to learn a nonlinear control policy and emphasized the first layer s role of learning a suitable representation. hampson was an early proponent of multilayer anns for learning value functions. barto sutton and anderson presented an actor critic algorithm in the form of an ann learning to balance a simulated pole sections and barto and anandan introduced a stochastic version of widrow et al. s selective bootstrap algorithm called the associative reward-penalty p algorithm. barto and barto and jordan described multi-layer anns consisting of ar p units trained with a globally-broadcast reinforcement signal to learn classification rules that are not linearly separable. barto discussed this approach to anns and how this type of learning rule is related to others in the literature at that time. section for additional discussion of this approach to training multi-layer anns. anderson evaluated numerous methods for training multilayer anns and showed that an actor critic algorithm in which both the actor and critic were implemented by two-layer anns trained by error backpropagation outperformed single-layer anns in the pole-balancing and tower of hanoi tasks. williams described several ways that backpropagation and reinforcement learning can be combined for training anns. gullapalli and williams devised reinforcement learning algorithms for neuron-like units having continuous rather than binary outputs. barto sutton and watkins argued that anns can play significant roles for approximating functions required for solving sequential decision problems. williams related reinforce learning rules to the error backpropagation method for training multi-layer anns. tesauro s td-gammon section influentially demonstrated the learning abilities of td algorithm with function approximation by multi-layer anns in learning to play backgammon. the alphago alphago zero and alphazero programs of silver et al. b section used reinforcement learning with deep convolutional anns in achieving impressive results with the game of go. schmidhuber reviews applications of anns in reinforcement learning including applications of recurrent anns. lstd is due to bradtke and barto bradtke bradtke and barto bradtke ydstie and barto and was further developed by boyan nedi c and bertsekas and yu the incremental update of the inverse matrix has been known at least since and morrison an extension of least-squares methods to control was introduced by lagoudakis and parr bu soniu lazaric ghavamzadeh munos babu ska and de schutter chapter on-policy prediction with approximation our discussion of memory-based function approximation is largely based on the review of locally weighted learning by atkeson moore and schaal atkeson discussed the use of locally weighted regression in memory-based robot learning and supplied an extensive bibliography covering the history of the idea. stanfill and waltz influentially argued for the importance of memory based methods in artificial intelligence especially in light of parallel architectures then becoming available such as the connection machine. baird and klopf introduced a novel memory-based approach and used it as the function approximation method for q-learning applied to the pole-balancing task. schaal and atkeson applied locally weighted regression to a robot juggling control problem where it was used to learn a system model. peng used the pole-balancing task to experiment with several nearest-neighbor methods for approximating value functions policies and environment models. tadepalli and ok obtained promising results with locally-weighted linear regression to learn a value function for a simulated automatic guided vehicle task. bottou and vapnik demonstrated surprising efficiency of several local learning algorithms compared to non-local algorithms in some pattern recognition tasks discussing the impact of local learning on generalization. bentley introduced k-d trees and reported observing average running time of olog n for nearest neighbor search over n records. friedman bentley and finkel clarified the algorithm for nearest neighbor search with kd trees. omohundro discussed efficiency gains possible with hierarchical data structures such as k-d-trees. moore schneider and deng introduced the use of k-d trees for efficient locally weighted regression. the origin of kernel regression is the method of potential functions of aizerman braverman and rozonoer they likened the data to point electric charges of various signs and magnitudes distributed over space. the resulting electric potential over space produced by summing the potentials of the point charges corresponded to the interpolated surface. in this analogy the kernel function is the potential of a point charge which falls off as the reciprocal of the distance from the charge. connell and utgoff applied an actor critic method to the pole-balancing task in which the critic approximated the value function using kernel regression with an inverse-distance weighting. predating widespread interest in kernel regression in machine learning these authors did not use the term kernel but referred to shepard s method other kernel-based approaches to reinforcement learning include those of ormoneit and sen dietterich and wang xu xie hu and lu taylor and parr barreto precup and pineau and bhat farias and moallemi for emphatic-td methods see the bibliographical notes to section summary the earliest example we know of in which function approximation methods were used for learning value functions was samuel s checkers player samuel followed shannon s suggestion that a value function did not have to be exact to be a useful guide to selecting moves in a game and that it might be approximated by linear combination of features. in addition to linear function approximation samuel experimented with lookup tables and hierarchical lookup tables called signature tables page biermann fairfield and beres at about the same time as samuel s work bellman and dreyfus proposed using function approximation methods with dp. is tempting to think that bellman and samuel had some influence on one another but we know of no reference to the other in the work of either. there is now a fairly extensive literature on function approximation methods and dp such as multigrid methods and methods using splines and orthogonal polynomials bellman and dreyfus bellman kalaba and kotkin daniel whitt reetz schweitzer and seidmann chow and tsitsiklis kushner and dupuis rust holland s classifier system used a selective feature-match technique to generalize evaluation information across state action pairs. each classifier matched a subset of states having specified values for a subset of features with the remaining features having arbitrary values wild cards these subsets were then used in a conventional state-aggregation approach to function approximation. holland s idea was to use a genetic algorithm to evolve a set of classifiers that collectively would implement a useful action-value function. holland s ideas influenced the early research of the authors on reinforcement learning but we focused on different approaches to function approximation. as function approximators classifiers are limited in several ways. first they are state-aggregation methods with concomitant limitations in scaling and in representing smooth functions efficiently. in addition the matching rules of classifiers can implement only aggregation boundaries that are parallel to the feature axes. perhaps the most important limitation of conventional classifier systems is that the classifiers are learned via the genetic algorithm an evolutionary method. as we discussed in chapter there is available during learning much more detailed information about how to learn than can be used by evolutionary methods. this perspective led us to instead adapt supervised learning methods for use in reinforcement learning specifically gradient-descent and neural network methods. these differences between holland s approach and ours are not surprising because holland s ideas were developed during a period when neural networks were generally regarded as being too weak in computational power to be useful whereas our work was at the beginning of the period that saw widespread questioning of that conventional wisdom. there remain many opportunities for combining aspects of these different approaches. christensen and korf experimented with regression methods for modifying coefficients of linear value function approximations in the game of chess. chapman and kaelbling and tan adapted decision-tree methods for learning value functions. explanation-based learning methods have also been adapted for learning value functions yielding compact representations saxena utgoff and barto dietterich and flann chapter on-policy control with approximation in this chapter we return to the control problem now with parametric approximation of the action-value function qs a w q a where w rd is a finite-dimensional weight vector. we continue to restrict attention to the on-policy case leaving off-policy methods to chapter the present chapter features the semi-gradient sarsa algorithm the natural extension of semi-gradient chapter to action values and to onpolicy control. in the episodic case the extension is straightforward but in the continuing case we have to take a few steps backward and re-examine how we have used discounting to define an optimal policy. surprisingly once we have genuine function approximation we have to give up discounting and switch to a new average-reward formulation of the control problem with new differential value functions. starting first in the episodic case we extend the function approximation ideas presented in the last chapter from state values to action values. then we extend them to control following the general pattern of on-policy gpi using for action selection. we show results for n-step linear sarsa on the mountain car problem. then we turn to the continuing case and repeat the development of these ideas for the average-reward case with differential values. episodic semi-gradient control the extension of the semi-gradient prediction methods of chapter to action values is straightforward. in this case it is the approximate action-value function q q that is represented as a parameterized functional form with weight vector w. whereas before we considered random training examples of the form st ut now we consider examples of the form st at ut. the update target ut can be any approximation of q at including the usual backed-up values such as the full monte carlo return or any of the n-step sarsa returns the general gradient-descent update for action-value chapter on-policy control with approximation prediction is for example the update for the one-step sarsa method is wt qst at qst at wt. wt wt qst at qst at wt. we call this method episodic semi-gradient one-step sarsa. for a constant policy this method converges in the same way that does with the same kind of error bound to form control methods we need to couple such action-value prediction methods with techniques for policy improvement and action selection. suitable techniques applicable to continuous actions or to actions from large discrete sets are a topic of ongoing research with as yet no clear resolution. on the other hand if the action set is discrete and not too large then we can use the techniques already developed in previous chapters. that is for each possible action a available in the current state st we can compute qst a wt and then find the greedy action a t argmaxa qst a wt. policy improvement is then done the on-policy case treated in this chapter by changing the estimation policy to a soft approximation of the greedy policy such as the policy. actions are selected according to this same policy. pseudocode for the complete algorithm is given in the box. episodic semi-gradient sarsa for estimating q q input a differentiable action-value function parameterization q s a rd r algorithm parameters step size small initialize value-function weights w rd arbitrarily w loop for each episode s a initial state and action of episode loop for each step of episode take action a observe r if is terminal go to next episode w w qs a qs a w choose as a function of w w w w qs a qs a w s a example mountain car task consider the task of driving an underpowered car up a steep mountain road as suggested by the diagram in the upper left of figure the difficulty is that gravity is stronger than the car s engine and even at full throttle the car cannot accelerate up the steep slope. the only solution is to first move away from episodic semi-gradient control figure the mountain car task left panel and the cost-to-go function maxa qs a w learned during one run. the goal and up the opposite slope on the left. then by applying full throttle the car can build up enough inertia to carry it up the steep slope even though it is slowing down the whole way. this is a simple example of a continuous control task where things have to get worse in a sense from the goal before they can get better. many control methodologies have great difficulties with tasks of this kind unless explicitly aided by a human designer. the reward in this problem is on all time steps until the car moves past its goal position at the top of the mountain which ends the episode. there are three possible actions full throttle forward full throttle reverse and zero throttle the car moves according to a simplified physics. its position xt and velocity xt are updated by xt where the bound operation enforces and in addition when reached the left bound was reset to zero. when it reached the right bound the goal was reached and the episode was terminated. each episode started from a random position xt and zero velocity. to convert the two continuous state variables to binary features we used grid-tilings as in figure we used tilings with each tile covering of the bounded distance in each dimension and cargoal chapter on-policy control with approximation asymmetrical offsets as described in section the feature vectors xs a created by tile coding were then combined linearly with the parameter vector to approximate the action-value function qs a w a wi xis a for each pair of state s and action a. figure shows what typically happens while learning to solve this task with this form of function shown is the negative of the value function costto-go function learned on a single run. the initial action values were all zero which was optimistic true values are negative in this task causing extensive exploration to occur even though the exploration parameter was this can be seen in the middle-top panel of the figure labeled step at this time not even one episode had been completed but the car has oscillated back and forth in the valley following circular trajectories in state space. all the states visited frequently are valued worse than unexplored states because the actual rewards have been worse than what was expected. this continually drives the agent away from wherever it has been to explore new states until a solution is found. figure shows several learning curves for semi-gradient sarsa on this problem with various step sizes. figure mountain car learning curves for the semi-gradient sarsa method with tile-coding function approximation and action selection. particular we used the tile-coding software available at httpincompleteideas.nettiles with and to get the indices of the ones in the feature vector for state xdot and action a. data is actually from the semi-gradient sarsa algorithm that we will not meet until chapter but semi-gradient sarsa would behave similarly. carsteps per episodelog scaleaveraged over semi-gradient n-step sarsa semi-gradient n-step sarsa we can obtain an n-step version of episodic semi-gradient sarsa by using an n-step return as the update target in the semi-gradient sarsa update equation the n-step return immediately generalizes from its tabular form to a function approximation form gttn with gttn n n qstn atn wtn gt if t n t as usual. the n-step update equation is wtn qst at wtn qst at wtn wtn tn t t t. complete pseudocode is given in the box below. episodic semi-gradient n-step sarsa for estimating q q or q input a differentiable action-value function parameterization q s a rd r input a policy estimating q algorithm parameters step size small a positive integer n initialize value-function weights w rd arbitrarily w all store and access operations at and rt can take their index mod n loop for each episode if t t then take action at observe and store the next reward as and the next state as if is terminal then initialize and store terminal select and store an action or wrt w t loop for t until t if n t then g g n qs a w w w qs a w qs a w g t t select and store or wrt w is the time whose estimate is being updated t n if i i else as we have seen before performance is best if an intermediate level of bootstrapping is used corresponding to an n larger than figure shows how this algorithm tends to learn faster and obtain a better asymptotic performance at n than at n on the mountain car task. figure shows the results of a more detailed study of the effect of the parameters and n on the rate of learning on this task. chapter on-policy control with approximation figure performance of one-step vs semi-gradient sarsa on the mountain car task. good step sizes were used for n and for n figure effect of the and n on early performance of n-step semi-gradient sarsa and tile-coding function approximation on the mountain car task. as usual an intermediate level of bootstrapping performed best. these results are for selected values on a log scale and then connected by straight lines. the standard errors ranged from than the line width for n to about for n so the main effects are all statistically significant. exercise we not explicitly considered or given pseudocode for any monte carlo methods or in this chapter. what would they be like? why is it reasonable not to give pseudocode for them? how would they perform on the mountain car task? exercise give pseudocode for semi-gradient one-step expected sarsa for control. exercise why do the results shown in figure have higher standard errors at large n than at small n? carsteps per episodelog scaleaveraged over carsteps per episodeaveraged overfirst episodesand runs number of tilings average reward a new problem setting for continuing tasks average reward a new problem setting for continuing tasks we now introduce a third classical setting alongside the episodic and discounted settings for formulating the goal in markov decision problems like the discounted setting the average reward setting applies to continuing problems problems for which the interaction between agent and environment goes on and on forever without termination or start states. unlike that setting however there is no discounting the agent cares just as much about delayed rewards as it does about immediate reward. the averagereward setting is one of the major settings commonly considered in the classical theory of dynamic programming and less-commonly in reinforcement learning. as we discuss in the next section the discounted setting is problematic with function approximation and thus the average-reward setting is needed to replace it. in the average-reward setting the quality of a policy is defined as the average rate of reward or simply average reward while following that policy which we denote as r r lim h lim t ert h ert rs ar where the expectations are conditioned on the prior actions at being limt prst s taken according to and is the steady-state distribution which is assumed to exist for any and to be independent of this assumption about the mdp is known as ergodicity. it means that where the mdp starts or any early decision made by the agent can have only a temporary effect in the long run the expectation of being in a state depends only on the policy and the mdp transition probabilities. ergodicity is sufficient to guarantee the existence of the limits in the equations above. there are subtle distinctions that can be drawn between different kinds of optimality in the undiscounted continuing case. nevertheless for most practical purposes it may be adequate simply to order policies according to their average reward per time step in other words according to their r this quantity is essentially the average reward under as suggested by in particular we consider all policies that attain the maximal value of r to be optimal. note that the steady state distribution is the special distribution under which if you select actions according to you remain in the same distribution. that is for which a in the average-reward setting returns are defined in terms of differences between chapter on-policy control with approximation rewards and the average reward gt r r r this is known as the differential return and the corresponding value functions are known as differential value functions. they are defined in the same way and we will use the same notation for them as we have all along v e s at a for v and q differential value functions also have bellman equations just slightly different from those we have seen earlier. we simply remove all s and replace all rewards by the difference between the reward and the true average reward e s and q a rs r v v rs r q a rs max a rs max q a v max r v and q r max exercise and there is also a differential form of the two td errors t and t vstwt wt qst at wt where rt is an estimate at time t of the average reward r with these alternate definitions most of our algorithms and many theoretical results carry through to the average-reward setting without change. for example the average reward version of semi-gradient sarsa is defined just as in except with the differential version of the td error. that is by wt t qst at wt with t given by the pseudocode for the complete algorithm is given in the box on the next page. exercise give pseudocode for a differential version of semi-gradient q-learning. exercise what equations are needed to specify the differential version of average reward a new problem setting for continuing tasks differential semi-gradient sarsa for estimating q q input a differentiable action-value function parameterization q s a rd r algorithm parameters step sizes initialize value-function weights w rd arbitrarily w initialize average reward estimate r r arbitrarily r initialize state s and action a loop for each step take action a observe r choose as a function of w r r w qs a w r r w w qs a w s a example an access-control queuing task this is a decision task involving access control to a set of k servers. customers of four different priorities arrive at a single queue. if given access to a server the customers pay a reward of or to the server depending on their priority with higher priority customers paying more. in each time step the customer at the head of the queue is either accepted to one of the servers or rejected from the queue with a reward of zero. in either case on the next time step the next customer in the queue is considered. the queue never empties and the priorities of the customers in the queue are equally randomly distributed. of course a customer cannot be served if there is no free server the customer is always rejected in this case. each busy server becomes free with probability p on each time step. although we have just described them for definiteness let us assume the statistics of arrivals and departures are unknown. the task is to decide on each step whether to accept or reject the next customer on the basis of his priority and the number of free servers so as to maximize long-term reward without discounting. in this example we consider a tabular solution to this problem. although there is no generalization between states we can still consider it in the general function approximation setting as this setting generalizes the tabular setting. thus we have a differential action-value estimate for each pair of state of free servers and priority of the customer at the head of the queue and action or reject. figure shows the solution found by differential semi-gradient sarsa for this task with k and p the algorithm parameters were and the initial action values and r were zero. chapter on-policy control with approximation figure the policy and value function found by differential semi-gradient one-step sarsa on the access-control queuing task after million steps. the drop on the right of the graph is probably due to insufficient data many of these states were never experienced. the value learned for r was about exercise consider an markov reward process consisting of a ring of three states a b and c with state transitions going deterministically around the ring. a reward of is received upon arrival in a and otherwise the reward is what are the differential values of the three states? exercise the pseudocode in the box on page updates using t as an error rather than simply both errors work but using t is better. to see why consider the ring mrp of three states from the previous exercise. the estimate of the average reward should tend towards its true value of suppose it was already there and was held stuck there. what would the sequence of rt rt errors be? what would the sequence of t errors be which error sequence would produce a more stable estimate of the average reward if the estimate were allowed to change in response to the errors? why? exercise suppose there is an mdp that under any policy produces the deterministic sequence of rewards going on forever. technically this is not allowed because it violates ergodicity there is no stationary limiting distribution and the limit does not exist. nevertheless the average reward is well defined what is it? now consider two states in this mdp. from a the reward sequence is exactly as described above starting with a whereas from b the reward sequence starts with of best actionnumber of free of free of free ofbest deprecating the discounted setting a and then continues with the differential return is not well defined for this case as the limit does not exist. to repair this one could alternately define the value of a state as v lim h under this definition what are the values of states a and b? s r deprecating the discounted setting the continuing discounted problem formulation has been very useful in the tabular case in which the returns from each state can be separately identified and averaged. but in the approximate case it is questionable whether one should ever use this problem formulation. to see why consider an infinite sequence of returns with no beginning or end and no clearly identified states. the states might be represented only by feature vectors which may do little to distinguish the states from each other. as a special case all of the feature vectors may be the same. thus one really has only the reward sequence the actions and performance has to be assessed purely from these. how could it be done? one way is by averaging the rewards over a long interval this is the idea of the average-reward setting. how could discounting be used? well for each time step we could measure the discounted return. some returns would be small and some big so again we would have to average them over a sufficiently large time interval. in the continuing setting there are no starts and ends and no special time steps so there is nothing else that could be done. however if you do this it turns out that the average of the discounted returns is proportional to the average reward. in fact for policy the average of the discounted returns is always r that is it is essentially the average reward r in particular the ordering of all policies in the average discounted return setting would be exactly the same as in the average-reward setting. the discount rate thus has no effect on the problem formulation. it could in fact be zero and the ranking would be unchanged. this surprising fact is proven in the box on the next page but the basic idea can be seen via a symmetry argument. each time step is exactly the same as every other. with discounting every reward will appear exactly once in each position in some return. the tth reward will appear undiscounted in the t return discounted once in the t return and discounted times in the t return. the weight on the tth reward is thus because all states are the same they are all weighted by this and thus the average of the returns will be this times the average reward or r this example and the more general argument in the box show that if we optimized discounted value over the on-policy distribution then the effect would be identical to optimizing undiscounted average reward the actual value of would have no effect. this strongly suggests that discounting has no role to play in the definition of the control problem with function approximation. one can nevertheless go ahead and use discounting in chapter on-policy control with approximation the futility of discounting in continuing problems perhaps discounting can be saved by choosing an objective that sums discounted values over the distribution with which states occur under the policy v is the discounted value function rs a v rs a v a v v eq. j r r r r j r r r r r the proposed discounted objective orders policies identically to the undiscounted reward objective. the discount rate does not influence the ordering! solution methods. the discounting parameter changes from a problem parameter to a solution method parameter! however in this case we unfortunately would not be guaranteed to optimize average reward the equivalent discounted value over the on-policy distribution. the root cause of the difficulties with the discounted control setting is that with function approximation we have lost the policy improvement theorem it is no longer true that if we change the policy to improve the discounted value of one state then we are guaranteed to have improved the overall policy in any useful sense. that guarantee was key to the theory of our reinforcement learning control methods. with function approximation we have lost it! in fact the lack of a policy improvement theorem is also a theoretical lacuna for the total-episodic and average-reward settings. once we introduce function approximation we can no longer guarantee improvement for any setting. in chapter we introduce an alternative class of reinforcement learning algorithms based on parameterized policies and there we have a theoretical guarantee called the policy-gradient theorem which plays a similar role as the policy improvement theorem. but for methods that learn action values we seem to be currently without a local improvement guarantee differential semi-gradient n-step sarsa the approach taken by perkins and precup may provide a part of the answer. we do know that may sometimes result in an inferior policy as policies may chatter among good policies rather than converge this is an area with multiple open theoretical questions. differential semi-gradient n-step sarsa in order to generalize to n-step bootstrapping we need an n-step version of the td error. we begin by generalizing the n-step return to its differential form with function approximation gttn rtn qstn atn wtn where r is an estimate of r n and t n t if t n t then we define gttn gt as usual. the n-step td error is then t gttn qst at w after which we can apply our usual semi-gradient sarsa update pseudocode for the complete algorithm is given in the box. differential semi-gradient n-step sarsa for estimating q q or q input a differentiable function q s a rd r a policy initialize value-function weights w rd arbitrarily w initialize average-reward estimate r r arbitrarily r algorithm parameters step size a positive integer n all store and access operations at and rt can take their index mod n initialize and store and loop for each step t take action at observe and store the next reward as and the next state as select and store an action or wrt w t n if is the time whose estimate is being updated i r qs a w qs a w r r w w qs a w exercise in the differential semi-gradient n-step sarsa algorithm the step-size parameter on the average reward needs to be quite small so that r becomes a good long-term estimate of the average reward. unfortunately r will then be biased by its chapter on-policy control with approximation initial value for many steps which may make learning inefficient. alternatively one could use a sample average of the observed rewards for r. that would initially adapt rapidly but in the long run would also adapt slowly. as the policy slowly changed r would also change the potential for such long-term nonstationarity makes sample-average methods ill-suited. in fact the step-size parameter on the average reward is a perfect place to use the unbiased constant-step-size trick from exercise describe the specific changes needed to the boxed algorithm for differential semi-gradient n-step sarsa to use this trick. summary in this chapter we have extended the ideas of parameterized function approximation and semi-gradient descent introduced in the previous chapter to control. the extension is immediate for the episodic case but for the continuing case we have to introduce a whole new problem formulation based on maximizing the average reward setting per time step. surprisingly the discounted formulation cannot be carried over to control in the presence of approximations. in the approximate case most policies cannot be represented by a value function. the arbitrary policies that remain need to be ranked and the scalar average reward r provides an effective way to do this. the average reward formulation involves new differential versions of value functions bellman equations and td errors but all of these parallel the old ones and the conceptual changes are small. there is also a new parallel set of differential algorithms for the average-reward case. bibliographical and historical remarks semi-gradient sarsa with function approximation was first explored by rummery and niranjan linear semi-gradient sarsa with action selection does not converge in the usual sense but does enter a bounded region near the best solution precup and perkins showed convergence in a differentiable action selection setting. see also perkins and pendrith and melo meyn and ribeiro the mountain car example is based on a similar task studied by moore but the exact form used here is from sutton episodic n-step semi-gradient sarsa is based on the forward sarsa algorithm of van seijen the empirical results shown here are new to the second edition of this text. the average-reward formulation has been described for dynamic programming puterman and from the point of view of reinforcement learning tadepalli and ok bertsekas and tsitiklis tsitsiklis and van roy the algorithm described here is the on-policy analog of the r-learning algorithm introduced by schwartz the name r-learning summary was probably meant to be the alphabetic successor to q-learning but we prefer to think of it as a reference to the learning of differential or relative values. the access-control queuing example was suggested by the work of carlstr om and nordstr om the recognition of the limitations of discounting as a formulation of the reinforcement learning problem with function approximation became apparent to the authors shortly after the publication of the first edition of this text. singh jaakkola and jordan may have been the first to observe it in print. the differential version of n-step semi-gradient sarsa is new to this text and has not been significantly studied. chapter methods with approximation this book has treated on-policy and off-policy learning methods since chapter primarily as two alternative ways of handling the conflict between exploitation and exploration inherent in learning forms of generalized policy iteration. the two chapters preceding this have treated the on-policy case with function approximation and in this chapter we treat the off case with function approximation. the extension to function approximation turns out to be significantly different and harder for off-policy learning than it is for on-policy learning. the tabular off-policy methods developed in chapters and readily extend to semi-gradient algorithms but these algorithms do not converge as robustly as they do under on-policy training. in this chapter we explore the convergence problems take a closer look at the theory of linear function approximation introduce a notion of learnability and then discuss new algorithms with stronger convergence guarantees for the off-policy case. in the end we will have improved methods but the theoretical results will not be as strong nor the empirical results as satisfying as they are for on-policy learning. along the way we will gain a deeper understanding of approximation in reinforcement learning for on-policy learning as well as off-policy learning. recall that in off-policy learning we seek to learn a value function for a target policy given data due to a different behavior policy b. in the prediction case both policies are static and given and we seek to learn either state values v v or action values q q in the control case action values are learned and both policies typically change during learning being the greedy policy with respect to q and b being something more exploratory such as the policy with respect to q. the challenge of off-policy learning can be divided into two parts one that arises in the tabular case and one that arises only with function approximation. the first part of the challenge has to do with the target of the update to be confused with the target policy and the second part has to do with the distribution of the updates. the techniques related to importance sampling developed in chapters and deal with chapter methods with approximation the first part these may increase variance but are needed in all successful algorithms tabular and approximate. the extension of these techniques to function approximation are quickly dealt with in the first section of this chapter. something more is needed for the second part of the challenge of off-policy learning with function approximation because the distribution of updates in the off-policy case is not according to the on-policy distribution. the on-policy distribution is important to the stability of semi-gradient methods. two general approaches have been explored to deal with this. one is to use importance sampling methods again this time to warp the update distribution back to the on-policy distribution so that semi-gradient methods are guaranteed to converge the linear case. the other is to develop true gradient methods that do not rely on any special distribution for stability. we present methods based on both approaches. this is a cutting-edge research area and it is not clear which of these approaches is most effective in practice. semi-gradient methods we begin by describing how the methods developed in earlier chapters for the off-policy case extend readily to function approximation as semi-gradient methods. these methods address the first part of the challenge of off-policy learning the update targets but not the second part the update distribution. accordingly these methods may diverge in some cases and in that sense are not sound but still they are often successfully used. remember that these methods are guaranteed stable and asymptotically unbiased for the tabular case which corresponds to a special case of function approximation. so it may still be possible to combine them with feature selection methods in such a way that the combined system could be assured stable. in any event these methods are simple and thus a good place to start. in chapter we described a variety of tabular off-policy algorithms. to convert them to semi-gradient form we simply replace the update to an array or q to an update to a weight vector using the approximate value function v or q and its gradient. many of these algorithms use the per-step importance sampling ratio tt t batst for example the one-step state-value algorithm is semi-gradient off-policy which is just like the corresponding on-policy algorithm except for the addition of t wt t t vstwt where t is defined appropriately depending on whether the problem is episodic and discounted or continuing and undiscounted using average reward t vstwt or t rt vstwt. examples of off-policy divergence for action values the one-step algorithm is semi-gradient expected sarsa wt t qst at wt with t t rt a wt qst at wt or a wt qst at wt. note that this algorithm does not use importance sampling. in the tabular case it is clear that this is appropriate because the only sample action is at and in learning its value we do not have to consider any other actions. with function approximation it is less clear because we might want to weight different state action pairs differently once they all contribute to the same overall approximation. proper resolution of this issue awaits a more thorough understanding of the theory of function approximation in reinforcement learning. in the multi-step generalizations of these algorithms both the state-value and actionvalue algorithms involve importance sampling. for example the n-step version of semigradient expected sarsa is wtn wtn tn qst at wtn qst at wtn with gttn gttn n n qstn atn wtn or rt rtn rtn qstn atn wtn where here we are being slightly informal in our treatment of the ends of episodes. in the first equation the ks for k t t is the last time step of the episode should be taken to be and gtn should be taken to be gt if t n t recall that we also presented in chapter an off-policy algorithm that does not involve importance sampling at all the n-step tree-backup algorithm. here is its semi-gradient version wtn gttn wtn qst at wtn qst at wtn qst at wt k tn with t as defined at the top of this page for expected sarsa. we also defined in chapter an algorithm that unifies all action-value algorithms n-step q we leave the semigradient form of that algorithm and also of the n-step state-value algorithm as exercises for the reader. exercise convert the equation of n-step off-policy td to semi-gradient form. give accompanying definitions of the return for both the episodic and continuing cases. exercise convert the equations of n-step q and to semi-gradient form. give definitions that cover both the episodic and continuing cases. chapter methods with approximation examples of off-policy divergence in this section we begin to discuss the second part of the challenge of off-policy learning with function approximation that the distribution of updates does not match the onpolicy distribution. we describe some instructive counterexamples to off-policy learning cases where semi-gradient and other simple algorithms are unstable and diverge. to establish intuitions it is best to consider first a very simple example. suppose perhaps as part of a larger mdp there are two states whose estimated values are of the functional form w and where the parameter vector w consists of only a single component w. this occurs under linear function approximation if the feature vectors for the two states are each simple numbers vectors in this case and in the first state only one action is available and it results deterministically in a transition to the second state with a reward of where the expressions inside the two circles indicate the two state s values. suppose initially w the transition will then be from a state of estimated value to a state of estimated value it will look like a good transition and w will be increased to raise the first state s estimated value. if is nearly then the td error will be nearly and if then w will be increased to nearly in trying to reduce the td error. however the second state s estimated value will also be increased to nearly if the transition occurs again then it will be from a state of estimated value to a state of estimated value for a td error of larger not smaller than before. it will look even more like the first state is undervalued and its value will be increased again this time to this looks bad and in fact with further updates w will diverge to infinity. to see this definitively we have to look more carefully at the sequence of updates. the td error on a transition between the two states is t vstwt wt and the off-policy semi-gradient update is wt t t vstwt wt note that the importance sampling ratio t is on this transition because there is only one action available from the first state so its probabilities of being taken under the target and behavior policies must both be in the final update above the new parameter is the old parameter times a scalar constant if this constant is greater than then the system is unstable and w will go to positive or negative infinity depending on its initial value. here this constant is greater than whenever note that stability does not depend on the specific step size as long as smaller or larger step sizes would affect the rate at which w goes to infinity but not whether it goes there or not. key to this example is that the one transition occurs repeatedly without w being updated on other transitions. this is possible under off-policy training because the examples of off-policy divergence behavior policy might select actions on those other transitions which the target policy never would. for these transitions t would be zero and no update would be made. under on-policy training however t is always one. each time there is a transition from the w state to the state increasing w there would also have to be a transition out of the state. that transition would reduce w unless it were to a state whose value was higher than and then that state would have to be followed by a state of even higher value or else again w would be reduced. each state can support the one before only by creating a higher expectation. eventually the piper must be paid. in the on-policy case the promise of future reward must be kept and the system is kept in check. but in the off-policy case a promise can be made and then after taking an action that the target policy never would forgotten and forgiven. this simple example communicates much of the reason why off-policy training can lead to divergence but it is not completely convincing because it is not complete it is just a fragment of a complete mdp. can there really be a complete system with instability? a simple complete example of divergence is baird s counterexample. consider the episodic seven-state two-action mdp shown in figure the dashed action takes the system to one of the six upper states with equal probability whereas the solid action takes the system to the seventh state. the behavior policy b selects the dashed and solid actions with probabilities so that the next-state distribution under it is uniform same for all nonterminal states which is also the starting distribution for each episode. the target policy always takes the solid action and so the on-policy distribution is concentrated in the seventh state. the reward is zero on all transitions. the discount rate is and consider estimating the state-value under the linear parameterization indicated by the expression shown in each state circle. for example the estimated value of the leftmost state is where the subscript corresponds to the component of the figure baird s counterexample. the approximate state-value function for this markov process is of the form shown by the linear expressions inside each state. the solid action usually results in the seventh state and the dashed action usually results in one of the other six states each with equal probability. the reward is always zero. chapter methods with approximation overall weight vector w this corresponds to a feature vector for the first state being the reward is zero on all transitions so the true value function is v for all s which can be exactly approximated if w in fact there are many solutions as there are more components to the weight vector than there are nonterminal states moreover the set of feature vectors s s is a linearly independent set. in all these ways this task seems a favorable case for linear function approximation. if we apply semi-gradient to this problem then the weights diverge to infinity as shown in figure the instability occurs for any positive step size no matter how small. in fact it even occurs if a expected update is done as in dynamic programming if we do a dp-style expected update instead of a sample update as shown in figure that is if the weight vector wk is updated for all states all at the same time in a semi-gradient way using the dp target wk st s vswk. in this case there is no randomness and no asynchrony just as in a classical dp update. the method is conventional except in its use of semi-gradient function approximation. yet still the system is unstable. if we alter just the distribution of dp updates in baird s counterexample from the uniform distribution to the on-policy distribution generally requires asynchronous updating then convergence is guaranteed to a solution with error bounded by figure demonstration of instability on baird s counterexample. shown are the evolution of the components of the parameter vector w of the two semi-gradient algorithms. the step size was and the initial weights were w off-policy tdsemi-gradient examples of off-policy divergence this example is striking because the td and dp methods used are arguably the simplest and best-understood bootstrapping methods and the linear semi-descent method used is arguably the simplest and best-understood kind of function approximation. the example shows that even the simplest combination of bootstrapping and function approximation can be unstable if the updates are not done according to the on-policy distribution. there are also counterexamples similar to baird s showing divergence for q-learning. this is cause for concern because otherwise q-learning has the best convergence guarantees of all control methods. considerable effort has gone into trying to find a remedy to this problem or to obtain some weaker but still workable guarantee. for example it may be possible to guarantee convergence of q-learning as long as the behavior policy is sufficiently close to the target policy for example when it is the policy. to the best of our knowledge q-learning has never been found to diverge in this case but there has been no theoretical analysis. in the rest of this section we present several other ideas that have been explored. suppose that instead of taking just a step toward the expected one-step return on each iteration as in baird s counterexample we actually change the value function all the way to the best least-squares approximation. would this solve the instability problem? of course it would if the feature vectors s s formed a linearly independent set as they do in baird s counterexample because then exact approximation is possible on each iteration and the method reduces to standard tabular dp. but of course the point here is to consider the case when an exact solution is not possible. in this case stability is not guaranteed even when forming the best approximation at each iteration as shown in the example. example tsitsiklis and van roy s counterexample this example shows that linear function approximation would not work with dp even if the least-squares solution was found at each step. the counterexample is formed by extending the example earlier in this section with a terminal state as shown to the right. as before the estimated value of the first state is w and the estimated value of the second state is the reward is zero on all transitions so the true values are zero at both states which is exactly representable with w if we set at each step so as to minimize the ve between the estimated value and the expected one-step return then we have arg min w r vsw e st w r arg min wk. the sequence diverges when and chapter methods with approximation another way to try to prevent instability is to use special methods for function approximation. in particular stability is guaranteed for function approximation methods that do not extrapolate from the observed targets. these methods called averagers include nearest neighbor methods and locally weighted regression but not popular methods such as tile coding and artificial neural networks. exercise apply one-step semi-gradient q-learning to baird s terexample and show empirically that it s weights diverge. the deadly triad our discussion so far can be summarized by saying that the danger of instability and divergence arises whenever we combine all of the following three elements making up what we call the deadly triad function approximation a powerful scalable way of generalizing from a state space much larger than the memory and computational resources linear function approximation or artificial neural networks. bootstrapping update targets that include existing estimates in dynamic programming or td methods rather than relying exclusively on actual rewards and complete returns in mc methods. off-policy training training on a distribution of transitions other than that produced by the target policy. sweeping through the state space and updating all states uniformly as in dynamic programming does not respect the target policy and is an example of off-policy training. in particular note that the danger is not due to control or to generalized policy iteration. those cases are more complex to analyze but the instability arises in the simpler prediction case whenever it includes all three elements of the deadly triad. the danger is also not due to learning or to uncertainties about the environment because it occurs just as strongly in planning methods such as dynamic programming in which the environment is completely known. if any two elements of the deadly triad are present but not all three then instability can be avoided. it is natural then to go through the three and see if there is any one that can be given up. of the three function approximation most clearly cannot be given up. we need methods that scale to large problems and to great expressive power. we need at least linear function approximation with many features and parameters. state aggregation or nonparametric methods whose complexity grows with data are too weak or too expensive. least-squares methods such as lstd are of quadratic complexity and are therefore too expensive for large problems. doing without bootstrapping is possible at the cost of computational and data efficiency. perhaps most important are the losses in computational efficiency. monte carlo methods require memory to save everything that happens between linear value-function geometry making each prediction and obtaining the final return and all their computation is done once the final return is obtained. the cost of these computational issues is not apparent on serial von neumann computers but would be on specialized hardware. with bootstrapping and eligibility traces data can be dealt with when and where it is generated then need never be used again. the savings in communication and memory made possible by bootstrapping are great. the losses in data efficiency by giving up bootstrapping are also significant. we have seen this repeatedly such as in chapters and where some degree of bootstrapping performed much better than monte carlo methods on the randomwalk prediction task and in chapter where the same was seen on the mountain-car control task many other problems show much faster learning with bootstrapping see figure bootstrapping often results in faster learning because it allows learning to take advantage of the state property the ability to recognize a state upon returning to it. on the other hand bootstrapping can impair learning on problems where the state representation is poor and causes poor generalization this seems to be the case on tetris see s im sek alg orta and kothiyal a poor state representation can also result in bias this is the reason for the poorer bound on the asymptotic approximation quality of bootstrapping methods on balance the ability to bootstrap has to be considered extremely valuable. one may sometimes choose not to use it by selecting long n-step updates a large bootstrapping parameter see chapter but often bootstrapping greatly increases efficiency. it is an ability that we would very much like to keep in our toolkit. finally there is off-policy learning can we give that up? on-policy methods are often adequate. for model-free reinforcement learning one can simply use sarsa rather than q-learning. off-policy methods free behavior from the target policy. this could be considered an appealing convenience but not a necessity. however off-policy learning is essential to other anticipated use cases cases that we have not yet mentioned in this book but may be important to the larger goal of creating a powerful intelligent agent. in these use cases the agent learns not just a single value function and single policy but large numbers of them in parallel. there is extensive psychological evidence that people and animals learn to predict many different sensory events not just rewards. we can be surprised by unusual events and correct our predictions about them even if they are of neutral valence good nor bad. this kind of prediction presumably underlies predictive models of the world such as are used in planning. we predict what we will see after eye movements how long it will take to walk home the probability of making a jump shot in basketball and the satisfaction we will get from taking on a new project. in all these cases the events we would like to predict depend on our acting in a certain way. to learn them all in parallel requires learning from the one stream of experience. there are many target policies and thus the one behavior policy cannot equal all of them. yet parallel learning is conceptually possible because the behavior policy may overlap in part with many of the target policies. to take full advantage of this requires off-policy learning. chapter methods with approximation linear value-function geometry to better understand the stability challenge of off-policy learning it is helpful to think about value function approximation more abstractly and independently of how learning is done. we can imagine the space of all possible state-value functions all functions from states to real numbers v s r. most of these value functions do not correspond to any policy. more important for our purposes is that most are not representable by the function approximator which by design has far fewer parameters than there are states. given an enumeration of the state space s ss any value function v corresponds to a vector listing the value of each state in order this vector representation of a value function has as many components as there are states. in most cases where we want to use function approximation this would be far too many components to represent the vector explicitly. nevertheless the idea of this vector is conceptually useful. in the following we treat a value function and its vector representation interchangably. to develop intuitions consider the case with three states s and two parameters w we can then view all value functionsvectors as points in a three-dimensional space. the parameters provide an alternative coordinate system over a two-dimensional subspace. any weight vector w is a point in the two-dimensional subspace and thus also a complete value function vw that assigns values to all three states. with general function approximation the relationship between the full space and the subspace of representable functions could be complex but in the case of linear value-function approximation the subspace is a simple plane as suggested by figure now consider a single fixed policy we assume that its true value function v is too complex to be represented exactly as an approximation. thus v is not in the subspace in the figure it is depicted as being above the planar subspace of representable functions. if v cannot be represented exactly what representable value function is closest to it? this turns out to be a subtle question with multiple answers. to begin we need a measure of the distance between two value functions. given two value functions and we can talk about the vector difference between them v if v is small then the two value functions are close to each other. but how are we to measure the size of this difference vector? the conventional euclidean norm is not appropriate because as discussed in section some states are more important than others because they occur more frequently or because we are more interested in them as in section let us use the distribution s to specify the degree to which we care about different states being accurately valued taken to be the on-policy distribution. we can then define the distance between value functions using the norm s note that the ve from section can be written simply using this norm as vew v for any value function v the operation of finding its closest value function in the subspace of representable value functions is a projection operation. we define a linear value-function geometry figure the geometry of linear value-function approximation. shown is the threedimensional space of all value functions over three states while shown as a plane is the subspace of all value functions representable by a linear function approximator with parameter w the true value function v is in the larger space and can be projected down the subspace using a projection operator to its best approximation in the value error sense. the best approximators in the bellman error projected bellman error and temporal difference error senses are all potentially different and are shown in the lower right. be and pbe are all treated as the corresponding vectors in this figure. the bellman operator takes a value function in the plane to one outside which can then be projected back. if you iteratively applied the bellman operator outside the space in gray above you would reach the true value function as in conventional dynamic programming. if instead you kept projecting back into the subspace at each step as in the lower step shown in gray then the fixed point would be the point of vector-zero pbe. projection operator that takes an arbitrary value function to the representable function that is closest in our norm v vw where w arg min w the representable value function that is closest to the true value function v is thus its projection v as suggested in figure this is the solution asymptotically found by monte carlo methods albeit often very slowly. the projection operation is discussed more fully in the box on the next page. td methods find different solutions. to understand their rationale recall that the bellman equation for value function v is v rs a v for all s s. accordingtoastationarydecisionmakingpolicy v beingusedtoselectactions.thefunctionv iscalledthestate-valuefunctionforpolicy foragivenpolicy criticmethods.ifthestatespaceisfinitethentheestimatedvaluefunctionmayberepresentedinacomputerasalargearraywithoneentryforeachstateandtheentriesdirectlyupdatedtoformtheestimate.suchtabularmethodscanhandlelargestatespacesevencontinuousonesthroughdiscretizationstateaggregationandinterpolationbutasthedimensionalityofthestatespaceincreasesthesemethodsrapidlybecomecomputationallyinfeasibleorine ective.thisisthee ectwhichgaverisetothephrase thecurseofdimensionality. amoregeneralandflexibleapproachistorepresentthevaluefunctionbyafunctionalformoffixedsizeandfixedstructurewithmanyvariableparametersorweights.theweightsarethenchangedtoreshapetheapproximatevaluefunctiontobettermatchthetruevaluefunction.wedenotetheparameterizedvaluefunctionapproximatorasv v erentiablewithrespecttotheweights.forexampleitcouldbeacubicsplineoritcouldimplementedbyamulti-layerneuralnetworkwhere istheconcatenationofalltheconnectionweights.henceforthreferto exclusivelyastheweightsorweightvectorandreservetheword parameter forthingslikethediscount-rateparameterandstep-sizeparameters.animportantspecialcaseisthatinwhichtheapproximatevaluefunctionislinearintheweightsandinfeaturesofthestatev subspace of all value functions representable as bellman error vector v istheuniquesolutiontothebellmanequationthebellmanequationcanbeviewedasanalternatewayofdefiningv vs.thediscrepancybetweenthetwosidesofthebellmanequationv v slengthinthed-metric.thatistominimizethemean-squaredbellmanerrorbe v isnotrepresentablethenitisnotbepossibletoreducethebellmanerrortozero.foranyv v b v tbesolvedexactlyyoucanminimizethemean-squaredprojectedbellmanerrorpbe v v r v v vev pbev v istheuniquesolutiontothebellmanequationandinthissensethebellmanequationcanbeviewedasanalternatewayofdefiningv notequaltov b v v b v b v error vw b space of all value functions over states chapter methods with approximation the projection matrix for a linear function approximator the projection operation is linear which implies that it can be represented as an matrix where as in section d denotes the diagonal matrix with the on the diagonal and x denotes the d matrix whose rows are the feature vectors one for each state s. if the inverse in does not exist then the pseudoinverse is substituted. using these matrices the norm of a vector can be written and the approximate linear value function can be written vw xw. the true value function v is the only value function that solves exactly. if an approximate value function vw were substituted for v the difference between the right and left sides of the modified equation could be used as a measure of how far off vw is from v we call this the bellman error at state s ws rs a vws st s at which shows clearly the relationship of the bellman error to the td error the bellman error is the expectation of the td error. the vector of all the bellman errors at all states w rs is called the bellman error vector as be in figure the overall size of this vector in the norm is an overall measure of the error in the value function called the mean squared bellman error bew it is not possible in general to reduce the be to zero which point vw v but for linear function approximation there is a unique value of w for which the be is minimized. this point in the representable-function subspace min be in figure is different in general from that which minimizes the ve as v methods that seek to minimize the be are discussed in the next two sections. the bellman error vector is shown in figure as the result of applying the bellman operator b rs rs to the approximate value function. the bellman operator is gradient descent in the bellman error defined by vs rs a for all s s and v s r. the bellman error vector for v can be written w b vw vw. if the bellman operator is applied to a value function in the representable subspace then in general it will produce a new value function that is outside the subspace as suggested in the figure. in dynamic programming function approximation this operator is applied repeatedly to the points outside the representable space as suggested by the gray arrows in the top of figure eventually that process converges to the true value function v the only fixed point for the bellman operator the only value function for which v b v which is just another way of writing the bellman equation for with function approximation however the intermediate value functions lying outside the subspace cannot be represented. the gray arrows in the upper part of figure cannot be followed because after the first update line the value function must be projected back into something representable. the next iteration then begins within the subspace the value function is again taken outside of the subspace by the bellman operator and then mapped back by the projection operator as suggested by the lower gray arrow and line. following these arrows is a dp-like process with approximation. in this case we are interested in the projection of the bellman error vector back into the representable space. this is the projected bellman error vector vw shown in figure as pbe. the size of this vector in the norm is another measure of error in the approximate value function. for any approximate value function v we define the mean square projected bellman error denoted pbe as pbew with linear function approximation there always exists an approximate value function the subspace with zero pbe this is the td fixed point wtd introduced in section as we have seen this point is not always stable under semi-gradient td methods and off-policy training. as shown in the figure this value function is generally different from those minimizing ve or be. methods that are guaranteed to converge to it are discussed in sections and gradient descent in the bellman error armed with a better understanding of value function approximation and its various objectives we return now to the challenge of stability in off-policy learning. we would like to apply the approach of stochastic gradient descent section in which updates chapter methods with approximation are made that in expectation are equal to the negative gradient of an objective function. these methods always go downhill expectation in the objective and because of this are typically stable with excellent convergence properties. among the algorithms investigated so far in this book only the monte carlo methods are true sgd methods. these methods converge robustly under both on-policy and off-policy training as well as for general nonlinear function approximators though they are often slower than semi-gradient methods with bootstrapping which are not sgd methods. semi-gradient methods may diverge under off-policy training as we have seen earlier in this chapter and under contrived cases of nonlinear function approximation and van roy with a true sgd method such divergence would not be possible. the appeal of sgd is so strong that great effort has gone into finding a practical way of harnessing it for reinforcement learning. the starting place of all such efforts is the choice of an error or objective function to optimize. in this and the next section we explore the origins and limits of the most popular proposed objective function that based on the bellman error introduced in the previous section. although this has been a popular and influential approach the conclusion that we reach here is that it is a misstep and yields no good learning algorithms. on the other hand this approach fails in an interesting way that offers insight into what might constitute a good approach. to begin let us consider not the bellman error but something more immediate and naive. temporal difference learning is driven by the td error. why not take the minimization of the expected square of the td error as the objective? in the general functionapproximation case the one-step td error with discounting is t vstwt. a possible objective function then is what one might call the mean squared td error tdew s s t t t st s at t st s at is the distribution encountered under b the last equation is of the form needed for sgd it gives the objective as an expectation that can be sampled from experience the experience is due to the behavior policy b. thus following the standard sgd approach one can derive the per-step update based on a sample of this expected value wt t t wt t t t wt t vstwt which you will recognize as the same as the semi-gradient td algorithm except for the additional final term. this term completes the gradient and makes this a true sgd gradient descent in the bellman error algorithm with excellent convergence guarantees. let us call this algorithm the naive residual-gradient algorithm baird although the naive residual-gradient algorithm converges robustly it does not necessarily converge to a desirable place. example a-split example showing the naivet e of the naive residual-gradient algorithm consider the three-state episodic mrp shown to the right. episodes begin in state a and then split stochastically half the time going to b then invariably going on to terminate with a reward of and half the time going to state c then invariably terminating with a reward of zero. reward for the first transition out of a is always zero whichever way the episode goes. as this is an episodic problem we can take to be we also assume on-policy training so that t is always and tabular function approximation so that the learning algorithms are free to give arbitrary independent values to all three states. thus this should be an easy problem. what should the values be? from a half the time the return is and half the time the return is a should have value from b the return is always so its value should be and similarly from c the return is always so its value should be these are the true values and as this is a tabular problem all the methods presented previously converge to them exactly. however the naive residual-gradient algorithm finds different values for b and c. converges it converges with b having a value of correctly to and c having a value of these are in fact the values that minimize the tde. to b s to c s a change of or down from a s let us compute the tde for these values. the first transition of each episode is a change because the reward is zero on these transitions and these changes are on the first transition. to a reward of a to a reward of with a terminal on the either up from a s of the td errors and thus the squared td error is always the second transition is similar it is either up from b s terminal state of value or down from c s state of value thus the td error is always second step. thus for this set of values the tde on both steps is for a squared error of up to at b or from now let s compute the tde for the true values at c at and a at in this case the first transition is either from down to at c in either case the absolute error is the second transition has zero error because the starting value either or depending on whether the transition is from b or c always exactly matches the immediate reward and return. thus the squared td error is on the first transition and on the second for a mean reward over the two transitions of this solution is worse according to the tde. on this simple problem the true values do not have the smallest tde. and the squared error is is bigger that as chapter methods with approximation a tabular representation is used in the a-split example so the true state values can be exactly represented yet the naive residual-gradient algorithm finds different values and these values have lower tde than do the true values. minimizing the tde is naive by penalizing all td errors it achieves something more like temporal smoothing than accurate prediction. a better idea would seem to be minimizing the bellman error. if the exact values are learned the bellman error is zero everywhere. thus a bellman-error-minimizing algorithm should have no trouble with the a-split example. we cannot expect to achieve zero bellman error in general as it would involve finding the true value function which we presume is outside the space of representable value functions. but getting close to this ideal is a natural-seeming goal. as we have seen the bellman error is also closely related to the td error. the bellman error for a state is the expected td error in that state. so let s repeat the derivation above with the expected td error expectations here are implicitly conditional on st t wt wt wt eb t t eb t t wt eb t t wt vstw t this update and various ways of sampling it are referred to as the residual-gradient algorithm. if you simply used the sample values in all the expectations then the equation above reduces almost exactly to the naive residual-gradient but this is naive because the equation above involves the next state appearing in two expectations that are multiplied together. to get an unbiased sample of the product two independent samples of the next state are required but during normal interaction with an external environment only one is obtained. one expectation or the other can be sampled but not both. there are two ways to make the residual-gradient algorithm work. one is in the case of deterministic environments. if the transition to the next state is deterministic then the two samples will necessarily be the same and the naive algorithm is valid. the other way is to obtain two independent samples of the next state from st one for the first expectation and another for the second expectation. in real interaction with an environment this would not seem possible but when interacting with a simulated environment it is. one simply rolls back to the previous state and obtains an alternate next state before proceeding forward from the first next state. in either of these cases the residual-gradient algorithm is guaranteed to converge to a minimum of the be under the usual conditions on the step-size parameter. as a true sgd method this convergence state values there remains a small difference in the treatment of the importance sampling ratio t. in the analagous action-value case is the most important case for control algorithms the residual-gradient algorithm would reduce exactly to the naive version. gradient descent in the bellman error is robust applying to both linear and nonlinear function approximators. in the linear case convergence is always to the unique w that minimizes the be. however there remain at least three ways in which the convergence of the residualgradient method is unsatisfactory. the first of these is that empirically it is slow much slower that semi-gradient methods. indeed proponents of this method have proposed increasing its speed by combining it with faster semi-gradient methods initially then gradually switching over to residual gradient for the convergence guarantee and moore the second way in which the residual-gradient algorithm is unsatisfactory is that it still seems to converge to the wrong values. it does get the right values in all tabular cases such as the a-split example as for those an exact solution to the bellman equation is possible. but if we examine examples with genuine function approximation example a-presplit example a counterexample for the be consider the three-state episodic mrp shown to the right episodes start in either or with equal probability. these two states look exactly the same to the function approximator like a single state a whose feature representation is distinct from and unrelated to the feature representation of the other two states b and c which are also distinct from each other. specifically the parameter of the function approximator has three components one giving the value of state b one giving the value of state c and one giving the value of both states and other than the selection of the initial state the system is deterministic. if it starts in then it transitions to b with a reward of and then on to termination with a reward of if it starts in then it transitions to c and then to termination with both rewards zero. to a learning algorithm seeing only the features the system looks identical to the a-split example. the system seems to always start in a followed by either b or c with equal probability and then terminating with a or a depending deterministically on the previous state. as in the a-split example the true values of b and c are and and the best shared value of and is by symmetry. because this problem appears externally identical to the a-split example we already know what values will be found by the algorithms. semi-gradient td converges to the ideal values just mentioned while the naive residual-gradient algorithm converges to values of for b and c respectively. all state transitions are deterministic so the non-naive residual-gradient algorithm will also converge to these values is the same algorithm in this case. it follows then that this naive solution must also be the one that minimizes the be and so it is. on a deterministic problem the bellman errors and td errors are all the same so the be is always the same as the tde. optimizing the be on this example gives rise to the same failure mode as with the naive residual-gradient algorithm on the a-split example. and chapter methods with approximation then the residual-gradient algorithm and indeed the be objective seem to find the wrong value functions. one of the most telling such examples is the variation on the a-split example known as the a-presplit example shown on the preceding page in which the residual-gradient algorithm finds the same poor solution as its naive version. this example shows intuitively that minimizing the be the residual-gradient algorithm surely does may not be a desirable goal. the third way in which the convergence of the residual-gradient algorithm is not satisfactory is explained in the next section. like the second way the third way is also a problem with the be objective itself rather than with any particular algorithm for achieving it. the bellman error is not learnable the concept of learnability that we introduce in this section is different from that commonly used in machine learning. there a hypothesis is said to be learnable if it is efficiently learnable meaning that it can be learned within a polynomial rather than an exponential number of examples. here we use the term in a more basic way to mean learnable at all with any amount of experience. it turns out many quantities of apparent interest in reinforcement learning cannot be learned even from an infinite amount of experiential data. these quantities are well defined and can be computed given knowledge of the internal structure of the environment but cannot be computed or estimated from the observed sequence of feature vectors actions and we say that they are not learnable. it will turn out that the bellman error objective introduced in the last two sections is not learnable in this sense. that the bellman error objective cannot be learned from the observable data is probably the strongest reason not to seek it. to make the concept of learnability clear let s start with some simple examples. consider the two markov reward diagrammed below where two edges leave a state both transitions are assumed to occur with equal probability and the numbers indicate the reward received. all the states appear the same they all produce the same single-component feature vector x and have approximated value w. thus the only varying part of the data trajectory is the reward sequence. the left mrp stays in the same state and emits an endless stream of and at random each with probability. the right mrp on every step either stays in its current state or switches to the other with equal probability. the reward is deterministic in this mrp always a from one state and always a from the other but because the each state is would of course be estimated if the state sequence were observed rather than only the corre sponding feature vectors. mrps can be considered mdps with a single action in all states what we conclude about mrps here applies as well to mdps. the bellman error is not learnable equally likely on each step the observable data is again an endless stream of and at random identical to that produced by the left mrp. can assume the right mrp starts in one of two states at random with equal probability. thus even given even an infinite amount of data it would not be possible to tell which of these two mrps was generating it. in particular we could not tell if the mrp has one state or two is stochastic or deterministic. these things are not learnable. this pair of mrps also illustrates that the ve objective is not learnable. if then the true values of the three states both mrps left to right are and suppose w then the ve is for the left mrp and for the right mrp. because the ve is different in the two problems yet the data generated has the same distribution the ve cannot be learned. the ve is not a unique function of the data distribution. and if it cannot be learned then how could the ve possibly be useful as an objective for learning? if an objective cannot be learned it does indeed draw its utility into question. in the case of the ve however there is a way out. note that the same solution w is optimal for both mrps above is the same for the two indistinguishable states in the right mrp. is this a coincidence or could it be generally true that all mdps with the same data distribution also have the same optimal parameter vector? if this is true and we will show next that it is then the ve remains a usable objective. the ve is not learnable but the parameter that optimizes it is! to understand this it is useful to bring in another natural objective function this time one that is clearly learnable. one error that is always observable is that between the value estimate at each time and the return from that time. the mean square return error denoted re is the expectation under of the square of this error. in the on-policy case the re can be written rew vew v thus the two objectives are the same except for a variance term that does not depend on the parameter vector. the two objectives must therefore have the same optimal parameter value w the overall relationships are summarized in the left side of figure exercise prove hint write the re as an expectation over possible states s of the expectation of the squared error given that st s. then add and subtract the true value of state s from the error squaring grouping the subtracted true value with the return and the added true value with the estimated value. then if you expand the square the most complex term will end up being zero leaving you with now let us return to the be. the be is like the ve in that it can be computed from knowledge of the mdp but is not learnable from data. but it is not like the ve in that its minimum solution is not learnable. the box on the next page presents a counterexample two mrps that generate the same data distribution but whose minimizing parameter vector is different proving that the optimal parameter vector is not a function of the data and thus cannot be learned from it. the other bootstrapping objectives that we have considered the pbe and tde can be determined from data chapter methods with approximation example counterexample to the learnability of the bellman error to show the full range of possibilities we need a slightly more complex pair of markov reward processes than those considered earlier. consider the following two mrps where two edges leave a state both transitions are assumed to occur with equal probability and the numbers indicate the reward received. the mrp on the left has two states that are represented distinctly. the mrp on the right has three states two of which b and appear the same and must be given the same approximate value. specifically w has two components and the value of state a is given by the first component and the value of b and is given by the second. the second mrp has been designed so that equal time is spent in all three states so we can take for all s. note that the observable data distribution is identical for the two mrps. in both cases the agent will see single occurrences of a followed by a then some number of apparent bs each followed by a except the last which is followed by a then we start all over again with a single a and a etc. all the statistical details are the same as well in both mrps the probability of a string of k bs is k. now suppose w in the first mrp this is an exact solution and the be is zero. in the second mrp this solution produces a squared error in both b and of such that be these two mrps which generate the same data distribution have different bes the be is not learnable. moreover unlike the earlier example for the ve the minimizing value of w is different for the two mrps. for the first mrp w minimizes the be for any for the second mrp the minimizing w is a complicated function of but in the limit as it is thus the solution that minimizes be cannot be estimated from data alone knowledge of the mrp beyond what is revealed in the data is required. in this sense it is impossible in principle to pursue the be as an objective for learning. it may be surprising that in the second mrp the be-minimizing value of a is so far from zero. recall that a has a dedicated weight and thus its value is unconstrained by function approximation. a is followed by a reward of and transition to a state with a value of nearly which suggests vwa should be why is its optimal value substantially negative rather than the answer is that making vwa negative reduces the error upon arriving in a from b. the reward on this deterministic transition is which implies that b should have a value more than a. because b s value is approximately zero a s value is driven toward the be-minimizing value of for a is a compromise between reducing the errors on leaving and on entering a. the bellman error is not learnable figure causal relationships among the data distribution mdps and various objectives. left monte carlo objectives two different mdps can produce the same data distribution yet also produce different ves proving that the ve objective cannot be determined from data and is not learnable. however all such ves must have the same optimal parameter vector w moreover this same w can be determined from another objective the re which is uniquely determined from the data distribution. thus w and the re are learnable even though the ves are not. right bootstrapping objectives two different mdps can produce the same data distribution yet also produce different bes and have different minimizing parameter vectors these are not learnable from the data distribution. the pbe and tde objectives and their minima can be directly determined from data and thus are learnable. learnable and determine optimal solutions that are in general different from each other and the be minimums. the general case is summarized in the right side of figure thus the be is not learnable it cannot be estimated from feature vectors and other observable data. this limits the be to model-based settings. there can be no algorithm that minimizes the be without access to the underlying mdp states beyond the feature vectors. the residual-gradient algorithm is only able to minimize be because it is allowed to double sample from the same state not a state that has the same feature vector but one that is guaranteed to be the same underlying state. we can see now that there is no way around this. minimizing the be requires some such access to the nominal underlying mdp. this is an important limitation of the be beyond that identified in the a-presplit example on page all this directs more attention toward the pbe. erentmdpsisidenticalineveryrespectyetthebeisdi erentbes.thusthebecannotbeestimatedfromdataaloneknowledgeofthemdpbeyondwhatisrevealedinthedataisrequired.moreoverthetwomdpshavedi erentmdpsisidenticalineveryrespectyetthebeisdi erentbes.thusthebecannotbeestimatedfromdataaloneknowledgeofthemdpbeyondwhatisrevealedinthedataisrequired.moreoverthetwomdpshavedi erentmdpsisidenticalineveryrespectyetthebeisdi erentbes.thusthebecannotbeestimatedfromdataaloneknowledgeofthemdpbeyondwhatisrevealedinthedataisrequired.moreoverthetwomdpshavedi erentmdpsisidenticalineveryrespectyetthebeisdi erentbes.thusthebecannotbeestimatedfromdataaloneknowledgeofthemdpbeyondwhatisrevealedinthedataisrequired.moreoverthetwomdpshavedi erentmdpsisidenticalineveryrespectyetthebeisdi erentbes.thusthebecannotbeestimatedfromdataaloneknowledgeofthemdpbeyondwhatisrevealedinthedataisrequired.moreoverthetwomdpshavedi w carloobjectivesbootstrappingobjectives chapter methods with approximation gradient-td methods we now consider sgd methods for minimizing the pbe. as true sgd methods these gradient-td methods have robust convergence properties even under off-policy training and nonlinear function approximation. remember that in the linear case there is always an exact solution the td fixed point wtd at which the pbe is zero. this solution could be found by least-squares methods but only by methods of quadratic complexity in the number of parameters. we seek instead an sgd method which should be od and have robust convergence properties. gradient-td methods come close to achieving these goals at the cost of a rough doubling of computational complexity. to derive an sgd method for the pbe linear function approximation we begin by expanding and rewriting the objective in matrix terms pbew w w w and the identity the gradient with respect to w is pbew to turn this into an sgd method we have to sample something on every time step that has this quantity as its expected value. let us take to be the distribution of states visited under the behavior policy. all three of the factors above can then be written in terms of expectations under this distribution. for example the last factor can be written w ws e t txt which is just the expectation of the semi-gradient update the first factor is the transpose of the gradient of this update e t t episodic t finally the middle factor is the inverse of the expected outer-product matrix of the feature vectors t t gradient-td methods substituting these expectations for the three factors in our expression for the gradient of the pbe we get pbew t e t txt it might not be obvious that we have made any progress by writing the gradient in this form. it is a product of three expressions and the first and last are not independent. they both depend on the next feature vector we cannot simply sample both of these expectations and then multiply the samples. this would give us a biased estmate of the gradient just as in the naive residual-gradient algorithm. another idea would be to estimate the three expectations separately and then combine them to produce an unbiased estimate of the gradient. this would work but would require a lot of computational resources particularly to store the first two expectations which are d d matrices and to compute the inverse of the second. this idea can be improved. if two of the three expectations are estimated and stored then the third could be sampled and used in conjunction with the two stored quantities. for example you could store estimates of the second two quantities the increment inverse-updating techniques in section and then sample the first expression. unfortunately the overall algorithm would still be of quadratic complexity order the idea of storing some estimates separately and then combining them with samples is a good one and is also used in gradient-td methods. gradient-td methods estimate and store the product of the second two factors in these factors are a d d matrix and a d-vector so their product is just a d-vector like w itself. we denote this second learned vector as v where is another step-size parameter. we can use this method to effectively achieve with od storage and per-step computation. given a stored estimate vt approximating we can update our main parameter vector wt using sgd methods based on the simplest such rule is wt wt pbewt t e t txt wt txt e t txt wt txt vt wt t vt. on general sgd rule this form is familiar to students of linear supervised learning. it is the solution to a linear least-squares problem that tries to approximate t t from the features. the standard sgd method for incrementally finding the vector v that minimizes the expected squared is known as the least mean square rule augmented v e t txt error t with an importance sampling ratio vt t xt chapter methods with approximation this algorithm is called note that if the final inner product vt is done first then the entire algorithm is of od complexity. a slightly better algorithm can be derived by doing a few more analytic steps before substituting in vt. continuing from wt txt e t txt wt e t txt wt t t e t wt t t wt txt which again is od if the final product vt is done first. this algorithm is known as either with gradient correction or alternatively as figure shows a sample and the expected behavior of tdc on baird s counterexample. as intended the pbe falls to zero but note that the individual components of the parameter vector do not approach zero. in fact these values are still far from an optimal solution vs for all s for which w would have to be proportional to after iterations we are still far from an optimal solution as figure the behavior of the tdc algorithm on baird s counterexample. on the left is shown a typical single run and on the right is shown the expected behavior of this algorithm if the updates are done synchronously to except for the two tdc parameter vectors. the step sizes were and emphatic-td methods we can see from the ve which remains almost the system is actually converging to an optimal solution but progress is extremely slow because the pbe is already so close to zero. and tdc both involve two learning processes a primary one for w and a secondary one for v. the logic of the primary learning process relies on the secondary learning process having finished at least approximately whereas the secondary learning process proceeds without being influenced by the first. we call this sort of asymmetrical dependence a cascade. in cascades we often assume that the secondary learning process is proceeding faster and thus is always at its asymptotic value ready and accurate to assist the primary learning process. the convergence proofs for these methods often make this assumption explicitly. these are called two-time-scale proofs. the fast time scale is that of the secondary learning process and the slower time scale is that of the primary learning process. if is the step size of the primary learning process and is the step size of the secondary learning process then these convergence proofs will typically require that in the limit and gradient-td methods are currently the most well understood and widely used stable off-policy methods. there are extensions to action values and control maei et al. to eligibility traces and gq maei maei and sutton and to nonlinear function approximation et al. there have also been proposed hybrid algorithms midway between semi-gradient td and gradient td white and white hybrid-td algorithms behave like gradient-td algorithms in states where the target and behavior policies are very different and behave like semigradient algorithms in states where the target and behavior policies are the same. finally the gradient-td idea has been combined with the ideas of proximal methods and control variates to produce more efficient methods et al. emphatic-td methods we turn now to the second major strategy that has been extensively explored for obtaining a cheap and efficient off-policy learning method with function approximation. recall that linear semi-gradient td methods are efficient and stable when trained under the on-policy distribution and that we showed in section that this has to do with the positive definiteness of the matrix a and the match between the on-policy state distribution and the state-transition probabilities pss a under the target policy. in off-policy learning we reweight the state transitions using importance sampling so that they become appropriate for learning about the target policy but the state distribution is still that of the behavior policy. there is a mismatch. a natural idea is to somehow reweight the states emphasizing some and de-emphasizing others so as to return the distribution of updates to the on-policy distribution. there would then be a match and stability and convergence would follow from existing results. this is the idea of emphatic-td methods first introduced for on-policy training in section actually the notion of the on-policy distribution is not quite right as there are many on-policy distributions and any one of these is sufficient to guarantee stability. consider an undiscounted episodic problem. the way episodes terminate is fully determined by chapter methods with approximation the transition probabilities but there may be several different ways the episodes might begin. however the episodes start if all state transitions are due to the target policy then the state distribution that results is an on-policy distribution. you might start close to the terminal state and visit only a few states with high probability before ending the episode. or you might start far away and pass through many states before terminating. both are on-policy distributions and training on both with a linear semi-gradient method would be guaranteed to be stable. however the process starts an on-policy distribution results as long as all states encountered are updated up until termination. if there is discounting it can be treated as partial or probabilistic termination for these purposes. if then we can consider that with probability the process terminates on every time step and then immediately restarts in the state that is transitioned to. a discounted problem is one that is continually terminating and restarting with probability on every step. this way of thinking about discounting is an example of a more general notion of pseudo termination termination that does not affect the sequence of state transitions but does affect the learning process and the quantities being learned. this kind of pseudo termination is important to off-policy learning because the restarting is optional remember we can start any way we want to and the termination relieves the need to keep including encountered states within the on-policy distribution. that is if we don t consider the new states as restarts then discounting quickly gives us a limited on-policy distribution. the one-step emphatic-td algorithm for learning episodic state values is defined by t vstwt wt mt t t vstwt mt t it figure the behavior of the one-step emphatic-td algorithm in expectation on baird s counterexample. the step size was reducing variance with it the interest being arbitrary and mt the emphasis being initialized to mt how does this algorithm perform on baird s counterexample? figure shows the trajectory in expectation of the components of the parameter vector the case in which it for all t. there are some oscillations but eventually everything converges and the ve goes to zero. these trajectories are obtained by iteratively computing the expectation of the parameter vector trajectory without any of the variance due to sampling of transitions and rewards. we do not show the results of applying the emphatic-td algorithm directly because its variance on baird s counterexample is so high that it is nigh impossible to get consistent results in computational experiments. the algorithm converges to the optimal solution in theory on this problem but in practice it does not. we turn to the topic of reducing the variance of all these algorithms in the next section. reducing variance off-policy learning is inherently of greater variance than on-policy learning. this is not surprising if you receive data less closely related to a policy you should expect to learn less about the policy s values. in the extreme one may be able to learn nothing. you can t expect to learn how to drive by cooking dinner for example. only if the target and behavior policies are related if they visit similar states and take similar actions should one be able to make significant progress in off-policy training. on the other hand any policy has many neighbors many similar policies with considerable overlap in states visited and actions chosen and yet which are not identical. the raison d etre of off-policy learning is to enable generalization to this vast number of related-but-not-identical policies. the problem remains of how to make the best use of the experience. now that we have some methods that are stable in expected value the step sizes are set right attention naturally turns to reducing the variance of the estimates. there are many possible ideas and we can just touch on of a few of them in this introductory text. why is controlling variance especially critical in off-policy methods based on importance sampling? as we have seen importance sampling often involves products of policy ratios. the ratios are always one in expectation but their actual values may be very high or as low as zero. successive ratios are uncorrelated so their products are also always one in expected value but they can be of very high variance. recall that these ratios multiply the step size in sgd methods so high variance means taking steps that vary greatly in their sizes. this is problematic for sgd because of the occasional very large steps. they must not be so large as to take the parameter to a part of the space with a very different gradient. sgd methods rely on averaging over multiple steps to get a good sense of the gradient and if they make large moves from single samples they become unreliable. if the step-size parameter is set small enough to prevent this then the expected step can end up being very small resulting in very slow learning. the notions of momentum of polyak-ruppert averaging ruppert polyak and juditsky or further extensions of these ideas may significantly help. methods for adaptively setting separate step sizes for different components of the chapter methods with approximation parameter vector are also pertinent jacobs sutton c as are the importance weight aware updates of karampatziakis and langford in chapter we saw how weighted importance sampling is significantly better behaved with lower variance updates than ordinary importance sampling. however adapting weighted importance sampling to function approximation is challenging and can probably only be done approximately with od complexity and sutton the tree backup algorithm shows that it is possible to perform some off-policy learning without using importance sampling. this idea has been extended to the off-policy case to produce stable and more efficient methods by munos stepleton harutyunyan and bellemare and by mahmood yu and sutton another complementary strategy is to allow the target policy to be determined in part by the behavior policy in such a way that it never can be so different from it to create large importance sampling ratios. for example the target policy can be defined by reference to the behavior policy as in the recognizers proposed by precup et al. summary off-policy learning is a tempting challenge testing our ingenuity in designing stable and efficient learning algorithms. tabular q-learning makes off-policy learning seem easy and it has natural generalizations to expected sarsa and to the tree backup algorithm. but as we have seen in this chapter the extension of these ideas to significant function approximation even linear function approximation involves new challenges and forces us to deepen our understanding of reinforcement learning algorithms. why go to such lengths? one reason to seek off-policy algorithms is to give flexibility in dealing with the tradeoff between exploration and exploitation. another is to free behavior from learning and avoid the tyranny of the target policy. td learning appears to hold out the possibility of learning about multiple things in parallel of using one stream of experience to solve many tasks simultaneously. we can certainly do this in special cases just not in every case that we would like to or as efficiently as we would like to. in this chapter we divided the challenge of off-policy learning into two parts. the first part correcting the targets of learning for the behavior policy is straightforwardly dealt with using the techniques devised earlier for the tabular case albeit at the cost of increasing the variance of the updates and thereby slowing learning. high variance will probably always remains a challenge for off-policy learning. the second part of the challenge of off-policy learning emerges as the instability of semi-gradient td methods that involve bootstrapping. we seek powerful function approximation off-policy learning and the efficiency and flexibility of bootstrapping td methods but it is challenging to combine all three aspects of this deadly triad in one algorithm without introducing the potential for instability. there have been several attempts. the most popular has been to seek to perform true stochastic gradient descent in the bellman error the bellman residual. however our analysis con summary cludes that this is not an appealing goal in many cases and that anyway it is impossible to achieve with a learning algorithm the gradient of the be is not learnable from experience that reveals only feature vectors and not underlying states. another approach gradient-td methods performs sgd in the projected bellman error. the gradient of the pbe is learnable with od complexity but at the cost of a second parameter vector with a second step size. the newest family of methods emphatic-td methods refine an old idea for reweighting updates emphasizing some and de-emphasizing others. in this way they restore the special properties that make on-policy learning stable with computationally simple semi-gradient methods. the whole area of off-policy learning is relatively new and unsettled. which methods are best or even adequate is not yet clear. are the complexities of the new methods introduced at the end of this chapter really necessary? which of them can be combined effectively with variance reduction methods? the potential for off-policy learning remains tantalizing the best way to achieve it still a mystery. bibliographical and historical remarks the first semi-gradient method was linear td the name semi-gradient is more recent semi-gradient off-policy with general importance-sampling ratio may not have been explicitly stated until sutton mahmood and white but the action-value forms were introduced by precup sutton and singh who also did eligibility trace forms of these algorithms chapter their continuing undiscounted forms have not been significantly explored. the atomic n-step forms given here are new. the earliest example was given by tsitsiklis and van roy who also introduced the specific counterexample in the box on page baird s counterexample is due to baird though the version we present here is slightly modified. averaging methods for function approximation were developed by gordon other examples of instability with off-policy dp methods and more complex methods of function approximation are given by boyan and moore bradtke gives an example in which q-learning using linear function approximation in a linear quadratic regulation problem converges to a destabilizing policy. the deadly triad was first identified by sutton and thoroughly analyzed by tsitsiklis and van roy the name deadly triad is due to sutton this kind of linear analysis was pioneered by tsitsiklis and van roy including the dynamic programming operator. diagrams like figure were introduced by lagoudakis and parr what we have called the bellman operator and denoted b is more commonly denoted t and called a dynamic programming operator while a generalized chapter methods with approximation form denoted t is called the td operator and van roy the be was first proposed as an objective function for dynamic programming by schweitzer and seidmann baird extended it to td learning based on stochastic gradient descent. in the literature be minimization is often referred to as bellman residual minimization. the earliest a-split example is due to dayan the two forms given here were introduced by sutton et al. the contents of this section are new to this text. gradient-td methods were introduced by sutton szepesv ari and maei the methods highlighted in this section were introduced by sutton et al. and mahmood et al. the most sensitive empirical investigations to date of gradient-td and related methods are given by geist and scherrer dann neumann and peters and white the latest developments in the theory of gradient-td methods are developed by yu emphatic-td methods were introduced by sutton mahmood and white full convergence proofs and other theory were later established by yu yu mahmood and sutton hallak tamar and mannor and hallak tamar munos and mannor chapter eligibility traces eligibility traces are one of the basic mechanisms of reinforcement learning. for example in the popular td algorithm the refers to the use of an eligibility trace. almost any temporal-difference method such as q-learning or sarsa can be combined with eligibility traces to obtain a more general method that may learn more efficiently. eligibility traces unify and generalize td and monte carlo methods. when td methods are augmented with eligibility traces they produce a family of methods spanning a spectrum that has monte carlo methods at one end and one-step td methods at the other in between are intermediate methods that are often better than either extreme method. eligibility traces also provide a way of implementing monte carlo methods online and on continuing problems without episodes. of course we have already seen one way of unifying td and monte carlo methods the n-step td methods of chapter what eligibility traces offer beyond these is an elegant algorithmic mechanism with significant computational advantages. the mechanism is a short-term memory vector the eligibility trace zt rd that parallels the long-term weight vector wt rd. the rough idea is that when a component of wt participates in producing an estimated value then the corresponding component of zt is bumped up and then begins to fade away. learning will then occur in that component of wt if a nonzero td error occurs before the trace falls back to zero. the trace-decay parameter determines the rate at which the trace falls. the primary computational advantage of eligibility traces over n-step methods is that only a single trace vector is required rather than a store of the last n feature vectors. learning also occurs continually and uniformly in time rather than being delayed and then catching up at the end of the episode. in addition learning can occur and affect behavior immediately after a state is encountered rather than being delayed n steps. eligibility traces illustrate that a learning algorithm can sometimes be implemented in a different way to obtain computational advantages. many algorithms are most naturally formulated and understood as an update of a state s value based on events that follow that state over multiple future time steps. for example monte carlo methods update a state based on all the future rewards and n-step td methods chapter eligibility traces update based on the next n rewards and state n steps in the future. such formulations based on looking forward from the updated state are called forward views. forward views are always somewhat complex to implement because the update depends on later things that are not available at the time. however as we show in this chapter it is often possible to achieve nearly the same updates and sometimes exactly the same updates with an algorithm that uses the current td error looking backward to recently visited states using an eligibility trace. these alternate ways of looking at and implementing learning algorithms are called backward views. backward views transformations between forward-views and backward-views and equivalences between them date back to the introduction of temporal difference learning but have become much more powerful and sophisticated since here we present the basics of the modern view. as usual first we fully develop the ideas for state values and prediction then extend them to action values and control. we develop them first for the on-policy case then extend them to off-policy learning. our treatment pays special attention to the case of linear function approximation for which the results with eligibility traces are stronger. all these results apply also to the tabular and state aggregation cases because these are special cases of linear function approximation. the in chapter we defined an n-step return as the sum of the first n rewards plus the estimated value of the state reached in n steps each appropriately discounted the general form of that equation for any parameterized function approximator is gttn n n vstnwtn t t n. we noted in chapter that each n-step return for n is a valid update target for a tabular learning update just as it is for an approximate sgd learning update such as now we note that a valid update can be done not just toward any n-step return but toward any average of n-step returns. for example an update can be done toward a target that is half of a two-step return and half of a four-step return any set of n-step returns can be averaged in this way even an infinite set as long as the weights on the component returns are positive and sum to the composite return possesses an error reduction property similar to that of individual n-step returns and thus can be used to construct updates with guaranteed convergence properties. averaging produces a substantial new range of algorithms. for example one could average one-step and infinite-step returns to obtain another way of interrelating td and monte carlo methods. in principle one could even average experience-based updates with dp updates to get a simple combination of experience-based and model-based methods chapter an update that averages simpler component updates is called a compound update. the backup diagram for a compound update consists of the backup diagrams for each of the component updates with a horizontal line above them and the weighting fractions below. the for example the compound update for the case mentioned at the start of this section mixing half of a two-step return and half of a four-step return has the diagram shown to the right. a compound update can only be done when the longest of its component updates is complete. the update at the right for example could only be done at time for the estimate formed at time t. in general one would like to limit the length of the longest component update because of the corresponding delay in the updates. the td algorithm can be understood as one particular way of averaging n-step updates. this average contains all the n-step updates each weighted proportional to n and is normalized by a factor of to ensure that the weights sum to figure the resulting update is toward a return called the defined in its statebased form by g t n figure further illustrates the weighting on the sequence of n-step returns in the the one-step return is given the largest weight the two-step return is given the next largest weight the three-step return is given the weight and so on. the weight fades by with each additional step. after a terminal state has been reached all subsequent n-step returns are equal to gt. if we want we can separate figure the backup digram for td if then the overall update reduces to its first component the one-step td update whereas if then the overall update reduces to its last component the monte carlo update. chapter eligibility traces figure weighting given in the to each of the n-step returns. these post-termination terms from the main sum yielding g t t t n t t as indicated in the figures. this equation makes it clearer what happens when in this case the main sum goes to zero and the remaining term reduces to the conventional return gt. thus for updating according to the is a monte carlo algorithm. on the other hand if then the reduces to the onestep return. thus for updating according to the is a one-step td method. exercise just as the return can be written recursively in terms of the first reward and itself one-step later so can the derive the analogous recursive relationship from and exercise the parameter characterizes how fast the exponential weighting in figure falls off and thus how far into the future the algorithm looks in determining its update. but a rate factor such as is sometimes an awkward way of characterizing the speed of the decay. for some purposes it is better to specify a time constant or half-life. what is the equation relating and the half-life the time by which the weighting sequence will have fallen to half of its initial value? we are now ready to define our first learning algorithm based on the the off-line algorithm. as an off-line algorithm it makes no changes to the weight vector during the episode. then at the end of the episode a whole sequence of off-line updates are made according to our usual semi-gradient rule using the as the target wt t vstwt t t given tothe returndecay by given toactual final returntttimeweighttotal area the the gives us an alternative way of moving smoothly between monte carlo and one-step td methods that can be compared with the n-step td way of chapter there we assessed effectiveness on a random walk task page figure shows the performance of the off-line algorithm on this task alongside that of the n-step methods from figure the experiment was just as described earlier except that for the algorithm we varied instead of n. the performance measure used is the estimated root-mean-squared error between the correct and estimated values of each state measured at the end of the episode averaged over the first episodes and the states. note that overall performance of the off-line algorithms is comparable to that of the n-step algorithms. in both cases we get best performance with an intermediate value of the bootstrapping parameter n for n-step methods and for the off-line algorithm. figure random walk results performance of the off-line return algorithm alongside that of the n-step td methods. in both case intermediate values of the bootstrapping parameter or n performed best. the results with the off-line algorithm are slightly better at the best values of and and at high the approach that we have been taking so far is what we call the theoretical or forward view of a learning algorithm. for each state visited we look forward in time to all the future rewards and decide how best to combine them. we might imagine ourselves riding the stream of states looking forward from each state to determine its update as suggested by figure after looking forward from and updating one state we move on to the next and never have to work with the preceding state again. future states on the other hand are viewed and processed repeatedly once from each vantage point preceding them. n-step td methodsfrom chapter averagerms errorover statesand first algorithm rms errorat the end of the episodeover the episodes chapter eligibility traces figure the forward view. we decide how to update each state by looking forward to future rewards and states. td td is one of the oldest and most widely used algorithms in reinforcement learning. it was the first algorithm for which a formal relationship was shown between a more theoretical forward view and a more computationally congenial backward view using eligibility traces. here we will show empirically that it approximates the off-line algorithm presented in the previous section. td improves over the off-line algorithm in three ways. first it updates the weight vector on every step of an episode rather than only at the end and thus its estimates may be better sooner. second its computations are equally distributed in time rather that all at the end of the episode. and third it can be applied to continuing problems rather than just episodic problems. in this section we present the semi-gradient version of td with function approximation. with function approximation the eligibility trace is a vector zt rd with the same number of components as the weight vector wt. whereas the weight vector is a long-term memory accumulating over the lifetime of the system the eligibility trace is a short-term memory typically lasting less time than the length of an episode. eligibility traces assist in the learning process their only consequence is that they affect the weight vector and then the weight vector determines the estimated value. in td the eligibility trace vector is initialized to zero at the beginning of the episode is incremented on each time step by the value gradient and then fades away by z zt vstwt zt t t where is the discount rate and is the parameter introduced in the previous section which we henceforth call the trace-decay parameter. the eligibility trace keeps track of which components of the weight vector have contributed positively or negatively to recent state valuations where recent is defined in terms of that in linear function approximation vstwt is just the feature vector xt in which case the eligibility trace vector is just a sum of past fading input vectors. the trace is said to indicate the eligibility of each component of the weight vector for undergoing learning td changes should a reinforcing event occur. the reinforcing events we are concerned with are the moment-by-moment one-step td errors. the td error for state-value prediction is t vstwt. in td the weight vector is updated on each step proportional to the scalar td error and the vector eligibility trace wt t zt. semi-gradient td for estimating v v input the policy to be evaluated input a differentiable function v s rd r such that vterminal algorithm parameters step size trace decay rate initialize value-function weights w arbitrarily w loop for each episode initialize s z loop for each step of episode choose a take action a observe r z z vsw r vsw w w z s until is terminal d-dimensional vector figure the backward or mechanistic view of td each update depends on the current td error combined with the current eligibility traces of past events. chapter eligibility traces td is oriented backward in time. at each moment we look at the current td error and assign it backward to each prior state according to how much that state contributed to the current eligibility trace at that time. we might imagine ourselves riding along the stream of states computing td errors and shouting them back to the previously visited states as suggested by figure where the td error and traces come together we get the update given by changing the values of those past states for when they occur again in the future. to better understand the backward view of td consider what happens at various values of if then by the trace at t is exactly the value gradient corresponding to st. thus the td update reduces to the one-step semi-gradient td update treated in chapter in the tabular case to the simple td rule this is why that algorithm was called in terms of figure is the case in which only the one state preceding the current one is changed by the td error. for larger values of but still more of the preceding states are changed but each more temporally distant state is changed less because the corresponding eligibility trace is smaller as suggested by the figure. we say that the earlier states are given less credit for the td error. if then the credit given to earlier states falls only by per step. this turns out to be just the right thing to do to achieve monte carlo behavior. for example remember that the td error t includes an undiscounted term of in passing this back k steps it needs to be discounted like any reward in a return by k which is just what the falling eligibility trace achieves. if and then the eligibility traces do not decay at all with time. in this case the method behaves like a monte carlo method for an undiscounted episodic task. if the algorithm is also known as is a way of implementing monte carlo algorithms that is more general than those presented earlier and that significantly increases their range of applicability. whereas the earlier monte carlo methods were limited to episodic tasks can be applied to discounted continuing tasks as well. moreover can be performed incrementally and online. one disadvantage of monte carlo methods is that they learn nothing from an episode until it is over. for example if a monte carlo control method takes an action that produces a very poor reward but does not end the episode then the agent s tendency to repeat the action will be undiminished during the episode. online on the other hand learns in an n-step td way from the incomplete ongoing episode where the n steps are all the way up to the current step. if something unusually good or bad happens during an episode control methods based on can learn immediately and alter their behavior on that same episode. it is revealing to revisit the random walk example to see how well td ddoes in approximating the off-line algorithm. the results for both algorithms are shown in figure for each value if is selected optimally for it smaller then the two algorithms perform virtually identically. if is chosen larger than is optimal however then the algorithm is only a little worse whereas td is much worse and may even be unstable. this is not catastrophic for td on this problem as these higher parameter values are not what one would want to use anyway but for other problems it can be a significant weakness. n-step truncated methods figure random walk results performance of td alongside that of the off-line algorithm. the two algorithms performed virtually identically at low than optimal values but td was worse at high values. linear td has been proved to converge in the on-policy case if the step-size parameter is reduced over time according to the usual conditions just as discussed in section convergence is not to the minimum-error weight vector but to a nearby weight vector that depends on the bound on solution quality presented in that section can now be generalized to apply to any for the continuing discounted case vew min w vew. that is the asymptotic error is no more than times the smallest possible error. as approaches the bound approaches the minimum error it is loosest at in practice however is often the poorest choice as will be illustrated later in figure exercise some insight into how td can closely approximate the off-line algorithm can be gained by seeing that the latter s error term brackets in can be written as the sum of td errors for a single fixed w. show this following the pattern of and using the recursive relationship for the you obtained in exercise exercise use your result from the preceding exercise to show that if the weight updates over an episode were computed on each step but not actually used to change the weights remained fixed then the sum of td s weight updates would be the same as the sum of the off-line algorithm s updates. n-step truncated methods the off-line algorithm is an important ideal but it s of limited utility because it uses the which is not known until the end of the episode. in the off-line algorithmfrom the previous section errorat the end of the episodeover the chapter eligibility traces continuing case the is technically never known as it depends on n-step returns for arbitrarily large n and thus on rewards arbitrarily far in the future. however the dependence gets weaker for long-delayed rewards falling by for each step of delay. a natural approximation then would be to truncate the sequence after some number of steps. our existing notion of n-step returns provides a natural way to do this in which the missing rewards are replaced with estimated values. in general we define the truncated for time t given data only up to some later horizon h as g th h t n h t t h t. if you compare this equation with the it is clear that the horizon h is playing the same role as was previously played by t the time of termination. whereas in the there is a residual weighting given to the true return here it is given to the longest available n-step return the t-step return the truncated immediately gives rise to a family of n-step algorithms similar to the n-step methods of chapter in all these algorithms updates are delayed by n steps and only take into account the first n rewards but now all the k-step returns are included for k n the earlier n-step algorithms used only the n-step return weighted geometrically as in figure in the state-value case this family of algorithms is known as truncated td or ttd the compound backup diagram shown in figure is similar to that for td except that the longest component update is at most n steps rather than always going all the way to the end of figure the backup diagram for truncated td redoing updates the online algorithm the episode. ttd is defined by wtn wtn ttn vstwtn vstwtn t t. this algorithm can be implemented efficiently so that per-step computation does not scale with n of course memory must. much as in n-step td methods no updates are made on the first n time steps and n additional updates are made upon termination. efficient implementation relies on the fact that the k-step can be written exactly as g ttk vstwt tk t where vstwt exercise several times in this book in exercises we have established that returns can be written as sums of td errors if the value function is held constant. why is another instance of this? prove redoing updates the online algo rithm choosing the truncation parameter n in truncated td involves a tradeoff. n should be large so that the method closely approximates the off-line algorithm but it should also be small so that the updates can be made sooner and can influence behavior sooner. can we get the best of both? well yes in principle we can albeit at the cost of computational complexity. the idea is that on each time step as you gather a new increment of data you go back and redo all the updates since the beginning of the current episode. the new updates will be better than the ones you previously made because now they can take into account the time step s new data. that is the updates are always towards an n-step truncated target but they always use the latest horizon. in each pass over that episode you can use a slightly longer horizon and obtain slightly better results. recall that the n-step truncated is defined by g th h t n h t let us step through how this target could ideally be used if computational complexity was not an issue. the episode begins with an estimate at time using the weights from the end of the previous episode. learning begins when the data horizon is extended to time step the target for the estimate at step given the data up to horizon could chapter eligibility traces only be the one-step return which includes and bootstraps from the estimate note that this is exactly what g is with the sum in the first term of degenerating to zero. using this update target we construct then after advancing the data horizon to step what do we do? we have new data in the form of and as well as the new so now we can construct a better update target g for the first update from as well as a better update target g for the second update from using these improved targets we redo the updates at and starting again from to produce now we advance the horizon to step and repeat going all the way back to produce three new targets redoing all updates starting from the original to produce and so on. each time the horizon is advanced all the updates are redone starting from using the weight vector from the preceding horizon. this conceptual algorithm involves multiple passes over the episode one at each horizon each generating a different sequence of weight vectors. to describe it clearly we have to distinguish between the weight vectors computed at the different horizons. let us use wh t to denote the weights used to generate the value at time t in the sequence at horizon h. the first weight vector wh in each sequence is that inherited from the previous episode and the last weight vector wh h in each sequence defines the ultimate weight-vector sequence of the algorithm. at the final horizon h t we obtain the final weights wt t which will be passed on to form the initial weights of the next episode. with these conventions the three first sequences described in the previous paragraph can be given explicitly h h h th vstwh wt the general form for the update is wh wh t t vstwh t t h t. this update together with wt t defines the online algorithm. the online algorithm is fully online determining a new weight vector wt at each step t during an episode using only information available at time t. its main drawback is that it is computationally complex passing over the entire episode so far on every step. note that it is strictly more complex than the off-line algorithm which passes through all the steps at the time of termination but does not make any updates during the episode. in return the online algorithm can be expected to perform better than the off-line one not only during the episode when it makes an update while true online td the off-line algorithm makes none but also at the end of the episode because the weight vector used in bootstrapping g th has had a greater number of informative updates. this effect can be seen if one looks carefully at figure which compares the two algorithms on the random walk task. figure random walk results performance of online and off-line algorithms. the performance measure here is the ve at the end of the episode which should be the best case for the off-line algorithm. nevertheless the online algorithm performs subtly better. for comparison the line is the same for both methods. true online td the online algorithm just presented is currently the best performing temporaldifference algorithm. it is an ideal which online td only approximates. as presented however the online algorithm is very complex. is there a way to invert this forward-view algorithm to produce an efficient backward-view algorithm using eligibility traces? it turns out that there is indeed an exact computationally congenial implementation of the online algorithm for the case of linear function approximation. this implementation is known as the true online td algorithm because it is truer to the ideal of the online algorithm than the td algorithm is. the derivation of true online td is a little too complex to present here the next section and the appendix to the paper by van seijen et al. but its strategy is simple. the sequence of weight vectors produced by the online algorithm can be arranged in a triangle wt wt wt wt wt t off-line algorithmfrom section rms errorat the end of the episodeover the algorithm true online td chapter eligibility traces t are really needed. the first t is the output and each weight vector along the way wt it turns out that only the one row of this triangle is produced on each time step. weight vectors on the diagonal the wt is the input the last wt t plays a role in bootstrapping in the n-step returns of the updates. in the final algorithm the diagonal weight vectors are renamed without a superscript wt t. the strategy then is to find a compact efficient way of computing each wt t from the one before. if this is done for the linear case in which vsw then we arrive at the true online td algorithm wt xst t is defined as in td and zt where we have used the shorthand xt is defined by wt t zt xt xt zt xt. zt this algorithm has been proven to produce exactly the same sequence of weight vectors wt t t as the online algorithm seijen et al. thus the results on the random walk task on the left of figure are also its results on that task. now however the algorithm is much less expensive. the memory requirements of true online td are identical to those of conventional td while the per-step computation is increased by about is one more inner product in the eligibility-trace update. overall the per-step computational complexity remains of od the same as td pseudocode for the complete algorithm is given in the box. true online td for estimating v input the policy to be evaluated input a feature function x s rd such that xterminal algorithm parameters step size trace decay rate initialize value-function weights w rd w loop for each episode d-dimensional vector temporary scalar variable initialize state and obtain initial feature vector x z vold loop for each step of episode choose a take action a observe r vector of the next state v v r v v z z x w w v voldz voldx vold v x until arrival at a terminal state dutch traces in monte carlo learning the eligibility trace used in true online td is called a dutch trace to distinguish it from the trace used in td which is called an accumulating trace. earlier work often used a third kind of trace called the replacing trace defined only for the tabular case or for binary feature vectors such as those produced by tile coding. the replacing trace is defined on a component-by-component basis depending on whether the component of the feature vector was or zit zit if xit otherwise. nowadays use of the replacing trace is deprecated a dutch trace should almost always be used instead. dutch traces in monte carlo learning although eligibility traces are closely associated historically with td learning in fact they have nothing to do with it. in fact eligibility traces arise even in monte carlo learning as we show in this section. we show that the linear mc algorithm taken as a forward view can be used to derive an equivalent yet computationally cheaper backward-view algorithm using dutch traces. this is the only equivalence of forwardand backward-views that we explicitly demonstrate in this book. it gives some of the flavor of the proof of equivalence of true online td and the online algorithm but is much simpler. the linear version of the gradient monte carlo prediction algorithm makes the following sequence of updates one for each time step of the episode wt xt t t. to make the example simpler we assume here that the return g is a single reward received at the end of the episode is why g is not subscripted by time and that there is no discounting. in this case the update is also known as the least mean square rule. as a monte carlo algorithm all the updates depend on the final rewardreturn so none can be made until the end of the episode. the mc algorithm is an off-line algorithm and we do not seek to improve this aspect of it. rather we seek merely an implementation of this algorithm with computational advantages. we will still update the weight vector only at the end of the episode but we will do some computation during each step of the episode and less at its end. this will give a more equal distribution of computation od per step and also remove the need to store the feature vectors at each step for use later at the end of each episode. instead we will introduce an additional vector memory the eligibility trace keeping in it a summary of all the feature vectors seen so far. this will be sufficient to efficiently recreate exactly the same overall update chapter eligibility traces as the sequence of mc updates by the end of the episode wt wt xt wt xt gxt xt wt gxt i ft gxt where ft is a forgetting or fading matrix. now recursing ft gxt gxt ft g xt ft gxt g xt ft g ft xt ft ft at at gzt g t zt where at and zt are the values at time t of two auxilary memory vectors that can be updated incrementally without knowledge of g and with od complexity per time step. the zt vector is in fact a dutch-style eligibility trace. it is initialized to and then updated according to ftft t t which is the dutch trace for the case of eq. the at auxilary vector is initialized to and then updated according to at ftft ftat at at t t. zt t t ftft xt ft ft xt ftzt xt zt xt zt zt xt zt xt xt zt xt sarsa the auxiliary vectors at and zt are updated on each time step t t and then at time t when g is observed they are used in to compute wt in this way we achieve exactly the same final result as the mclms algorithm that has poor computational properties but now with an incremental algorithm whose time and memory complexity per step is od. this is surprising and intriguing because the notion of an eligibility trace the dutch trace in particular has arisen in a setting without temporal-difference learning contrast to van seijen and sutton it seems eligibility traces are not specific to td learning at all they are more fundamental than that. the need for eligibility traces seems to arise whenever one tries to learn long-term predictions in an efficient manner. sarsa very few changes in the ideas already presented in this chapter are required in order to extend eligibility-traces to action-value methods. to learn approximate action values qs a w rather than approximate state values vsw we need to use the action-value form of the n-step return from chapter gttn n n qstn atn wtn gt if t n t using this we can form the action-value form of the with gttn truncated which is otherwise identical to the state-value form the action-value form of the off-line algorithm simply uses q rather than v t n t wt t qst qst at wt t t g where g t the compound backup diagram for this forward view is shown in t figure notice the similarity to the diagram of the td algorithm the first update looks ahead one full step to the next state action pair the second looks ahead two steps to the second state action pair and so on. a final update is based on the complete return. the weighting of each n-step update in the is just as in td and the algorithm the temporal-difference method for action values known as sarsa approximates this forward view. it has the same update rule as given earlier for td wt t zt except naturally using the action-value form of the td error t wt qst at wt and the action-value form of the eligibility trace z zt qst at wt zt t t chapter eligibility traces figure sarsa s backup diagram. compare with figure alternatively the replacing trace given by complete pseudocode for sarsa with linear function approximation binary features and either accumulating or replacing traces is given in the box on the next page. this pseudocode highlights a few optimizations possible in the special case of binary features are either active or inactive example traces in gridworld the use of eligibility traces can substantially increase the efficiency of control algorithms over one-step methods and even over n-step methods. the reason for this is illustrated by the gridworld example below. the first panel shows the path taken by an agent in a single episode. the initial estimated values were zero and all rewards were zero except for a positive reward at the goal location marked by g. the arrows in the other panels show for various algorithms which action-values would be increased and by how much upon reaching the goal. a one-step method would increment only the last action value whereas an n-step method would equally increment the last n actions values and an eligibility trace method would update all the action values up to the beginning of the episode to different degrees fading with recency. the fading strategy is often the best. takenaction values increasedby one-step sarsaaction values increasedby sarsa with takenaction values increasedby one-step sarsaaction values increasedby sarsa! with sarsagggpath takenaction values increasedby one-step sarsaaction values increased by sarsaggg sarsa sarsa with binary features and linear function approximation for estimating q or q input a function fs a returning the set of of active features for s a input a policy estimating q algorithm parameters step size trace decay rate initialize w rd w z rd loop for each episode initialize s choose a or according to qs w z loop for each step of episode take action a observe r r loop for i in fs a wi zi zi or zi w w z go to next episode if is terminal then choose or near greedily w loop for i in wi w w z z z s a traces traces exercise modify the pseudocode for sarsa to use dutch traces without the other features of a true online algorithm. assume linear function approximation and binary features. example sarsa on mountain car figure shows results with sarsa on the mountain car task introduced in example the function approximation action selection and environmental details were exactly as in chapter and thus it is appropriate to numerically compare these results with the chapter results for n-step sarsa side of the figure. the earlier results varied the update length n whereas here for sarsa we vary the trace parameter which plays a similar role. the fading-trace bootstrapping strategy of sarsa appears to result in more efficient learning on this problem. there is also an action-value version of our ideal td method the online algorithm presented in section everything in that section goes through without change other than to use the action-value form of the n-step return given at the beginning of this section. in the case of linear function approximation the ideal algorithm again has an exact efficient od implementation called true online sarsa the analyses chapter eligibility traces figure early performance on the mountain car task of sarsa with replacing traces and n-step sarsa from figure as a function of the step size in sections and carry through without change other than to use state action feature vectors xt xst at instead of state feature vectors xt xst. the pseudocode for this algorithm is given in the box on the next page. figure compares the performance of various versions of sarsa on the mountain car example. figure summary comparison of sarsa algorithms on the mountain car task. true online sarsa performed better than regular sarsa with both accumulating and replacing traces. also included is a version of sarsa with replacing traces in which on each time step the traces for the state and the actions not selected were set to zero. carsteps per episodeaveraged overfirst episodesand number of tilings number of tilings sarsa with replacing tracesn-step sarsa sizerms error td accumulating traces task sizerms error td replacing traces task sizerms error true online td task sizerms error td accumulating traces task sizerms error td replacing traces task sizerms error true online td task matchinganintuitivelyclearforwardviewevenintheonlinecase sarsa replacing clearingsarsa replacing no clearingsarsa accumulatingtrue online sarsa technologyfuturesandthenationalscienceandengineeringresearchcouncilofcanada.mountain carreward per episodeaveraged overfirst episodesand runs number of tilings true online sarsa with replacing tracessarsa with replacing tracesand clearing the traces of other actionssarsa with accumulating traces variable and true online sarsa for estimating q or q input a feature function x s a rd such that xterminal input a policy estimating q algorithm parameters step size trace decay rate initialize w rd w loop for each episode initialize s choose a or near greedily from s using w x xs a z qold loop for each step of episode take action a observe r choose or near greedily from using w q r q z z x w w q qoldz qoldx qold x a until is terminal variable and we are starting now to reach the end of our development of fundamental td learning algorithms. to present the final algorithms in their most general forms it is useful to generalize the degree of bootstrapping and discounting beyond constant parameters to functions potentially dependent on the state and action. that is each time step will have a different and denoted t and t. we change notation now so that s a is now a whole function from states and actions to the unit interval at and similarly s is a function from states to the such that t unit interval such that t introducing the function the termination function is particularly significant because it changes the return the fundamental random variable whose expectation we seek to chapter eligibility traces estimate. now the return is defined more generally as gt i where to assure the sums are finite we require kt k with probability one for all t. one convenient aspect of this definition is that it allows us to dispense with episodes start and terminal states and t as special cases and quantities. a terminal state just becomes a state at which and which transitions to the start state. in that way by choosing as a constant function we can recover the classical episodic setting as a special case. state dependent termination includes other prediction cases such as pseudo termination in which we seek to predict a quantity that becomes complete but does not alter the flow of the markov process. discounted returns themselves can be thought of as such a quantity and state dependent termination is a deep unification of the episodic and discounted-continuing cases. undiscounted-continuing case still needs some special treatment. the generalization to variable bootstrapping is not a change in the problem like discounting but a change in the solution strategy. the generalization affects the returns for states and actions. the new state-based can be written recursively as g s t s where now we have added the s to the superscript to remind us that this is a return that bootstraps from state values distinguishing it from returns that bootstrap from action values which we present below with a in the superscript. this equation says that the is the first reward undiscounted and unaffected by bootstrapping plus possibly a second term to the extent that we are not discounting at the next state is according to recall that this is zero if the next state is terminal. to the extent that we aren t terminating at the next state we have a second term which is itself divided into two cases depending on the degree of bootstrapping in the state. to the extent we are bootstrapping this term is the estimated value at the state whereas to the extent that we not bootstrapping the term is the for the next time step. the action-based is either the sarsa form or the expected sarsa form g a t g a t vts wt a a qs a wt. where is generalized to function approximation as off-policy eligibility traces with control variates exercise generalize the three recursive equations above to their truncated versions defining g s th and g a th. off-policy eligibility traces with control vari ates the final step is to incorporate importance sampling. unlike in the case of n-step methods for full non-truncated one does not have a practical option in which the importance sampling is done outside the target return. instead we move directly to the bootstrapping generalization of per-decision importance sampling with control variates in the state case our final definition of the generalizes after the model of to g s t s t vstwt where t batst is the usual single-step importance sampling ratio. much like the other returns we have seen in this book the truncated version of this return can be approximated simply in terms of sums of the state-based td error s t vstwt as g s t vstwt t s k i i i with the approximation becoming exact if the approximate value function does not change. exercise prove that becomes exact if the value function does not change. to save writing consider the case of t and use the notation vk exercise the truncated version of the general off-policy return is denoted g s th. guess the correct equation based on the above form of the is convenient to use in a forward-view update vskw. wt s wt s k t vstwt i i vstwt which to the experienced eye looks like an eligibility-based td update the product is like an eligibility trace and it is multiplied by td errors. but this is just one time step of a forward view. the relationship that we are looking for is that the forward-view update summed over time is approximately equal to a backward-view update summed chapter eligibility traces over time relationship is only approximate because again we ignore changes in the value function. the sum of the forward-view update over time is wt s k t s k vstwt i i i k i i i t vstwt s the summation rule t vstwt i i i kt tx which would be in the form of the sum of a backward-view td update if the entire expression from the second sum left could be written and updated incrementally as an eligibility trace which we now show can be done. that is we show that if this expression was the trace at time k then we could update it from its value at time k by zk k t vstwt t vstwt i i i i i i k vskwk k k k t vstwt k k k kzk zk i i i k vskwk which changing the index from k to t is the general accumulating trace update for state values zt t tzt this eligibility trace together with the usual semi-gradient parameter-update rule for td forms a general td algorithm that can be applied to either on-policy or off-policy data. in the on-policy case the algorithm is exactly td because t is alway and becomes the usual accumulating trace to variable and in the off-policy case the algorithm often works well but as a semi-gradient method is not guaranteed to be stable. in the next few sections we will consider extensions of it that do guarantee stability. a very similar series of steps can be followed to derive the off-policy eligibility traces for action-value methods and corresponding general sarsa algorithms. one could start with either recursive form for the general action-based or off-policy eligibility traces with control variates but the latter expected sarsa form works out to be simpler. we extend to the off-policy case after the model of to produce g a t a a where is as given by again the can be written approximately as the sum of td errors g a t qst at wt a k i i i using the expectation form of the action-based td error a t qst at wt. as before the approximation becomes exact if the approximate value function does not change. exercise prove that becomes exact if the value function does not change. to save writing consider the case of t and use the notation qk qsk ak w. hint start by writing out a exercise the truncated version of the general off-policy return is denoted g a th. guess the correct equation for it based on using steps entirely analogous to those for the state case one can write a forward-view update based on transform the sum of the updates using the summation rule and finally derive the following form for the eligibility trace for action values then g a and g a zt t t tzt qst at wt. this eligibility trace together with the expectation-based td error and the usual semi-gradient parameter-update rule forms an elegant efficient expected sarsa algorithm that can be applied to either on-policy or off-policy data. it is probably the best algorithm of this type at the current time of course it is not guaranteed to be stable until combined in some way with one of the methods presented in the following sections. in the on-policy case with constant and and the usual state-action td error the algorithm would be identical to the sarsa algorithm presented in section exercise show in detail the steps outlined above for deriving from start with the update substitute g a t then follow similar steps as led to at these algorithms become closely related to corresponding monte carlo algorithms. one might expect that an exact equivalence would hold for episodic problems and off-line updating but in fact the relationship is subtler and slightly weaker than that. under these most favorable conditions still there is not an episode by episode equivalence from for g t chapter eligibility traces of updates only of their expectations. this should not be surprising as these method make irrevocable updates as a trajectory unfolds whereas true monte carlo methods would make no update for a trajectory if any action within it has zero probability under the target policy. in particular all of these methods even at still bootstrap in the sense that their targets depend on the current value estimates it s just that the dependence cancels out in expected value. whether this is a good or bad property in practice is another question. recently methods have been proposed that do achieve an exact equivalence mahmood precup and van hasselt these methods require an additional vector of provisional weights that keep track of updates which have been made but may need to be retracted emphasized depending on the actions taken later. the state and state action versions of these methods are called ptd and pq respectively where the p stands for provisional. the practical consequences of all these new off-policy methods have not yet been established. undoubtedly issues of high variance will arise as they do in all off-policy methods using importance sampling if then all these off-policy algorithms involve bootstrapping and the deadly triad applies meaning that they can be guaranteed stable only for the tabular case for state aggregation and for other limited forms of function approximation. for linear and more-general forms of function approximation the parameter vector may diverge to infinity as in the examples in chapter as we discussed there the challenge of off-policy learning has two parts. off-policy eligibility traces deal effectively with the first part of the challenge correcting for the expected value of the targets but not at all with the second part of the challenge having to do with the distribution of updates. algorithmic strategies for meeting the second part of the challenge of off-policy learning with eligibility traces are summarized in section exercise what are the dutch-trace and replacing-trace versions of off-policy bility traces for state-value and action-value methods? watkins s q to tree-backup several methods have been proposed over the years to extend q-learning to eligibility traces. the original is watkins s q which decays its eligibility traces in the usual way as long as a greedy action was taken then cuts the traces to zero after the first non-greedy action. the backup diagram for watkins s q is shown in figure in chapter we unified q-learning and expected sarsa in the off-policy version of the latter which includes q-learning as a special case and generalizes it to arbitrary target policies and in the previous section of this chapter we completed our treatment of expected sarsa by generalizing it to off-policy eligibility traces. in chapter however we distinguished n-step expected sarsa from n-step tree backup where the latter retained the property of not using importance sampling. it remains then to present the eligibility trace version of tree backup which we well call tree-backup or tb for short. this is arguably the true successor to q-learning because it retains its appealing absence of importance sampling even though it can be applied to off-policy data. watkins s q to tree-backup figure the backup diagram for watkins s q the series of component updates ends either with the end of the episode or with the first nongreedy action whichever comes first. the concept of tb is straightforward. as shown in its backup diagram in figure the tree-backup updates of each length section are weighted in the usual way dependent on the bootstrapping parameter to get the detailed equations with the right indices on the general bootstrapping and discounting parameters it is best to start with a recursive form for the using action values and then expand the bootstrapping case of the target after the model of as per the usual pattern it can also be written approximately changes in the approximate value function as a sum of td errors g a t qst at wt a k i i using the expectation form of the action-based td error following the same steps as in the previous section we arrive at a special eligibility trace update involving the target-policy probabilities of the selected actions zt t t qst at wt. g a t a a wt a sq chapter eligibility traces figure the backup diagram for the version of the tree backup algorithm. this together with the usual parameter-update rule defines the tb algorithm. like all semi-gradient algorithms tb is not guaranteed to be stable when used with off-policy data and with a powerful function approximator. to obtain those assurances tb would have to be combined with one of the methods presented in the next section. exercise how might double expected sarsa be extended to eligibility traces? stable off-policy methods with traces several methods using eligibility traces have been proposed that achieve guarantees of stability under off-policy training and here we present four of the most important using this book s standard notation including general bootstrapping and discounting functions. all are based on either the gradient-td or the emphatic-td ideas presented in sections and all the algorithms assume linear function approximation though extensions to nonlinear function approximation can also be found in the literature. gtd is the eligibility-trace algorithm analogous to tdc the better of the two state-value gradient-td prediction algorithms discussed in section its goal is to xs v even from data that is due learn a parameter wt such that vsw to following another policy b. its update is wt s t zt stable off-policy methods with traces with s t zt and t defined in the usual ways for state values and vt s t zt xt where as in section v rd is a vector of the same dimension as w initialized to and is a second step-size parameter. gq is the gradient-td algorithm for action values with eligibility traces. its goal xs a q a from off-policy is to learn a parameter wt such that qs a wt data. if the target policy is or otherwise biased toward the greedy policy for q then gq can be used as a control algorithm. its update is wt a t zt where xt is the average feature vector for st under the target policy xt a a t is the expectation form of the td error which can be written a t xt zt is defined in the usual way for action values and the rest is as in gtd including the update for vt htd is a hybrid state-value algorithm combining aspects of gtd and td its most appealing feature is that it is a strict generalization of td to off-policy learning meaning that if the behavior policy happens to be the same as the target policy then htd becomes the same as td which is not true for gtd this is appealing because td is often faster than gtd when both algorithms converge and td requires setting only a single step size. htd is defined by zt zb t wt s vt s t zt zb t zt t tzt t tzb with zb t xt t with z with in addition to the second set of where again is a second step-size parameter. weights vt htd also has a second set of eligibility traces zb t. these are conventional accumulating eligibility traces for the behavior policy and become equal to zt if all the t are which causes the last term in the wt update to be zero and the overall update to reduce to td emphatic td is the extension of the one-step emphatic-td algorithm and to eligibility traces. the resultant algorithm retains strong off-policy convergence guarantees while enabling any degree of bootstrapping albeit at the cost of chapter eligibility traces high variance and potentially slow convergence. emphatic td is defined by t zt mt ft wt tzt xt t tzt t it tft t tft it with with z where mt is the general form of emphasis ft is termed the followon trace and it is the interest as described in section note that mt like t is not really an additional memory variable. it can be removed from the algorithm by substituting its definition into the eligibility-trace equation. pseudocode and software for the true online version of emphatic-td are available on the web in the on-policy case t for all t emphatic-td is similar to conventional td but still significantly different. in fact whereas emphatic-td is guaranteed to converge for all state-dependent functions td is not. td is guaranteed convergent only for all constant see yu s counterexample rafiee and sutton implementation issues it might at first appear that tabular methods using eligibility traces are much more complex than one-step methods. a naive implementation would require every state state action pair to update both its value estimate and its eligibility trace on every time step. this would not be a problem for implementations on single-instruction multipledata parallel computers or in plausible neural implementations but it is a problem for implementations on conventional serial computers. fortunately for typical values of and the eligibility traces of almost all states are almost always nearly zero only those states that have recently been visited will have traces significantly greater than zero and only these few states need to be updated to closely approximate these algorithms. in practice then implementations on conventional computers may keep track of and update only the few traces that are significantly greater than zero. using this trick the computational expense of using traces in tabular methods is typically just a few times that of a one-step method. the exact multiple of course depends on and and on the expense of the other computations. note that the tabular case is in some sense the worst case for the computational complexity of eligibility traces. when function approximation is used the computational advantages of not using traces generally decrease. for example if artificial neural networks and backpropagation are used then eligibility traces generally cause only a doubling of the required memory and computation per step. truncated methods can be computationally efficient on conventional computers though they always require some additional memory. conclusions conclusions eligibility traces in conjunction with td errors provide an efficient incremental way of shifting and choosing between monte carlo and td methods. the atomic n-step methods of chapter also enabled this but eligibility trace methods are more general often faster to learn and offer different computational complexity tradeoffs. this chapter has offered an introduction to the elegant emerging theoretical understanding of eligibility traces for on- and off-policy learning and for variable bootstrapping and discounting. one aspect of this elegant theory is true online methods which exactly reproduce the behavior of expensive ideal methods while retaining the computational congeniality of conventional td methods. another aspect is the possibility of derivations that automatically convert from intuitive forward-view methods to more efficient incremental backward-view algorithms. we illustrated this general idea in a derivation that started with a classical expensive monte carlo algorithm and ended with a cheap incremental non-td implementation using the same novel eligibility trace used in true online td methods. as we mentioned in chapter monte carlo methods may have advantages in nonmarkov tasks because they do not bootstrap. because eligibility traces make td methods more like monte carlo methods they also can have advantages in these cases. if one wants to use td methods because of their other advantages but the task is at least partially non-markov then the use of an eligibility trace method is indicated. eligibility traces are the first line of defense against both long-delayed rewards and non-markov tasks. by adjusting we can place eligibility trace methods anywhere along a continuum from monte carlo to one-step td methods. where shall we place them? we do not yet have a good theoretical answer to this question but a clear empirical answer appears to be emerging. on tasks with many steps per episode or many steps within the half-life of discounting it appears significantly better to use eligibility traces than not to see figure on the other hand if the traces are so long as to produce a pure monte carlo method or nearly so then performance degrades sharply. an intermediate mixture appears to be the best choice. eligibility traces should be used to bring us toward monte carlo methods but not all the way there. in the future it may be possible to more finely vary the trade-off between td and monte carlo methods by using variable but at present it is not clear how this can be done reliably and usefully. methods using eligibility traces require more computation than one-step methods but in return they offer significantly faster learning particularly when rewards are delayed by many steps. thus it often makes sense to use eligibility traces when data are scarce and cannot be repeatedly processed as is often the case in online applications. on the other hand in off-line applications in which data can be generated cheaply perhaps from an inexpensive simulation then it often does not pay to use eligibility traces. in these cases the objective is not to get more out of a limited amount of data but simply to process as much data as possible as quickly as possible. in these cases the speedup per datum due to traces is typically not worth their computational cost and one-step methods are favored. chapter eligibility traces figure the effect of on reinforcement learning performance in four different test problems. in all cases performance is generally best lower number in the graph at an intermediate value of the two left panels are applications to simple continuous-state control tasks using the sarsa algorithm and tile coding with either replacing or accumulating traces the upper-right panel is for policy evaluation on a random walk task using td and sutton the lower right panel is unpublished data for the polebalancing task from an earlier study accumulatingtraces and steps worldreplacingtracesaccumulatingtraces replacingtracesaccumulatingtracesrms error conclusions bibliographical and historical remarks eligibility traces came into reinforcement learning via the fecund ideas of klopf our use of eligibility traces is based on klopf s work barto and sutton sutton and barto barto sutton and anderson sutton we may have been the first to use the term eligibility trace and barto the idea that stimuli produce after effects in the nervous system that are important for learning is very old chapter some of the earliest uses of eligibility traces were in the actor critic methods discussed in chapter sutton and anderson sutton compound updates were called complex backups in the first edition of this book. the and its error-reduction properties were introduced by watkins and further developed by jaakkola jordan and singh the random walk results in this and subsequent sections are new to this text as are the terms forward view and backward view. the notion of a algorithm was introduced in the first edition of this text. the more refined treatment presented here was developed in conjunction with harm van seijen van seijen and sutton td with accumulating traces was introduced by sutton convergence in the mean was proved by dayan and with probability by many researchers including peng dayan and sejnowski tsitsiklis and gurvits lin and hanson the bound on the error of the asymptotic solution of linear td is due to tsitsiklis and van roy truncated td methods were developed by cichosz and van seijen true online td and the other ideas presented in these sections are primarily due to work of van seijen seijen and sutton van seijen et al. replacing traces are due to singh and sutton the material in this section is from van hasselt and sutton sarsa with accumulating traces was first explored as a control method by rummery and niranjan rummery true online sarsa was introduced by van seijen and sutton the algorithm on page was adapted from van seijen et al. the mountain car results were made for this text except for figure which is adapted from van seijen and sutton perhaps the first published discussion of variable was by watkins who pointed out that the cutting off of the update sequence in his q when a nongreedy action was selected could be implemented by temporarily setting to chapter eligibility traces variable was introduced in the first edition of this text. the roots of variable are in the work on options precup and singh and its precursors becoming explicit in the gq paper and sutton which also introduced some of these recursive forms for the a different notion of variable has been developed by yu off-policy eligibility traces were introduced by precup et al. then further developed by bertsekas and yu maei maei and sutton yu and by sutton mahmood precup and van hasselt the last reference in particular gives a powerful forward view for off-policy td methods with general state-dependent and the presentation here seems to be new. this section ends with an elegant expected sarsa algorithm. although it is a natural algorithm to our knowledge it has not previously been described or tested in the literature. watkins s q is due to watkins the tabular episodic off-line version has been proven convergent by munos stepleton harutyunyan and bellemare alternative q algorithms were proposed by peng and williams and by sutton mahmood precup and van hasselt tree backup is due to precup sutton and singh gtd is due to maei gq is due to maei and sutton htd is due to white and white based on the one-step htd algorithm introduced by hackman the latest developments in the theory of gradient-td methods are by yu emphatic td was introduced by sutton mahmood and white who proved its stability. yu proved its convergence and the algorithm was developed further by hallak et al. chapter policy gradient methods in this chapter we consider something new. so far in this book almost all the methods have been action-value methods they learned the values of actions and then selected actions based on their estimated action their policies would not even exist without the action-value estimates. in this chapter we consider methods that instead learn a parameterized policy that can select actions without consulting a value function. a value function may still be used to learn the policy parameter but is not required for action selection. we use the notation for the policy s parameter vector. thus we write prat a st s t for the probability that action a is taken at time t given that the environment is in state s at time t with parameter if a method uses a learned value function as well then the value function s weight vector is denoted w rd as usual as in vsw. in this chapter we consider methods for learning the policy parameter based on the gradient of some performance measure j with respect to the policy parameter. these methods seek to maximize performance so their updates approximate gradient ascent in j t j t where j t is a stochastic estimate whose expectation approximates the gradient of the performance measure with respect to its argument t. all methods that follow this general schema we call policy gradient methods whether or not they also learn an approximate value function. methods that learn approximations to both policy and value functions are often called actor critic methods where actor is a reference to the learned policy and critic refers to the learned value function usually a state-value function. first we treat the episodic case in which performance is defined as the value of the start state under the parameterized policy before going on to consider the continuing case in which performance is defined as the average reward rate as in section in the end lone exception is the gradient bandit algorithms of section in fact that section goes through many of the same steps in the single-state bandit case as we go through here for full mdps. reviewing that section would be good preparation for fully understanding this chapter. chapter policy gradient methods we are able to express the algorithms for both cases in very similar terms. policy approximation and its advantages in policy gradient methods the policy can be parameterized in any way as long as is differentiable with respect to its parameters that is as long as column vector of partial derivatives of with respect to the components of exists and is finite for all s s a as and in practice to ensure exploration we generally require that the policy never becomes deterministic that for all s a in this section we introduce the most common parameterization for discrete action spaces and point out the advantages it offers over action-value methods. policy-based methods also offer useful ways of dealing with continuous action spaces as we describe later in section if the action space is discrete and not too large then a natural and common kind of parameterization is to form parameterized numerical preferences hs a r for each state action pair. the actions with the highest preferences in each state are given the highest probabilities of being selected for example according to an exponential soft-max distribution ehsa ehsb where e is the base of the natural logarithm. note that the denominator here is just what is required so that the action probabilities in each state sum to one. we call this kind of policy parameterization soft-max in action preferences. the action preferences themselves can be parameterized arbitrarily. for example they might be computed by a deep neural network where is the vector of all the connection weights of the network in the alphago system described in section or the preferences could simply be linear in features hs a a using feature vectors xs a constructed by any of the methods described in chapter one advantage of parameterizing policies according to the soft-max in action preferences is that the approximate policy can approach a deterministic policy whereas with action selection over action values there is always an probability of selecting a random action. of course one could select according to a soft-max distribution based on action values but this alone would not allow the policy to approach a deterministic policy. instead the action-value estimates would converge to their corresponding true values which would differ by a finite amount translating to specific probabilities other than and if the soft-max distribution included a temperature parameter then the temperature could be reduced over time to approach determinism but in practice it would be difficult to choose the reduction schedule or even the initial temperature without more prior knowledge of the true action values than we would like to assume. policy approximation and its advantages action preferences are different because they do not approach specific values instead they are driven to produce the optimal stochastic policy. if the optimal policy is deterministic then the preferences of the optimal actions will be driven infinitely higher than all suboptimal actions permitted by the parameterization. a second advantage of parameterizing policies according to the soft-max in action preferences is that it enables the selection of actions with arbitrary probabilities. in problems with significant function approximation the best approximate policy may be stochastic. for example in card games with imperfect information the optimal play is often to do two different things with specific probabilities such as when bluffing in poker. action-value methods have no natural way of finding stochastic optimal policies whereas policy approximating methods can as shown in example example short corridor with switched actions consider the small corridor gridworld shown inset in the graph below. the reward is per step as usual. in each of the three nonterminal states there are only two actions right and left. these actions have their usual consequences in the first and third states causes no movement in the first state but in the second state they are reversed so that right moves to the left and left moves to the right. the problem is difficult because all the states appear identical under the function approximation. in particular we define xs right and xs left for all s. an action-value method with action selection is forced to choose between just two policies choosing right with high probability on all steps or choosing left with the same high probability on all time steps. if then these two policies achieve a value the start state of less than and respectively as shown in the graph. a method can do significantly better if it can learn a specific probability with which to select right. the best probability is about which achieves a value of about probability of right left right optimalstochasticpolicy j chapter policy gradient methods perhaps the simplest advantage that policy parameterization may have over actionvalue parameterization is that the policy may be a simpler function to approximate. problems vary in the complexity of their policies and action-value functions. for some the action-value function is simpler and thus easier to approximate. for others the policy is simpler. in the latter case a policy-based method will typically learn faster and yield a superior asymptotic policy seems to be the case with tetris see s im sek alg orta and kothiyal finally we note that the choice of policy parameterization is sometimes a good way of injecting prior knowledge about the desired form of the policy into the reinforcement learning system. this is often the most important reason for using a policy-based learning method. exercise use your knowledge of the gridworld and its dynamics to determine an exact symbolic expression for the optimal probability of selecting the right action in example the policy gradient theorem in addition to the practical advantages of policy parameterization over action selection there is also an important theoretical advantage. with continuous policy parameterization the action probabilities change smoothly as a function of the learned parameter whereas in selection the action probabilities may change dramatically for an arbitrarily small change in the estimated action values if that change results in a different action having the maximal value. largely because of this stronger convergence guarantees are available for policy-gradient methods than for action-value methods. in particular it is the continuity of the policy dependence on the parameters that enables policy-gradient methods to approximate gradient ascent the episodic and continuing cases define the performance measure j differently and thus have to be treated separately to some extent. nevertheless we will try to present both cases uniformly and we develop a notation so that the major theoretical results can be described with a single set of equations. in this section we treat the episodic case for which we define the performance measure as the value of the start state of the episode. we can simplify the notation without losing any meaningful generality by assuming that every episode starts in some particular state then in the episodic case we define performance as j v where v is the true value function for the policy determined by from here on in our discussion we will assume no discounting for the episodic case although for completeness we do include the possibility of discounting in the boxed algorithms. with function approximation it may seem challenging to change the policy parameter in a way that ensures improvement. the problem is that performance depends on both the action selections and the distribution of states in which those selections are made and that both of these are affected by the policy parameter. given a state the effect of the policy gradient theorem proof of the policy gradient theorem case with just elementary calculus and re-arranging of terms we can prove the policy gradient theorem from first principles. to keep the notation simple we leave it implicit in all cases that is a function of and all gradients are also implicitly with respect to first note that the gradient of the state-value function can be written in terms of the action-value function as v for all s s a q rule of calculus a a a rs v a v a and equation prs x k a s v after repeated unrolling where prs x k is the probability of transitioning from state s to state x in k steps under policy it is then immediate that j v a a s k a a a page chapter policy gradient methods the policy parameter on the actions and thus on reward can be computed in a relatively straightforward way from knowledge of the parameterization. but the effect of the policy on the state distribution is a function of the environment and is typically unknown. how can we estimate the performance gradient with respect to the policy parameter when the gradient depends on the unknown effect of policy changes on the state distribution? fortunately there is an excellent theoretical answer to this challenge in the form of the policy gradient theorem which provides an analytic expression for the gradient of performance with respect to the policy parameter is what we need to approximate for gradient ascent that does not involve the derivative of the state distribution. the policy gradient theorem for the episodic case establishes that j q a where the gradients are column vectors of partial derivatives with respect to the components of and denotes the policy corresponding to parameter vector the symbol here means proportional to in the episodic case the constant of proportionality is the average length of an episode and in the continuing case it is so that the relationship is actually an equality. the distribution here in chapters and is the on-policy distribution under page the policy gradient theorem is proved for the episodic case in the box on the previous page. reinforce monte carlo policy gradient we are now ready for our first policy-gradient learning algorithm. recall our overall strategy of stochastic gradient ascent which requires a way to obtain samples such that the expectation of the sample gradient is proportional to the actual gradient of the performance measure as a function of the parameter. the sample gradients need only be proportional to the gradient because any constant of proportionality can be absorbed into the step size which is otherwise arbitrary. the policy gradient theorem gives an exact expression proportional to the gradient all that is needed is some way of sampling whose expectation equals or approximates this expression. notice that the right-hand side of the policy gradient theorem is a sum over states weighted by how often the states occur under the target policy if is followed then states will be encountered in these proportions. thus q a j q a e this is good progress and we would like to carry it further and handle the action in the same way replacing a with the sample action at. the remaining part of the expectation above is a sum over actions if only each term were weighted by the probability of selecting the actions that is according to then the replacement could be done. we reinforce monte carlo policy gradient can arrange for this by multiplying and dividing by this probability. continuing from the previous equation this gives j e a e at e a by the sample at e at q at where gt is the return as usual. the final expression in the brackets is exactly what is needed a quantity that can be sampled on each time step whose expectation is equal to the gradient. using this sample to instantiate our generic stochastic gradient ascent algorithm yields the update t gt t t we call this algorithm reinforce williams its update has an intuitive appeal. each increment is proportional to the product of a return gt and a vector the gradient of the probability of taking the action actually taken divided by the probability of taking that action. the vector is the direction in parameter space that most increases the probability of repeating the action at on future visits to state st. the update increases the parameter vector in this direction proportional to the return and inversely proportional to the action probability. the former makes sense because it causes the parameter to move most in the directions that favor actions that yield the highest return. the latter makes sense because otherwise actions that are selected frequently are at an advantage updates will be more often in their direction and might win out even if they do not yield the highest return. note that reinforce uses the complete return from time t which includes all future rewards up until the end of the episode. in this sense reinforce is a monte carlo algorithm and is well defined only for the episodic case with all updates made in retrospect after the episode is completed the monte carlo algorithms in chapter this is shown explicitly in the boxed on the next page. notice that the update in the last line of pseudocode appears rather different from the reinforce update rule one difference is that the pseudocode uses the compact expression ln t for the fractional vector t in that these t two expressions for the vector are equivalent follows from the identity ln x x x this vector has been given several names and notations in the literature we will refer to it simply as the eligibility vector. note that it is the only place that the policy parameterization appears in the algorithm. chapter policy gradient methods reinforce monte-carlo policy-gradient control for input a differentiable policy parameterization algorithm parameter step size initialize policy parameter to loop forever each episode generate an episode st at rt following loop for each step of the episode t t g rk t g ln the second difference between the pseudocode update and the reinforce update equation is that the former includes a factor of t. this is because as mentioned earlier in the text we are treating the non-discounted case while in the boxed algorithms we are giving the algorithms for the general discounted case. all of the ideas go through in the discounted case with appropriate adjustments to the box on page but involve additional complexity that distracts from the main ideas. exercise generalize the box on page the policy gradient theorem the proof of the policy gradient theorem and the steps leading to the reinforce update equation so that ends up with a factor of t and thus aligns with the general algorithm given in the pseudocode. figure shows the performance of reinforce averaged over runs on the short-corridor gridworld from example figure reinforce on the short-corridor gridworld with a good step size the total reward per episode approaches the optimal value of the start state. rewardon reinforce with baseline as a stochastic gradient method reinforce has good theoretical convergence properties. by construction the expected update over an episode is in the same direction as the performance gradient. this assures an improvement in expected performance for sufficiently small and convergence to a local optimum under standard stochastic approximation conditions for decreasing however as a monte carlo method reinforce may be of high variance and thus produce slow learning. exercise in section we considered policy parameterizations using the soft-max in action preferences with linear action preferences for this parameterization prove that the eligibility vector is ln xs a b using the definitions and elementary calculus. reinforce with baseline the policy gradient theorem can be generalized to include a comparison of the action value to an arbitrary baseline bs j a the baseline can be any function even a random variable as long as it does not vary with a the equation remains valid because the subtracted quantity is zero bs bs bs the policy gradient theorem with baseline can be used to derive an update rule using similar steps as in the previous section. the update rule that we end up with is a new version of reinforce that includes a general baseline t t t because the baseline could be uniformly zero this update is a strict generalization of reinforce. in general the baseline leaves the expected value of the update unchanged but it can have a large effect on its variance. for example we saw in section that an analogous baseline can significantly reduce the variance thus speed the learning of gradient bandit algorithms. in the bandit algorithms the baseline was just a number average of the rewards seen so far but for mdps the baseline should vary with state. in some states all actions have high values and we need a high baseline to differentiate the higher valued actions from the less highly valued ones in other states all actions will have low values and a low baseline is appropriate. one natural choice for the baseline is an estimate of the state value vstw where w rm is a weight vector learned by one of the methods presented in previous chapters. chapter policy gradient methods because reinforce is a monte carlo method for learning the policy parameter it seems natural to also use a monte carlo method to learn the state-value weights w. a complete pseudocode algorithm for reinforce with baseline using such a learned state-value function as the baseline is given in the box below. reinforce with baseline for estimating input a differentiable policy parameterization input a differentiable state-value function parameterization vsw algorithm parameters step sizes w initialize policy parameter and state-value weights w rd to loop forever each episode generate an episode st at rt following loop for each step of the episode t t g rk g vstw w w w t vstw t ln this algorithm has two step sizes denoted and w is the in choosing the step size for values w is relatively easy in the linear case we have rules of thumb for setting it such as w much less clear how to set the step size for the policy parameters whose best value depends on the range of variation of the rewards and on the policy parameterization. section it is figure adding a baseline to reinforce can make it learn much faster as illustrated here on the short-corridor gridworld the step size used here for plain reinforce is that at which it performs best the nearest power of two see figure each line is an average over independent runs. with baseline rewardon actor critic methods figure compares the behavior of reinforce with and without a baseline on the short-corridor gridword here the approximate state-value function used in the baseline is vsw w. that is w is a single component w. actor critic methods although the reinforce-with-baseline method learns both a policy and a state-value function we do not consider it to be an actor critic method because its state-value function is used only as a baseline not as a critic. that is it is not used for bootstrapping the value estimate for a state from the estimated values of subsequent states but only as a baseline for the state whose estimate is being updated. this is a useful distinction for only through bootstrapping do we introduce bias and an asymptotic dependence on the quality of the function approximation. as we have seen the bias introduced through bootstrapping and reliance on the state representation is often beneficial because it reduces variance and accelerates learning. reinforce with baseline is unbiased and will converge asymptotically to a local minimum but like all monte carlo methods it tends to learn slowly estimates of high variance and to be inconvenient to implement online or for continuing problems. as we have seen earlier in this book with temporal-difference methods we can eliminate these inconveniences and through multi-step methods we can flexibly choose the degree of bootstrapping. in order to gain these advantages in the case of policy gradient methods we use actor critic methods with a bootstrapping critic. first consider one-step actor critic methods the analog of the td methods introduced in chapter such as and q-learning. the main appeal of one-step methods is that they are fully online and incremental yet avoid the complexities of eligibility traces. they are a special case of the eligibility trace methods and not as general but easier to understand. one-step actor critic methods replace the full return of reinforce with the one-step return use a learned state-value function as the baseline as follows t t t t t t t t t t the natural state-value-function learning method to pair with this is semi-gradient pseudocode for the complete algorithm is given in the box on the next page. note that it is now a fully online incremental algorithm with states actions and rewards processed as they occur and then never revisited. chapter policy gradient methods one-step actor critic for estimating input a differentiable policy parameterization input a differentiable state-value function parameterization vsw parameters step sizes w initialize policy parameter and state-value weights w rd to loop forever each episode initialize s state of episode i loop while s is not terminal each time step a take action a observe r r vsw w w w i vsw i ln i i s is terminal then the generalizations to the forward view of n-step methods and then to a algorithm are straightforward. the one-step return in is merely replaced by gttn or g t respectively. the backward view of the algorithm is also straightforward using separate eligibility traces for the actor and critic each after the patterns in chapter pseudocode for the complete algorithm is given in the box below. actor critic with eligibility traces for estimating input a differentiable policy parameterization input a differentiable state-value function parameterization vsw parameters trace-decay rates w step sizes w initialize policy parameter and state-value weights w rd to loop forever each episode initialize s state of episode z eligibility trace vector zw eligibility trace vector i loop while s is not terminal each time step is terminal then a take action a observe r r vsw zw wzw i vsw z z i ln w w w zw z i i s policy gradient for continuing problems policy gradient for continuing problems as discussed in section for continuing problems without episode boundaries we need to define performance in terms of the average rate of reward per time step j r ert lim h lim t h ert rs ar limt prst where is the steady-state distribution under which is assumed to exist and to be independent of ergodicity assumption. remember that this is the special distribution under which if you select actions according to you remain in the same distribution a for all s. we also define values v respect to the differential return e s and q a e s at a with gt r r r with these alternate definitions the policy gradient theorem as given for the episodic case remains true for the continuing case. a proof is given in the box on the next page. the forward and backward view equations also remain the same. complete pseudocode for the actor critic algorithm in the continuing case view is given in the box on the page after next. chapter policy gradient methods proof of the policy gradient theorem case the proof of the policy gradient theorem for the continuing case begins similarly to the episodic case. again we leave it implicit in all cases that is a function of and that the gradients are with respect to recall that in the continuing case j r and that v and q denote values with respect to the differential return the gradient of the state-value function can be written for any s s as rule of calculus v for all s s a q a a r r a rs r v a v a v v after re-arranging terms we obtain notice that the left-hand side can be written j and that it does not depend on s. thus the right-hand side does not depend on s either and we can safely sum it over all s s weighted by without changing it a v v j a a v v a a v a. v a a v v q.e.d. policy parameterization for continuous actions actor critic with eligibility traces for estimating input a differentiable policy parameterization input a differentiable state-value function parameterization vsw algorithm parameters w w r initialize r r to initialize state-value weights w rd and policy parameter to initialize s s to zw eligibility trace vector z eligibility trace vector loop forever each time step a take action a observe r r r vsw r r r zw wzw vsw z z ln w w w zw z s policy parameterization for continuous actions policy-based methods offer practical ways of dealing with large actions spaces even continuous spaces with an infinite number of actions. instead of computing learned probabilities for each of the many actions we instead learn statistics of the probability distribution. for example the action set might be the real numbers with actions chosen from a normal distribution. the probability density function for the normal distribution is conventionally written px where and here are the mean and standard deviation of the normal distribution and of course here is just the number the probability density functions for several different means and standard deviations are shown in figure the value px is the density of the probability at x not the probability. it can be greater than it is the total area under px that must sum to in general one can take the integral under px for any range of x values to get the probability of x falling within that range. to produce a policy parameterization the policy can be defined as the normal probability density over a real-valued scalar action with mean and standard deviation given chapter policy gradient methods figure the probability density function of the normal distribution for different means and variances. by parametric function approximators that depend on the state. that is where s r and s r are two parameterized function approximators. to complete the example we need only give a form for these approximators. for this we divide the policy s parameter vector into two parts one part to be used for the approximation of the mean and one part for the approximation of the standard deviation. the mean can be approximated as a linear function. the standard deviation must always be positive and is better approximated as the exponential of a linear function. thus and where x and x are state feature vectors perhaps constructed by one of the methods described in chapter with these definitions all the algorithms described in the rest of this chapter can be applied to learn to select real-valued actions. exercise show that for the gaussian policy parameterization the eligibility vector has the following two parts ln ln and x exp exp summary exercise a bernoulli-logistic unit is a stochastic neuron-like unit used in some artificial neural networks its input at time t is a feature vector xst its output at is a random variable having two values and with prat pt and prat pt bernoulli distribution. let hs and hs be the preferences in state s for the unit s two actions given policy parameter assume that the difference between the action preferences is given by a weighted sum of the unit s input vector that is assume that hs hs where is the unit s weight vector. show that if the exponential soft-max distribution is used to convert action preferences to policies then pt t exp xst logistic function. what is the monte-carlo reinforce update of t to upon receipt of return gt? express the eligibility ln for a bernoulli-logistic unit in terms of a xs and by calculating the gradient. hint separately for each action compute the derivative of the logarithm first with respect to pt t combine the two results into one expression that depends on a and pt and then use the chain rule noting that the derivative of the logistic function f is f f summary prior to this chapter this book focused on action-value methods meaning methods that learn action values and then use them to determine action selections. in this chapter on the other hand we considered methods that learn a parameterized policy that enables actions to be taken without consulting action-value estimates. in particular we have considered policy-gradient methods meaning methods that update the policy parameter on each step in the direction of an estimate of the gradient of performance with respect to the policy parameter. methods that learn and store a policy parameter have many advantages. they can learn specific probabilities for taking the actions. they can learn appropriate levels of exploration and approach deterministic policies asymptotically. they can naturally handle continuous action spaces. all these things are easy for policy-based methods but awkward or impossible for methods and for action-value methods in general. in addition on some problems the policy is just simpler to represent parametrically than the value function these problems are more suited to parameterized policy methods. parameterized policy methods also have an important theoretical advantage over action-value methods in the form of the policy gradient theorem which gives an exact formula for how performance is affected by the policy parameter that does not involve derivatives of the state distribution. this theorem provides a theoretical foundation for all policy gradient methods. chapter policy gradient methods the reinforce method follows directly from the policy gradient theorem. adding a state-value function as a baseline reduces reinforce s variance without introducing bias. using the state-value function for bootstrapping introduces bias but is often desirable for the same reason that bootstrapping td methods are often superior to monte carlo methods reduced variance. the state-value function assigns credit to critizes the policy s action selections and accordingly the former is termed the critic and the latter the actor and these overall methods are termed actor critic methods. overall policy-gradient methods provide a significantly different set of strengths and weaknesses than action-value methods. today they are less well understood in some respects but a subject of excitement and ongoing research. bibliographical and historical remarks methods that we now see as related to policy gradients were actually some of the earliest to be studied in reinforcement learning barto sutton and anderson sutton williams and in predecessor fields and thathachar they were largely supplanted in the by the action-value methods that are the focus of the other chapters of this book. in recent years however attention has returned to actor critic methods and to policy-gradient methods in general. among the further developments beyond what we cover here are natural-gradient methods kakade peters vijayakumar and schaal peters and schall park kim and kang bhatnagar sutton ghavamzadeh and lee see grondman busoniu lopes and babuska and deterministic policy gradient et al. major applications include acrobatic helicopter autopilots and alphago section our presentation in this chapter is based primarily on that by sutton mcallester singh and mansour see also sutton singh and mcallester who introduced the term policy gradient methods. a useful overview is provided by bhatnagar et al. one of the earliest related works is by aleksandrov sysoyev and shemeneva thomas first realized that the factor of t as specified in the boxed algorithms of this chapter was needed in the case of discounted episodic problems. example and the results with it in this chapter were developed with eric graves. the policy gradient theorem here and on page was first obtained by marbach and tsitsiklis and then independently by sutton et al. a similar expression was obtained by cao and chen other early results are due to konda and tsitsiklis baxter and bartlett and baxter bartlett and weaver some additional results are developed by sutton singh and mcallester reinforce is due to williams the use of a power of the discount factor in the update in the boxed algorithms is due to thomas summary phansalkar and thathachar proved both local and global convergence theorems for modified versions of reinforce algorithms. the baseline was introduced in williams s original work. greensmith bartlett and baxter analyzed an arguably better baseline dick actor critic methods were among the earliest to be investigated in reinforcement learning barto sutton and anderson sutton the algorithms presented here and in section are based on the work of degris white and sutton who also introduced the study of off-policy policygradient methods. the first to show how continuous actions could be handled this way appears to have been williams figure is adapted from wikipedia. part iii looking deeper in this last part of the book we look beyond the standard reinforcement learning ideas presented in the first two parts of the book to briefly survey their relationships with psychology and neuroscience a sampling of reinforcement learning applications and some of the active frontiers for future reinforcement learning research. chapter psychology in previous chapters we developed ideas for algorithms based on computational considerations alone. in this chapter we look at some of these algorithms from another perspective the perspective of psychology and its study of how animals learn. the goals of this chapter are first to discuss ways that reinforcement learning ideas and algorithms correspond to what psychologists have discovered about animal learning and second to explain the influence reinforcement learning is having on the study of animal learning. the clear formalism provided by reinforcement learning that systemizes tasks returns and algorithms is proving to be enormously useful in making sense of experimental data in suggesting new kinds of experiments and in pointing to factors that may be critical to manipulate and to measure. the idea of optimizing return over the long term that is at the core of reinforcement learning is contributing to our understanding of otherwise puzzling features of animal learning and behavior. some of the correspondences between reinforcement learning and psychological theories are not surprising because the development of reinforcement learning drew inspiration from psychological learning theories. however as developed in this book reinforcement learning explores idealized situations from the perspective of an artificial intelligence researcher or engineer with the goal of solving computational problems with efficient algorithms rather than to replicate or explain in detail how animals learn. as a result some of the correspondences we describe connect ideas that arose independently in their respective fields. we believe these points of contact are specially meaningful because they expose computational principles important to learning whether it is learning by artificial or by natural systems. for the most part we describe correspondences between reinforcement learning and learning theories developed to explain how animals like rats pigeons and rabbits learn in controlled laboratory experiments. thousands of these experiments were conducted throughout the century and many are still being conducted today. although sometimes dismissed as irrelevant to wider issues in psychology these experiments probe subtle properties of animal learning often motivated by precise theoretical questions. as psychology shifted its focus to more cognitive aspects of behavior that is to mental processes such as thought and reasoning animal learning experiments came to play less chapter psychology of a role in psychology than they once did. but this experimentation led to the discovery of learning principles that are elemental and widespread throughout the animal kingdom principles that should not be neglected in designing artificial learning systems. in addition as we shall see some aspects of cognitive processing connect naturally to the computational perspective provided by reinforcement learning. this chapter s final section includes references relevant to the connections we discuss as well as to connections we neglect. we hope this chapter encourages readers to probe all of these connections more deeply. also included in this final section is a discussion of how the terminology used in reinforcement learning relates to that of psychology. many of the terms and phrases used in reinforcement learning are borrowed from animal learning theories but the computationalengineering meanings of these terms and phrases do not always coincide with their meanings in psychology. prediction and control the algorithms we describe in this book fall into two broad categories algorithms for prediction and algorithms for control. these categories arise naturally in solution methods for the reinforcement learning problem presented in chapter in many ways these categories respectively correspond to categories of learning extensively studied by psychologists classical or pavlovian conditioning and instrumental or operant conditioning. these correspondences are not completely accidental because of psychology s influence on reinforcement learning but they are nevertheless striking because they connect ideas arising from different objectives. the prediction algorithms presented in this book estimate quantities that depend on how features of an agent s environment are expected to unfold over the future. we specifically focus on estimating the amount of reward an agent can expect to receive over the future while it interacts with its environment. in this role prediction algorithms are policy evaluation algorithms which are integral components of algorithms for improving policies. but prediction algorithms are not limited to predicting future reward they can predict any feature of the environment for example modayil white and sutton the correspondence between prediction algorithms and classical conditioning rests on their common property of predicting upcoming stimuli whether or not those stimuli are rewarding punishing. the situation in an instrumental or operant conditioning experiment is different. here the experimental apparatus is set up so that an animal is given something it likes reward or something it dislikes penalty depending on what the animal did. the animal learns to increase its tendency to produce rewarded behavior and to decrease its tendency to produce penalized behavior. the reinforcing stimulus is said to be contingent on the animal s behavior whereas in classical conditioning it is not it is difficult to remove all behavior contingencies in a classical conditioning experiment. instrumental conditioning experiments are like those that inspired thorndike s law of effect that we briefly discuss in chapter control is at the core of this form of learning which corresponds to the operation of reinforcement learning s policy-improvement classical conditioning thinking of classical conditioning in terms of prediction and instrumental conditioning in terms of control is a starting point for connecting our computational view of reinforcement learning to animal learning but in reality the situation is more complicated than this. there is more to classical conditioning than prediction it also involves action and so is a mode of control sometimes called pavlovian control. further classical and instrumental conditioning interact in interesting ways with both sorts of learning likely being engaged in most experimental situations. despite these complications aligning the classicalinstrumental distinction with the predictioncontrol distinction is a convenient first approximation in connecting reinforcement learning to animal learning. in psychology the term reinforcement is used to describe learning in both classical and instrumental conditioning. originally referring only to the strengthening of a pattern of behavior it is frequently also used for the weakening of a pattern of behavior. a stimulus considered to be the cause of the change in behavior is called a reinforcer whether or not it is contingent on the animal s previous behavior. at the end of this chapter we discuss this terminology in more detail and how it relates to terminology used in machine learning. classical conditioning while studying the activity of the digestive system the celebrated russian physiologist ivan pavlov found that an animal s innate responses to certain triggering stimuli can come to be triggered by other stimuli that are quite unrelated to the inborn triggers. his experimental subjects were dogs that had undergone minor surgery to allow the intensity of their salivary reflex to be accurately measured. in one case he describes the dog did not salivate under most circumstances but about seconds after being presented with food it produced about six drops of saliva over the next several seconds. after several repetitions of presenting another stimulus one not related to food in this case the sound of a metronome shortly before the introduction of food the dog salivated in response to the sound of the metronome in the same way it did to the food. the activity of the salivary gland has thus been called into play by impulses of sound a stimulus quite alien to food p. summarizing the significance of this finding pavlov wrote it is pretty evident that under natural conditions the normal animal must respond not only to stimuli which themselves bring immediate benefit or harm but also to other physical or chemical agencies waves of sound light and the like which in themselves only signal the approach of these stimuli though it is not the sight and sound of the beast of prey which is in itself harmful to the smaller animal but its teeth and claws. p. control means for us is different from what it typically means in animal learning theories there the environment controls the agent instead of the other way around. see our comments on terminology at the end of this chapter. chapter psychology connecting new stimuli to innate reflexes in this way is now called classical or pavlovian conditioning. pavlov more exactly his translators called inborn responses salivation in his demonstration described above unconditioned responses their natural triggering stimuli food unconditioned stimuli and new responses triggered by predictive stimuli here also salivation conditioned responses a stimulus that is initially neutral meaning that it does not normally elicit strong responses the metronome sound becomes a conditioned stimulus as the animal learns that it predicts the us and so comes to produce a cr in response to the cs. these terms are still used in describing classical conditioning experiments better translations would have been conditional and unconditional instead of conditioned and unconditioned. the us is called a reinforcer because it reinforces producing a cr in response to the cs. the arrangement of stimuli in two common types of classical conditioning experiments is shown to the right. in delay conditioning the cs extends throughout the interstimulus interval or isi which is the time interval between the cs onset and the us onset the cs ending when the us ends in a common version shown here. in trace conditioning the us begins after the cs ends and the time interval between cs offset and us onset is called the trace interval. the salivation of pavlov s dogs to the sound of a metronome is just one example of classical conditioning which has been intensively studied across many response systems of many species of animals. urs are often preparatory in some way like the salivation of pavlov s dog or protective in some way like an eye blink in response to something irritating to the eye or freezing in response to seeing a predator. experiencing the cs-us predictive relationship over a series of trials causes the animal to learn that the cs predicts the us so that the animal can respond to the cs with a cr that prepares the animal for or protects it from the predicted us. some crs are similar to the ur but begin earlier and differ in ways that increase their effectiveness. in one intensively studied type of experiment for example a tone cs reliably predicts a puff of air us to a rabbit s eye triggering a ur consisting of the closure of a protective inner eyelid called the nictitating membrane. after one or more trials the tone comes to trigger a cr consisting of membrane closure that begins before the air puff and eventually becomes timed so that peak closure occurs just when the air puff is likely to occur. this cr being initiated in anticipation of the air puff and appropriately timed offers better protection than simply initiating closure as a reaction to the irritating us. the ability to act in anticipation of important events by learning about predictive relationships among stimuli is so beneficial that it is widely present across the animal kingdom. ttrace conditioningdelay conditioningcsuscsusisi classical conditioning blocking and higher-order conditioning many interesting properties of classical conditioning have been observed in experiments. beyond the anticipatory nature of crs two widely observed properties figured prominently in the development of classical conditioning models blocking and higher-order conditioning. blocking occurs when an animal fails to learn a cr when a potential cs is presented along with another cs that had been used previously to condition the animal to produce that cr. for example in the first stage of a blocking experiment involving rabbit nictitating membrane conditioning a rabbit is first conditioned with a tone cs and an air puff us to produce the cr of closing its nictitating membrane in anticipation of the air puff. the experiment s second stage consists of additional trials in which a second stimulus say a light is added to the tone to form a compound tonelight cs followed by the same air puff us. in the experiment s third phase the second stimulus alone the light is presented to the rabbit to see if the rabbit has learned to respond to it with a cr. it turns out that the rabbit produces very few or no crs in response to the light learning to the light had been blocked by the previous learning to the blocking results like this challenged the idea that conditioning depends only on simple temporal contiguity that is that a necessary and sufficient condition for conditioning is that a us frequently follows a cs closely in time. in the next section we describe the rescorla wagner model and wagner that offered an influential explanation for blocking. higher-order conditioning occurs when a previously-conditioned cs acts as a us in conditioning another initially neutral stimulus. pavlov described an experiment in which his assistant first conditioned a dog to salivate to the sound of a metronome that predicted a food us as described above. after this stage of conditioning a number of trials were conducted in which a black square to which the dog was initially indifferent was placed in the dog s line of vision followed by the sound of the metronome and this was not followed by food. in just ten trials the dog began to salivate merely upon seeing the black square despite the fact that the sight of it had never been followed by food. the sound of the metronome itself acted as a us in conditioning a salivation cr to the black square cs. this was second-order conditioning. if the black square had been used as a us to establish salivation crs to another otherwise neutral cs it would have been third-order conditioning and so on. higher-order conditioning is difficult to demonstrate especially above the second order in part because a higher-order reinforcer loses its reinforcing value due to not being repeatedly followed by the original us during higher-order conditioning trials. but under the right conditions such as intermixing first-order trials with higher-order trials or by providing a general energizing stimulus higher-order conditioning beyond the second order can be demonstrated. as we describe below the td model of classical conditioning uses the bootstrapping idea that is central to our approach to extend the rescorla wagner model s account of blocking to include both the anticipatory nature of crs and higher-order conditioning. with a control group is necessary to show that the previous conditioning to the tone is responsible for blocking learning to the light. this is done by trials with the tonelight cs but with no prior conditioning to the tone. learning to the light in this case is unimpaired. moore and schmajuk give a full account of this procedure. chapter psychology higher-order instrumental conditioning occurs as well. in this case a stimulus that consistently predicts primary reinforcement becomes a reinforcer itself where reinforcement is primary if its rewarding or penalizing quality has been built into the animal by evolution. the predicting stimulus becomes a secondary reinforcer or more generally a higher-order or conditioned reinforcer the latter being a better term when the predicted reinforcing stimulus is itself a secondary or an even higher-order reinforcer. a conditioned reinforcer delivers conditioned reinforcement conditioned reward or conditioned penalty. conditioned reinforcement acts like primary reinforcement in increasing an animal s tendency to produce behavior that leads to conditioned reward and to decrease an animal s tendency to produce behavior that leads to conditioned penalty. our comments at the end of this chapter that explain how our terminology sometimes differs as it does here from terminology used in psychology. conditioned reinforcement is a key phenomenon that explains for instance why we work for the conditioned reinforcer money whose worth derives solely from what is predicted by having it. in actor critic methods described in section discussed in the context of neuroscience in sections and the critic uses a td method to evaluate the actor s policy and its value estimates provide conditioned reinforcement to the actor allowing the actor to improve its policy. this analog of higher-order instrumental conditioning helps address the credit-assignment problem mentioned in section because the critic gives moment-by-moment reinforcement to the actor when the primary reward signal is delayed. we discuss this more below in section the rescorla wagner model rescorla and wagner created their model mainly to account for blocking. the core idea of the rescorla wagner model is that an animal only learns when events violate its expectations in other words only when the animal is surprised without necessarily implying any conscious expectation or emotion. we first present rescorla and wagner s model using their terminology and notation before shifting to the terminology and notation we use to describe the td model. here is how rescorla and wagner described their model. the model adjusts the associative strength of each component stimulus of a compound cs which is a number representing how strongly or reliably that component is predictive of a us. when a compound cs consisting of several component stimuli is presented in a classical conditioning trial the associative strength of each component stimulus changes in a way that depends on an associative strength associated with the entire stimulus compound called the aggregate associative strength and not just on the associative strength of each component itself. rescorla and wagner considered a compound cs ax consisting of component stimuli a and x where the animal may have already experienced stimulus a and stimulus x might be new to the animal. let va vx and vax respectively denote the associative strengths of stimuli a x and the compound ax. suppose that on a trial the compound cs ax is followed by a us which we label stimulus y. then the associative strengths classical conditioning of the stimulus components change according to these expressions va a yry vax vx x yry vax where a y and x y are the step-size parameters which depend on the identities of the cs components and the us and ry is the asymptotic level of associative strength that the us y can support. and wagner used here instead of r but we use r to avoid confusion with our use of and because we usually think of this as the magnitude of a reward signal with the caveat that the us in classical conditioning is not necessarily rewarding or penalizing. a key assumption of the model is that the aggregate associative strength vax is equal to va vx. the associative strengths as changed by these s become the associative strengths at the beginning of the next trial. to be complete the model needs a response-generation mechanism which is a way of mapping values of v s to crs. because this mapping would depend on details of the experimental situation rescorla and wagner did not specify a mapping but simply assumed that larger v s would produce stronger or more likely crs and that negative v s would mean that there would be no crs. the rescorla wagner model accounts for the acquisition of crs in a way that explains blocking. as long as the aggregate associative strength vax of the stimulus compound is below the asymptotic level of associative strength ry that the us y can support the prediction error ry vax is positive. this means that over successive trials the associative strengths va and vx of the component stimuli increase until the aggregate associative strength vax equals ry at which point the associative strengths stop changing the us changes. when a new component is added to a compound cs to which the animal has already been conditioned further conditioning with the augmented compound produces little or no increase in the associative strength of the added cs component because the error has already been reduced to zero or to a low value. the occurrence of the us is already predicted nearly perfectly so little or no error or surprise is introduced by the new cs component. prior learning blocks learning to the new component. to transition from rescorla and wagner s model to the td model of classical conditioning we just call the td model we first recast their model in terms of the concepts that we are using throughout this book. specifically we match the notation we use for learning with linear function approximation and we think of the conditioning process as one of learning to predict the magnitude of the us on a trial on the basis of the compound cs presented on that trial where the magnitude of a us y is the ry of the rescorla wagner model as given above. we also introduce states. because the rescorla wagner model is a trial-level model meaning that it deals with how associative strengths change from trial to trial without considering any details about what happens within and between trials we do not have to consider how states change during a trial until we present the full td model in the following section. instead here we simply think of a state as a way of labeling a trial in terms of the collection of component css that are present on the trial. therefore assume that trial-type or state s is described by a real-valued vector of chapter psychology features xs where xis if csi the ith component of a compound cs is present on the trial and otherwise. then if the d-dimensional vector of associative strengths is w the aggregate associative strength for trial-type s is vsw this corresponds to a value estimate in reinforcement learning and we think of it as the us prediction. now temporally let t denote the number of a complete trial and not its usual meaning as a time step revert to t s usual meaning when we extend this to the td model below and assume that st is the state corresponding to trial t. conditioning trial t updates the associative strength vector wt to as follows wt t xst where is the step-size parameter and because here we are describing the rescorla wagner model t is the prediction error t rt vstwt. rt is the target of the prediction on trial t that is the magnitude of the us or in rescorla and wagner s terms the associative strength that the us on the trial can support. note that because of the factor xst in only the associative strengths of cs components present on a trial are adjusted as a result of that trial. you can think of the prediction error as a measure of surprise and the aggregate associative strength as the animal s expectation that is violated when it does not match the target us magnitude. from the perspective of machine learning the rescorla wagner model is an errorcorrection supervised learning rule. it is essentially the same as the least mean square or widrow-hoff learning rule and hoff that finds the weights here the associative strengths that make the average of the squares of all the errors as close to zero as possible. it is a curve-fitting or regression algorithm that is widely used in engineering and scientific applications section the rescorla wagner model was very influential in the history of animal learning theory because it showed that a mechanistic theory could account for the main facts about blocking without resorting to more complex cognitive theories involving for example an animal s explicit recognition that another stimulus component had been added and then scanning its short-term memory backward to reassess the predictive relationships involving the us. the rescorla wagner model showed how traditional contiguity theories of conditioning that temporal contiguity of stimuli was a necessary and sufficient condition for learning could be adjusted in a simple way to account for blocking and schmajuk only differences between the lms rule and the rescorla wagner model are that for lms the input vectors xt can have any real numbers as components and at least in the simplest version of the lms rule the step-size parameter does not depend on the input vector or the identity of the stimulus setting the prediction target. classical conditioning the rescorla wagner model provides a simple account of blocking and some other features of classical conditioning but it is not a complete or perfect model of classical conditioning. different ideas account for a variety of other observed effects and progress is still being made toward understanding the many subtleties of classical conditioning. the td model which we describe next though also not a complete or perfect model model of classical conditioning extends the rescorla wagner model to address how within-trial and between-trial timing relationships among stimuli can influence learning and how higher-order conditioning might arise. the td model the td model is a real-time model as opposed to a trial-level model like the rescorla wagner model. a single step t in the rescorla wagner model represents an entire conditioning trial. the model does not apply to details about what happens during the time a trial is taking place or what might happen between trials. within each trial an animal might experience various stimuli whose onsets occur at particular times and that have particular durations. these timing relationships strongly influence learning. the rescorla wagner model also does not include a mechanism for higher-order conditioning whereas for the td model higher-order conditioning is a natural consequence of the bootstrapping idea that is at the base of td algorithms. to describe the td model we begin with the formulation of the rescorla wagner model above but t now labels time steps within or between trials instead of complete trials. think of the time between t and t as a small time interval say second and think of a trial as a sequences of states one associated with each time step where the state at step t now represents details of how stimuli are represented at t instead of just a label for the cs components present on a trial. in fact we can completely abandon the idea of trials. from the point of view of the animal a trial is just a fragment of its continuing experience interacting with its world. following our usual view of an agent interacting with its environment imagine that the animal is experiencing an endless sequence of states s each represented by a feature vector xs. that said it is still often convenient to refer to trials as fragments of time during which patterns of stimuli repeat in an experiment. state features are not restricted to describing the external stimuli that an animal experiences they can describe neural activity patterns that external stimuli produce in an animal s brain and these patterns can be history-dependent meaning that they can be persistent patterns produced by sequences of external stimuli. of course we do not know exactly what these neural activity patterns are but a real-time model like the td model allows one to explore the consequences on learning of different hypotheses about the internal representations of external stimuli. for these reasons the td model does not commit to any particular state representation. in addition because the td model includes discounting and eligibility traces that span time intervals between stimuli the model also makes it possible to explore how discounting and eligibility traces interact with stimulus representations in making predictions about the results of classical conditioning experiments. chapter psychology below we describe some of the state representations that have been used with the td model and some of their implications but for the moment we stay agnostic about the representation and just assume that each state s is represented by a feature vector xs then the aggregate associative strength corresponding to a state s is given by the same as for the rescorla-wgner model but the td model updates the associative strength vector w differently. with t now labeling a time step instead of a complete trial the td model governs learning according to this update wt t zt which replaces xtst in the rescorla wagner update with zt a vector of eligibility traces and instead of the t of here t is a td error t vstwt where is a discount factor and rt is the prediction target at time t and and vstwt are aggregate associative strengths at t and t as defined by each component i of the eligibility-trace vector zt increments or decrements according to the component xist of the feature vector xst and otherwise decays with a rate determined by zt xst. here is the usual eligibility trace decay parameter. note that if the td model reduces to the rescorla wagner model with the exceptions that the meaning of t is different in each case trial number for the rescorla wagner model and a time step for the td model and in the td model there is a one-time-step lead in the prediction target r. the td model is equivalent to the backward view of the semi-gradient td algorithm with linear function approximation except that rt in the model does not have to be a reward signal as it does when the td algorithm is used to learn a value function for policy-improvement. td model simulations real-time conditioning models like the td model are interesting primarily because they make predictions for a wide range of situations that cannot be represented by trial-level models. these situations involve the timing and durations of conditionable stimuli the timing of these stimuli in relation to the timing of the us and the timing and shapes of crs. for example the us generally must begin after the onset of a neutral stimulus for conditioning to occur with the rate and effectiveness of learning depending on the interstimulus interval or isi the interval between the onsets of the cs and the us. when crs appear they generally begin before the appearance of the us and their temporal profiles change during learning. in conditioning with compound css the component stimuli of the compound css may not all begin and end at the same time sometimes classical conditioning forming what is called a serial compound in which the component stimuli occur in a sequence over time. timing considerations like these make it important to consider how stimuli are represented how these representations unfold over time during and between trials and how they interact with discounting and eligibility traces. figure shows three of the stimulus representations that have been used in exploring the behavior of the td model the complete serial compound the microstimulus and the presence representations sutton and kehoe these representations differ in the degree to which they force generalization among nearby time points during which a stimulus is present. the simplest of the representations shown in figure is the presence representation in the figure s right column. this representation has a single feature for each component cs present on a trial where the feature has value whenever that component is present figure three stimulus representations columns sometimes used with the td model. each row represents one element of the stimulus representation. the three representations vary along a temporal generalization gradient with no generalization between nearby time points in the complete serial compound column and complete generalization between nearby time points in the presence representation column. the microstimulus representation occupies a middle ground. the degree of temporal generalization determines the temporal granularity with which us predictions are learned. adapted with minor changes from learning behavior evaluating the td model of classical conditioning volume p. e. a. ludvig r. s. sutton e. j. kehoe. with permission of springer. presencecomplete serial compoundstimulus representationmicrostimulicsus chapter psychology and the presence representation is not a realistic hypothesis about how stimuli are represented in an animal s brain but as we describe below the td model with this representation can produce many of the timing phenomena seen in classical conditioning. for the csc representation column of figure the onset of each external stimulus initiates a sequence of precisely-timed short-duration internal signals that continues until the external stimulus this is like assuming the animal s nervous system has a clock that keeps precise track of time during stimulus presentations it is what engineers call a tapped delay line. like the presence representation the csc representation is unrealistic as a hypothesis about how the brain internally represents stimuli but ludvig et al. call it a useful fiction because it can reveal details of how the td model works when relatively unconstrained by the stimulus representation. the csc representation is also used in most td models of dopamine-producing neurons in the brain a topic we take up in chapter the csc representation is often viewed as an essential part of the td model although this view is mistaken. the ms representation column of figure is like the csc representation in that each external stimulus initiates a cascade of internal stimuli but in this case the internal stimuli the microstimuli are not of such limited and non-overlapping form they are extended over time and overlap. as time elapses from stimulus onset different sets of microstimuli become more or less active and each subsequent microstimulus becomes progressively wider in time and reaches a lower maximal level. of course there are many ms representations depending on the nature of the microstimuli and a number of examples of ms representations have been studied in the literature in some cases along with proposals for how an animal s brain might generate them the bibliographic and historical comments at the end of this chapter. ms representations are more realistic than the presence or csc representations as hypotheses about neural representations of stimuli and they allow the behavior of the td model to be related to a broader collection of phenomena observed in animal experiments. in particular by assuming that cascades of microstimuli are initiated by uss as well as by css and by studying the significant effects on learning of interactions between microstimuli eligibility traces and discounting the td model is helping to frame hypotheses to account for many of the subtle phenomena of classical conditioning and how an animal s brain might produce them. we say more about this below particularly in chapter where we discuss reinforcement learning and neuroscience. even with the simple presence representation however the td model produces all the basic properties of classical conditioning that are accounted for by the rescorla our formalism there is a different state st for each time step t during a trial and for a trial in which a compound cs consists of n component css of various durations occurring at various times throughout the trial there is a feature xi for each component csi i n where xist for all times t when the csi is present and equals zero otherwise. our formalism for each cs component csi present on a trial and for each time step t during a if t for any at which csi is present and trial there is a separate feature xt equals otherwise. this is different from the csc representation in sutton and barto in which there are the same distinct features for each time step but no reference to external stimuli hence the name complete serial compound. i where xt classical conditioning wagner model plus features of conditioning that are beyond the scope of trial-level models. for example as we have already mentioned a conspicuous feature of classical conditioning is that the us generally must begin after the onset of a neutral stimulus for conditioning to occur and that after conditioning the cr begins before the appearance of the us. in other words conditioning generally requires a positive isi and the cr generally anticipates the us. how the strength of conditioning the percentage of crs elicited by a cs depends on the isi varies substantially across species and response systems but it typically has the following properties it is negligible for a zero or negative isi i.e. when the us onset occurs simultaneously with or earlier than the cs onset research has found that associative strengths sometimes increase slightly or become negative with negative isis it increases to a maximum at a positive isi where conditioning is most effective and it then decreases to zero after an interval that varies widely with response systems. the precise shape of this dependency for the td model depends on the values of its parameters and details of the stimulus representation but these basic features of isi-dependency are core properties of the td model. one of the theoretical issues arising with serial-compound conditioning that is conditioning with a compound cs whose components occur in a sequence concerns the facilitation of remote associations. it has been found that if the empty trace interval between a first cs and the us is filled with a second cs to form a serial-compound stimulus then conditioning to csa is facilitated. shown to the right is the behavior of the td model with the presence representation in a simulation of such an experiment whose timing details are shown above. consistent with the experimental results the model shows facilitation of both the rate of conditioning and the asymptotic level of conditioning of the first cs due to the presence of the second cs. figure facilitation of a remote association by an intervening stimulus in the td model. adapted from sutton and barto wcsa chapter psychology a well-known demonstration of the effects on conditioning of temporal relationships among stimuli within a trial is an experiment by egger and miller that involved two overlapping css in a delay configuration as shown to the right although csb was in a better temporal relationship with the us the presence of csa substantially reduced conditioning to csb as compared to controls in which csa was absent. the bottom panel shows the same result being generated by the td model in a simulation of this experiment with the presence representation. i.e. figure the egger-miller or primacy effect in the td model. adapted from sutton and barto the td model accounts for blocking because it is an error-correcting learning rule like the rescorla wagner model. beyond accounting for basic blocking results however the td model predicts the presence representation and more complex representations a well that blocking is reversed if the blocked stimulus is moved earlier in time so that its onset occurs before the onset of the blocking stimulus. this feature of the td model s behavior deserves attention because it had not been observed at the time of the model s introduction. recall that in blocking if an animal has already learned that one cs predicts a us then learning that a newly-added second cs also predicts the us is much reduced is blocked. but if the newly-added second cs begins earlier than the pretrained cs then according to the td model learning to the newly-added cs is not blocked. in fact as training continues and the newly-added cs gains associative strength the pretrained cs loses associative strength. the behavior of the td model under these conditions is shown to the right. this simulation experiment differed from the egger-miller experiment of figure in that the shorter cs with the later onset was given prior training until it was fully associated with the us. this surprising prediction led kehoe schreurs and graham to conduct the experiment using the well-studied rabbit nic figure temporal primacy overriding blocking in the td model. adapted from sutton and barto wcsbwcsb classical conditioning titating membrane preparation. their results confirmed the model s prediction and they noted that non-td models have considerable difficulty explaining their data. with the td model an earlier predictive stimulus takes precedence over a later predictive stimulus because like all the prediction methods described in this book the td model is based on the backing-up or bootstrapping idea updates to associative strengths shift the strengths at a particular state toward the strength at later states. another consequence of bootstrapping is that the td model provides an account of higher-order conditioning a feature of classical conditioning that is beyond the scope of the rescoral-wagner and similar models. as we described above higher-order conditioning is the phenomenon in which a previously-conditioned cs can act as a us in conditioning another initially neutral stimulus. to the right is shown the behavior of the td model with the presence representation in a higherorder conditioning experiment in this case it is second-order conditioning. in the first phase shown in the figure csb is trained to predict a us so that its associative strength increases here to in the second phase csa is paired with csb in the absence of the us in the sequential arrangement shown at the top of the figure. csa acquires associative strength even though it is never paired with the us. with continued training csa s associative strength reaches a peak and then decreases because the associative strength of csb the secondary reinforcer decreases so that it loses its ability to provide secondary reinforcement. csb s associative strength decreases because the us does not occur in these higher-order conditioning trials. these are extinction trials for csb because its predictive relationship to the us is disrupted so that its ability to act as a reinforcer decreases. this same pattern is seen in animal experiments. this extinction of conditioned reinforcement in higher-order conditioning trials makes it difficult to demonstrate higher-order conditioning unless the original predictive relationships are periodically refreshed by occasionally inserting first-order trials. figure second-order conditioning with the td model. csb has an initial associative strength of at the beginning of the simulation. adapted from sutton and barto the td model produces an analog of second- and higher-order conditioning because vstwt appears in the td error t this means that as a result of previous learning can differ from vstwt making t non-zero temporal difference. this difference has the same status as in implying that as far as learning is concerned there is no difference between a temporal difference and the occurrence of a us. in fact this feature of the td algorithm is one of the major reasons for its development which we now understand through its connection to dynamic w chapter psychology programming as described in chapter bootstrapping values is intimately related to second-order and higher-order conditioning. in the examples of the td model s behavior described above we examined only the changes in the associative strengths of the cs components we did not look at what the model predicts about properties of an animal s conditioned responses their timing shape and how they develop over conditioning trials. these properties depend on the species the response system being observed and parameters of the conditioning trials but in many experiments with different animals and different response systems the magnitude of the cr or the probability of a cr increases as the expected time of the us approaches. for example in classical conditioning of a rabbit s nictitating membrane response that we mentioned above over conditioning trials the delay from cs onset to when the nictitating membrane begins to move across the eye decreases over trials and the amplitude of this anticipatory closure gradually increases over the interval between the cs and the us until the membrane reaches maximal closure at the expected time of the us. the timing and shape of this cr is critical to its adaptive significance covering the eye too early reduces vision though the nictitating membrane is translucent while covering it too late is of little protective value. capturing cr features like these is challenging for models of classical conditioning. the td model does not include as part of its definition any mechanism for translating the time course of the us prediction vstwt into a profile that can be compared with the properties of an animal s cr. the simplest choice is to let the time course of a simulated cr equal the time course of the us prediction. in this case features of simulated crs and how they change over trials depend only on the stimulus representation chosen and the values of the model s parameters and figure shows the time courses of us predictions at different points during learning with the three representations shown in figure for these simulations the us occurred time steps after the onset of the cs and and with the csc representation left the curve of the us prediction formed by the td model increases exponentially throughout the interval between the cs and the us until it reaches a maximum exactly when the us occurs time step this exponential increase is the result of discounting in the td model learning rule. with the presence representation middle the us prediction is nearly constant while the stimulus is present because there is only one weight or associative strength to be learned for each stimulus. consequently the td model with the presence representation cannot recreate many features of cr timing. with an ms representation right the development of the td model s us prediction is more complicated. after trials the prediction s profile is a reasonable approximation of the us prediction curve produced with the csc representation. the us prediction curves shown in figure were not intended to precisely match profiles of crs as they develop during conditioning in any particular animal experiment but they illustrate the strong influence that the stimulus representation has on predictions derived from the td model. further although we can only mention it here how the stimulus representation interacts with discounting and eligibility traces is important in determining properties of the us prediction profiles produced by the td model. classical conditioning figure time course of us prediction over the course of acquisition for the td model with three different stimulus representations. left with the complete serial compound the us prediction increases exponentially through the interval peaking at the time of the us. at asymptote the us prediction peaks at the us intensity in these simulations. middle with the presence representation the us prediction converges to an almost constant level. this constant level is determined by the us intensity and the length of the cs us interval. right with the microstimulus representation at asymptote the td model approximates the exponentially increasing time course depicted with the csc through a linear combination of the different microstimuli. adapted with minor changes from learning behavior evaluating the td model of classical conditioning volume e. a. ludvig r. s. sutton e. j. kehoe. with permission of springer. another dimension beyond what we can discuss here is the influence of different responsegeneration mechanisms that translate us predictions into cr profiles the profiles shown in figure are raw us prediction profiles. even without any special assumption about how an animal s brain might produce overt responses from us predictions however the profiles in figure for the csc and ms representations increase as the time of the us approaches and reach a maximum at the time of the us as is seen in many animal conditioning experiments. the td model when combined with particular stimulus representations and responsegeneration mechanisms is able to account for a surprisingly-wide range of phenomena observed in animal classical conditioning experiments but it is far from being a perfect model. to generate other details of classical conditioning the model needs to be extended perhaps by adding model-based elements and mechanisms for adaptively altering some of its parameters. other approaches to modeling classical conditioning depart significantly from the rescorla wagner-style error-correction process. bayesian models for example work within a probabilistic framework in which experience revises probability estimates. all of these models usefully contribute to our understanding of classical conditioning. perhaps the most notable feature of the td model is that it is based on a theory the theory we have described in this book that suggests an account of what an animal s nervous system is trying to do while undergoing conditioning it is trying to form accurate long-term predictions consistent with the limitations imposed by the way stimuli are represented and how the nervous system works. in other words it suggests a normative account of classical conditioning in which long-term instead of immediate prediction is v v v a key feature. chapter psychology the development of the td model of classical conditioning is one instance in which the explicit goal was to model some of the details of animal learning behavior. in addition to its standing as an algorithm then td learning is also the basis of this model of aspects of biological learning. as we discuss in chapter td learning has also turned out to underlie an influential model of the activity of neurons that produce dopamine a chemical in the brain of mammals that is deeply involved in reward processing. these are instances in which reinforcement learning theory makes detailed contact with animal behavioral and neural data. we now turn to considering correspondences between reinforcement learning and animal behavior in instrumental conditioning experiments the other major type of laboratory experiment studied by animal learning psychologists. instrumental conditioning in instrumental conditioning experiments learning depends on the consequences of behavior the delivery of a reinforcing stimulus is contingent on what the animal does. in classical conditioning experiments in contrast the reinforcing stimulus the us is delivered independently of the animal s behavior. instrumental conditioning is usually considered to be the same as operant conditioning the term b. f. skinner introduced for experiments with behavior-contingent reinforcement though the experiments and theories of those who use these two terms differ in a number of ways some of which we touch on below. we will exclusively use the term instrumental conditioning for experiments in which reinforcement is contingent upon behavior. the roots of instrumental conditioning go back to experiments performed by the american psychologist edward thorndike one hundred years before publication of the first edition of this book. thorndike observed the behavior of cats when they were placed in puzzle boxes such as the one at the right from which they could escape by appropriate actions. for example a cat could open the door of one box by performing a sequence of three separate actions depressing a platform at the back of the box pulling a string by clawing at it and pushing a bar up or down. when first placed in a puzzle box with food visible outside all but a few of thorndike s cats displayed evident signs of discomfort and extraordinarily vigorous activity to strive instinctively to escape from confinement in experiments with different cats and one of thorndike s puzzle boxes. reprinted from thorndike animal intelligence an experimental study of the associative processes in animals the psychological review series of monograph supplements macmillan new york boxes with different escape mechanisms thorndike recorded the amounts of time each cat took to escape over multiple experiences in each box. he observed that the time instrumental conditioning almost invariably decreased with successive experiences for example from seconds to or seconds. he described cats behavior in a puzzle box like this the cat that is clawing all over the box in her impulsive struggle will probably claw the string or loop or button so as to open the door. and gradually all the other non-successful impulses will be stamped out and the particular impulse leading to the successful act will be stamped in by the resulting pleasure until after many trials the cat will when put in the box immediately claw the button or loop in a definite way. p. these and other experiments with dogs chicks monkeys and even fish led thorndike to formulate a number of laws of learning the most influential being the law of effect a version of which we quoted in chapter this law describes what is generally known as learning by trial and error. as mentioned in chapter many aspects of the law of effect have generated controversy and its details have been modified over the years. still the law in one form or another expresses an enduring principle of learning. essential features of reinforcement learning algorithms correspond to features of animal learning described by the law of effect. first reinforcement learning algorithms are selectional meaning that they try alternatives and select among them by comparing their consequences. second reinforcement learning algorithms are associative meaning that the alternatives found by selection are associated with particular situations or states to form the agent s policy. like learning described by the law of effect reinforcement learning is not just the process of finding actions that produce a lot of reward but also of connecting these actions to situations or states. thorndike used the phrase learning by selecting and connecting natural selection in evolution is a prime example of a selectional process but it is not associative least as it is commonly understood supervised learning is associative but it is not selectional because it relies on instructions that directly tell the agent how to change its behavior. in computational terms the law of effect describes an elementary way of combining search and memory search in the form of trying and selecting among many actions in each situation and memory in the form of associations linking situations with the actions found so far to work best in those situations. search and memory are essential components of all reinforcement learning algorithms whether memory takes the form of an agent s policy value function or environment model. a reinforcement learning algorithm s need to search means that it has to explore in some way. animals clearly explore as well and early animal learning researchers disagreed about the degree of guidance an animal uses in selecting its actions in situations like thorndike s puzzle boxes. are actions the result of absolutely random blind groping p. or is there some degree of guidance either from prior learning reasoning or other means? although some thinkers including thorndike seem to have taken the former position others favored more deliberate exploration. reinforcement learning algorithms allow wide latitude for how much guidance an agent can employ in selecting actions. the forms of exploration we have used in the algorithms presented in this book such as and upper-confidence-bound action selection are merely chapter psychology among the simplest. more sophisticated methods are possible with the only stipulation being that there has to be some form of exploration for the algorithms to work effectively. the feature of our treatment of reinforcement learning allowing the set of actions available at any time to depend on the environment s current state echoes something thorndike observed in his cats puzzle-box behaviors. the cats selected actions from those that they instinctively perform in their current situation which thorndike called their instinctual impulses. first placed in a puzzle box a cat instinctively scratches claws and bites with great energy a cat s instinctual responses to finding itself in a confined space. successful actions are selected from these and not from every possible action or activity. this is like the feature of our formalism where the action selected from a state s belongs to a set of admissible actions as. specifying these sets is an important aspect of reinforcement learning because it can radically simplify learning. they are like an animal s instinctual impulses. on the other hand thorndike s cats might have been exploring according to an instinctual context-specific ordering over actions rather than by just selecting from a set of instinctual impulses. this is another way to make reinforcement learning easier. among the most prominent animal learning researchers influenced by the law of effect were clark hull hull and b. f. skinner skinner at the center of their research was the idea of selecting behavior on the basis of its consequences. reinforcement learning has features in common with hull s theory which included eligibility-like mechanisms and secondary reinforcement to account for the ability to learn when there is a significant time interval between an action and the consequent reinforcing stimulus section randomness also played a role in hull s theory through what he called behavioral oscillation to introduce exploratory behavior. skinner did not fully subscribe to the memory aspect of the law of effect. being averse to the idea of associative linkages he instead emphasized selection from spontaneouslyemitted behavior. he introduced the term operant to emphasize the key role of an action s effects on an animal s environment. unlike the experiments of thorndike and others which consisted of sequences of separate trials skinner s operant conditioning experiments allowed animal subjects to behave for extended periods of time without interruption. he invented the operant conditioning chamber now called a skinner box the most basic version of which contains a lever or key that an animal can press to obtain a reward such as food or water which would be delivered according to a welldefined rule called a reinforcement schedule. by recording the cumulative number of lever presses as a function of time skinner and his followers could investigate the effect of different reinforcement schedules on the animal s rate of lever-pressing. modeling results from experiments likes these using the reinforcement learning principles we present in this book is not well developed but we mention some exceptions in the bibliographic and historical remarks section at the end of this chapter. another of skinner s contributions resulted from his recognition of the effectiveness of training an animal by reinforcing successive approximations of the desired behavior a process he called shaping. although this technique had been used by others including skinner himself its significance was impressed upon him when he and colleagues were attempting to train a pigeon to bowl by swiping a wooden ball with its beak. after instrumental conditioning waiting for a long time without seeing any swipe that they could reinforce they decided to reinforce any response that had the slightest resemblance to a swipe perhaps at first merely the behavior of looking at the ball and then to select responses which more closely approximated the final form. the result amazed us. in a few minutes the ball was caroming off the walls of the box as if the pigeon had been a champion squash player. p. not only did the pigeon learn a behavior that is unusual for pigeons it learned quickly through an interactive process in which its behavior and the reinforcement contingencies changed in response to each other. skinner compared the process of altering reinforcement contingencies to the work of a sculptor shaping clay into a desired form. shaping is a powerful technique for computational reinforcement learning systems as well. when it is difficult for an agent to receive any non-zero reward signal at all either due to sparseness of rewarding situations or their inaccessibility given initial behavior starting with an easier problem and incrementally increasing its difficulty as the agent learns can be an effective and sometimes indispensable strategy. a concept from psychology that is especially relevant in the context of instrumental conditioning is motivation which refers to processes that influence the direction and strength or vigor of behavior. thorndike s cats for example were motivated to escape from puzzle boxes because they wanted the food that was sitting just outside. obtaining this goal was rewarding to them and reinforced the actions allowing them to escape. it is difficult to link the concept of motivation which has many dimensions in a precise way to reinforcement learning s computational perspective but there are clear links with some of its dimensions. in one sense a reinforcement learning agent s reward signal is at the base of its motivation the agent is motivated to maximize the total reward it receives over the long run. a key facet of motivation then is what makes an agent s experience rewarding. in reinforcement learning reward signals depend on the state of the reinforcement learning agent s environment and the agent s actions. further as pointed out in chapter the state of the agent s environment not only includes information about what is external to the machine like an organism or a robot that houses the agent but also what is internal to this machine. some internal state components correspond to what psychologists call an animal s motivational state which influences what is rewarding to the animal. for example an animal will be more rewarded by eating when it is hungry than when it has just finished a satisfying meal. the concept of state dependence is broad enough to allow for many types of modulating influences on the generation of reward signals. value functions provide a further link to psychologists concept of motivation. if the most basic motive for selecting an action is to obtain as much reward as possible for a reinforcement learning agent that selects actions using a value function a more proximal motive is to ascend the gradient of its value function that is to select actions expected to lead to the most highly-valued next states what is essentially the same thing to select actions with the greatest action-values. for these agents value functions are the main driving force determining the direction of their behavior. chapter psychology another dimension of motivation is that an animal s motivational state not only influences learning but also influences the strength or vigor of the animal s behavior after learning. for example after learning to find food in the goal box of a maze a hungry rat will run faster to the goal box than one that is not hungry. this aspect of motivation does not link so cleanly to the reinforcement learning framework we present here but in the bibliographical and historical remarks section at the end of this chapter we cite several publications that propose theories of behavioral vigor based on reinforcement learning. we turn now to the subject of learning when reinforcing stimuli occur well after the events they reinforce. the mechanisms used by reinforcement learning algorithms to enable learning with delayed reinforcement eligibility traces and td learning closely correspond to psychologists hypotheses about how animals can learn under these conditions. delayed reinforcement the law of effect requires a backward effect on connections and some early critics of the law could not conceive of how the present could affect something that was in the past. this concern was amplified by the fact that learning can even occur when there is a considerable delay between an action and the consequent reward or penalty. similarly in classical conditioning learning can occur when us onset follows cs offset by a non-negligible time interval. we call this the problem of delayed reinforcement which is related to what minsky called the credit-assignment problem for learning systems how do you distribute credit for success among the many decisions that may have been involved in producing it? the reinforcement learning algorithms presented in this book include two basic mechanisms for addressing this problem. the first is the use of eligibility traces and the second is the use of td methods to learn value functions that provide nearly immediate evaluations of actions tasks like instrumental conditioning experiments or that provide immediate prediction targets tasks like classical conditioning experiments. both of these methods correspond to similar mechanisms proposed in theories of animal learning. pavlov pointed out that every stimulus must leave a trace in the nervous system that persists for some time after the stimulus ends and he proposed that stimulus traces make learning possible when there is a temporal gap between the cs offset and the us onset. to this day conditioning under these conditions is called trace conditioning assuming a trace of the cs remains when the us arrives learning occurs through the simultaneous presence of the trace and the us. we discuss some proposals for trace mechanisms in the nervous system in chapter stimulus traces were also proposed as a means for bridging the time interval between actions and consequent rewards or penalties in instrumental conditioning. in hull s influential learning theory for example molar stimulus traces accounted for what he called an animal s goal gradient a description of how the maximum strength of an instrumentally-conditioned response decreases with increasing delay of reinforcement hull hypothesized that an animal s actions leave internal stimuli cognitive maps whose traces decay exponentially as functions of time since an action was taken. looking at the animal learning data available at the time he hypothesized that the traces effectively reach zero after to seconds. the eligibility traces used in the algorithms described in this book are like hull s traces they are decaying traces of past state visitations or of past state action pairs. eligibility traces were introduced by klopf in his neuronal theory in which they are temporally-extended traces of past activity at synapses the connections between neurons. klopf s traces are more complex than the exponentially-decaying traces our algorithms use and we discuss this more when we take up his theory in section to account for goal gradients that extend over longer time periods than spanned by stimulus traces hull proposed that longer gradients result from conditioned reinforcement passing backwards from the goal a process acting in conjunction with his molar stimulus traces. animal experiments showed that if conditions favor the development of conditioned reinforcement during a delay period learning does not decrease with increased delay as much as it does under conditions that obstruct secondary reinforcement. conditioned reinforcement is favored if there are stimuli that regularly occur during the delay interval. then it is as if reward is not actually delayed because there is more immediate conditioned reinforcement. hull therefore envisioned that there is a primary gradient based on the delay of the primary reinforcement mediated by stimulus traces and that this is progressively modified and lengthened by conditioned reinforcement. algorithms presented in this book that use both eligibility traces and value functions to enable learning with delayed reinforcement correspond to hull s hypothesis about how animals are able to learn under these conditions. the actor critic architecture discussed in sections and illustrates this correspondence most clearly. the critic uses a td algorithm to learn a value function associated with the system s current behavior that is to predict the current policy s return. the actor updates the current policy based on the critic s predictions or more exactly on changes in the critic s predictions. the td error produced by the critic acts as a conditioned reinforcement signal for the actor providing an immediate evaluation of performance even when the primary reward signal itself is considerably delayed. algorithms that estimate actionvalue functions such as q-learning and sarsa similarly use td learning principles to enable learning with delayed reinforcement by means of conditioned reinforcement. the close parallel between td learning and the activity of dopamine producing neurons that we discuss in chapter lends additional support to links between reinforcement learning algorithms and this aspect of hull s learning theory. cognitive maps model-based reinforcement learning algorithms use environment models that have elements in common with what psychologists call cognitive maps. recall from our discussion of planning and learning in chapter that by an environment model we mean anything an agent can use to predict how its environment will respond to its actions in terms of state transitions and rewards and by planning we mean any process that computes a chapter psychology policy from such a model. environment models consist of two parts the state-transition part encodes knowledge about the effect of actions on state changes and the rewardmodel part encodes knowledge about the reward signals expected for each state or each state action pair. a model-based algorithm selects actions by using a model to predict the consequences of possible courses of action in terms of future states and the reward signals expected to arise from those states. the simplest kind of planning is to compare the predicted consequences of collections of imagined sequences of decisions. questions about whether or not animals use environment models and if so what are the models like and how are they learned have played influential roles in the history of animal learning research. some researchers challenged the then-prevailing stimulusresponse r view of learning and behavior which corresponds to the simplest modelfree way of learning policies by demonstrating latent learning. in the earliest latent learning experiment two groups of rats were run in a maze. for the experimental group there was no reward during the first stage of the experiment but food was suddenly introduced into the goal box of the maze at the start of the second stage. for the control group food was in the goal box throughout both stages. the question was whether or not rats in the experimental group would have learned anything during the first stage in the absence of food reward. although the experimental rats did not appear to learn much during the first unrewarded stage as soon as they discovered the food that was introduced in the second stage they rapidly caught up with the rats in the control group. it was concluded that during the non-reward period the rats the experimental group were developing a latent learning of the maze which they were able to utilize as soon as reward was introduced latent learning is most closely associated with the psychologist edward tolman who interpreted this result and others like it as showing that animals could learn a cognitive map of the environment in the absence of rewards or penalties and that they could use the map later when they were motivated to reach a goal a cognitive map could also allow a rat to plan a route to the goal that was different from the route the rat had used in its initial exploration. explanations of results like these led to the enduring controversy lying at the heart of the behavioristcognitive dichotomy in psychology. in modern terms cognitive maps are not restricted to models of spatial layouts but are more generally environment models or models of an animal s task space wilson takahashi schoenbaum and niv the cognitive map explanation of latent learning experiments is analogous to the claim that animals use model-based algorithms and that environment models can be learned even without explicit rewards or penalties. models are then used for planning when the animal is motivated by the appearance of rewards or penalties. tolman s account of how animals learn cognitive maps was that they learn stimulusstimulus or s s associations by experiencing successions of stimuli as they explore an environment. in psychology this is called expectancy theory given s s associations the occurrence of a stimulus generates an expectation about the stimulus to come next. this is much like what control engineers call system identification in which a model of a system with unknown dynamics is learned from labeled training examples. in the simplest discrete-time versions training examples are s pairs where s is a state habitual and goal-directed behavior and the subsequent state is the label. when s is observed the model creates the expectation that will be observed next. models more useful for planning involve actions as well so that examples look like sa where is expected when action a is executed in state s. it is also useful to learn how the environment generates rewards. in this case examples are of the form s r or sa r where r is a reward signal associated with s or the sa pair. these are all forms of supervised learning by which an agent can acquire cognitive-like maps whether or not it receives any non-zero reward signals while exploring its environment. habitual and goal-directed behavior the distinction between model-free and model-based reinforcement learning algorithms corresponds to the distinction psychologists make between habitual and goal-directed control of learned behavioral patterns. habits are behavior patterns triggered by appropriate stimuli and then performed more-or-less automatically. goal-directed behavior according to how psychologists use the phrase is purposeful in the sense that it is controlled by knowledge of the value of goals and the relationship between actions and their consequences. habits are sometimes said to be controlled by antecedent stimuli whereas goal-directed behavior is said to be controlled by its consequences goal-directed control has the advantage that it can rapidly change an animal s behavior when the environment changes its way of reacting to the animal s actions. while habitual behavior responds quickly to input from an accustomed environment it is unable to quickly adjust to changes in the environment. the development of goal-directed behavioral control was likely a major advance in the evolution of animal intelligence. figure illustrates the difference between model-free and model-based decision strategies in a hypothetical task in which a rat has to navigate a maze that has distinctive goal boxes each delivering an associated reward of the magnitude shown top. starting at the rat has to first select left or right and then has to select l or r again at or to reach one of the goal boxes. the goal boxes are the terminal states of each episode of the rat s episodic task. a model-free strategy lower left relies on stored values for state action pairs. these action values are estimates of the highest return the rat can expect for each action taken from each state. they are obtained over many trials of running the maze from start to finish. when the action values have become good enough estimates of the optimal returns the rat just has to select at each state the action with the largest action value in order to make optimal decisions. in this case when the action-value estimates become accurate enough the rat selects l from and r from to obtain the maximum return of a different model-free strategy might simply rely on a cached policy instead of action values making direct links from to l and from to r. in neither of these strategies do decisions rely on an environment model. there is no need to consult a state-transition model and no connection is required between the features of the goal boxes and the rewards they deliver. figure right illustrates a model-based strategy. it uses an environment model consisting of a state-transition model and a reward model. the state-transition chapter psychology figure model-based and model-free strategies to solve a hypothetical sequential actionselection problem. top a rat navigates a maze with distinctive goal boxes each associated with a reward having the value shown. lower left a model-free strategy relies on stored action values for all the state action pairs obtained over many learning trials. to make decisions the rat just has to select at each state the action with the largest action value for that state. lower right in a model-based strategy the rat learns an environment model consisting of knowledge of state action-next-state transitions and a reward model consisting of knowledge of the reward associated with each distinctive goal box. the rat can decide which way to turn at each state by using the model to simulate sequences of action choices to find a path yielding the highest return. adapted from trends in cognitive science volume number y. niv d. joel and p. dayan a normative perspective on motivation p. with permission from elsevier. model is shown as a decision tree and the reward model associates the distinctive features of the goal boxes with the rewards to be found in each. rewards associated with states and are also part of the reward model but here they are zero and are not shown. a model-based agent can decide which way to turn at each state by using the model to simulate sequences of action choices to find a path yielding the highest return. in this case the return is the reward obtained from the outcome at the end of the path. here with a sufficiently accurate model the rat would select l and then r to obtain reward of comparing the predicted returns of simulated paths is a simple form of planning which can be done in a variety of ways as discussed in chapter when the environment of a model-free agent changes the way it reacts to the agent s actions the agent has to acquire new experience in the changed environment during which it can update its policy andor value function. in the model-free strategy shown habitual and goal-directed behavior in figure left for example if one of the goal boxes were to somehow shift to delivering a different reward the rat would have to traverse the maze possibly many times to experience the new reward upon reaching that goal box all the while updating either its policy or its action-value function both based on this experience. the key point is that for a model-free agent to change the action its policy specifies for a state or to change an action value associated with a state it has to move to that state act from it possibly many times and experience the consequences of its actions. a model-based agent can accommodate changes in its environment without this kind of personal experience with the states and actions affected by the change. a change in its model automatically planning changes its policy. planning can determine the consequences of changes in the environment that have never been linked together in the agent s own experience. for example again referring to the maze task of figure imagine that a rat with a previously learned transition and reward model is placed directly in the goal box to the right of to find that the reward available there now has value instead of the rat s reward model will change even though the action choices required to find that goal box in the maze were not involved. the planning process will bring knowledge of the new reward to bear on maze running without the need for additional experience in the maze in this case changing the policy to right turns at both and to obtain a return of exactly this logic is the basis of outcome-devaluation experiments with animals. results from these experiments provide insight into whether an animal has learned a habit or if its behavior is under goal-directed control. outcome-devaluation experiments are like latent-learning experiments in that the reward changes from one stage to the next. after an initial rewarded stage of learning the reward value of an outcome is changed including being shifted to zero or even to a negative value. an early important experiment of this type was conducted by adams and dickinson they trained rats via instrumental conditioning until the rats energetically pressed a lever for sucrose pellets in a training chamber. the rats were then placed in the same chamber with the lever retracted and allowed non-contingent food meaning that pellets were made available to them independently of their actions. after of this free-access to the pellets rats in one group were injected with the nausea-inducing poison lithium chloride. this was repeated for three sessions in the last of which none of the injected rats consumed any of the non-contingent pellets indicating that the reward value of the pellets had been decreased the pellets had been devalued. in the next stage taking place a day later the rats were again placed in the chamber and given a session of extinction training meaning that the response lever was back in place but disconnected from the pellet dispenser so that pressing it did not release pellets. the question was whether the rats that had the reward value of the pellets decreased would lever-press less than rats that did not have the reward value of the pellets decreased even without experiencing the devalued reward as a result of lever-pressing. it turned out that the injected rats had significantly lower response rates than the non-injected rats right from the start of the extinction trials. adams and dickinson concluded that the injected rats associated lever pressing with consequent nausea by means of a cognitive map linking lever pressing to pellets and chapter psychology pellets to nausea. hence in the extinction trials the rats knew that the consequences of pressing the lever would be something they did not want and so they reduced their lever-pressing right from the start. the important point is that they reduced leverpressing without ever having experienced lever-pressing directly followed by being sick no lever was present when they were made sick. they seemed able to combine knowledge of the outcome of a behavioral choice the lever will be followed by getting a pellet with the reward value of the outcome are to be avoided and hence could alter their behavior accordingly. not every psychologist agrees with this cognitive account of this kind of experiment and it is not the only possible way to explain these results but the model-based planning explanation is widely accepted. nothing prevents an agent from using both model-free and model-based algorithms and there are good reasons for using both. we know from our own experience that with enough repetition goal-directed behavior tends to turn into habitual behavior. experiments show that this happens for rats too. adams conducted an experiment to see if extended training would convert goal-directed behavior into habitual behavior. he did this by comparing the effect of outcome devaluation on rats that experienced different amounts of training. if extended training made the rats less sensitive to devaluation compared to rats that received less training this would be evidence that extended training made the behavior more habitual. adams experiment closely followed the adams and dickinson experiment just described. simplifying a bit rats in one group were trained until they made rewarded lever-presses and rats in the other group the overtrained group were trained until they made rewarded lever-presses. after this training the reward value of the pellets was decreased lithium chloride injections for rats in both groups. then both groups of rats were given a session of extinction training. adams question was whether devaluation would effect the rate of lever-pressing for the overtrained rats less than it would for the non-overtrained rats which would be evidence that extended training reduces sensitivity to outcome devaluation. it turned out that devaluation strongly decreased the lever-pressing rate of the non-overtrained rats. for the overtrained rats in contrast devaluation had little effect on their lever-pressing in fact if anything it made it more vigorous. full experiment included control groups showing that the different amounts of training did not by themselves significantly effect lever-pressing rates after learning. this result suggested that while the non-overtrained rats were acting in a goal-directed manner sensitive to their knowledge of the outcome of their actions the overtrained rats had developed a lever-pressing habit. viewing this and other results like it from a computational perspective provides insight as to why one might expect animals to behave habitually in some circumstances in a goal-directed way in others and why they shift from one mode of control to another as they continue to learn. while animals undoubtedly use algorithms that do not exactly match those we have presented in this book one can gain insight into animal behavior by considering the tradeoffs that various reinforcement learning algorithms imply. an idea developed by computational neuroscientists daw niv and dayan is that animals use both model-free and model-based processes. each process proposes an action and the action chosen for execution is the one proposed by the process judged to be the more trustworthy of the two as determined by measures of confidence that are maintained summary throughout learning. early in learning the planning process of a model-based system is more trustworthy because it chains together short-term predictions which can become accurate with less experience than long-term predictions of the model-free process. but with continued experience the model-free process becomes more trustworthy because planning is prone to making mistakes due to model inaccuracies and short-cuts necessary to make planning feasible such as various forms of tree-pruning the removal of unpromising search tree branches. according to this idea one would expect a shift from goal-directed behavior to habitual behavior as more experience accumulates. other ideas have been proposed for how animals arbitrate between goal-directed and habitual control and both behavioral and neuroscience research continues to examine this and related questions. the distinction between model-free and model-based algorithms is proving to be useful for this research. one can examine the computational implications of these types of algorithms in abstract settings that expose basic advantages and limitations of each type. this serves both to suggest and to sharpen questions that guide the design of experiments necessary for increasing psychologists understanding of habitual and goaldirected behavioral control. summary our goal in this chapter has been to discuss correspondences between reinforcement learning and the experimental study of animal learning in psychology. we emphasized at the outset that reinforcement learning as described in this book is not intended to model details of animal behavior. it is an abstract computational framework that explores idealized situations from the perspective of artificial intelligence and engineering. but many of the basic reinforcement learning algorithms were inspired by psychological theories and in some cases these algorithms have contributed to the development of new animal learning models. this chapter described the most conspicuous of these correspondences. the distinction in reinforcement learning between algorithms for prediction and algorithms for control parallels animal learning theory s distinction between classical or pavlovian conditioning and instrumental conditioning. the key difference between instrumental and classical conditioning experiments is that in the former the reinforcing stimulus is contingent upon the animal s behavior whereas in the latter it is not. learning to predict via a td algorithm corresponds to classical conditioning and we described the td model of classical conditioning as one instance in which reinforcement learning principles account for some details of animal learning behavior. this model generalizes the influential rescorla wagner model by including the temporal dimension where events within individual trials influence learning and it provides an account of secondorder conditioning where predictors of reinforcing stimuli become reinforcing themselves. it also is the basis of an influential view of the activity of dopamine neurons in the brain something we take up in chapter learning by trial and error is at the base of the control aspect of reinforcement learning. we presented some details about thorndike s experiments with cats and other animals chapter psychology that led to his law of effect which we discussed here and in chapter we pointed out that in reinforcement learning exploration does not have to be limited to blind groping trials can be generated by sophisticated methods using innate and previously learned knowledge as long as there is some exploration. we discussed the training method b. f. skinner called shaping in which reward contingencies are progressively altered to train an animal to successively approximate a desired behavior. shaping is not only indispensable for animal training it is also an effective tool for training reinforcement learning agents. there is also a connection to the idea of an animal s motivational state which influences what an animal will approach or avoid and what events are rewarding or punishing for the animal. the reinforcement learning algorithms presented in this book include two basic mechanisms for addressing the problem of delayed reinforcement eligibility traces and value functions learned via td algorithms. both mechanisms have antecedents in theories of animal learning. eligibility traces are similar to stimulus traces of early theories and value functions correspond to the role of secondary reinforcement in providing nearly immediate evaluative feedback. the next correspondence the chapter addressed is that between reinforcement learning s environment models and what psychologists call cognitive maps. experiments conducted in the mid century purported to demonstrate the ability of animals to learn cognitive maps as alternatives to or as additions to state action associations and later use them to guide behavior especially when the environment changes unexpectedly. environment models in reinforcement learning are like cognitive maps in that they can be learned by supervised learning methods without relying on reward signals and then they can be used later to plan behavior. reinforcement learning s distinction between model-free and model-based algorithms corresponds to the distinction in psychology between habitual and goal-directed behavior. model-free algorithms make decisions by accessing information that has been strored in a policy or an action-value function whereas model-based methods select actions as the result of planning ahead using a model of the agent s environment. outcome-devaluation experiments provide information about whether an animal s behavior is habitual or under goal-directed control. reinforcement learning theory has helped clarify thinking about these issues. animal learning clearly informs reinforcement learning but as a type of machine learning reinforcement learning is directed toward designing and understanding effective learning algorithms not toward replicating or explaining details of animal behavior. we focused on aspects of animal learning that relate in clear ways to methods for solving prediction and control problems highlighting the fruitful two-way flow of ideas between reinforcement learning and psychology without venturing deeply into many of the behavioral details and controversies that have occupied the attention of animal learning researchers. future development of reinforcement learning theory and algorithms will likely exploit links to many other features of animal learning as the computational utility of these features becomes better appreciated. we expect that a flow of ideas between reinforcement learning and psychology will continue to bear fruit for both disciplines. many connections between reinforcement learning and areas of psychology and other summary behavioral sciences are beyond the scope of this chapter. we largely omit discussing links to the psychology of decision making which focuses on how actions are selected or how decisions are made after learning has taken place. we also do not discuss links to ecological and evolutionary aspects of behavior studied by ethologists and behavioral ecologists how animals relate to one another and to their physical surroundings and how their behavior contributes to evolutionary fitness. optimization mdps and dynamic programming figure prominently in these fields and our emphasis on agent interaction with dynamic environments connects to the study of agent behavior in complex ecologies. multi-agent reinforcement learning omitted in this book has connections to social aspects of behavior. despite the lack of treatment here reinforcement learning should by no means be interpreted as dismissing evolutionary perspectives. nothing about reinforcement learning implies a tabula rasa view of learning and behavior. indeed experience with engineering applications has highlighted the importance of building into reinforcement learning systems knowledge that is analogous to what evolution provides to animals. bibliographical and historical remarks ludvig bellemare and pearson and shah review reinforcement learning in the contexts of psychology and neuroscience. these publications are useful companions to this chapter and the following chapter on reinforcement learning and neuroscience. dayan niv seymour and daw focused on interactions between classical and instrumental conditioning particularly situations where classicallyconditioned and instrumental responses are in conflict. they proposed a qlearning framework for modeling aspects of this interaction. modayil and sutton used a mobile robot to demonstrate the effectiveness of a control method combining a fixed response with online prediction learning. calling this pavlovian control they emphasized that it differs from the usual control methods of reinforcement learning being based on predictively executing fixed responses and not on reward maximization. the electro-mechanical machine of ross and especially the learning version of walter s turtle were very early illustrations of pavlovian control. kamin first reported blocking now commonly known as kamin blocking in classical conditioning. moore and schmajuk provide an excellent summary of the blocking phenomenon the research it stimulated and its lasting influence on animal learning theory. gibbs cool land kehoe and gormezano describe second-order conditioning of the rabbit s nictitating membrane response and its relationship to conditioning with serial-compound stimuli. finch and culler reported obtaining fifth-order conditioning of a dog s foreleg withdrawal when the motivation of the animal is maintained through the various orders. the idea built into the rescorla wagner model that learning occurs when ani chapter psychology mals are surprised is derived from kamin models of classical conditioning other than rescorla and wagner s include the models of klopf grossberg mackintosh moore and stickney pearce and hall and courville daw and touretzky schmajuk review models of classical conditioning. an early version of the td model of classical conditioning appeared in sutton and barto which also included the early model s prediction that temporal primacy overrides blocking later shown by kehoe schreurs and graham to occur in the rabbit nictitating membrane preparation. sutton and barto contains the earliest recognition of the near identity between the rescorla wagner model and the least-mean-square or widrow-hoff learning rule and hoff this early model was revised following sutton s development of the td algorithm and was first presented as the td model in sutton and barto and more completely in sutton and barto upon which this section is largely based. additional exploration of the td model and its possible neural implementation was conducted by moore and colleagues desmond berthier blazis sutton and barto moore and blazis moore choi and brunzell moore marks castagna and polewan klopf s drive-reinforcement theory of classical conditioning extends the td model to address additional experimental details such as the s-shape of acquisition curves. in some of these publications td is taken to mean time derivative instead of temporal difference. ludvig sutton and kehoe evaluated the performance of the td model in previously unexplored tasks involving classical conditioning and examined the influence of various stimulus representations including the microstimulus representation that they introduced earlier sutton and kehoe earlier investigations of the influence of various stimulus representations and their possible neural implementations on response timing and topography in the context of the td model are those of moore and colleagues cited above. although not in the context of the td model representations like the microstimulus representation of ludvig et al. have been proposed and studied by grossberg and schmajuk brown bullock and grossberg buhusi and schmajuk and machado section includes comments on the history of trial-and-error learning and the law of effect. the idea that thorndikes cats might have been exploring according to an instinctual context-specific ordering over actions rather than by just selecting from a set of instinctual impulses was suggested by peter dayan communication. selfridge sutton and barto illustrated the effectiveness of shaping in a pole-balancing reinforcement learning task. other examples of shaping in reinforcement learning are gullapalli and barto mahadevan and connell mataric dorigo and colombette saksida raymond and touretzky and randl v and alstr m ng and ng harada and russell used the term shaping in a sense summary somewhat different from skinner s focussing on the problem of how to alter the reward signal without altering the set of optimal policies. dickinson and balleine discuss the complexity of the interaction between learning and motivation. wise provides an overview of reinforcement learning and its relation to motivation. daw and shohamy link motivation and learning to aspects of reinforcement learning theory. see also mcclure daw and montague niv joel and dayan rangel camerer and montague and dayan and berridge mcclure et al. niv daw and dayan and niv daw joel and dayan present theories of behavioral vigor related to the reinforcement learning framework. spence hull s student and collaborator at yale elaborated the role of higherorder reinforcement in addressing the problem of delayed reinforcement learning over very long delays as in taste-aversion conditioning with delays up to several hours led to interference theories as alternatives to decayingtrace theories revusky and garcia boakes and costa other views of learning under delayed reinforcement invoke roles for awareness and working memory clark and squire seo barraclough and lee thistlethwaite provides an extensive review of latent learning experiments up to the time of its publication. ljung provides an overview of model learning or system identification techniques in engineering. gopnik glymour sobel schulz kushnir and danks present a bayesian theory about how children learn models. connections between habitual and goal-directed behavior and model-free and model-based reinforcement learning were first proposed by daw niv and dayan the hypothetical maze task used to explain habitual and goal-directed behavioral control is based on the explanation of niv joel and dayan dolan and dayan review four generations of experimental research related to this issue and discuss how it can move forward on the basis of reinforcement learning s model-freemodel-based distinction. dickinson and dickinson and balleine discuss experimental evidence related to this distinction. donahoe and burgos alternatively argue that model-free processes can account for the results of outcome-devaluation experiments. dayan and berridge argue that classical conditioning involves model-based processes. rangel camerer and montague review many of the outstanding issues involving habitual goal-directed and pavlovian modes of control. comments on terminology the traditional meaning of reinforcement in psychology is the strengthening of a pattern of behavior increasing either its intensity or frequency as a result of an animal receiving a stimulus experiencing the omission of a stimulus in an appropriate temporal relationship with another stimulus or with a response. reinforcement produces changes that remain in future behavior. sometimes in psychology reinforcement refers to the process of producing lasting changes in behavior whether the changes strengthen or weaken a behavior pattern chapter psychology letting reinforcement refer to weakening in addition to strengthening is at odds with the everyday meaning of reinforce and its traditional use in psychology but it is a useful extension that we have adopted here. in either case a stimulus considered to be the cause of the behavioral change is called a reinforcer. psychologists do not generally use the specific phrase reinforcement learning as we do. animal learning pioneers probably regarded reinforcement and learning as being synonymous so it would be redundant to use both words. our use of the phrase follows its use in computational and engineering research influenced mostly by minsky but the phrase is lately gaining currency in psychology and neuroscience likely because strong parallels have surfaced between reinforcement learning algorithms and animal learning parallels described in this chapter and the next. according to common usage a reward is an object or event that an animal will approach and work for. a reward may be given to an animal in recognition of its good behavior or given in order to make the animal s behavior better. similarly a penalty is an object or event that the animal usually avoids and that is given as a consequence of bad behavior usually in order to change that behavior. primary reward is reward due to machinery built into an animal s nervous system by evolution to improve its chances of survival and reproduction e.g. reward produced by the taste of nourishing food sexual contact successful escape and many other stimuli and events that predicted reproductive success over the animal s ancestral history. as explained in section higher-order reward is reward delivered by stimuli that predict primary reward either directly or indirectly by predicting other stimuli that predict primary reward. reward is secondary if its rewarding quality is the result of directly predicting primary reward. in this book we call rt the reward signal at time t or sometimes just the reward at time t but we do not think of it as an object or event in the agent s environment. because rt is a number not an object or an event it is more like a reward signal in neuroscience which is a signal internal to the brain like the activity of neurons that influences decision making and learning. this signal might be triggered when the animal perceives an attractive an aversive object but it can also be triggered by things that do not physically exist in the animal s external environment such as memories ideas or hallucinations. because our rt can be positive negative or zero it might be better to call a negative rt a penalty and an rt equal to zero a neutral signal but for simplicity we generally avoid these terms. in reinforcement learning the process that generates all the rts defines the problem the agent is trying to solve. the agent s objective is to keep the magnitude of rt as large as possible over time. in this respect rt is like primary reward for an animal if we think of the problem the animal faces as the problem of obtaining as much primary reward as possible over its lifetime thereby through the prospective wisdom of evolution improve its chances of solving its real problem which is to pass its genes on to future generations. however as we suggest in chapter it is unlikely that there is a single master reward signal like rt in an animal s brain. not all reinforcers are rewards or penalties. sometimes reinforcement is not the result of an animal receiving a stimulus that evaluates its behavior by labeling the behavior good or bad. a behavior pattern can be reinforced by a stimulus that arrives to an animal summary no matter how the animal behaved. as described in section whether the delivery of reinforcer depends or does not depend on preceding behavior is the defining difference between instrumental or operant conditioning experiments and classical or pavlovian conditioning experiments. reinforcement is at work in both types of experiments but only in the former is it feedback that evaluates past behavior. it has often been pointed out that even when the reinforcing us in a classical conditioning experiment is not contingent on the subject s preceding behavior its reinforcing value can be influenced by this behavior an example being that a closed eye makes an air puff to the eye less aversive. the distinction between reward signals and reinforcement signals is a crucial point when we discuss neural correlates of these signals in the next chapter. like a reward signal for us the reinforcement signal at any specific time is a positive or negative number or zero. a reinforcement signal is the major factor directing changes a learning algorithm makes in an agent s policy value estimates or environment models. the definition that makes the most sense to us is that a reinforcement signal at any time is a number that multiplies along with some constants a vector to determine parameter updates in some learning algorithm. for some algorithms the reward signal alone is the critical multiplier in the parameterupdate equation. for these algorithms the reinforcement signal is the same as the reward signal. but for most of the algorithms we discuss in this book reinforcement signals include terms in addition to the reward signal an example being a td error t v v which is the reinforcement signal for td state-value learning analogous td errors for action-value learning. in this reinforcement signal is the primary reinforcement contribution and the temporal difference in predicted values v v an analogous temporal difference for action values is the conditioned reinforcement contribution. thus whenever v v t signals pure primary reinforcement and whenever it signals pure conditioned reinforcement but it often signals a mixture of these. note as we mentioned in section this t is not available until time t we therefore think of t as the reinforcement signal at time which is fitting because it reinforces predictions andor actions made earlier at step t. a possible source of confusion is the terminology used by the famous psychologist b. f. skinner and his followers. for skinner positive reinforcement occurs when the consequences of an animal s behavior increase the frequency of that behavior punishment occurs when the behavior s consequences decrease that behavior s frequency. negative reinforcement occurs when behavior leads to the removal of an aversive stimulus is a stimulus the animal does not like thereby increasing the frequency of that behavior. negative punishment on the other hand occurs when behavior leads to the removal of an appetitive stimulus is a stimulus the animal likes thereby decreasing the frequency of that behavior. we find no critical need for these distinctions because our approach is more abstract than this with both reward and reinforcement signals allowed to take on both positive and negative values. note especially that when our reinforcement signal is negative it is not the same as skinner s negative reinforcement. chapter psychology on the other hand it has often been pointed out that using a single number as a reward or a penalty signal depending only on its sign is at odds with the fact that animals appetitive and aversive systems have qualitatively different properties and involve different brain mechanisms. this points to a direction in which the reinforcement learning framework might be developed in the future to exploit computational advantages of separate appetitive and aversive systems but for now we are passing over these possibilities. another discrepancy in terminology is how we use the word action. to many cognitive scientists an action is purposeful in the sense of being the result of an animal s knowledge about the relationship between the behavior in question and the consequences of that behavior. an action is goal-directed and the result of a decision in contrast to a response which is triggered by a stimulus the result of a reflex or a habit. we use the word action without differentiating among what others call actions decisions and responses. these are important distinctions but for us they are encompassed by differences between model-free and model-based reinforcement learning algorithms which we discussed above in relation to habitual and goal-directed behavior in section dickinson discusses the distinction between responses and actions. a term used a lot in this book is control. what we mean by control is entirely different from what it means to animal learning psychologists. by control we mean that an agent influences its environment to bring about states or events that the agent prefers the agent exerts control over its environment. this is the sense of control used by control engineers. in psychology on the other hand control typically means that an animal s behavior is influenced by is controlled by the stimuli the animal receives control or the reinforcement schedule it experiences. here the environment is controlling the agent. control in this sense is the basis of behavior modification therapy. of course both of these directions of control are at play when an agent interacts with its environment but our focus is on the agent as controller not the environment as controller. a view equivalent to ours and perhaps more illuminating is that the agent is actually controlling the input it receives from its environment this is not what psychologists mean by stimulus control. sometimes reinforcement learning is understood to refer solely to learning policies directly from rewards penalties without the involvement of value functions or environment models. this is what psychologists call stimulus-response or s-r learning. but for us along with most of today s psychologists reinforcement learning is much broader than this including in addition to s-r learning methods involving value functions environment models planning and other processes that are commonly thought to belong to the more cognitive side of mental functioning. chapter neuroscience neuroscience is the multidisciplinary study of nervous systems how they regulate bodily functions control behavior change over time as a result of development learning and aging and how cellular and molecular mechanisms make these functions possible. one of the most exciting aspects of reinforcement learning is the mounting evidence from neuroscience that the nervous systems of humans and many other animals implement algorithms that correspond in striking ways to reinforcement learning algorithms. the main objective of this chapter is to explain these parallels and what they suggest about the neural basis of reward-related learning in animals. the most remarkable point of contact between reinforcement learning and neuroscience involves dopamine a chemical deeply involved in reward processing in the brains of mammals. dopamine appears to convey temporal-difference errors to brain structures where learning and decision making take place. this parallel is expressed by the reward prediction error hypothesis of dopamine neuron activity a hypothesis that resulted from the convergence of computational reinforcement learning and results of neuroscience experiments. in this chapter we discuss this hypothesis the neuroscience findings that led to it and why it is a significant contribution to understanding brain reward systems. we also discuss parallels between reinforcement learning and neuroscience that are less striking than this dopaminetd-error parallel but that provide useful conceptual tools for thinking about reward-based learning in animals. other elements of reinforcement learning have the potential to impact the study of nervous systems but their connections to neuroscience are still relatively undeveloped. we discuss several of these evolving connections that we think will grow in importance over time. as we outlined in the history section of this book s introductory chapter many aspects of reinforcement learning were influenced by neuroscience. a second objective of this chapter is to acquaint readers with ideas about brain function that have contributed to our approach to reinforcement learning. some elements of reinforcement learning are easier to understand when seen in light of theories of brain function. this is particularly true for the idea of the eligibility trace one of the basic mechanisms of reinforcement learning that originated as a conjectured property of synapses the structures by which nerve cells neurons communicate with one another. chapter neuroscience in this chapter we do not delve very deeply into the enormous complexity of the neural systems underlying reward-based learning in animals this chapter is too short and we are not neuroscientists. we do not try to describe or even to name the very many brain structures and pathways or any of the molecular mechanisms believed to be involved in these processes. we also do not do justice to hypotheses and models that are alternatives to those that align so well with reinforcement learning. it should not be surprising that there are differing views among experts in the field. we can only provide a glimpse into this fascinating and developing story. we hope though that this chapter convinces you that a very fruitful channel has emerged connecting reinforcement learning and its theoretical underpinnings to the neuroscience of reward-based learning in animals. many excellent publications cover links between reinforcement learning and neuroscience some of which we cite in this chapter s final section. our treatment differs from most of these because we assume familiarity with reinforcement learning as presented in the earlier chapters of this book but we do not assume knowledge of neuroscience. we begin with a brief introduction to the neuroscience concepts needed for a basic understanding of what is to follow. neuroscience basics some basic information about nervous systems is helpful for following what we cover in this chapter. terms that we refer to later are italicized. skipping this section will not be a problem if you already have an elementary knowledge of neuroscience. neurons the main components of nervous systems are cells specialized for processing and transmitting information using electrical and chemical signals. they come in many forms but a neuron typically has a cell body dendrites and a single axon. dendrites are structures that branch from the cell body to receive input from other neurons to also receive external signals in the case of sensory neurons. a neuron s axon is a fiber that carries the neuron s output to other neurons to muscles or glands. a neuron s output consists of sequences of electrical pulses called action potentials that travel along the axon. action potentials are also called spikes and a neuron is said to fire when it generates a spike. in models of neural networks it is common to use real numbers to represent a neuron s firing rate the average number of spikes per some unit of time. a neuron s axon can branch widely so that the neuron s action potentials reach many targets. the branching structure of a neuron s axon is called the neuron s axonal arbor. because the conduction of an action potential is an active process not unlike the burning of a fuse when an action potential reaches an axonal branch point it lights up action potentials on all of the outgoing branches propagation to a branch can sometimes fail. as a result the activity of a neuron with a large axonal arbor can influence many target sites. a synapse is a structure generally at the termination of an axon branch that mediates the communication of one neuron to another. a synapse transmits information from the presynaptic neuron s axon to a dendrite or cell body of the postsynaptic neuron. with a few exceptions synapses release a chemical neurotransmitter upon the arrival reward signals reinforcement signals values and prediction errors of an action potential from the presynaptic neuron. exceptions are cases of direct electric coupling between neurons but these will not concern us here. neurotransmitter molecules released from the presynaptic side of the synapse diffuse across the synaptic cleft the very small space between the presynaptic ending and the postsynaptic neuron and then bind to receptors on the surface of the postsynaptic neuron to excite or inhibit its spike-generating activity or to modulate its behavior in other ways. a particular neurotransmitter may bind to several different types of receptors with each producing a different effect on the postsynaptic neuron. for example there are at least five different receptor types by which the neurotransmitter dopamine can affect a postsynaptic neuron. many different chemicals have been identified as neurotransmitters in animal nervous systems. a neuron s background activity is its level of activity usually its firing rate when the neuron does not appear to be driven by synaptic input related to the task of interest to the experimenter for example when the neuron s activity is not correlated with a stimulus delivered to a subject as part of an experiment. background activity can be irregular due to input from the wider network or due to noise within the neuron or its synapses. sometimes background activity is the result of dynamic processes intrinsic to the neuron. a neuron s phasic activity in contrast to its background activity consists of bursts of spiking activity usually caused by synaptic input. activity that varies slowly and often in a graded manner whether as background activity or not is called a neuron s tonic activity. the strength or effectiveness by which the neurotransmitter released at a synapse influences the postsynaptic neuron is the synapse s efficacy. one way a nervous system can change through experience is through changes in synaptic efficacies as a result of combinations of the activities of the presynaptic and postsynaptic neurons and sometimes by the presence of a neuromodulator which is a neurotransmitter having effects other than or in addition to direct fast excitation or inhibition. brains contain several different neuromodulation systems consisting of clusters of neurons with widely branching axonal arbors with each system using a different neurotransmitter. neuromodulation can alter the function of neural circuits mediate motivation arousal attention memory mood emotion sleep and body temperature. important here is that a neuromodulatory system can distribute something like a scalar signal such as a reinforcement signal to alter the operation of synapses in widely distributed sites critical for learning. the ability of synaptic efficacies to change is called synaptic plasticity. it is one of the primary mechanisms responsible for learning. the parameters or weights adjusted by learning algorithms correspond to synaptic efficacies. as we detail below modulation of synaptic plasticity via the neuromodulator dopamine is a plausible mechanism for how the brain might implement learning algorithms like many of those described in this book. chapter neuroscience reward signals reinforcement signals values and prediction errors links between neuroscience and computational reinforcement learning begin as parallels between signals in the brain and signals playing prominent roles in reinforcement learning theory and algorithms. in chapter we said that any problem of learning goal-directed behavior can be reduced to the three signals representing actions states and rewards. however to explain links that have been made between neuroscience and reinforcement learning we have to be less abstract than this and consider other reinforcement learning signals that correspond in certain ways to signals in the brain. in addition to reward signals these include reinforcement signals we argue are different from reward signals value signals and signals conveying prediction errors. when we label a signal by its function in this way we are doing it in the context of reinforcement learning theory in which the signal corresponds to a term in an equation or an algorithm. on the other hand when we refer to a signal in the brain we mean a physiological event such as a burst of action potentials or the secretion of a neurotransmitter. labeling a neural signal by its function for example calling the phasic activity of a dopamine neuron a reinforcement signal means that the neural signal behaves like and is conjectured to function like the corresponding theoretical signal. uncovering evidence for these correspondences involves many challenges. neural activity related to reward processing can be found in nearly every part of the brain and it is difficult to interpret results unambiguously because representations of different rewardrelated signals tend to be highly correlated with one another. experiments need to be carefully designed to allow one type of reward-related signal to be distinguished with any degree of certainty from others or from an abundance of other signals not related to reward processing. despite these difficulties many experiments have been conducted with the aim of reconciling aspects of reinforcement learning theory and algorithms with neural signals and some compelling links have been established. to prepare for examining these links in the rest of this section we remind the reader of what various reward-related signals mean according to reinforcement learning theory. in our comments on terminology at the end of the previous chapter we said that rt is like a reward signal in an animal s brain and not an object or event in the animal s environment. in reinforcement learning the reward signal with an agent s environment defines the problem a reinforcement learning agent is trying to solve. in this respect rt is like a signal in an animal s brain that distributes primary reward to sites throughout the brain. but it is unlikely that a unitary master reward signal like rt exists in an animal s brain. it is best to think of rt as an abstraction summarizing the overall effect of a multitude of neural signals generated by many systems in the brain that assess the rewarding or punishing qualities of sensations and states. reinforcement signals in reinforcement learning are different from reward signals. the function of a reinforcement signal is to direct the changes a learning algorithm makes in an agent s policy value estimates or environment models. for a td method for instance the reinforcement signal at time t is the td error t rt v v the as we mentioned in section t in our notation is defined to be v v so t the reward prediction error hypothesis reinforcement signal for some algorithms could be just the reward signal but for most of the algorithms we consider the reinforcement signal is the reward signal adjusted by other information such as the value estimates in td errors. estimates of state values or of action values that is v or q specify what is good or bad for the agent over the long run. they are predictions of the total reward an agent can expect to accumulate over the future. agents make good decisions by selecting actions leading to states with the largest estimated state values or by selecting actions with the largest estimated action values. prediction errors measure discrepancies between expected and actual signals or sensations. reward prediction errors specifically measure discrepancies between the expected and the received reward signal being positive when the reward signal is greater than expected and negative otherwise. td errors like are special kinds of rpes that signal discrepancies between current and earlier expectations of reward over the long-term. when neuroscientists refer to rpes they generally not always mean td rpes which we simply call td errors throughout this chapter. also in this chapter a td error is generally one that does not depend on actions as opposed to td errors used in learning action-values by algorithms like sarsa and q-learning. this is because the most well-known links to neuroscience are stated in terms of action-free td errors but we do not mean to rule out possible similar links involving action-dependent td errors. errors for predicting signals other than rewards are useful too but that case will not concern us here. see for example modayil white and sutton one can ask many questions about links between neuroscience data and these theoretically defined signals. is an observed signal more like a reward signal a value signal a prediction error a reinforcement signal or something altogether different? and if it is an error signal is it an rpe a td error or a simpler error like the rescorla wagner error and if it is a td error does it depend on actions like the td error of qlearning or sarsa? as indicated above probing the brain to answer questions like these is extremely difficult. but experimental evidence suggests that one neurotransmitter specifically the neurotransmitter dopamine signals rpes and further that the phasic activity of dopamine-producing neurons in fact conveys td errors section for a definition of phasic activity. this evidence led to the reward prediction error hypothesis of dopamine neuron activity which we describe next. the reward prediction error hypothesis the reward prediction error hypothesis of dopamine neuron activity proposes that one of the functions of the phasic activity of dopamine-producing neurons in mammals is to deliver an error between an old and a new estimate of expected future reward to target areas throughout the brain. this hypothesis not in these exact words was first explicitly stated by montague dayan and sejnowski who showed how the td error concept from reinforcement learning accounts for many features of the phasic is not available until time t the td error available at t is actually t rt v v because we are thinking of time steps as very small or even infinitesimal time intervals one should not attribute undue importance to this one-step time shift. chapter neuroscience activity of dopamine neurons in mammals. the experiments that led to this hypothesis were performed in the and early in the laboratory of neuroscientist wolfram schultz. section describes these influential experiments section explains how the results of these experiments align with td errors and the bibliographical and historical remarks section at the end of this chapter includes a guide to the literature surrounding the development of this influential hypothesis. montague et al. compared the td errors of the td model of classical conditioning with the phasic activity of dopamine-producing neurons during classical conditioning experiments. recall from section that the td model of classical conditioning is basically the semi-gradient-descent td algorithm with linear function approximation. montague et al. made several assumptions to set up this comparison. first because a td error can be negative but neurons cannot have a negative firing rate they assumed that the quantity corresponding to dopamine neuron activity is t bt where bt is the background firing rate of the neuron. a negative td error corresponds to a drop in a dopamine neuron s firing rate below its background a second assumption was needed about the states visited in each classical conditioning trial and how they are represented as inputs to the learning algorithm. this is the same issue we discussed in section for the td model. montague et al. chose a complete serial compound representation as shown in the left column of figure but where the sequence of short-duration internal signals continues until the onset of the us which here is the arrival of a non-zero reward signal. this representation allows the td error to mimic the fact that dopamine neuron activity not only predicts a future reward but that it is also sensitive to when after a predictive cue that reward is expected to arrive. there has to be some way to keep track of the time between sensory cues and the arrival of reward. if a stimulus initiates a sequence of internal signals that continues after the stimulus ends and if there is a different signal for each time step following the stimulus then each time step after the stimulus is represented by a distinct state. thus the td error being state-dependent can be sensitive to the timing of events within a trial. in simulated trials with these assumptions about background firing rate and input representation td errors of the td model are remarkably similar to dopamine neuron phasic activity. previewing our description of details about these similarities in section below the td errors parallel the following features of dopamine neuron activity the phasic response of a dopamine neuron only occurs when a rewarding event is unpredicted early in learning neutral cues that precede a reward do not cause substantial phasic dopamine responses but with continued learning these cues gain predictive value and come to elicit phasic dopamine responses if an even earlier cue reliably precedes a cue that has already acquired predictive value the phasic dopamine response shifts to the earlier cue ceasing for the later cue and if after learning the predicted rewarding event is omitted a dopamine neuron s response decreases below its baseline level shortly after the expected time of the rewarding event. although not every dopamine neuron monitored in the experiments of schultz and col the literature relating td errors to the activity of dopamine neurons their t is the same as our t rt v v dopamine leagues behaved in all of these ways the striking correspondence between the activities of most of the monitored neurons and td errors lends strong support to the reward prediction error hypothesis. there are situations however in which predictions based on the hypothesis do not match what is observed in experiments. the choice of input representation is critical to how closely td errors match some of the details of dopamine neuron activity particularly details about the timing of dopamine neuron responses. different ideas some of which we discuss below have been proposed about input representations and other features of td learning to make the td errors fit the data better though the main parallels appear with the csc representation that montague et al. used. overall the reward prediction error hypothesis has received wide acceptance among neuroscientists studying reward-based learning and it has proven to be remarkably resilient in the face of accumulating results from neuroscience experiments. to prepare for our description of the neuroscience experiments supporting the reward prediction error hypothesis and to provide some context so that the significance of the hypothesis can be appreciated we next present some of what is known about dopamine the brain structures it influences and how it is involved in reward-based learning. dopamine dopamine is produced as a neurotransmitter by neurons whose cell bodies lie mainly in two clusters of neurons in the midbrain of mammals the substantia nigra pars compacta and the ventral tegmental area dopamine plays essential roles in many processes in the mammalian brain. prominent among these are motivation learning action-selection most forms of addiction and the disorders schizophrenia and parkinson s disease. dopamine is called a neuromodulator because it performs many functions other than direct fast excitation or inhibition of targeted neurons. although much remains unknown about dopamine s functions and details of its cellular effects it is clear that it is fundamental to reward processing in the mammalian brain. dopamine is not the only neuromodulator involved in reward processing and its role in aversive situations punishment remains controversial. dopamine also can function differently in non-mammals. but no one doubts that dopamine is essential for reward-related processes in mammals including humans. an early traditional view is that dopamine neurons broadcast a reward signal to multiple brain regions implicated in learning and motivation. this view followed from a famous paper by james olds and peter milner that described the effects of electrical stimulation on certain areas of a rat s brain. they found that electrical stimulation to particular regions acted as a very powerful reward in controlling the rat s behavior control exercised over the animal s behavior by means of this reward is extreme possibly exceeding that exercised by any other reward previously used in animal experimentation and milner later research revealed that the sites at which stimulation was most effective in producing this rewarding effect excited dopamine pathways either directly or indirectly that ordinarily are excited by natural rewarding stimuli. effects similar to these with rats were also observed with human subjects. these observations strongly suggested that dopamine neuron activity signals reward. chapter neuroscience but if the reward prediction error hypothesis is correct even if it accounts for only some features of a dopamine neuron s activity this traditional view of dopamine neuron activity is not entirely correct phasic responses of dopamine neurons signal reward prediction errors not reward itself. in reinforcement learning s terms a dopamine neuron s phasic response at a time t corresponds to t rt v v not to rt. reinforcement learning theory and algorithms help reconcile the reward-predictionerror view with the conventional notion that dopamine signals reward. in many of the algorithms we discuss in this book functions as a reinforcement signal meaning that it is the main driver of learning. for example is the critical factor in the td model of classical conditioning and is the reinforcement signal for learning both a value function and a policy in an actor critic architecture and action-dependent forms of are reinforcement signals for q-learning and sarsa. the reward signal rt is a crucial component of t but it is not the complete determinant of its reinforcing effect in these algorithms. the additional term v v is the higher-order reinforcement part of t and even if reward occurs the td error can be silent if the reward is fully predicted is fully explained in section below. a closer look at olds and milner s paper in fact reveals that it is mainly about the reinforcing effect of electrical stimulation in an instrumental conditioning task. electrical stimulation not only energized the rats behavior through dopamine s effect on motivation it also led to the rats quickly learning to stimulate themselves by pressing a lever which they would do frequently for long periods of time. the activity of dopamine neurons triggered by electrical stimulation reinforced the rats lever pressing. more recent experiments using optogenetic methods clinch the role of phasic responses of dopamine neurons as reinforcement signals. these methods allow neuroscientists to precisely control the activity of selected neuron types at a millisecond timescale in awake behaving animals. optogenetic methods introduce light-sensitive proteins into selected neuron types so that these neurons can be activated or silenced by means of flashes of laser light. the first experiment using optogenetic methods to study dopamine neurons showed that optogenetic stimulation producing phasic activation of dopamine neurons in mice was enough to condition the mice to prefer the side of a chamber where they received this stimulation as compared to the chamber s other side where they received no or lower-frequency stimulation et al. in another example steinberg et al. used optogenetic activation of dopamine neurons to create artificial bursts of dopamine neuron activity in rats at the times when rewarding stimuli were expected but omitted times when dopamine neuron activity normally pauses. with these pauses replaced by artificial bursts responding was sustained when it would ordinarily decrease due to lack of reinforcement extinction trials and learning was enabled when it would ordinarily be blocked due to the reward being already predicted blocking paradigm section additional evidence for the reinforcing function of dopamine comes from optogenetic experiments with fruit flies except in these animals dopamine s effect is the opposite of its effect in mammals optically triggered bursts of dopamine neuron activity act just like electric foot shock in reinforcing avoidance behavior at least for the population of dopamine neurons activated et al. although none of these dopamine optogenetic experiments showed that phasic dopamine neuron activity is specifically like a td error they convincingly demonstrated that phasic dopamine neuron activity acts just like acts perhaps like minus acts in fruit flies as the reinforcement signal in algorithms for both prediction conditioning and control conditioning. dopamine neurons are particularly well suited to broadcasting a reinforcement signal to many areas of the brain. these neurons have huge axonal arbors each releasing dopamine at to times more synaptic sites than reached by the axons of typical neurons. shown to the right is the axonal arbor of a single dopamine neuron whose cell body is in the snpc of a rat s brain. each axon of a snpc or vta dopamine neuron makes roughly synaptic contacts on the dendrites of neurons in targeted brain areas. axonal arbor of a single neuron producing dopamine as a neurotransmitter. these axons make synaptic contacts with a huge number of dendrites of neurons in targeted brain areas. adapted from the journal of neuroscience matsuda furuta naka if dopamine neurons broadcast a reinforcement signal like reinforcement learning s then because this is a scalar signal i.e. a single number all dopamine neurons in both the snpc and vta would be expected to activate more-orless identically so that they would act in near synchrony to send the same signal to all of the sites their axons target. although it has been a common belief that dopamine neurons do act together like this modern evidence is pointing to the more complicated picture that different subpopulations of dopamine neurons respond to input differently depending on the structures to which they send their signals and the different ways these signals act on their target structures. dopamine has functions other than signaling rpes and even for dopamine neurons that do signal rpes it can make sense to send different rpes to different structures depending on the roles these structures play in producing reinforced behavior. this is beyond what we treat in any detail in this book but vector-valued rpe signals make sense from the perspective of reinforcement learning when decisions can be decomposed into separate sub-decisions or more generally as a way to address the structural version of the credit assignment problem how do you distribute credit for success blame for failure of a decision among the many component structures that could have been involved in producing it? we say a bit more about this in section below. mura hioki fujiyama arai and kaneko vol ume page the axons of most dopamine neurons make synaptic contact with neurons in the frontal cortex and the basal ganglia areas of the brain involved in voluntary movement decision making learning and cognitive functions such as planning. because most ideas relating chapter neuroscience dopamine to reinforcement learning focus on the basal ganglia and the connections from dopamine neurons are particularly dense there we focus on the basal ganglia here. the basal ganglia are a collection of neuron groups or nuclei lying at the base of the forebrain. the main input structure of the basal ganglia is called the striatum. essentially all of the cerebral cortex among other structures provides input to the striatum. the activity of cortical neurons conveys a wealth of information about sensory input internal states and motor activity. the axons of cortical neurons make synaptic contacts on the dendrites of the main inputoutput neurons of the striatum called medium spiny neurons. output from the striatum loops back via other basal ganglia nuclei and the thalamus to frontal areas of cortex and to motor areas making it possible for the striatum to influence movement abstract decision processes and reward processing. two main subdivisions of the striatum are important for reinforcement learning the dorsal striatum primarily implicated in influencing action selection and the ventral striatum thought to be critical for different aspects of reward processing including the assignment of affective value to sensations. the dendrites of medium spiny neurons are covered with spines on whose tips the axons of neurons in the cortex make synaptic contact. also making synaptic contact with these spines in this case contacting the spine stems are axons of dopamine neurons this arrangement brings together presynaptic activity of cortical neurons figure spine of a striatal neuron showing input from both cortical and dopamine neurons. axons of cortical neurons influence striatal neurons via corticostriatal synapses releasing the neurotransmitter glutamate at the tips of spines covering the dendrites of striatal neurons. an axon of a vta or snpc dopamine neuron is shown passing by the spine the lower right. dopamine varicosities on this axon release dopamine at or near the spine stem in an arrangement that brings together presynaptic input from cortex postsynaptic activity of the striatal neuron and dopamine making it possible that several types of learning rules govern the plasticity of corticostriatal synapses. each axon of a dopamine neuron makes synaptic contact with the stems of roughly spines. some of the complexity omitted from our discussion is shown here by other neurotransmitter pathways and multiple receptor types such as an dopamine receptors by which dopamine can produce different effects at spines and other postsynaptic sites. from journal of neurophysiology w. schultz vol. page experimental support for the reward prediction error hypothesis postsynaptic activity of medium spiny neurons and input from dopamine neurons. what actually occurs at these spines is complex and not completely understood. figure hints at the complexity by showing two types of receptors for dopamine receptors for glutamate the neurotransmitter of the cortical inputs and multiple ways that the various signals can interact. but evidence is mounting that changes in the efficacies of the synapses on the pathway from the cortex to the striatum which neuroscientists call corticostriatal synapses depend critically on appropriately-timed dopamine signals. experimental support for the reward predic tion error hypothesis dopamine neurons respond with bursts of activity to intense novel or unexpected visual and auditory stimuli that trigger eye and body movements but very little of their activity is related to the movements themselves. this is surprising because degeneration of dopamine neurons is a cause of parkinson s disease whose symptoms include motor disorders particularly deficits in self-initiated movement. motivated by the weak relationship between dopamine neuron activity and stimulus-triggered eye and body movements romo and schultz and schultz and romo took the first steps toward the reward prediction error hypothesis by recording the activity of dopamine neurons and muscle activity while monkeys moved their arms. they trained two monkeys to reach from a resting hand position into a bin containing a bit of apple a piece of cookie or a raisin when the monkey saw and heard the bin s door open. the monkey could then grab and bring the food to its mouth. after a monkey became good at this it was trained on two additional tasks. the purpose of the first task was to see what dopamine neurons do when movements are self-initiated. the bin was left open but covered from above so that the monkey could not see inside but could reach in from below. no triggering stimuli were presented and after the monkey reached for and ate the food morsel the experimenter usually not always silently and unseen by the monkey replaced food in the bin by sticking it onto a rigid wire. here too the activity of the dopamine neurons romo and schultz monitored was not related to the monkey s movements but a large percentage of these neurons produced phasic responses whenever the monkey first touched a food morsel. these neurons did not respond when the monkey touched just the wire or explored the bin when no food was there. this was good evidence that the neurons were responding to the food and not to other aspects of the task. the purpose of romo and schultz s second task was to see what happens when movements are triggered by stimuli. this task used a different bin with a movable cover. the sight and sound of the bin opening triggered reaching movements to the bin. in this case romo and schultz found that after some period of training the dopamine neurons no longer responded to the touch of the food but instead responded to the sight and sound of the opening cover of the food bin. the phasic responses of these neurons had shifted from the reward itself to stimuli predicting the availability of the reward. in a followup study romo and schultz found that most of the dopamine neurons whose activity they chapter neuroscience monitored did not respond to the sight and sound of the bin opening outside the context of the behavioral task. these observations suggested that the dopamine neurons were responding neither to the initiation of a movement nor to the sensory properties of the stimuli but were rather signaling an expectation of reward. schultz s group conducted many additional studies involving both snpc and vta dopamine neurons. a particular series of experiments was influential in suggesting that the phasic responses of dopamine neurons correspond to td errors and not to simpler errors like those in the rescorla wagner model in the first of these experiments apicella and schultz monkeys were trained to depress a lever after a light was illuminated as a trigger cue to obtain a drop of apple juice. as romo and schultz had observed earlier many dopamine neurons initially responded to the reward the drop of juice top panel. but many of these neurons lost that reward response as training continued and developed responses instead to the illumination of the light that predicted the reward middle panel. with continued training lever pressing became faster while the number of dopamine neurons responding to the trigger cue decreased. figure the response of dopamine neurons shifts from initial responses to primary reward to earlier predictive stimuli. these are plots of the number of action potentials produced by monitored dopamine neurons within small time intervals averaged over all the monitored dopamine neurons from to neurons for these data. top dopamine neurons are activated by the unpredicted delivery of drop of apple juice. middle with learning dopamine neurons developed responses to the reward-predicting trigger cue and lost responsiveness to the delivery of reward. bottom with the addition of an instruction cue preceding the trigger cue by second dopamine neurons shifted their responses from the trigger cue to the earlier instruction cue. from schultz et al. mit press. following this study the same monkeys were trained on a new task apicella and ljungberg here the monkeys faced two levers each with a light above it. experimental support for the reward prediction error hypothesis illuminating one of these lights was an instruction cue indicating which of the two levers would produce a drop of apple juice. in this task the instruction cue preceded the trigger cue of the previous task by a fixed interval of second. the monkeys learned to withhold reaching until seeing the trigger cue and dopamine neuron activity increased but now the responses of the monitored dopamine neurons occurred almost exclusively to the earlier instruction cue and not to the trigger cue bottom panel. here again the number of dopamine neurons responding to the instruction cue was much reduced when the task was well learned. during learning across these tasks dopamine neuron activity shifted from initially responding to the reward to responding to the earlier predictive stimuli first progressing to the trigger stimulus then to the still earlier instruction cue. as responding moved earlier in time it disappeared from the later stimuli. this shifting of responses to earlier reward predictors while losing responses to later predictors is a hallmark of td learning for example figure the task just described revealed another property of dopamine neuron activity shared with td learning. sometimes pressed the wrong key that is the key other than the instructed one and consequently received no reward. in these trials many of the dopamine neurons showed a sharp decrease in their firing rates below baseline shortly after the reward s usual time of delivery and this happened without the availability of any the monkeys figure the response of dopamine neurons drops below baseline shortly after the time when an expected reward fails to occur. top dopamine neurons are activated by the unpredicted delivery of a drop of apple juice. middle dopamine neurons respond to a conditioned stimulus that predicts reward and do not respond to the reward itself. bottom when the reward predicted by the cs fails to occur the activity of dopamine neurons drops below baseline shortly after the time the reward is expected to occur. at the top of each of these panels is shown the average number of action potentials produced by monitored dopamine neurons within small time intervals around the indicated times. the raster plots below show the activity patterns of the individual dopamine neurons that were monitored each dot represents an action potential. from schultz dayan and montague a neural substrate of prediction and reward science vol. issue pages march reprinted with permission from aaas. chapter neuroscience external cue to mark the usual time of reward delivery somehow the monkeys were internally keeping track of the timing of the reward. timing is one area where the simplest version of td learning needs to be modified to account for some of the details of the timing of dopamine neuron responses. we consider this issue in the following section. the observations from the studies described above led schultz and his group to conclude that dopamine neurons respond to unpredicted rewards to the earliest predictors of reward and that dopamine neuron activity decreases below baseline if a reward or a predictor of reward does not occur at its expected time. researchers familiar with reinforcement learning were quick to recognize that these results are strikingly similar to how the td error behaves as the reinforcement signal in a td algorithm. the next section explores this similarity by working through a specific example in detail. td errordopamine correspondence this section explains the correspondence between the td error and the phasic responses of dopamine neurons observed in the experiments just described. we examine how changes over the course of learning in a task something like the one described above where a monkey first sees an instruction cue and then a fixed time later has to respond correctly to a trigger cue in order to obtain reward. we use a simple idealized version of this task but we go into a lot more detail than is usual because we want to emphasize the theoretical basis of the parallel between td errors and dopamine neuron activity. the first simplifying assumption is that the agent has already learned the actions required to obtain reward. then its task is just to learn accurate predictions of future reward for the sequence of states it experiences. this is then a prediction task or more technically a policy-evaluation task learning the value function for a fixed policy and the value function to be learned assigns to each state a value that predicts the return that will follow that state if the agent selects actions according to the given policy where the return is the discounted sum of all the future rewards. this is unrealistic as a model of the monkey s situation because the monkey would likely learn these predictions at the same time that it is learning to act correctly would a reinforcement learning algorithm that learns policies as well as value functions such as an actor critic algorithm but this scenario is simpler to describe than one in which a policy and a value function are learned simultaneously. now imagine that the agent s experience divides into multiple trials in each of which the same sequence of states repeats with a distinct state occurring on each time step during the trial. further imagine that the return being predicted is limited to the return over a trial which makes a trial analogous to a reinforcement learning episode as we have defined it. in reality of course the returns being predicted are not confined to single trials and the time interval between trials is an important factor in determining what an animal learns. this is true for td learning as well but here we assume that returns do not accumulate over multiple trials. given this then a trial in experiments like those conducted by schultz and colleagues is equivalent to an episode of reinforcement learning. in this discussion we will use the term trial instead of episode to td errordopamine correspondence relate better to the experiments. as usual we also need to make an assumption about how states are represented as inputs to the learning algorithm an assumption that influences how closely the td error corresponds to dopamine neuron activity. we discuss this issue later but for now we assume the same csc representation used by montague et al. in which there is a separate internal stimulus for each state visited at each time step in a trial. this reduces the process to the tabular case covered in the first part of this book. finally we assume that the agent uses to learn a value function v stored in a lookup table initialized to be zero for all the states. we also assume that this is a deterministic task and that the discount factor is very nearly one so that we can ignore it. figure shows the time courses of r v and at several stages of learning in this policy-evaluation task. the time axes represent the time interval over which a sequence of states is visited in a trial for clarity we omit showing individual states. the reward signal is zero throughout each trial except when the agent reaches the rewarding state shown near the right end of the time line when the reward signal becomes some positive number say the goal of td learning is to predict the return for each state visited in a trial which in this undiscounted case and given our assumption that predictions are confined to individual trials is simply for each state. figure the behavior of the td error during td learning is consistent with features of the phasic activation of dopamine neurons. is the td error available at time t i.e. t top a sequence of states shown as an interval of regular predictors is followed by a non-zero reward early in learning the initial value function v and initial which at first is equal to learning complete the value function accurately predicts future reward is positive at the earliest predictive state and at the time of the non-zero reward. omitted at the time the predicted reward is omitted becomes negative. see text for a complete explanation of why this happens. inlearninglearningcompleteomittedrregular predictors of over this intervalrr? chapter neuroscience preceding the rewarding state is a sequence of reward-predicting states with the earliest reward-predicting state shown near the left end of the time line. this is like the state near the start of a trial for example like the state marked by the instruction cue in a trial of the monkey experiment of schultz et al. described above. it is the first state in a trial that reliably predicts that trial s reward. course in reality states visited on preceding trials are even earlier reward-predicting states but because we are confining predictions to individual trials these do not qualify as predictors of this trial s reward. below we give a more satisfactory though more abstract description of an earliest reward-predicting state. the latest reward-predicting state in a trial is the state immediately preceding the trial s rewarding state. this is the state near the far right end of the time line in figure note that the rewarding state of a trial does not predict the return for that trial the value of this state would come to predict the return over all the following trials which here we are assuming to be zero in this episodic formulation. figure shows the first-trial time courses of v and as the graphs labeled early in learning. because the reward signal is zero throughout the trial except when the rewarding state is reached and all the v are zero the td error is also zero until it becomes at the rewarding state. this follows because t rt vt vt rt rt which is zero until it equals when the reward occurs. here vt and vt are respectively the estimated values of the states visited at times t and t in a trial. the td error at this stage of learning is analogous to a dopamine neuron responding to an unpredicted reward e.g. a drop apple juice at the start of training. throughout this first trial and all successive trials updates occur at each state transition as described in chapter this successively increases the values of the reward-predicting states with the increases spreading backwards from the rewarding state until the values converge to the correct return predictions. in this case we are assuming no discounting the correct predictions are equal to for all the reward-predicting states. this can be seen in figure as the graph of v labeled learning complete where the values of all the states from the earliest to the latest reward-predicting states all equal the values of the states preceding the earliest reward-predicting state remain low figure shows as zero because they are not reliable predictors of reward. when learning is complete that is when v attains its correct values the td errors associated with transitions from any reward-predicting state are zero because the predictions are now accurate. this is because for a transition from a reward-predicting state to another reward-predicting state we have t rt vt vt and for the transition from the latest reward-predicting state to the rewarding state we have t rt vt vt on the other hand the td error on a transition from any state to the earliest reward-predicting state is positive because of the mismatch between this state s low value and the larger value of the following rewardpredicting state. indeed if the value of a state preceding the earliest reward-predicting state were zero then after the transition to the earliest reward-predicting state we would have that t rt vt vt the learning complete graph of in figure shows this positive value at the earliest reward-predicting state and zeros td errordopamine correspondence everywhere else. the positive td error upon transitioning to the earliest reward-predicting state is analogous to the persistence of dopamine responses to the earliest stimuli predicting reward. by the same token when learning is complete a transition from the latest reward-predicting state to the rewarding state produces a zero td error because the latest reward-predicting state s value being correct cancels the reward. this parallels the observation that fewer dopamine neurons generate a phasic response to a fully predicted reward than to an unpredicted reward. after learning if the reward is suddenly omitted the td error goes negative at the usual time of reward because the value of the latest reward-predicting state is then too high t rt vt vt as shown at the right end of the r omitted graph of in figure this is like dopamine neuron activity decreasing below baseline at the time an expected reward is omitted as seen in the experiment of schultz et al. described above and shown in figure the idea of an earliest reward-predicting state deserves more attention. in the scenario described above because experience is divided into trials and we assumed that predictions are confined to individual trials the earliest reward-predicting state is always the first state of a trial. clearly this is artificial. a more general way to think of an earliest reward-predicting state is that it is an unpredicted predictor of reward and there can be many such states. in an animal s life many different states may precede an earliest reward-predicting state. however because these states are more often followed by other states that do not predict reward their reward-predicting powers that is their values remain low. a td algorithm if operating throughout the animal s life would update the values of these states too but the updates would not consistently accumulate because by assumption none of these states reliably precedes an earliest reward-predicting state. if any of them did they would be reward-predicting states as well. this might explain why with overtraining dopamine responses decrease to even the earliest reward-predicting stimulus in a trial. with overtraining one would expect that even a formerly-unpredicted predictor state would become predicted by stimuli associated with earlier states the animal s interaction with its environment both inside and outside of an experimental task would become commonplace. upon breaking this routine with the introduction of a new task however one would see td errors reappear as indeed is observed in dopamine neuron activity. the example described above explains why the td error shares key features with the phasic activity of dopamine neurons when the animal is learning in a task similar to the idealized task of our example. but not every property of the phasic activity of dopamine neurons coincides so neatly with properties of one of the most troubling discrepancies involves what happens when a reward occurs earlier than expected. we have seen that the omission of an expected reward produces a negative prediction error at the reward s expected time which corresponds to the activity of dopamine neurons decreasing below baseline when this happens. if the reward arrives later than expected it is then an unexpected reward and generates a positive prediction error. this happens with both td errors and dopamine neuron responses. but when reward arrives earlier than expected dopamine neurons do not do what the td error does at least with the chapter neuroscience csc representation used by montague et al. and by us in our example. dopamine neurons do respond to the early reward which is consistent with a positive td error because the reward is not predicted to occur then. however at the later time when the reward is expected but omitted the td error is negative whereas in contrast to this prediction dopamine neuron activity does not drop below baseline in the way the td model predicts and schultz something more complicated is going on in the animal s brain than simply td learning with a csc representation. some of the mismatches between the td error and dopamine neuron activity can be addressed by selecting suitable parameter values for the td algorithm and by using stimulus representations other than the csc representation. for instance to address the early-reward mismatch just described suri and schultz proposed a csc representation in which the sequences of internal signals initiated by earlier stimuli are cancelled by the occurrence of a reward. another proposal by daw courville and touretzky is that the brain s td system uses representations produced by statistical modeling carried out in sensory cortex rather than simpler representations based on raw sensory input. ludvig sutton and kehoe found that td learning with a microstimulus representation fits the activity of dopamine neurons in the early-reward and other situations better than when a csc representation is used. pan schmidt wickens and hyland found that even with the csc representation prolonged eligibility traces improve the fit of the td error to some aspects of dopamine neuron activity. in general many fine details of td-error behavior depend on subtle interactions between eligibility traces discounting and stimulus representations. findings like these elaborate and refine the reward prediction error hypothesis without refuting its core claim that the phasic activity of dopamine neurons is well characterized as signaling td errors. on the other hand there are other discrepancies between the td theory and experimental data that are not so easily accommodated by selecting parameter values and stimulus representations mention some of these discrepancies in the bibliographical and historical remarks section at the end of this chapter and more mismatches are likely to be discovered as neuroscientists conduct ever more refined experiments. but the reward prediction error hypothesis has been functioning very effectively as a catalyst for improving our understanding of how the brain s reward system works. intricate experiments have been designed to validate or refute predictions derived from the hypothesis and experimental results have in turn led to refinement and elaboration of the td errordopamine hypothesis. a remarkable aspect of these developments is that the reinforcement learning algorithms and theory that connect so well with properties of the dopamine system were developed from a computational perspective in total absence of any knowledge about the relevant properties of dopamine neurons remember td learning and its connections to optimal control and dynamic programming were developed many years before any of the experiments were conducted that revealed the td-like nature of dopamine neuron activity. this unplanned correspondence despite not being perfect suggests that the td errordopamine parallel captures something significant about brain reward processes. neural actor critic in addition to accounting for many features of the phasic activity of dopamine neurons the reward prediction error hypothesis links neuroscience to other aspects of reinforcement learning in particular to learning algorithms that use td errors as reinforcement signals. neuroscience is still far from reaching complete understanding of the circuits molecular mechanisms and functions of the phasic activity of dopamine neurons but evidence supporting the reward prediction error hypothesis along with evidence that phasic dopamine responses are reinforcement signals for learning suggest that the brain might implement something like an actor critic algorithm in which td errors play critical roles. other reinforcement learning algorithms are plausible candidates too but actor critic algorithms fit the anatomy and physiology of the mammalian brain particularly well as we describe in the following two sections. neural actor critic actor critic algorithms learn both policies and value functions. the actor is the component that learns policies and the critic is the component that learns about whatever policy is currently being followed by the actor in order to criticize the actor s action choices. the critic uses a td algorithm to learn the state-value function for the actor s current policy. the value function allows the critic to critique the actor s action choices by sending td errors to the actor. a positive means that the action was good because it led to a state with a better-than-expected value a negative means that the action was bad because it led to a state with a worse-than-expected value. based on these critiques the actor continually updates its policy. two distinctive features of actor critic algorithms are responsible for thinking that the brain might implement an algorithm like this. first the two components of an actor critic algorithm the actor and the critic suggest that two parts of the striatum the dorsal and ventral subdivisions both critical for reward-based learning may function respectively something like an actor and a critic. a second property of actor critic algorithms that suggests a brain implementation is that the td error has the dual role of being the reinforcement signal for both the actor and the critic though it has a different influence on learning in each of these components. this fits well with several properties of the neural circuitry axons of dopamine neurons target both the dorsal and ventral subdivisions of the striatum dopamine appears to be critical for modulating synaptic plasticity in both structures and how a neuromodulator such as dopamine acts on a target structure depends on properties of the target structure and not just on properties of the neuromodulator. section presents actor critic algorithms as policy gradient methods but the actor critic algorithm of barto sutton and anderson was simpler and was presented as an artificial neural network. here we describe an artificial neural network implementation something like that of barto et al. and we follow takahashi schoenbaum and niv in giving a schematic proposal for how this artificial neural network might be implemented by real neural networks in the brain. we postpone discussion of the actor and critic learning rules until section where we present them as special cases of the policy-gradient formulation and discuss what they suggest about how chapter neuroscience dopamine might modulate synaptic plasticity. figure shows an implementation of an actor critic algorithm as an artificial neural network with component networks implementing the actor and the critic. the critic consists of a single neuron-like unit v whose output activity represents state values and a component shown as the diamond labeled td that computes td errors by combining v s output with reward signals and with previous state values suggested by the loop from the td diamond to itself. the actor network has a single layer of k actor units labeled ai i k. the output of each actor unit is a component of a k-dimensional action vector. an alternative is that there are k separate actions one commanded by each actor unit that compete with one another to be executed but here we will think of the entire a-vector as an action. figure actor critic artificial neural network and a hypothetical neural implementation. a actor critic algorithm as an artificial neural network. the actor adjusts a policy based on the td error it receives from the critic the critic adjusts state-value parameters using the same the critic produces a td error from the reward signal r and the current change in its estimate of state values. the actor does not have direct access to the reward signal and the critic does not have direct access to the action. b hypothetical neural implementation of an actor critic algorithm. the actor and the value-learning part of the critic are respectively placed in the ventral and dorsal subdivisions of the striatum. the td error is transmitted by dopamine neurons located in the vta and snpc to modulate changes in synaptic efficacies of input from cortical areas to the ventral and dorsal striatum. adapted from frontiers in neuroscience vol. y. takahashi g. schoenbaum and y. niv silencing the critics understanding the effects of cocaine sensitization on dorsolateral and ventral striatum in the context of an actorcritic model. rewardactortd. actionsstatesstimulitd striatumcortex neural actor critic both the critic and actor networks receive input consisting of multiple features representing the state of the agent s environment. from chapter that the environment of a reinforcement learning agent includes components both inside and outside of the organism containing the agent. the figure shows these features as the circles labeled xn shown twice just to keep the figure simple. a weight representing the efficacy of a synapse is associated with each connection from each feature xi to the critic unit v and to each of the action units ai. the weights in the critic network parameterize the value function and the weights in the actor network parameterize the policy. the networks learn as these weights change according to the critic and actor learning rules that we describe in the following section. the td error produced by circuitry in the critic is the reinforcement signal for changing the weights in both the critic and the actor networks. this is shown in figure by the line labeled td error extending across all of the connections in the critic and actor networks. this aspect of the network implementation together with the reward prediction error hypothesis and the fact that the activity of dopamine neurons is so widely distributed by the extensive axonal arbors of these neurons suggests that an actor critic network something like this may not be too farfetched as a hypothesis about how reward-related learning might happen in the brain. figure suggests very schematically how the artificial neural network on the figure s left might map onto structures in the brain according to the hypothesis of takahashi et al. the hypothesis puts the actor and the value-learning part of the critic respectively in the dorsal and ventral subdivisions of the striatum the input structure of the basal ganglia. recall from section that the dorsal striatum is primarily implicated in influencing action selection and the ventral striatum is thought to be critical for different aspects of reward processing including the assignment of affective value to sensations. the cerebral cortex along with other structures sends input to the striatum conveying information about stimuli internal states and motor activity. in this hypothetical actor critic brain implementation the ventral striatum sends value information to the vta and snpc where dopamine neurons in these nuclei combine it with information about reward to generate activity corresponding to td errors exactly how dopaminergic neurons calculate these errors is not yet understood. the td error line in figure becomes the line labeled dopamine in figure which represents the widely branching axons of dopamine neurons whose cell bodies are in the vta and snpc. referring back to figure these axons make synaptic contact with the spines on the dendrites of medium spiny neurons the main inputoutput neurons of both the dorsal and ventral divisions of the striatum. axons of the cortical neurons that send input to the striatum make synaptic contact on the tips of these spines. according to the hypothesis it is at these spines where changes in the efficacies of the synapses from cortical regions to the stratum are governed by learning rules that critically depend on a reinforcement signal supplied by dopamine. an important implication of the hypothesis illustrated in figure is that the dopamine signal is not the master reward signal like the scalar rt of reinforcement learning. in fact the hypothesis implies that one should not necessarily be able to probe the brain and record any signal like rt in the activity of any single neuron. many inter chapter neuroscience connected neural systems generate reward-related information with different structures being recruited depending on different types of rewards. dopamine neurons receive information from many different brain areas so the input to the snpc and vta labeled reward in figure should be thought of as vector of reward-related information arriving to neurons in these nuclei along multiple input channels. what the theoretical scalar reward signal rt might correspond to then is the net contribution of all rewardrelated information to dopamine neuron activity. it is the result of a pattern of activity across many neurons in different areas of the brain. although the actor critic neural implementation illustrated in figure may be correct on some counts it clearly needs to be refined extended and modified to qualify as a full-fledged model of the function of the phasic activity of dopamine neurons. the historical and bibliographic remarks section at the end of this chapter cites publications that discuss in more detail both empirical support for this hypothesis and places where it falls short. we now look in detail at what the actor and critic learning algorithms suggest about the rules governing changes in synaptic efficacies of corticostriatal synapses. actor and critic learning rules if the brain does implement something like the actor critic algorithm and assuming populations of dopamine neurons broadcast a common reinforcement signal to the corticostriatal synapses of both the dorsal and ventral striatum as illustrated in figure is likely an oversimplification as we mentioned above then this reinforcement signal affects the synapses of these two structures in different ways. the learning rules for the critic and the actor use the same reinforcement signal the td error but its effect on learning is different for these two components. the td error with eligibility traces tells the actor how to update action probabilities in order to reach higher-valued states. learning by the actor is like instrumental conditioning using a law-of-effect-type learning rule the actor works to keep as positive as possible. on the other hand the td error combined with eligibility traces tells the critic the direction and magnitude in which to change the parameters of the value function in order to improve its predictive accuracy. the critic works to reduce s magnitude to be as close to zero as possible using a learning rule like the td model of classical conditioning the difference between the critic and actor learning rules is relatively simple but this difference has a profound effect on learning and is essential to how the actor critic algorithm works. the difference lies solely in the eligibility traces each type of learning rule uses. more than one set of learning rules can be used in actor critic neural networks like those in figure but to be specific here we focus on the actor critic algorithm for continuing problems with eligibility traces presented in section on each transition from state st to state taking action at and receiving action that algorithm computes the td error and then updates the eligibility trace vectors t and z t actor and critic learning rules and the parameters for the critic and actor and according to t vstw t ln t vstw t wzw zw t z z w w w t zw t z t where is a discount-rate parameter wc and wa are bootstrapping parameters for the critic and the actor respectively and w and are analogous step-size parameters. think of the approximate value function v as the output of a single linear neuron-like unit called the critic unit and labeled v in figure then the value function is a linear function of the feature-vector representation of state s xs parameterized by a weight vector w vsw each xis is like the presynaptic signal to a neuron s synapse whose efficacy is wi. the weights of the critic are incremented according to the rule above by w tzw t where the reinforcement signal t corresponds to a dopamine signal being broadcast to all of the critic unit s synapses. the eligibility trace vector zw t for the critic unit is a trace of recent values of vstw. because vsw is linear in the weights vstw xst. in neural terms this means that each synapse has its own eligibility trace which is one component of the vector zw t a synapse s eligibility trace accumulates according to the level of activity arriving at that synapse that is the level of presynaptic activity represented here by the component of the feature vector xst arriving at that synapse. the trace otherwise decays toward zero at a rate governed by the fraction w. a synapse is eligible for modification as long as its eligibility trace is non-zero. how the synapse s efficacy is actually modified depends on the reinforcement signals that arrive while the synapse is eligible. we call eligibility traces like these of the critic unit s synapses noncontingent eligibility traces because they only depend on presynaptic activity and are not contingent in any way on postsynaptic activity. the non-contingent eligibility traces of the critic unit s synapses mean that the critic unit s learning rule is essentially the td model of classical conditioning described in section with the definition we have given above of the critic unit and its learning rule the critic in figure is the same as the critic in the neural network actor critic of barto et al. clearly a critic like this consisting of just one linear neuron-like unit is the simplest starting point this critic unit is a proxy for a more complicated neural network able to learn value functions of greater complexity. the actor in figure is a one-layer network of k neuron-like actor units each receiving at time t the same feature vector xst that the critic unit receives. each actor unit j j k has its own weight vector j but because the actor units chapter neuroscience are all identical we describe just one of the units and omit the subscript. one way for these units to follow the actor critic algorithm given in the equations above is for each to be a bernoulli-logistic unit. this means that the output of each actor unit at each time is a random variable at taking value or think of value as the neuron firing that is emitting an action potential. the weighted sum of a unit s input vector determines the unit s action probabilities via the exponential soft-max distribution which for two actions is the logistic function exp the weights of each actor unit are incremented as above by t z t where again corresponds to the dopamine signal the same reinforcement signal that is sent to all the critic unit s synapses. figure shows t being broadcast to all the synapses of all the actor units makes this actor network a team of reinforcement learning agents something we discuss in section below. the actor eligibility trace vector z is a trace of recent values of ln to understand this t eligibility trace refer to exercise which defines this kind of unit and asks you to give a learning rule for it. that exercise asked you to express ln in terms of a xs and arbitrary state s and action a by calculating the gradient. for the action and state actually occurring at time t the answer is unlike the non-contingent eligibility trace of a critic synapse that only accumulates the presynaptic activity xst the eligibility trace of an actor unit s synapse in addition depends on the activity of the actor unit itself. we call this a contingent eligibility trace because it is contingent on this postsynaptic activity. the eligibility trace at each synapse continually decays but increments or decrements depending on the activity of the presynaptic neuron and whether or not the postsynaptic neuron fires. the factor at in is positive when at and negative otherwise. the postsynaptic contingency in the eligibility traces of actor units is the only difference between the critic and actor learning rules. by keeping information about what actions were taken in what states contingent eligibility traces allow credit for reward or blame for punishment to be apportioned among the policy parameters efficacies of the actor units synapses according to the contributions these parameters made to the units outputs that could have influenced later values of contingent eligibility traces mark the synapses as to how they should be modified to alter the units future responses to favor positive values of what do the critic and actor learning rules suggest about how efficacies of corticostriatal synapses change? both learning rules are related to donald hebb s classic proposal that whenever a presynaptic signal participates in activating the postsynaptic neuron the synapse s efficacy increases the critic and actor learning rules share with hebb s proposal the idea that changes in a synapse s efficacy depend on the interaction of several factors. in the critic learning rule the interaction is between the reinforcement signal and eligibility traces that depend only on presynaptic signals. neuroscientists actor and critic learning rules call this a two-factor learning rule because the interaction is between two signals or quantities. the actor learning rule on the other hand is a three-factor learning rule because in addition to depending on its eligibility traces depend on both presynaptic and postsynaptic activity. unlike hebb s proposal however the relative timing of the factors is critical to how synaptic efficacies change with eligibility traces intervening to allow the reinforcement signal to affect synapses that were active in the recent past. some subtleties about signal timing for the actor and critic learning rules deserve closer attention. in defining the neuron-like actor and critic units we ignored the small amount of time it takes synaptic input to effect the firing of a real neuron. when an action potential from the presynaptic neuron arrives at a synapse neurotransmitter molecules are released that diffuse across the synaptic cleft to the postsynaptic neuron where they bind to receptors on the postsynaptic neuron s surface this activates molecular machinery that causes the postsynaptic neuron to fire to inhibit its firing in the case of inhibitory synaptic input. this process can take several tens of milliseconds. according to and though the input to a critic and actor unit instantaneously produces the unit s output. ignoring activation time like this is common in abstract models of hebbian-style plasticity in which synaptic efficacies change according to a simple product of simultaneous pre- and postsynaptic activity. more realistic models must take activation time into account. activation time is especially important for a more realistic actor unit because it influences how contingent eligibility traces have to work in order to properly apportion credit defining contingent eligibility traces for the actor unit s learning rule given above in works because by ignoring activation time the presynaptic activity xst participates for reinforcement to the appropriate synapses. the cludes the postsynaptic and the presynaptic factor xst. this in causing the postsynaptic activity appearing in to assign credit for reinforcement correctly the presynaptic factor defining the eligibility trace must be a cause of the postsynaptic factor that also defines the trace. contingent eligibility traces for a more realistic actor unit would have to take activation time into account. time should not be confused with the time required for a neuron to receive a reinforcement signal influenced by that neuron s activity. the function of eligibility traces is to span this time interval which is generally much longer than the activation time. we discuss this further in the following section. there are hints from neuroscience for how this process might work in the brain. neuroscientists have discovered a form of hebbian plasticity called spike-timing-dependent plasticity that lends plausibility to the existence of actor-like synaptic plasticity in the brain. stdp is a hebbian-style plasticity but changes in a synapse s efficacy depend on the relative timing of presynaptic and postsynaptic action potentials. the dependence can take different forms but in the one most studied a synapse increases in strength if spikes incoming via that synapse arrive shortly before the postsynaptic neuron fires. if the timing relation is reversed with a presynaptic spike arriving shortly after the postsynaptic neuron fires then the strength of the synapse decreases. stdp is a type of hebbian plasticity that takes the activation time of a neuron into account which is one of the ingredients needed for actor-like learning. chapter neuroscience the discovery of stdp has led neuroscientists to investigate the possibility of a threefactor form of stdp in which neuromodulatory input must follow appropriately-timed pre- and postsynaptic spikes. this form of synaptic plasticity called reward-modulated stdp is much like the actor learning rule discussed here. synaptic changes that would be produced by regular stdp only occur if there is neuromodulatory input within a time window after a presynaptic spike is closely followed by a postsynaptic spike. evidence is accumulating that reward-modulated stdp occurs at the spines of medium spiny neurons of the dorsal striatum with dopamine providing the neuromodulatory factor the sites where actor learning takes place in the hypothetical neural implementation of an actor critic algorithm illustrated in figure experiments have demonstrated reward-modulated stdp in which lasting changes in the efficacies of corticostriatal synapses occur only if a neuromodulatory pulse arrives within a time window that can last up to seconds after a presynaptic spike is closely followed by a postsynaptic spike et al. although the evidence is indirect these experiments point to the existence of contingent eligibility traces having prolonged time courses. the molecular mechanisms producing these traces as well as the much shorter traces that likely underly stdp are not yet understood but research focusing on time-dependent and neuromodulator-dependent synaptic plasticity is continuing. the neuron-like actor unit that we have described here with its law-of-effect-style learning rule appeared in somewhat simpler form in the actor critic network of barto et al. that network was inspired by the hedonistic neuron hypothesis proposed by physiologist a. h. klopf not all the details of klopf s hypothesis are consistent with what has been learned about synaptic plasticity but the discovery of stdp and the growing evidence for a reward-modulated form of stdp suggest that klopf s ideas may not have been far off the mark. we discuss klopf s hedonistic neuron hypothesis next. hedonistic neurons in his hedonistic neuron hypothesis klopf conjectured that individual neurons seek to maximize the difference between synaptic input treated as rewarding and synaptic input treated as punishing by adjusting the efficacies of their synapses on the basis of rewarding or punishing consequences of their own action potentials. in other words individual neurons can be trained with response-contingent reinforcement like an animal can be trained in an instrumental conditioning task. his hypothesis included the idea that rewards and punishments are conveyed to a neuron via the same synaptic input that excites or inhibits the neuron s spike-generating activity. klopf known what we know today about neuromodulatory systems he might have assigned the reinforcing role to neuromodulatory input but he wanted to avoid any centralized source of training information. synaptically-local traces of past pre- and postsynaptic activity had the key function in klopf s hypothesis of making synapses eligible the term he introduced for modification by later reward or punishment. he conjectured that these traces are implemented by molecular mechanisms local to each synapse and therefore different from the electrical activity of both the pre- and the postsynaptic neurons. in hedonistic neurons the bibliographical and historical remarks section of this chapter we bring attention to some similar proposals made by others. klopf specifically conjectured that synaptic efficacies change in the following way. when a neuron fires an action potential all of its synapses that were active in contributing to that action potential become eligible to undergo changes in their efficacies. if the action potential is followed within an appropriate time period by an increase of reward the efficacies of all the eligible synapses increase. symmetrically if the action potential is followed within an appropriate time period by an increase of punishment the efficacies of eligible synapses decrease. this is implemented by triggering an eligibility trace at a synapse upon a coincidence of presynaptic and postsynaptic activity more exactly upon pairing of presynaptic activity with the postsynaptic activity that that presynaptic activity participates in causing what we call a contingent eligibility trace. this is essentially the three-factor learning rule of an actor unit described in the previous section. the shape and time course of an eligibility trace in klopf s theory reflects the durations of the many feedback loops in which the neuron is embedded some of which lie entirely within the brain and body of the organism while others extend out through the organism s external environment as mediated by its motor and sensory systems. his idea was that the shape of a synaptic eligibility trace is like a histogram of the durations of the feedback loops in which the neuron is embedded. the peak of an eligibility trace would then occur at the duration of the most prevalent feedback loops in which that neuron participates. the eligibility traces used by algorithms described in this book are simplified versions of klopf s original idea being exponentially geometrically decreasing functions controlled by the parameters and this simplifies simulations as well as theory but we regard these simple eligibility traces as a placeholders for traces closer to klopf s original conception which would have computational advantages in complex reinforcement learning systems by refining the credit-assignment process. klopf s hedonistic neuron hypothesis is not as implausible as it may at first appear. a well-studied example of a single cell that seeks some stimuli and avoids others is the bacterium escherichia coli. the movement of this single-cell organism is influenced by chemical stimuli in its environment behavior known as chemotaxis. it swims in its liquid environment by rotating hairlike structures called flagella attached to its surface. it rotates them! molecules in the bacterium s environment bind to receptors on its surface. binding events modulate the frequency with which the bacterium reverses flagellar rotation. each reversal causes the bacterium to tumble in place and then head off in a random new direction. a little chemical memory and computation causes the frequency of flagellar reversal to decrease when the bacterium swims toward higher concentrations of molecules it needs to survive and increase when the bacterium swims toward higher concentrations of molecules that are harmful the result is that the bacterium tends to persist in swimming up attractant gradients and tends to avoid swimming up repellant gradients. the chemotactic behavior just described is called klinokinesis. it is a kind of trialand-error behavior although it is unlikely that learning is involved the bacterium needs a modicum of short-term memory to detect molecular concentration gradients but it chapter neuroscience probably does not maintain long-term memories. artificial intelligence pioneer oliver selfridge called this strategy run and twiddle pointing out its utility as a basic adaptive strategy keep going in the same way if things are getting better and otherwise move around similarly one might think of a neuron swimming literally of course in a medium composed of the complex collection of feedback loops in which it is embedded acting to obtain one type of input signal and to avoid others. unlike the bacterium however the neuron s synaptic strengths retain information about its past trial-and-error behavior. if this view of the behavior of a neuron just one type of neuron is plausible then the closed-loop nature of how the neuron interacts with its environment is important for understanding its behavior where the neuron s environment consists of the rest of the animal together with the environment with which the animal as a whole interacts. klopf s hedonistic neuron hypothesis extended beyond the idea that individual neurons are reinforcement learning agents. he argued that many aspects of intelligent behavior can be understood as the result of the collective behavior of a population of self-interested hedonistic neurons interacting with one another in an immense society or economic system making up an animal s nervous system. whether or not this view of nervous systems is useful the collective behavior of reinforcement learning agents has implications for neuroscience. we take up this subject next. collective reinforcement learning the behavior of populations of reinforcement learning agents is deeply relevant to the study of social and economic systems and if anything like klopf s hedonistic neuron hypothesis is correct to neuroscience as well. the hypothesis described above about how an actor critic algorithm might be implemented in the brain only narrowly addresses the implications of the fact that the dorsal and ventral subdivisions of the striatum the respective locations of the actor and the critic according to the hypothesis each contain millions of medium spiny neurons whose synapses undergo change modulated by phasic bursts of dopamine neuron activity. the actor in figure is a single-layer network of k actor units. the actions produced by this network are vectors presumed to drive the animal s behavior. changes in the efficacies of the synapses of all of these units depend on the reinforcement signal because actor units attempt to make as large as possible effectively acts as a reward signal for them in this case reinforcement is the same as reward. thus each actor unit is itself a reinforcement learning agent a hedonistic neuron if you will. now to make the situation as simple as possible assume that each of these units receives the same reward signal at the same time as indicated above the assumption that dopamine is released at all the corticostriatal synapses under the same conditions and at the same times is likely an oversimplification. what can reinforcement learning theory tell us about what happens when all members of a population of reinforcement learning agents learn according to a common reward signal? the field of multi-agent reinforcement learning considers many aspects of learning by populations of reinforcement learning agents. although this field is beyond the collective reinforcement learning scope of this book we believe that some of its basic concepts and results are relevant to thinking about the brain s diffuse neuromodulatory systems. in multi-agent reinforcement learning in game theory the scenario in which all the agents try to maximize a common reward signal that they simultaneously receive is known as a cooperative game or a team problem. what makes a team problem interesting and challenging is that the common reward signal sent to each agent evaluates the pattern of activity produced by the entire population that is it evaluates the collective action of the team members. this means that any individual agent has only limited ability to affect the reward signal because any single agent contributes just one component of the collective action evaluated by the common reward signal. effective learning in this scenario requires addressing a structural credit assignment problem which team members or groups of team members deserve credit for a favorable reward signal or blame for an unfavorable reward signal? it is a cooperative game or a team problem because the agents are united in seeking to increase the same reward signal there are no conflicts of interest among the agents. the scenario would be a competitive game if different agents receive different reward signals where each reward signal again evaluates the collective action of the population and the objective of each agent is to increase its own reward signal. in this case there might be conflicts of interest among the agents meaning that actions that are good for some agents are bad for others. even deciding what the best collective action should be is a non-trivial aspect of game theory. this competitive setting might be relevant to neuroscience too example to account for heterogeneity of dopamine neuron activity but here we focus only on the cooperative or team case. how can each reinforcement learning agent in a team learn to do the right thing so that the collective action of the team is highly rewarded? an interesting result is that if each agent can learn effectively despite its reward signal being corrupted by a large amount of noise and despite its lack of access to complete state information then the population as a whole will learn to produce collective actions that improve as evaluated by the common reward signal even when the agents cannot communicate with one another. each agent faces its own reinforcement learning task in which its influence on the reward signal is deeply buried in the noise created by the influences of other agents. in fact for any agent all the other agents are part of its environment because its input both the part conveying state information and the reward part depends on how all the other agents are behaving. furthermore lacking access to the actions of the other agents indeed lacking access to the parameters determining their policies each agent can only partially observe the state of its environment. this makes each team member s learning task very difficult but if each uses a reinforcement learning algorithm able to increase a reward signal even under these difficult conditions teams of reinforcement learning agents can learn to produce collective actions that improve over time as evaluated by the team s common reward signal. if the team members are neuron-like units then each unit has to have the goal of increasing the amount of reward it receives over time as the actor unit does that we described in section each unit s learning algorithm has to have two essential features. first it has to use contingent eligibility traces. recall that a contingent eligibility chapter neuroscience trace in neural terms is initiated increased at a synapse when its presynaptic input participates in causing the postsynaptic neuron to fire. a non-contingent eligibility trace in contrast is initiated or increased by presynaptic input independently of what the postsynaptic neuron does. as explained in section by keeping information about what actions were taken in what states contingent eligibility traces allow credit for reward or blame for punishment to be apportioned to an agent s policy parameters according to the contribution the values of these parameters made in determining the agent s action. by similar reasoning a team member must remember its recent action so that it can either increase or decrease the likelihood of producing that action according to the reward signal that is subsequently received. the action component of a contingent eligibility trace implements this action memory. because of the complexity of the learning task however contingent eligibility is merely a preliminary step in the credit assignment process the relationship between a single team member s action and changes in the team s reward signal is a statistical correlation that has to be estimated over many trials. contingent eligibility is an essential but preliminary step in this process. learning with non-contingent eligibility traces does not work at all in the team setting because it does not provide a way to correlate actions with consequent changes in the reward signal. non-contingent eligibility traces are adequate for learning to predict as the critic component of the actor critic algorithm does but they do not support learning to control as the actor component must do. the members of a population of critic-like agents may still receive a common reinforcement signal but they would all learn to predict the same quantity in the case of an actor critic method would be the expected return for the current policy. how successful each member of the population would be in learning to predict the expected return would depend on the information it receives which could be very different for different members of the population. there would be no need for the population to produce differentiated patterns of activity. this is not a team problem as defined here. a second requirement for collective learning in a team problem is that there has to be variability in the actions of the team members in order for the team to explore the space of collective actions. the simplest way for a team of reinforcement learning agents to do this is for each member to independently explore its own action space through persistent variability in its output. this will cause the team as a whole to vary its collective actions. for example a team of the actor units described in section explores the space of collective actions because the output of each unit being a bernoulli-logistic unit probabilistically depends on the weighted sum of its input vector s components. the weighted sum biases firing probability up or down but there is always variability. because each unit uses a reinforce policy gradient algorithm each unit adjusts its weights with the goal of maximizing the average reward rate it experiences while stochastically exploring its own action space. one can show as williams did that a team of bernoulli-logistic reinforce units implements a policy gradient algorithm as a whole with respect to average rate of the team s common reward signal where the actions are the collective actions of the team. further williams showed that a team of bernoulli-logistic units using reinforce ascends the average reward gradient when the units in the team are intercon model-based methods in the brain nected to form a multilayer neural network. in this case the reward signal is broadcast to all the units in the network though reward may depend only on the collective actions of the network s output units. this means that a multilayer team of bernoulli-logistic reinforce units learns like a multilayer network trained by the widely-used error backpropagation method but in this case the backpropagation process is replaced by the broadcasted reward signal. in practice the error backpropagation method is considerably faster but the reinforcement learning team method is more plausible as a neural mechanism especially in light of what is being learned about reward-modulated stdp as discussed in section exploration through independent exploration by team members is only the simplest way for a team to explore more sophisticated methods are possible if the team members coordinate their actions to focus on particular parts of the collective action space either by communicating with one another or by responding to common inputs. there are also mechanisms more sophisticated than contingent eligibility traces for addressing structural credit assignment which is easier in a team problem when the set of possible collective actions is restricted in some way. an extreme case is a winner-take-all arrangement example the result of lateral inhibition in the brain that restricts collective actions to those to which only one or a few team members contribute. in this case the winners get the credit or blame for resulting reward or punishment. details of learning in cooperative games team problems and non-cooperative game problems are beyond the scope of this book. the bibliographical and historical remarks section at the end of this chapter cites a selection of the relevant publications including extensive references to research on implications for neuroscience of collective reinforcement learning. model-based methods in the brain reinforcement learning s distinction between model-free and model-based algorithms is proving to be useful for thinking about animal learning and decision processes. section discusses how this distinction aligns with that between habitual and goaldirected animal behavior. the hypothesis discussed above about how the brain might implement an actor critic algorithm is relevant only to an animal s habitual mode of behavior because the basic actor critic method is model-free. what neural mechanisms are responsible for producing goal-directed behavior and how do they interact with those underlying habitual behavior? one way to investigate questions about the brain structures involved in these modes of behavior is to inactivate an area of a rat s brain and then observe what the rat does in an outcome-devaluation experiment results from experiments like these indicate that the actor critic hypothesis described above is too simple in placing the actor in the dorsal striatum. inactivating one part of the dorsal striatum the dorsolateral striatum impairs habit learning causing the animal to rely more on goal-directed processes. on the other hand inactivating the dorsomedial striatum impairs goal-directed processes requiring the animal to rely more on habit learning. results like these support the view that the dls in rodents is more involved in model-free processes chapter neuroscience whereas their dms is more involved in model-based processes. results of studies with human subjects in similar experiments using functional neuroimaging and with nonhuman primates support the view that the analogous structures in the primate brain are differentially involved in habitual and goal-directed modes of behavior. other studies identify activity associated with model-based processes in the prefrontal cortex of the human brain the front-most part of the frontal cortex implicated in executive function including planning and decision making. specifically implicated is the orbitofrontal cortex the part of the prefrontal cortex immediately above the eyes. functional neuroimaging in humans and also recordings of the activities of single neurons in monkeys reveals strong activity in the ofc related to the subjective reward value of biologically significant stimuli as well as activity related to the reward expected as a consequence of actions. although not free of controversy these results suggest significant involvement of the ofc in goal-directed choice. it may be critical for the reward part of an animal s environment model. another structure involved in model-based behavior is the hippocampus a structure critical for memory and spatial navigation. a rat s hippocampus plays a critical role in the rat s ability to navigate a maze in the goal-directed manner that led tolman to the idea that animals use models or cognitive maps in selecting actions the hippocampus may also be a critical component of our human ability to imagine new experiences and maguire olafsd ottir barry saleem hassabis and spiers the findings that most directly implicate the hippocampus in planning the process needed to enlist an environment model in making decisions come from experiments that decode the activity of neurons in the hippocampus to determine what part of space hippocampal activity is representing on a moment-to-moment basis. when a rat pauses at a choice point in a maze the representation of space in the hippocampus sweeps forward not backwards along the possible paths the animal can take from that point and redish furthermore the spatial trajectories represented by these sweeps closely correspond to the rat s subsequent navigational behavior and foster these results suggest that the hippocampus is critical for the statetransition part of an animal s environment model and that it is part of a system that uses the model to simulate possible future state sequences to assess the consequences of possible courses of action a form of planning. the results described above add to a voluminous literature on neural mechanisms underlying goal-directed or model-based learning and decision making but many questions remain unanswered. for example how can areas as structurally similar as the dls and dms be essential components of modes of learning and behavior that are as different as model-free and model-based algorithms? are separate structures responsible for we call the transition and reward components of an environment model? is all planning conducted at decision time via simulations of possible future courses of action as the forward sweeping activity in the hippocampus suggests? in other words is all planning something like a rollout algorithm or are models sometimes engaged in the background to refine or recompute value information as illustrated by the dyna architecture how does the brain arbitrate between the use of the addiction habit and goal-directed systems? is there in fact a clear separation between the neural substrates of these systems? the evidence is not pointing to a positive answer to this last question. summarizing the situation doll simon and daw wrote that model-based influences appear ubiquitous more or less wherever the brain processes reward information and this is true even in the regions thought to be critical for model-free learning. this includes the dopamine signals themselves which can exhibit the influence of model-based information in addition to the reward prediction errors thought to be the basis of model-free processes. continuing neuroscience research informed by reinforcement learning s model-free and model-based distinction has the potential to sharpen our understanding of habitual and goal-directed processes in the brain. a better grasp of these neural mechanisms may lead to algorithms combining model-free and model-based methods in ways that have not yet been explored in computational reinforcement learning. addiction understanding the neural basis of drug abuse is a high-priority goal of neuroscience with the potential to produce new treatments for this serious public health problem. one view is that drug craving is the result of the same motivation and learning processes that lead us to seek natural rewarding experiences that serve our biological needs. addictive substances by being intensely reinforcing effectively co-opt our natural mechanisms of learning and decision making. this is plausible given that many though not all drugs of abuse increase levels of dopamine either directly or indirectly in regions around terminals of dopamine neuron axons in the striatum a brain structure firmly implicated in normal reward-based learning but the self-destructive behavior associated with drug addiction is not characteristic of normal learning. what is different about dopamine-mediated learning when the reward is the result of an addictive drug? is addiction the result of normal learning in response to substances that were largely unavailable throughout our evolutionary history so that evolution could not select against their damaging effects? or do addictive substances somehow interfere with normal dopamine-mediated learning? the reward prediction error hypothesis of dopamine neuron activity and its connection to td learning are the basis of a model due to redish of some but certainly not all features of addiction. the model is based on the observation that administration of cocaine and some other addictive drugs produces a transient increase in dopamine. in the model this dopamine surge is assumed to increase the td error in a way that cannot be cancelled out by changes in the value function. in other words whereas is reduced to the degree that a normal reward is predicted by antecedent events the contribution to due to an addictive stimulus does not decrease as the reward signal becomes predicted drug rewards cannot be predicted away. the model does this by preventing from ever becoming negative when the reward signal is due to an addictive drug thus eliminating the error-correcting feature of td learning for states associated with administration of the drug. the result is that the values of these states increase without bound making actions leading to these states preferred above all others. chapter neuroscience addictive behavior is much more complicated than this result from redish s model but the model s main idea may be a piece of the puzzle. or the model might be misleading. dopamine appears not to play a critical role in all forms of addiction and not everyone is equally susceptible to developing addictive behavior. moreover the model does not include the changes in many circuits and brain regions that accompany chronic drug taking for example changes that lead to a drug s diminishing effect with repeated use. it is also likely that addiction involves model-based processes. still redish s model illustrates how reinforcement learning theory can be enlisted in the effort to understand a major health problem. in a similar manner reinforcement learning theory has been influential in the development of the new field of computational psychiatry which aims to improve understanding of mental disorders through mathematical and computational methods. summary the neural pathways involved in the brain s reward system are complex and incompletely understood but neuroscience research directed toward understanding these pathways and their roles in behavior is progressing rapidly. this research is revealing striking correspondences between the brain s reward system and the theory of reinforcement learning as presented in this book. the reward prediction error hypothesis of dopamine neuron activity was proposed by scientists who recognized striking parallels between the behavior of td errors and the activity of neurons that produce dopamine a neurotransmitter essential in mammals for reward-related learning and behavior. experiments conducted in the late and in the laboratory of neuroscientist wolfram schultz showed that dopamine neurons respond to rewarding events with substantial bursts of activity called phasic responses only if the animal does not expect those events suggesting that dopamine neurons are signaling reward prediction errors instead of reward itself. further these experiments showed that as an animal learns to predict a rewarding event on the basis of preceding sensory cues the phasic activity of dopamine neurons shifts to earlier predictive cues while decreasing to later predictive cues. this parallels the backing-up effect of the td error as a reinforcement learning agent learns to predict reward. other experimental results firmly establish that the phasic activity of dopamine neurons is a reinforcement signal for learning that reaches multiple areas of the brain by means of profusely branching axons of dopamine producing neurons. these results are consistent with the distinction we make between a reward signal rt and a reinforcement signal which is the td error t in most of the algorithms we present. phasic responses of dopamine neurons are reinforcement signals not reward signals. a prominent hypothesis is that the brain implements something like an actor critic algorithm. two structures in the brain dorsal and ventral subdivisions of the striatum both of which play critical roles in reward-based learning may function respectively like an actor and a critic. that the td error is the reinforcement signal for both the actor and the critic fits well with the facts that dopamine neuron axons target both the dorsal and ventral subdivisions of the striatum that dopamine appears to be critical summary for modulating synaptic plasticity in both structures and that the effect on a target structure of a neuromodulator such as dopamine depends on properties of the target structure and not just on properties of the neuromodulator. the actor and the critic can be implemented by artificial neural networks consisting of neuron-like units having learning rules based on the policy-gradient actor critic method described in section each connection in these networks is like a synapse between neurons in the brain and the learning rules correspond to rules governing how synaptic efficacies change as functions of the activities of the presynaptic and the postsynaptic neurons together with neuromodulatory input corresponding to input from dopamine neurons. in this setting each synapse has its own eligibility trace that records past activity involving that synapse. the only difference between the actor and critic learning rules is that they use different kinds of eligibility traces the critic unit s traces are noncontingent because they do not involve the critic unit s output whereas the actor unit s traces are contingent because in addition to the actor unit s input they depend on the actor unit s output. in the hypothetical implementation of an actor critic system in the brain these learning rules respectively correspond to rules governing plasticity of corticostriatal synapses that convey signals from the cortex to the principal neurons in the dorsal and ventral striatal subdivisions synapses that also receive inputs from dopamine neurons. the learning rule of an actor unit in the actor critic network closely corresponds to reward-modulated spike-timing-dependent plasticity. in spike-timing-dependent plasticity the relative timing of pre- and postsynaptic activity determines the direction of synaptic change. in reward-modulated stdp changes in synapses in addition depend on a neuromodulator such as dopamine arriving within a time window that can last up to seconds after the conditions for stdp are met. evidence is accumulating that reward-modulated stdp occurs at corticostriatal synapses where the actor s learning takes place in the hypothetical neural implementation of an actor critic system adds to the plausibility of the hypothesis that something like an actor critic system exists in the brains of some animals. the idea of synaptic eligibility and basic features of the actor learning rule derive from klopf s hypothesis of the hedonistic neuron he conjectured that individual neurons seek to obtain reward and to avoid punishment by adjusting the efficacies of their synapses on the basis of rewarding or punishing consequences of their action potentials. a neuron s activity can affect its later input because the neuron is embedded in many feedback loops some within the animal s nervous system and body and others passing through the animal s external environment. klopf s idea of eligibility is that synapses are temporarily marked as eligible for modification if they participated in the neuron s firing this the contingent form of eligibility trace. a synapse s efficacy is modified if a reinforcing signal arrives while the synapse is eligible. we alluded to the chemotactic behavior of a bacterium as an example of a single cell that directs its movements in order to seek some molecules and to avoid others. a conspicuous feature of the dopamine system is that fibers releasing dopamine project widely to multiple parts of the brain. although it is likely that only some populations of dopamine neurons broadcast the same reinforcement signal if this signal reaches chapter neuroscience the synapses of many neurons involved in actor-type learning then the situation can be modeled as a team problem. in this type of problem each agent in a collection of reinforcement learning agents receives the same reinforcement signal where that signal depends on the activities of all members of the collection or team. if each team member uses a sufficiently capable learning algorithm the team can learn collectively to improve performance of the entire team as evaluated by the globally-broadcast reinforcement signal even if the team members do not directly communicate with one another. this is consistent with the wide dispersion of dopamine signals in the brain and provides a neurally plausible alternative to the widely-used error-backpropagation method for training multilayer networks. the distinction between model-free and model-based reinforcement learning is helping neuroscientists investigate the neural bases of habitual and goal-directed learning and decision making. research so far points to their being some brain regions more involved in one type of process than the other but the picture remains unclear because modelfree and model-based processes do not appear to be neatly separated in the brain. many questions remain unanswered. perhaps most intriguing is evidence that the hippocampus a structure traditionally associated with spatial navigation and memory appears to be involved in simulating possible future courses of action as part of an animal s decisionmaking process. this suggests that it is part of a system that uses an environment model for planning. reinforcement learning theory is also influencing thinking about neural processes underlying drug abuse. a model of some features of drug addiction is based on the reward prediction error hypothesis. it proposes that an addicting stimulant such as cocaine destabilizes td learning to produce unbounded growth in the values of actions associated with drug intake. this is far from a complete model of addiction but it illustrates how a computational perspective suggests theories that can be tested with further research. the new field of computational psychiatry similarly focuses on the use of computational models some derived from reinforcement learning to better understand mental disorders. this chapter only touched the surface of how the neuroscience of reinforcement learning and the development of reinforcement learning in computer science and engineering have influenced one another. most features of reinforcement learning algorithms owe their design to purely computational considerations but some have been influenced by hypotheses about neural learning mechanisms. remarkably as experimental data has accumulated about the brain s reward processes many of the purely computationallymotivated features of reinforcement learning algorithms are turning out to be consistent with neuroscience data. other features of computational reinforcement learning such eligibility traces and the ability of teams of reinforcement learning agents to learn to act collectively under the influence of a globally-broadcast reinforcement signal may also turn out to parallel experimental data as neuroscientists continue to unravel the neural basis of reward-based animal learning and behavior. summary bibliographical and historical remarks the number of publications treating parallels between the neuroscience of learning and decision making and the approach to reinforcement learning presented in this book is enormous. we can cite only a small selection. niv dayan and niv gimcher ludvig bellemare and pearson and shah are good places to start. together with economics evolutionary biology and mathematical psychology reinforcement learning theory is helping to formulate quantitative models of the neural mechanisms of choice in humans and non-human primates. with its focus on learning this chapter only lightly touches upon the neuroscience of decision making. glimcher introduced the field of neuroeconomics in which reinforcement learning contributes to the study of the neural basis of decision making from an economics perspective. see also glimcher and fehr the text on computational and mathematical modeling in neuroscience by dayan and abbott includes reinforcement learning s role in these approaches. sterling and laughlin examined the neural basis of learning in terms of general design principles that enable efficient adaptive behavior. there are many good expositions of basic neuroscience. kandel schwartz jessell siegelbaum and hudspeth is an authoritative and very comprehensive source. berridge and kringelbach reviewed the neural basis of reward and pleasure pointing out that reward processing has many dimensions and involves many neural systems. space prevents discussion of the influential research of berridge and robinson who distinguish between the hedonic impact of a stimulus which they call liking and the motivational effect which they call wanting. hare o doherty camerer schultz and rangel examined the neural basis of value-related signals from an economic perspective distinguishing between goal values decision values and prediction errors. decision value is goal value minus action cost. see also rangel camerer and montague rangel and hare and peters and b uchel the reward prediction error hypothesis of dopamine neuron activity is most prominently discussed by schultz dayan and montague the hypothesis was first explicitly put forward by montague dayan and sejnowski as they stated the hypothesis it referred to reward prediction errors but not specifically to td errors however their development of the hypothesis made it clear that they were referring to td errors. the earliest recognition of the tderrordopamine connection of which we are aware is that of montague dayan nowlan pouget and sejnowski who proposed a td-error-modulated hebbian learning rule motivated by results on dopamine signaling from schultz s group. the connection was also pointed out in an abstract by quartz dayan montague and sejnowski montague and sejnowski emphasized the importance of prediction in the brain and outlined how predictive hebbian chapter neuroscience learning modulated by td errors could be implemented via a diffuse neuromodulatory system such as the dopamine system. friston tononi reeke sporns and edelman presented a model of value-dependent learning in the brain in which synaptic changes are mediated by a td-like error provided by a global neuromodulatory signal they did not single out dopamine. montague dayan person and sejnowski presented a model of honeybee foraging using the td error. the model is based on research by hammer menzel and colleagues and menzel hammer showing that the neuromodulator octopamine acts as a reinforcement signal in the honeybee. montague et al. pointed out that dopamine likely plays a similar role in the vertebrate brain. barto related the actor critic architecture to basalganglionic circuits and discussed the relationship between td learning and the main results from schultz s group. houk adams and barto suggested how td learning and the actor critic architecture might map onto the anatomy physiology and molecular mechanism of the basal ganglia. doya and sejnowski extended their earlier paper on a model of birdsong learning and sejnowski by including a td-like error identified with dopamine to reinforce the selection of auditory input to be memorized. o reilly and frank and o reilly frank hazy and watz argued that phasic dopamine signals are rpes but not td errors. in support of their theory they cited results with variable interstimulus intervals that do not match predictions of a simple td model as well as the observation that higher-order conditioning beyond second-order conditioning is rarely observed while td learning is not so limited. dayan and niv discussed the good the bad and the ugly of how reinforcement learning theory and the reward prediction error hypothesis align with experimental data. glimcher reviewed the empirical findings that support the reward prediction error hypothesis and emphasized the significance of the hypothesis for contemporary neuroscience. graybiel is a brief primer on the basal ganglia. the experiments mentioned that involve optogenetic activation of dopamine neurons were conducted by tsai zhang adamantidis stuber bonci de lecea and deisseroth steinberg keiflin boivin witten deisseroth and janak and claridgechang roorda vrontou sjulson li hirsh and miesenb ock fiorillo yun and song lammel lim and malenka and saddoris cacciapaglia wightmman and carelli are among studies showing that the signaling properties of dopamine neurons are specialized for different target regions. rpe-signaling neurons may belong to one among multiple populations of dopamine neurons having different targets and subserving different functions. eshel tian bukwich and uchida found homogeneity of reward prediction error responses of dopamine neurons in the lateral vta during classical conditioning in mice though their results do not rule out response diversity across wider areas. gershman pesaran and daw studied reinforcement learning tasks that can be decomposed into independent components with separate reward signals finding evidence in human neuroimaging data suggesting summary that the brain exploits this kind of structure. schultz s survey article is a good entr ee into the very extensive literature on reward predicting signaling of dopamine neurons. berns mcclure pagnoni and montague breiter aharon kahneman dale and shizgal pagnoni zink montague and berns and o doherty dayan friston critchley and dolan described functional brain imaging studies supporting the existence of signals like td errors in the human brain. this section roughly follows barto in explaining how td errors mimic the main results from schultz s group on the phasic responses of dopamine neurons. this section is largely based on takahashi schoenbaum and niv and niv to the best of our knowledge barto and houk adams and barto first speculated about possible implementations of actor critic algorithms in the basal ganglia. on the basis of functional magnetic resonance imaging of human subjects while engaged in instrumental conditioning o doherty dayan schultz deichmann friston and dolan suggested that the actor and the critic are most likely located respectively in the dorsal and ventral striatum. gershman moustafa and ludvig focused on how time is represented in reinforcement learning models of the basal ganglia discussing evidence for and implications of various computational approaches to time representation. the hypothetical neural implementation of the actor critic architecture described in this section includes very little detail about known basal ganglia anatomy and physiology. in addition to the more detailed hypothesis of houk adams and barto a number of other hypotheses include more specific connections to anatomy and physiology and are claimed to explain additional data. these include hypotheses proposed by suri and schultz brown bullock and grossberg contreras-vidal and schultz suri bargas and arbib o reilly and frank and o reilly frank hazy and watz joel niv and ruppin critically evaluated the anatomical plausibility of several of these models and present an alternative intended to accommodate some neglected features of basal ganglionic circuitry. the actor learning rule discussed here is more complicated than the one in the early actor critic network of barto et al. actor-unit eligibility traces in that network were traces of just at xst instead of the full that work did not benefit from the policy-gradient theory presented in chapter or the contributions of williams who showed how an artificial neural network of bernoulli-logistic units could implement a policy-gradient method. chapter neuroscience reynolds and wickens proposed a three-factor rule for synaptic plasticity in the corticostriatal pathway in which dopamine modulates changes in corticostriatal synaptic efficacy. they discussed the experimental support for this kind of learning rule and its possible molecular basis. the definitive demonstration of spike-timing-dependent plasticity is attributed to markram l ubke frotscher and sakmann with evidence from earlier experiments by levy and steward and others that the relative timing of pre- and postsynaptic spikes is critical for inducing changes in synaptic efficacy. rao and sejnowski suggested how stdp could be the result of a td-like mechanism at synapses with non-contingent eligibility traces lasting about milliseconds. dayan commented that this would require an error as in sutton and barto s early model of classical conditioning and not a true td error. representative publications from the extensive literature on rewardmodulated stdp are wickens reynolds and wickens and calabresi picconi tozzi and di filippo pawlak and kerr showed that dopamine is necessary to induce stdp at the corticostriatal synapses of medium spiny neurons. see also pawlak wickens kirkwood and kerr yagishita hayashi-takagi ellis-davies urakubo ishii and kasai found that dopamine promotes spine enlargement of the medium spiny neurons of mice only during a time window of from to seconds after stdp stimulation. izhikevich proposed and explored the idea of using stdp timing conditions to trigger contingent eligibility traces. fr emaux sprekeler and gerstner proposed theoretical conditions for successful learning by rules based on reward-modulated stdp. klopf s hedonistic neuron hypothesis inspired our actor critic algorithm implemented as an artificial neural network with a single neuronlike unit called the actor unit implementing a law-of-effect-like learning rule sutton and anderson ideas related to klopf s synaptically-local eligibility have been proposed by others. crow proposed that changes in the synapses of cortical neurons are sensitive to the consequences of neural activity. emphasizing the need to address the time delay between neural activity and its consequences in a reward-modulated form of synaptic plasticity he proposed a contingent form of eligibility but associated with entire neurons instead of individual synapses. according to his hypothesis a wave of neuronal activity leads to a short-term change in the cells involved in the wave such that they are picked out from a background of cells not so activated. such cells are rendered sensitive by the short-term change to a reward signal in such a way that if such a signal occurs before the end of the decay time of the change the synaptic connexions between the cells are made more effective. crow argued against previous proposals that reverberating neural circuits play this role by pointing out that the effect of a reward signal on such a circuit would summary the synaptic connexions leading to the reverberation is to say those involved in activity at the time of the reward signal and not those on the path which led to the adaptive motor output. crow further postulated that reward signals are delivered via a distinct neural fiber system presumably the one into which olds and milner tapped that would transform synaptic connections from a short into a long-term form. in another farsighted hypothesis miller proposed a law-of-effect-like learning rule that includes synaptically-local contingent eligibility traces it is envisaged that in a particular sensory situation neurone b by chance fires a meaningful burst of activity which is then translated into motor acts which then change the situation. it must be supposed that the meaningful burst has an influence at the neuronal level on all of its own synapses which are active at the time thereby making a preliminary selection of the synapses to be strengthened though not yet actually strengthening them. strengthening signal makes the final selection and accomplishes the definitive change in the appropriate synapses. p. miller s hypothesis also included a critic-like mechanism which he called a sensory analyzer unit that worked according to classical conditioning principles to provide reinforcement signals to neurons so that they would learn to move from lower- to higher-valued states thus anticipating the use of the td error as a reinforcement signal in the actor critic architecture. miller s idea not only parallels klopf s the exception of its explicit invocation of a distinct strengthening signal it also anticipated the general features of reward-modulated stdp. a related though different idea which seung called the hedonistic synapse is that synapses individually adjust the probability that they release neurotransmitter in the manner of the law of effect if reward follows release the release probability increases and decreases if reward follows failure to release. this is essentially the same as the learning scheme minsky used in his princeton ph.d. dissertation where he called the synapse-like learning element a snarc neural-analog reinforcement calculator. contingent eligibility is involved in these ideas too although it is contingent on the activity of an individual synapse instead of the postsynaptic neuron. also related is the proposal of unnikrishman and venugopal that uses the correlation-based method of harth and tzanakou to adjust neural network weights. frey and morris proposed the idea of a synaptic tag for the induction of long-lasting strengthening of synaptic efficacy. though not unlike klopf s eligibility their tag was hypothesized to consist of a temporary strengthening of a synapse that could be transformed into a long-lasting strengthening by subsequent neuron activation. the model of o reilly and frank and o reilly frank hazy and watz uses working memory to bridge temporal intervals instead of eligibility traces. wickens and kotter discuss possible mechanisms for synaptic eligibility. he huertas hong tie hell shouval kirkwood chapter neuroscience provide evidence supporting the existence of contingent eligibility traces in synapses of cortical neurons with time courses like those of the eligibility traces klopf postulated. the metaphor of a neuron using a learning rule related to bacterial chemotaxis was discussed by barto koshland s extensive study of bacterial chemotaxis was in part motivated by similarities between features of bacteria and features of neurons see also berg shimansky proposed a synaptic learning rule somewhat similar to seung s mentioned above in which each synapse individually acts like a chemotactic bacterium. in this case a collection of synapses swims toward attractants in the high-dimensional space of synaptic weight values. montague dayan person and sejnowski proposed a chemotactic-like model of the bee s foraging behavior involving the neuromodulator octopamine. research on the behavior of reinforcement learning agents in team and game problems has a long history roughly occurring in three phases. to the best of our knowledge the first phase began with investigations by the russian mathematician and physicist m. l. tsetlin. a collection of his work was published as tsetlin after his death in our sections and refer to his study of learning automata in connection to bandit problems. the tsetlin collection also includes studies of learning automata in team and game problems which led to later work in this area using stochastic learning automata as described by narendra and thathachar viswanathan and narendra lakshmivarahan and narendra narendra and wheeler and thathachar and sastry thathachar and sastry is a more recent comprehensive account. these studies were mostly restricted to nonassociative learning automata meaning that they did not address associative or contextual bandit problems the second phase began with the extension of learning automata to the associative or contextual case. barto sutton and brouwer and barto and sutton experimented with associative stochastic learning automata in single-layer artificial neural networks to which a global reinforcement signal was broadcast. the learning algorithm was an associative extension of the alopex algorithm of harth and tzanakou barto et al. called neuron-like elements implementing this kind of learning associative search elements barto and anandan introduced an associative reinforcement learning algorithm called the associative reward-penalty p algorithm. they proved a convergence result by combining theory of stochastic learning automata with theory of pattern classification. barto and barto and jordan described results with teams of ar p units connected into multi-layer neural networks showing that they could learn nonlinear functions such as xor and others with a globally-broadcast reinforcement signal. barto extensively discussed this approach to artificial neural networks and how this type of learning rule is related to others in the literature at that time. williams mathematically analyzed and broadened this class of learning rules and related summary their use to the error backpropagation method for training multilayer artificial neural networks. williams described several ways that backpropagation and reinforcement learning can be combined for training artificial neural networks. williams showed that a special case of the ar p algorithm is a reinforce algorithm although better results were obtained with the general ar p algorithm the third phase of interest in teams of reinforcement learning agents was influenced by increased understanding of the role of dopamine as a widely broadcast neuromodulator and speculation about the existence of reward-modulated stdp. much more so than earlier research this research considers details of synaptic plasticity and other constraints from neuroscience. publications include the following and alphabetically bartlett and baxter xie and seung baras and meir farries and fairhall florian izhikevich pecevski maass and legenstein legenstein pecevski and maass kolodziejski porr and w org otter urbanczik and senn and vasilaki fr emaux urbanczik senn and gerstner now e vrancx and de hauwere reviewed more recent developments in the wider field of multi-agent reinforcement learning yin and knowlton reviewed findings from outcome-devaluation experiments with rodents supporting the view that habitual and goal-directed behavior psychologists use the phrase are respectively most associated with processing in the dorsolateral striatum and the dorsomedial striatum results of functional imaging experiments with human subjects in the outcome-devaluation setting by valentin dickinson and o doherty suggest that the orbitofrontal cortex is an important component of goaldirected choice. single unit recordings in monkeys by padoa-schioppa and assad support the role of the ofc in encoding values guiding choice behavior. rangel camerer and montague and rangel and hare reviewed findings from the perspective of neuroeconomics about how the brain makes goal-directed decisions. pezzulo van der meer lansink and pennartz reviewed the neuroscience of internally generated sequences and presented a model of how these mechanisms might be components of model-based planning. daw and shohamy proposed that while dopamine signaling connects well to habitual or model-free behavior other processes are involved in goal-directed or model-based behavior. data from experiments by bromberg-martin matsumoto hong and hikosaka indicate that dopamine signals contain information pertinent to both habitual and goal-directed behavior. doll simon and daw argued that there may not a clear separation in the brain between mechanisms that subserve habitual and goal-directed learning and choice. keiflin and janak reviewed connections between td errors and addiction. nutt lingford-hughes erritzoe and stokes critically evaluated the hypothesis that addiction is due to a disorder of the dopamine system. montague dolan friston and dayan outlined the goals and early efforts chapter neuroscience in the field of computational psychiatry and adams huys and roiser reviewed more recent progress. chapter applications and case studies in this chapter we present a few case studies of reinforcement learning. several of these are substantial applications of potential economic significance. one samuel s checkers player is primarily of historical interest. our presentations are intended to illustrate some of the trade-offs and issues that arise in real applications. for example we emphasize how domain knowledge is incorporated into the formulation and solution of the problem. we also highlight the representation issues that are so often critical to successful applications. the algorithms used in some of these case studies are substantially more complex than those we have presented in the rest of the book. applications of reinforcement learning are still far from routine and typically require as much art as science. making applications easier and more straightforward is one of the goals of current research in reinforcement learning. td-gammon one of the most impressive applications of reinforcement learning to date is that by gerald tesauro to the game of backgammon tesauro s program td-gammon required little backgammon knowledge yet learned to play extremely well near the level of the world s strongest grandmasters. the learning algorithm in td-gammon was a straightforward combination of the td algorithm and nonlinear function approximation using a multilayer neural network trained by backpropagating td errors. backgammon is a major game in the sense that it is played throughout the world with numerous tournaments and regular world championship matches. it is in part a game of chance and it is a popular vehicle for waging significant sums of money. there are probably more professional backgammon players than there are professional chess players. the game is played with white and black pieces on a board of locations called points. to the right on the next page is shown a typical position early in the game seen from the perspective of the white player. white here has just rolled the dice and obtained a and a this means that he can move one of his pieces steps and one chapter applications and case studies the same piece steps. for example he could move two pieces from the point one to the point and one to the point. white s objective is to advance all of his pieces into the last quadrant and then off the board. the first player to remove all his pieces wins. one complication is that the pieces interact as they pass each other going in different directions. for example if it were black s move he could use the dice roll of to move a piece from the point to the point hitting the white piece there. pieces that have been hit are placed on the bar in the middle of the board we already see one previously hit black piece from whence they reenter the race from the start. however if there are two pieces on a point then the opponent cannot move to that point the pieces are protected from being hit. thus white cannot use his dice roll to move either of his pieces on the point because their possible resulting points are occupied by groups of black pieces. forming contiguous blocks of occupied points to block the opponent is one of the elementary strategies of the game. backgammon involves several further complications but the above description gives the basic idea. with pieces and possible locations counting the bar and off-theboard it should be clear that the number of possible backgammon positions is enormous far more than the number of memory elements one could have in any physically realizable computer. the number of moves possible from each position is also large. for a typical dice roll there might be different ways of playing. in considering future moves such as the response of the opponent one must consider the possible dice rolls as well. the result is that the game tree has an effective branching factor of about this is far too large to permit effective use of the conventional heuristic search methods that have proved so effective in games like chess and checkers. on the other hand the game is a good match to the capabilities of td learning methods. although the game is highly stochastic a complete description of the game s state is available at all times. the game evolves over a sequence of moves and positions until finally ending in a win for one player or the other ending the game. the outcome can be interpreted as a final reward to be predicted. on the other hand the theoretical results we have described so far cannot be usefully applied to this task. the number of states is so large that a lookup table cannot be used and the opponent is a source of uncertainty and time variation. td-gammon used a nonlinear form of td the estimated value vsw of any state position s was meant to estimate the probability of winning starting from state s. to achieve this rewards were defined as zero for all time steps except those on which the game is won. to implement the value function td-gammon used a standard multilayer neural network much as shown to the right on the next page. real network had two additional units in its final layer to estimate the probability of each white pieces move black pieces move clockwise td-gammon player s winning in a special way called a gammon or backgammon. the network consisted of a layer of input units a layer of hidden units and a final output unit. the input to the network was a representation of a backgammon position and the output was an estimate of the value of that position. figure the td-gammon neural network in the first version of td-gammon td-gammon backgammon positions were represented to the network in a relatively direct way that involved little backgammon knowledge. it did however involve substantial knowledge of how neural networks work and how information is best presented to them. it is instructive to note the exact representation tesauro chose. there were a total of input units to the network. for each point on the backgammon board four units indicated the number of white pieces on the point. if there were no white pieces then all four units took on the value zero. if there was one piece then the first unit took on the value this encoded the elementary concept of a blot i.e. a piece that can be hit by the opponent. if there were two or more pieces then the second unit was set to this encoded the basic concept of a made point on which the opponent cannot land. if there were exactly three pieces on the point then the third unit was set to this encoded the basic concept of a single spare i.e. an extra piece in addition to the two pieces that made the point. finally if there were more than three pieces the fourth unit was set to a value proportionate to the number of additional pieces beyond three. letting n denote the total number of pieces on the point if n then the fourth unit took on the value this encoded a linear representation of multiple spares at the given point. with four units for white and four for black at each of the points that made a total of units. two additional units encoded the number of white and black pieces on the bar took the value where n is the number of pieces on the bar and two more encoded the number of black and white pieces already successfully removed from the board took the value where n is the number of pieces already borne off. finally two units indicated in a binary fashion whether it was white s or black s turn to move. the general logic behind these choices should be clear. basically tesauro tried to represent the position in a straightforward way while keeping the number of units relatively small. he provided one unit for each conceptually distinct possibility that seemed likely to be relevant and he scaled them to roughly the same range in this case between and given a representation of a backgammon position the network computed its estimated value in the standard way. corresponding to each connection from an input unit to a hidden unit was a real-valued weight. signals from each input unit were multiplied by their corresponding weights and summed at the hidden unit. the output hj of hidden vthidden units position input unitspredicted probabilityof winning vttd error. snetworkwastrainedonalargetrainingcorpusofexemplarymovesprovidedbybackgammonex-pertsandinadditionstartedwithasetoffeaturesspeciallycraftedfortd snetworkwastrainedonalargetrainingcorpusofexemplarymovesprovidedbybackgammonex-pertsandinadditionstartedwithasetoffeaturesspeciallycraftedforhidden chapter applications and case studies unit j was a nonlinear sigmoid function of the weighted sum hj e i wij xi where xi is the value of the ith input unit and wij is the weight of its connection to the jth hidden unit the weights in the network together make up the parameter vector w. the output of the sigmoid is always between and and has a natural interpretation as a probability based on a summation of evidence. the computation from hidden units to the output unit was entirely analogous. each connection from a hidden unit to the output unit had a separate weight. the output unit formed the weighted sum and then passed it through the same sigmoid nonlinearity. td-gammon used the semi-gradient form of the td algorithm described in section with the gradients computed by the error backpropagation algorithm hinton and williams recall that the general update rule for this case is wt where wt is the vector of all modifiable parameters this case the weights of the network and zt is a vector of eligibility traces one for each component of wt updated by zt zt vstwt with the gradient in this equation can be computed efficiently by the backpropagation procedure. for the backgammon application in which and the reward is always zero except upon winning the td error portion of the learning rule is usually just vstw as suggested in figure to apply the learning rule we need a source of backgammon games. tesauro obtained an unending sequence of games by playing his learning backgammon player against itself. to choose its moves td-gammon considered each of the or so ways it could play its dice roll and the corresponding positions that would result. the resulting positions are afterstates as discussed in section the network was consulted to estimate each of their values. the move was then selected that would lead to the position with the highest estimated value. continuing in this way with td-gammon making the moves for both sides it was possible to easily generate large numbers of backgammon games. each game was treated as an episode with the sequence of positions acting as the states tesauro applied the nonlinear td rule fully incrementally that is after each individual move. the weights of the network were set initially to small random values. the initial evaluations were thus entirely arbitrary. because the moves were selected on the basis of these evaluations the initial moves were inevitably poor and the initial games often lasted hundreds or thousands of moves before one side or the other won almost by accident. after a few dozen games however performance improved rapidly. td-gammon after playing about games against itself td-gammon as described above learned to play approximately as well as the best previous backgammon computer programs. this was a striking result because all the previous high-performance computer programs had used extensive backgammon knowledge. for example the reigning champion program at the time was arguably neurogammon another program written by tesauro that used a neural network but not td learning. neurogammon s network was trained on a large training corpus of exemplary moves provided by backgammon experts and in addition started with a set of features specially crafted for backgammon. neurogammon was a highly tuned highly effective backgammon program that decisively won the world backgammon olympiad in td-gammon on the other hand was constructed with essentially zero backgammon knowledge. that it was able to do as well as neurogammon and all other approaches is striking testimony to the potential of self-play learning methods. the tournament success of td-gammon with zero expert backgammon knowledge suggested an obvious modification add the specialized backgammon features but keep the self-play td learning method. this produced td-gammon td-gammon was clearly substantially better than all previous backgammon programs and found serious competition only among human experts. later versions of the program tdgammon hidden units and td-gammon hidden units were augmented with a selective two-ply search procedure. to select moves these programs looked ahead not just to the positions that would immediately result but also to the opponent s possible dice rolls and moves. assuming the opponent always took the move that appeared immediately best for him the expected value of each candidate move was computed and the best was selected. to save computer time the second ply of search was conducted only for candidate moves that were ranked highly after the first ply about four or five moves on average. two-ply search affected only the moves selected the learning process proceeded exactly as before. the final versions of the program td-gammon and used hidden units and a selective three-ply search. td-gammon illustrates the combination of learned value functions and decision-time search as in heuristic search and mcts methods. in follow-on work tesauro and galperin explored trajectory sampling methods as an alternative to full-width search which reduced the error rate of live play by large numerical factors while keeping the think time reasonable at seconds per move. during the tesauro was able to play his programs in a significant number of program td-gammon td-gammon td-gammon td-gammon td-gammon hidden training games units opponents results other programs tied for best robertie magriel pts games various grandmasters pts games pt games pts games robertie kazaros table summary of td-gammon results chapter applications and case studies games against world-class human players. a summary of the results is given in table based on these results and analyses by backgammon grandmasters see tesauro td-gammon appeared to play at close to or possibly better than the playing strength of the best human players in the world. tesauro reported in a subsequent article the results of an extensive rollout analysis of the move decisions and doubling decisions of td-gammon relative to top human players. the conclusion was that td-gammon had a lopsided advantage in piece-movement decisions and a slight edge in doubling decisions over top humans. td-gammon had a significant impact on the way the best human players play the game. for example it learned to play certain opening positions differently than was the convention among the best human players. based on td-gammon s success and further analysis the best human players now play these positions as td-gammon does the impact on human play was greatly accelerated when several other self-teaching neural net backgammon programs inspired by td-gammon such as jellyfish snowie and gnubackgammon became widely available. these programs enabled wide dissemination of new knowledge generated by the neural nets resulting in great improvements in the overall caliber of human tournament play samuel s checkers player an important precursor to tesauro s td-gammon was the seminal work of arthur samuel in constructing programs for learning to play checkers. samuel was one of the first to make effective use of heuristic search methods and of what we would now call temporal-difference learning. his checkers players are instructive case studies in addition to being of historical interest. we emphasize the relationship of samuel s methods to modern reinforcement learning methods and try to convey some of samuel s motivation for using them. samuel first wrote a checkers-playing program for the ibm in his first learning program was completed in and was demonstrated on television in later versions of the program achieved good though not expert playing skill. samuel was attracted to game-playing as a domain for studying machine learning because games are less complicated than problems taken from life while still allowing fruitful study of how heuristic procedures and learning can be used together. he chose to study checkers instead of chess because its relative simplicity made it possible to focus more strongly on learning. samuel s programs played by performing a lookahead search from each current position. they used what we now call heuristic search methods to determine how to expand the search tree and when to stop searching. the terminal board positions of each search were evaluated or scored by a value function or scoring polynomial using linear function approximation. in this and other respects samuel s work seems to have been inspired by the suggestions of shannon in particular samuel s program was based on shannon s minimax procedure to find the best move from the current position. working backward through the search tree from the scored terminal positions each position was given the score of the position that would result from the best move assuming samuel s checkers player that the machine would always try to maximize the score while the opponent would always try to minimize it. samuel called this the backed-up score of the position. when the minimax procedure reached the search tree s root the current position it yielded the best move under the assumption that the opponent would be using the same evaluation criterion shifted to its point of view. some versions of samuel s programs used sophisticated search control methods analogous to what are known as alpha-beta cutoffs see pearl samuel used two main learning methods the simplest of which he called rote learning. it consisted simply of saving a description of each board position encountered during play together with its backed-up value determined by the minimax procedure. the result was that if a position that had already been encountered were to occur again as a terminal position of a search tree the depth of the search was effectively amplified because this position s stored value cached the results of one or more searches conducted earlier. one initial problem was that the program was not encouraged to move along the most direct path to a win. samuel gave it a a sense of direction by decreasing a position s value a small amount each time it was backed up a level a ply during the minimax analysis. if the program is now faced with a choice of board positions whose scores differ only by the ply number it will automatically make the most advantageous choice choosing a low-ply alternative if winning and a high-ply alternative if losing p. samuel found this discounting-like technique essential to successful learning. rote learning produced slow but continual improvement that was most effective for opening and endgame play. his program became a better-than-average novice after learning from many games against itself a variety of human opponents and from book games in a supervised learning mode. rote learning and other aspects of samuel s work strongly suggest the essential idea of temporal-difference learning that the value of a state should equal the value of likely following states. samuel came closest to this idea in his second learning method his learning by generalization procedure for modifying the parameters of the value function. samuel s method was the same in concept as that used much later by tesauro in td-gammon. he played his program many games against another version of itself and performed an update after each move. the idea of samuel s update is suggested by the backup diagram in figure each open circle represents a position where the program moves next an on-move position and each solid circle represents a position where the opponent moves next. an update was made to the value of each on-move position after a move by each side resulting in a second on-move position. the update was toward the minimax value of a search launched from the second on-move position. thus the overall effect was that of a backing-up over one full move of real events and then a search over possible events as suggested by figure samuel s actual algorithm was significantly more complex than this for computational reasons but this was the basic idea. samuel did not include explicit rewards. instead he fixed the weight of the most important feature the piece advantage feature which measured the number of pieces the program had relative to how many its opponent had giving higher weight to kings and including refinements so that it was better to trade pieces when winning than when losing. thus the goal of samuel s program was to improve its piece advantage which in chapter applications and case studies figure the backup diagram for samuel s checkers player. checkers is highly correlated with winning. however samuel s learning method may have been missing an essential part of a sound temporal-difference algorithm. temporal-difference learning can be viewed as a way of making a value function consistent with itself and this we can clearly see in samuel s method. but also needed is a way of tying the value function to the true value of the states. we have enforced this via rewards and by discounting or giving a fixed value to the terminal state. but samuel s method included no rewards and no special treatment of the terminal positions of games. as samuel himself pointed out his value function could have become consistent merely by giving a constant value to all positions. he hoped to discourage such solutions by giving his piece-advantage term a large nonmodifiable weight. but although this may decrease the likelihood of finding useless evaluation functions it does not prohibit them. for example a constant function could still be attained by setting the modifiable weights so as to cancel the effect of the nonmodifiable one. because samuel s learning procedure was not constrained to find useful evaluation functions it should have been possible for it to become worse with experience. in fact samuel reported observing this during extensive self-play training sessions. to get the program improving again samuel had to intervene and set the weight with the largest absolute value back to zero. his interpretation was that this drastic intervention jarred the program out of local optima but another possibility is that it jarred the program out of evaluation functions that were consistent but had little to do with winning or losing the game. despite these potential problems samuel s checkers player using the generalization learning method approached better-than-average play. fairly good amateur opponents characterized it as tricky but beatable in contrast to the rote-learning version this version was able to develop a good middle game but remained weak in opening and endgame play. this program also included an ability to search through sets of hypothetical eventsactual eventsbackup watson s daily-double wagering features to find those that were most useful in forming the value function. a later version included refinements in its search procedure such as alpha-beta pruning extensive use of a supervised learning mode called book learning and hierarchical lookup tables called signature tables to represent the value function instead of linear function approximation. this version learned to play much better than the program though still not at a master level. samuel s checkers-playing program was widely recognized as a significant achievement in artificial intelligence and machine learning. watson s daily-double wagering ibm is the system developed by a team of ibm researchers to play the popular tv quiz show it gained fame in by winning first prize in an exhibition match against human champions. although the main technical achievement demonstrated by watson was its ability to quickly and accurately answer natural language questions over broad areas of general knowledge its winning jeopardy! performance also relied on sophisticated decision-making strategies for critical parts of the game. tesauro gondek lechner fan and prager adapted tesauro s td-gammon system described above to create the strategy used by watson in daily-double wagering in its celebrated winning performance against human champions. these authors report that the effectiveness of this wagering strategy went well beyond what human players are able to do in live game play and that it along with other advanced strategies was an important contributor to watson s impressive winning performance. here we focus only on dd wagering because it is the component of watson that owes the most to reinforcement learning. jeopardy! is played by three contestants who face a board showing squares each of which hides a clue and has a dollar value. the squares are arranged in six columns each corresponding to a different category. a contestant selects a square the host reads the square s clue and each contestant may choose to respond to the clue by sounding a buzzer buzzing in the first contestant to buzz in gets to try responding to the clue. if this contestant s response is correct their score increases by the dollar value of the square if their response is not correct or if they do not respond within five seconds their score decreases by that amount and the other contestants get a chance to buzz in to respond to the same clue. one or two squares on the game s current round are special dd squares. a contestant who selects one of these gets an exclusive opportunity to respond to the square s clue and has to decide before the clue is revealed on how much to wager or bet. the bet has to be greater than five dollars but not greater than the contestant s current score. if the contestant responds correctly to the dd clue their score increases by the bet amount otherwise it decreases by the bet amount. at the end of each game is a final jeopardy round in which each contestant writes down a sealed bet and then writes an answer after the clue is read. trademark of ibm corp. trademark of jeopardy productions inc. chapter applications and case studies the contestant with the highest score after three rounds of play a round consists of revealing all clues is the winner. the game has many other details but these are enough to appreciate the importance of dd wagering. winning or losing often depends on a contestant s dd wagering strategy. whenever watson selected a dd square it chose its bet by comparing action values qs bet that estimated the probability of a win from the current game state s for each round-dollar legal bet. except for some risk-abatement measures described below watson selected the bet with the maximum action value. action values were computed whenever a betting decision was needed by using two types of estimates that were learned before any live game play took place. the first were estimated values of the afterstates that would result from selecting each legal bet. these estimates were obtained from a state-value function v defined by parameters w that gave estimates of the probability of a win for watson from any game state. the second estimates used to compute action values gave the in-category dd confidence pdd which estimated the likelihood that watson would respond correctly to the as-yet unrevealed dd clue. tesauro et al. used the reinforcement learning approach of td-gammon described above to learn v a straightforward combination of nonlinear td using a multilayer neural network with weights w trained by backpropagating td errors during many simulated games. states were represented to the network by feature vectors specifically designed for jeopardy!. features included the current scores of the three players how many dds remained the total dollar value of the remaining clues and other information related to the amount of play left in the game. unlike td-gammon which learned by self-play watson s v was learned over millions of simulated games against carefullycrafted models of human players. in-category confidence estimates were conditioned on the number of right responses r and wrong responses w that watson gave in previouslyplayed clues in the current category. the dependencies on w were estimated from watson s actual accuracies over many thousands of historical categories. with the previously learned value function v and in-category dd confidence pdd watson computed qs bet for each legal round-dollar bet as follows qs bet pdd vsw bet. pdd vsw bet. where sw is watson s current score and v gives the estimated value for the game state after watson s response to the dd clue which is either correct or incorrect. computing an action value this way corresponds to the insight from exercise that an action value is the expected next state value given the action that here it is the expected next afterstate value because the full next state of the entire game depends on the next square selection. tesauro et al. found that selecting bets by maximizing action values incurred a frightening amount of risk meaning that if watson s response to the clue happened to be wrong the loss could be disastrous for its chances of winning. to decrease the downside risk of a wrong answer tesauro et al. adjusted by subtracting a small fraction of the standard deviation over watson s correctincorrect afterstate evaluations. they further reduced risk by prohibiting bets that would cause the wrong-answer afterstate value to decrease below a certain limit. these measures slightly reduced watson s expectation of winning but they significantly reduced downside risk not only in terms of watson s daily-double wagering average risk per dd bet but even more so in extreme-risk scenarios where a risk-neutral watson would bet most or all of its bankroll. why was the td-gammon method of self-play not used to learn the critical value function v? learning from self-play in jeopardy! would not have worked very well because watson was so different from any human contestant. self-play would have led to exploration of state space regions that are not typical for play against human opponents particularly human champions. in addition unlike backgammon jeopardy! is a game of imperfect information because contestants do not have access to all the information influencing their opponents play. in particular jeopardy! contestants do not know how much confidence their opponents have for responding to clues in the various categories. self-play would have been something like playing poker with someone who is holding the same cards that you hold. as a result of these complications much of the effort in developing watson s ddwagering strategy was devoted to creating good models of human opponents. the models did not address the natural language aspect of the game but were instead stochastic process models of events that can occur during play. statistics were extracted from an extensive fan-created archive of game information from the beginning of the show to the present day. the archive includes information such as the ordering of the clues right and wrong contestant answers dd locations and dd and fj bets for nearly clues. three models were constructed an average contestant model on all the data a champion model on statistics from games with the best players and a grand champion model on statistics from games with the best players. in addition to serving as opponents during learning the models were used to asses the benefits produced by the learned dd-wagering strategy. watson s win rate in simulation when it used a baseline heuristic dd-wagering strategy was when it used the learned values and a default confidence value its win rate increased to and with live in-category confidence it was tesauro et al. regarded this as a significant improvement given that the dd wagering was needed only about to times in each game. because watson had only a few seconds to bet as well as to select squares and decide whether or not to buzz in the computation time needed to make these decisions was a critical factor. the neural network implementation of v allowed dd bets to be made quickly enough to meet the time constraints of live play. however once games could be simulated fast enough through improvements in the simulation software near the end of a game it was feasible to estimate the value of bets by averaging over many monte-carlo trials in which the consequence of each bet was determined by simulating play to the game s end. selecting endgame dd bets in live play based on monte-carlo trials instead of the neural network significantly improved watson s performance because errors in value estimates in endgames could seriously affect its chances of winning. making all the decisions via monte-carlo trials might have led to better wagering decisions but this was simply impossible given the complexity of the game and the time constraints of live play. although its ability to quickly and accurately answer natural language questions stands out as watson s major achievement all of its sophisticated decision strategies chapter applications and case studies contributed to its impressive defeat of human champions. according to tesauro et al. it is plainly evident that our strategy algorithms achieve a level of quantitative precision and real-time performance that exceeds human capabilities. this is particularly true in the cases of dd wagering and endgame buzzing where humans simply cannot come close to matching the precise equity and confidence estimates and complex decision calculations performed by watson. optimizing memory control most computers use dynamic random access memory as their main memory because of its low cost and high capacity. the job of a dram memory controller is to efficiently use the interface between the processor chip and an off-chip dram system to provide the high-bandwidth and low-latency data transfer necessary for highspeed program execution. a memory controller needs to deal with dynamically changing patterns of readwrite requests while adhering to a large number of timing and resource constraints required by the hardware. this is a formidable scheduling problem especially with modern processors with multiple cores sharing the same dram. ipek mutlu mart nez and caruana mart nez and ipek designed a reinforcement learning memory controller and demonstrated that it can significantly improve the speed of program execution over what was possible with conventional controllers at the time of their research. they were motivated by limitations of existing state-of-the-art controllers that used policies that did not take advantage of past scheduling experience and did not account for long-term consequences of scheduling decisions. ipek et al. s project was carried out by means of simulation but they designed the controller at the detailed level of the hardware needed to implement it including the learning algorithm directly on a processor chip. accessing dram involves a number of steps that have to be done according to strict time constraints. dram systems consist of multiple dram chips each containing multiple rectangular arrays of storage cells arranged in rows and columns. each cell stores a bit as the charge on a capacitor. because the charge decreases over time each dram cell needs to be recharged refreshed every few milliseconds to prevent memory content from being lost. this need to refresh the cells is why dram is called dynamic. each cell array has a row buffer that holds a row of bits that can be transferred into or out of one of the array s rows. an activate command opens a row which means moving the contents of the row whose address is indicated by the command into the row buffer. with a row open the controller can issue read and write commands to the cell array. each read command transfers a word short sequence of consecutive bits in the row buffer to the external data bus and each write command transfers a word in the external data bus to the row buffer. before a different row can be opened a precharge command must be issued which transfers the updated data in the row buffer back into the addressed row of the cell array. after this another activate command can open a new row to be accessed. read and write commands are column optimizing memory control commands because they sequentially transfer bits into or out of columns of the row buffer multiple bits can be transferred without re-opening the row. read and write commands to the currently-open row can be carried out more quickly than accessing a different row which would involve additional row commands precharge and activate this is sometimes referred to as row locality. a memory controller maintains a memory transaction queue that stores memory-access requests from the processors sharing the memory system. the controller has to process requests by issuing commands to the memory system while adhering to a large number of timing constraints. a controller s policy for scheduling access requests can have a large effect on the performance of the memory system such as the average latency with which requests can be satisfied and the throughput the system is capable of achieving. the simplest scheduling strategy handles access requests in the order in which they arrive by issuing all the commands required by the request before beginning to service the next one. but if the system is not ready for one of these commands or executing a command would result in resources being underutilized due to timing constraints arising from servicing that one command it makes sense to begin servicing a newer request before finishing the older one. policies can gain efficiency by reordering requests for example by giving priority to read requests over write requests or by giving priority to readwrite commands to already open rows. the policy called first-ready firstcome-first-serve gives priority to column commands and write over row commands and precharge and in case of a tie gives priority to the oldest command. fr-fcfs was shown to outperform other scheduling policies in terms of average memory-access latency under conditions commonly encountered figure is a high-level view of ipek et al. s reinforcement learning memory controller. they modeled the dram access process as an mdp whose states are the contents of the transaction queue and whose actions are commands to the dram system precharge activate read write and noop. the reward signal is whenever the action figure high-level view of the reinforcement learning dram controller. the scheduler is the reinforcement learning agent. its environment is represented by features of the transaction ieee. reprinted with queue and its actions are commands to the dram system. permission from j. f. mart nez and e. ipek dynamic multicore resource management a machine learning approach micro ieee p. chapter applications and case studies is read or write and otherwise it is state transitions were considered to be stochastic because the next state of the system not only depends on the scheduler s command but also on aspects of the system s behavior that the scheduler cannot control such as the workloads of the processor cores accessing the dram system. critical to this mdp are constraints on the actions available in each state. recall from chapter that the set of available actions can depend on the state at ast where at is the action at time step t and ast is the set of actions available in state st. in this application the integrity of the dram system was assured by not allowing actions that would violate timing or resource constraints. although ipek et al. did not make it explicit they effectively accomplished this by pre-defining the sets ast for all possible states st. these constraints explain why the mdp has a noop action and why the reward signal is except when a read or write command is issued. noop is issued when it is the sole legal action in a state. to maximize utilization of the memory system the controller s task is to drive the system to states in which either a read or a write action can be selected only these actions result in sending data over the external data bus so it is only these that contribute to the throughput of the system. although precharge and activate produce no immediate reward the agent needs to select these actions to make it possible to later select the rewarded read and write actions. the scheduling agent used sarsa to learn an action-value function. states were represented by six integer-valued features. to approximate the action-value function the algorithm used linear function approximation implemented by tile coding with hashing the tile coding had tilings each storing action values as fixed point numbers. exploration was with state features included the number of read requests in the transaction queue the number of write requests in the transaction queue the number of write requests in the transaction queue waiting for their row to be opened and the number of read requests in the transaction queue waiting for their row to be opened that are the oldest issued by their requesting processors. other features depended on how the dram interacts with cache memory details we omit here. the selection of the state features was based on ipek et al. s understanding of factors that impact dram performance. for example balancing the rate of servicing reads and writes based on how many of each are in the transaction queue can help avoid stalling the dram system s interaction with cache memory. the authors in fact generated a relatively long list of potential features and then pared them down to a handful using simulations guided by stepwise feature selection. an interesting aspect of this formulation of the scheduling problem as an mdp is that the features input to the tile coding for defining the action-value function were different from the features used to specify the action-constraint sets ast. whereas the tile coding input was derived from the contents of the transaction queue the constraint sets depended on a host of other features related to timing and resource constraints that had to be satisfied by the hardware implementation of the entire system. in this way the action constraints ensured that the learning algorithm s exploration could not endanger the integrity of the physical system while learning was effectively limited to a safe region of the much larger state space of the hardware implementation. optimizing memory control because an objective of this work was that the learning controller could be implemented on a chip so that learning could occur online while a computer is running hardware implementation details were important considerations. the design included two five-stage pipelines to calculate and compare two action values at every processor clock cycle and to update the appropriate action value. this included accessing the tile coding which was stored on-chip in static ram. for the configuration ipek et al. simulated which was a chip typical of high-end workstations at the time of their research there were processor cycles for every dram cycle. considering the cycles needed to fill the pipes up to actions could be evaluated in each dram cycle. ipek et al. found that the number of legal commands for any state was rarely greater than this and that performance loss was negligible if enough time was not always available to consider all legal commands. these and other clever design details made it feasible to implement the complete controller and learning algorithm on a multi-processor chip. ipek et al. evaluated their learning controller in simulation by comparing it with three other controllers the fr-fcfs controller mentioned above that produces the best on-average performance a conventional controller that processes each request in order and an unrealizable ideal controller called the optimistic controller able to sustain dram throughput if given enough demand by ignoring all timing and resource constraints but otherwise modeling dram latency row buffer hits and bandwidth. they simulated nine memory-intensive parallel workloads consisting of scientific and data-mining applications. figure shows the performance inverse of execution time normalized to the performance of fr-fcfs of each controller for the nine applications together with the geometric mean of their performances over the applications. the learning controller labeled rl in the figure improved over that of fr-fcfs by from to over the nine applications with an average improvement of of course no realizable controller can match the performance of optimistic which ignores all timing and resource constraints but the learning controller s performance figure performances of four controllers over a suite of simulated benchmark applications. the controllers are the simplest in-order controller fr-fcfs the learning controller rl and the unrealizable optimistic controller which ignores all timing and resource constraints to provide a performance upper bound. performance normalized to that of fr-fcfs is the inverse of execution time. at far right is the geometric mean of performances over the benchmark applications for each controller. controller rl comes closest to the ideal performance. ieee. reprinted with permission from j. f. mart nez and e. ipek dynamic multicore resource management a machine learning approach micro ieee p. chapter applications and case studies closed the gap with optimistic s upper bound by an impressive because the rationale for on-chip implementation of the learning algorithm was to allow the scheduling policy to adapt online to changing workloads ipek et al. analyzed the impact of online learning compared to a previously-learned fixed policy. they trained their controller with data from all nine benchmark applications and then held the resulting action values fixed throughout the simulated execution of the applications. they found that the average performance of the controller that learned online was better than that of the controller using the fixed policy leading them to conclude that online learning is an important feature of their approach. this learning memory controller was never committed to physical hardware because of the large cost of fabrication. nevertheless ipek et al. could convincingly argue on the basis of their simulation results that a memory controller that learns online via reinforcement learning has the potential to improve performance to levels that would otherwise require more complex and more expensive memory systems while removing from human designers some of the burden required to manually design efficient scheduling policies. mukundan and mart nez took this project forward by investigating learning controllers with additional actions other performance criteria and more complex reward functions derived using genetic algorithms. they considered additional performance criteria related to energy efficiency. the results of these studies surpassed the earlier results described above and significantly surpassed the state-of-the-art for all of the performance criteria they considered. the approach is especially promising for developing sophisticated power-aware dram interfaces. human-level video game play one of the greatest challenges in applying reinforcement learning to real-world problems is deciding how to represent and store value functions andor policies. unless the state set is finite and small enough to allow exhaustive representation by a lookup table as in many of our illustrative examples one must use a parameterized function approximation scheme. whether linear or nonlinear function approximation relies on features that have to be readily accessible to the learning system and able to convey the information necessary for skilled performance. most successful applications of reinforcement learning owe much to sets of features carefully handcrafted based on human knowledge and intuition about the specific problem to be tackled. a team of researchers at google deepmind developed an impressive demonstration that a deep multi-layer artificial neural network can automate the feature design process et al. multi-layer anns have been used for function approximation in reinforcement learning ever since the popularization of the backpropagation algorithm as a method for learning internal representations hinton and williams see section striking results have been obtained by coupling reinforcement learning with backpropagation. the results obtained by tesauro and colleages with td-gammon and watson discussed above are notable examples. these and other applications benefited from the ability of multi-layer anns to learn task-relevant features. however in all the examples of which we are aware the most human-level video game play impressive demonstrations required the network s input to be represented in terms of specialized features handcrafted for the given problem. this is vividly apparent in the td-gammon results. td-gammon whose network input was essentially a raw representation of he backgammon board meaning that it involved very little knowledge of backgammon learned to play approximately as well as the best previous backgammon computer programs. adding specialized backgammon features produced td-gammon which was substantially better than all previous backgammon programs and competed well against human experts. mnih et al. developed a reinforcement learning agent called deep q-network that combined q-learning with a deep convolutional ann a many-layered or deep ann specialized for processing spatial arrays of data such as images. we describe deep convolutional anns in section by the time of mnih et al. s work with dqn deep anns including deep convolutional anns had produced impressive results in many applications but they had not been widely used in reinforcement learning. mnih et al. used dqn to show how a single reinforcement learning agent can achieve high levels of performance in many different problems without relying on different problemspecific feature sets. to demonstrate this they let dqn learn to play different atari video games by interacting with a game emulator. for learning each game dqn used the same raw input the same network architecture and the same parameter values step size discount rate exploration parameters and many more specific to the implementation. dqn achieved levels of play at or beyond human level on a large fraction of these games. although the games were alike in being played by watching streams of video images they varied widely in other respects. their actions had different effects they had different state-transition dynamics and they needed different policies for earning high scores. the deep convolutional ann learned to transform the raw input common to all the games into features specialized for representing the action values required for playing at the high level dqn achieved for most of the games. the atari is a home video game console that was sold in various versions by atari inc. from to it introduced or popularized many arcade video games that are now considered classics such as pong breakout space invaders and asteroids. although much simpler than modern video games atari games are still entertaining and challenging for human players and they have been attractive as testbeds for developing and evaluating reinforcement learning methods cohen littman naddaf cobo zang isbell and thomaz bellemare veness and bowling bellemare naddaf veness and bowling developed the publicly available arcade learning environment to encourage and simplify using atari games to study learning and planning algorithms. these previous studies and the availability of ale made the atari game collection a good choice for mnih et al. s demonstration which was also influenced by the impressive human-level performance that td-gammon was able to achieve in backgammon. dqn is similar to td-gammon in using a multi-layer ann as the function approximation method for a semi-gradient form of a td algorithm with the gradients computed by the backpropagation algorithm. however instead of using td as td-gammon did dqn used the semi-gradient form of q-learning. td-gammon estimated the values of chapter applications and case studies afterstates which were easily obtained from the rules for making backgammon moves. to use the same algorithm for the atari games would have required generating the next states for each possible action would not have been afterstates in that case. this could have been done by using the game emulator to run single-step simulations for all the possible actions ale makes possible. or a model of each game s state-transition function could have been learned and used to predict next states guo lee lewis and singh while these methods might have produced results comparable to dqn s they would have been more complicated to implement and would have significantly increased the time needed for learning. another motivation for using q-learning was that dqn used the experience replay method described below which requires an off-policy algorithm. being model-free and off-policy made q-learning a natural choice. before describing the details of dqn and how the experiments were conducted we look at the skill levels dqn was able to achieve. mnih et al. compared the scores of dqn with the scores of the best performing learning system in the literature at the time the scores of a professional human games tester and the scores of an agent that selected actions at random. the best system from the literature used linear function approximation with features hand designed using some knowledge about atari games naddaf veness and bowling dqn learned on each game by interacting with the game emulator for million frames which corresponds to about days of experience with the game. at the start of learning on each game the weights of dqn s network were reset to random values. to evaluate dqn s skill level after learning its score was averaged over sessions on each game each lasting up to minutes and beginning with a random initial game state. the professional human tester played using the same emulator the sound turned off to remove any possible advantage over dqn which did not process audio. after hours of practice the human played about episodes of each game for up to minutes each and was not allowed to take any break during this time. dqn learned to play better than the best previous reinforcement learning systems on all but of the games and played better than the human player on of the games. by considering any performance that scored at or above of the human score to be comparable to or better than human-level play mnih et al. concluded that the levels of play dqn learned reached or exceeded human level on of the games. see mnih et al. for a more detailed account of these results. for an artificial learning system to achieve these levels of play would be impressive enough but what makes these results remarkable and what many at the time considered to be breakthrough results for artificial intelligence is that the very same learning system achieved these levels of play on widely varying games without relying on any game-specific modifications. a human playing any of these atari games sees pixel image frames with colors at in principle exactly these images could have formed the raw input to dqn but to reduce memory and processing requirements mnih et al. preprocessed each frame to produce an array of luminance values. because the full states of many of the atari games are not completely observable from the image frames mnih et al. stacked the four most recent frames so that the inputs to the network had dimension human-level video game play this did not eliminate partial observability for all of the games but it was helpful in making many of them more markovian. an essential point here is that these preprocessing steps were exactly the same for all games. no game-specific prior knowledge was involved beyond the general understanding that it should still be possible to learn good policies with this reduced dimension and that stacking adjacent frames should help with the partial observability of some of the games. because no game-specific prior knowledge beyond this minimal amount was used in preprocessing the image frames we can think of the input vectors as being raw input to dqn. the basic architecture of dqn is similar to the deep convolutional ann illustrated in figure unlike that network subsampling in dqn is treated as part of each convolutional layer with feature maps consisting of units having only a selection of the possible receptive fields. dqn has three hidden convolutional layers followed by one fully connected hidden layer followed by the output layer. the three successive hidden convolutional layers of dqn produce feature maps feature maps and feature maps. the activation function of the units of each feature map is a rectifier nonlinearity x. the units in this third convolutional layer all connect to each of units in the fully connected hidden layer which then each connect to all units in the output layer one for each possible action in an atari game. the activation levels of dqn s output units were the estimated optimal action values q-values of the corresponding state action pairs for the state represented by the network s input. the assignment of output units to a game s actions varied from game to game and because the number of valid actions varied between and for the games not all output units had functional roles in all of the games. it helps to think of the network as if it were separate networks one for estimating the optimal action value of each possible action. in reality these networks shared their initial layers but the output units learned to use the features extracted by these layers in different ways. dqn s reward signal indicated how a games s score changed from one time step to the next whenever it increased whenever it decreased and otherwise. this standardized the reward signal across the games and made a single step-size parameter work well for all the games despite their varying ranges of scores. dqn used an policy with decreasing linearly over the first million frames and remaining at a low value for the rest of the learning session. the values of the various other parameters such as the learning step size discount rate and others specific to the implementation were selected by performing informal searches to see which values worked best for a small selection of the games. these values were then held fixed for all of the games. after dqn selected an action the action was executed by the game emulator which returned a reward and the next video frame. the frame was preprocessed and added to the four-frame stack that became the next input to the network. skipping for the moment the changes to the basic q-learning procedure made by mnih et al. dqn used the following semi-gradient form of q-learning to update the network s weights wt max a a wt qst at qst at wt chapter applications and case studies where wt is the vector of the network s weights at is the action selected at time step t and st and are respectively the preprocessed image stacks input to the network at time steps t and t the gradient in was computed by backpropagation. imagining again that there was a separate network for each action for the update at time step t backpropagation was applied only to the network corresponding to at. mnih et al. took advantage of techniques shown to improve the basic backpropagation algorithm when applied to large networks. they used a mini-batch method that updated weights only after accumulating gradient information over a small batch of images after images. this yielded smoother sample gradients compared to the usual procedure that updates weights after each action. they also used a gradient-ascent algorithm called rmsprop and hinton that accelerates learning by adjusting the step-size parameter for each weight based on a running average of the magnitudes of recent gradients for that weight. mnih et al. modified the basic q-learning procedure in three ways. first they used a method called experience replay first studied by lin this method stores the agent s experience at each time step in a replay memory that is accessed to perform the weight updates. it worked like this in dqn. after the game emulator executed action at in a state represented by the image stack st and returned reward and image stack it added the tuple at to the replay memory. this memory accumulated experiences over many plays of the same game. at each time step multiple q-learning updates a mini-batch were performed based on experiences sampled uniformly at random from the replay memory. instead of becoming the new st for the next update as it would in the usual form of q-learning a new unconnected experience was drawn from the replay memory to supply data for the next update. because q-learning is an off-policy algorithm it does not need to be applied along connected trajectories. q-learning with experience replay provided several advantages over the usual form of q-learning. the ability to use each stored experience for many updates allowed dqn to learn more efficiently from its experiences. experience replay reduced the variance of the updates because successive updates were not correlated with one another as they would be with standard q-learning. and by removing the dependence of successive experiences on the current weights experience replay eliminated one source of instability. mnih et al. modified standard q-learning in a second way to improve its stability. as in other methods that bootstrap the target for a q-learning update depends on the current action-value function estimate. when a parameterized function approximation method is used to represent action values the target is a function of the same parameters that are being updated. for example the target in the update given by is maxa a wt. its dependence on wt complicates the process compared to the simpler supervised-learning situation in which the targets do not depend on the parameters being updated. as discussed in chapter this can lead to oscillations andor divergence. to address this problem mnih et al. used a technique that brought q-learning closer to the simpler supervised-learning case while still allowing it to bootstrap. whenever a certain number c of updates had been done to the weights w of the action-value mastering the game of go network they inserted the network s current weights into another network and held these duplicate weights fixed for the next c updates of w. the outputs of this duplicate network over the next c updates of w were used as the q-learning targets. letting q denote the output of this duplicate network then instead of the update rule was wt max a a wt qst at qst at wt. a final modification of standard q-learning was also found to improve stability. they clipped the error term maxa a wt qst at wt so that it remained in the interval mnih et al. conducted a large number of learning runs on of the games to gain insight into the effect that various of dqn s design features had on its performance. they ran dqn with the four combinations of experience replay and the duplicate target network being included or not included. although the results varied from game to game each of these features alone significantly improved performance and very dramatically improved performance when used together. mnih et al. also studied the role played by the deep convolutional ann in dqn s learning ability by comparing the deep convolutional version of dqn with a version having a network of just one linear layer both receiving the same stacked preprocessed video frames. here the improvement of the deep convolutional version over the linear version was particularly striking across all of the test games. creating artificial agents that excel over a diverse collection of challenging tasks has been an enduring goal of artificial intelligence. the promise of machine learning as a means for achieving this has been frustrated by the need to craft problem-specific representations. deepmind s dqn stands as a major step forward by demonstrating that a single agent can learn problem-specific features enabling it to acquire humancompetitive skills over a range of tasks. but as mnih et al. point out dqn is not a complete solution to the problem of task-independent learning. although the skills needed to excel on the atari games were markedly diverse all the games were played by observing video images which made a deep convolutional ann a natural choice for this collection of tasks. in addition dqn s performance on some of the atari games fell considerably short of human skill levels on these games. the games most difficult for dqn especially montezuma s revenge on which dqn learned to perform about as well as the random player require deep planning beyond what dqn was designed to do. further learning control skills through extensive practice like dqn learned how to play the atari games is just one of the types of learning humans routinely accomplish. despite these limitations dqn advanced the state-of-the-art in machine learning by impressively demonstrating the promise of combining reinforcement learning with modern methods of deep learning. mastering the game of go the ancient chinese game of go has challenged artificial intelligence researchers for many decades. methods that achieve human-level skill or even superhuman-level skill chapter applications and case studies in other games have not been successful in producing strong go programs. thanks to a very active community of go programmers and international competitions the level of go program play has improved significantly over the years. until recently however no go program had been able to play anywhere near the level of a human go master. a team at deepmind et al. developed the program alphago that broke this barrier by combining deep artificial neural networks anns section supervised learning monte carlo tree search section and reinforcement learning. by the time of silver et al. s publication alphago had been shown to be decisively stronger than other current go programs and it had defeated the european go champion fan hui games to these were the first victories of a go program over a professional human go player without handicap in full go games. shortly thereafter a similar version of alphago won stunning victories over the world champion lee sedol winning out of a games in a challenge match making worldwide headline news. artificial intelligence researchers thought that it would be many more years perhaps decades before a program reached this level of play. here we describe alphago and a successor program called alphago zero et al. where in addition to reinforcement learning alphago relied on supervised learning from a large database of expert human moves alphago zero used only reinforcement learning and no human data or guidance beyond the basic rules of the game the zero in its name. we first describe alphago in some detail in order to highlight the relative simplicity of alphago zero which is both higher-performing and more of a pure reinforcement learning program. in many ways both alphago and alphago zero are descendants of tesauo s tdgammon itself a descendant of samuel s checkers player all these programs included reinforcement learning over simulated games of self-play. alphago and alphago zero also built upon the progress made by deepmind on playing atari games with the program dqn that used deep convolutional anns to approximate optimal value functions. go is a game between two players who alternately place black and white stones on unoccupied intersections or points on a board with a grid of horizontal and vertical lines to produce positions like that shown to the right. the game s goal is to capture an area of the board larger than that captured by the opponent. stones are captured according to simple rules. a player s stones are captured if they are completely surrounded by the other player s stones meaning that there is no horizontally or vertically adjacent point that is unoccupied. for example figure shows on the left three white stones with an unoccupied adjacent point x. if player black places a stone on x the three white stones are captured and taken a go board configuration mastering the game of go off the board middle. however if player white were to place a stone on point x first than the possibility of this capture would be blocked right. other rules are needed to prevent infinite capturingre-capturing loops. the game ends when neither player wishes to place another stone. these rules are simple but they produce a very complex game that has had wide appeal for thousands of years. figure go capturing rule. left the three white stones are not surrounded because point x is unoccupied. middle if black places a stone on x the three white stones are captured and removed from the board. right if white places a stone on point x first the capture is blocked. methods that produce strong play for other games such as chess have not worked as well for go. the search space for go is significantly larger than that of chess because go has a larger number of legal moves per position than chess versus and go games tend to involve more moves than chess games versus but the size of the search space is not the major factor that makes go so difficult. exhaustive search is infeasible for both chess and go and go on smaller boards e.g. has proven to be exceedingly difficult as well. experts agree that the major stumbling block to creating stronger-than-amateur go programs is the difficulty of defining an adequate position evaluation function. a good evaluation function allows search to be truncated at a feasible depth by providing relatively easy-to-compute predictions of what deeper search would likely yield. according to m uller no simple yet reasonable evaluation function will ever be found for go. a major step forward was the introduction of mcts to go programs. the strongest programs at the time of alphago s development all included mcts but master-level skill remained elusive. recall from section that mcts is a decision-time planning procedure that does not attempt to learn and store a global evaluation function. like a rollout algorithm it runs many monte carlo simulations of entire episodes entire go games to select each action each go move where to place a stone or to resign. unlike a simple rollout algorithm however mcts is an iterative procedure that incrementally extends a search tree whose root node represents the current environment state. as illustrated in figure each iteration traverses the tree by simulating actions guided by statistics associated with the tree s edges. in its basic version when a simulation reaches a leaf node of the search tree mcts expands the tree by adding some or all of the leaf node s children to the tree. from the leaf node or one of its newly added child notes a rollout is executed a simulation that typically proceeds all the way to a terminal state with actions selected by a rollout policy. when the rollout completes the statistics associated with the search tree s edges that were traversed in this iteration are updated by backing up the return produced by the rollout. mcts continues this process starting each time at the search tree s root at the current state for as many iterations as possible given the time constraints. then finally an action from the root node still represents the current environment state is selected x chapter applications and case studies according to statistics accumulated in the root node s outgoing edges. this is the action the agent takes. after the environment transitions to its next state mcts is executed again with the root node set to represent the new current state. the search tree at the start of this next execution might be just this new root node or it might include descendants of this node left over from mcts s previous execution. the remainder of the tree is discarded. alphago the main innovation that made alphago such a strong player is that it selected moves by a novel version of mcts that was guided by both a policy and a value function learned by reinforcement learning with function approximation provided by deep convolutional anns. another key feature is that instead of reinforcement learning starting from random network weights it started from weights that were the result of previous supervised learning from a large collection of human expert moves. the deepmind team called alphago s modification of basic mcts asynchronous policy and value mcts or apv-mcts. it selected actions via basic mcts as described above but with some twists in how it extended its search tree and how it evaluated action edges. in contrast to basic mcts which expands its current search tree by using stored action values to select an unexplored edge from a leaf node apv-mcts as implemented in alphago expanded its tree by choosing an edge according to probabilities supplied by a deep convolutional ann called the sl-policy network trained previously by supervised learning to predict moves contained in a database of nearly million human expert moves. then also in contrast to basic mcts which evaluates the newly-added state node solely by the return of a rollout initiated from it apv-mcts evaluated the node in two ways by this return of the rollout but also by a value function v learned previously by a reinforcement learning method. if s was the newly-added node its value became vs g where g was the return of the rollout and controlled the mixing of the values resulting from these two evaluation methods. in alphago these values were supplied by the value network another deep convolutional ann that was trained as we describe below to output estimated values of board positions. apv-mcts s rollouts in alphago were simulated games with both players using a fast rollout policy provided by a simple linear network also trained by supervised learning before play. throughout its execution apv-mcts kept track of how many simulations passed through each edge of the search tree and when its execution completed the most-visited edge from the root node was selected as the action to take here the move alphago actually made in a game. the value network had the same structure as the deep convolutional sl policy network except that it had a single output unit that gave estimated values of game positions instead of the sl policy network s probability distributions over legal actions. ideally the value network would output optimal state values and it might have been possible to approximate the optimal value function along the lines of td-gammon described above mastering the game of go self-play with nonlinear td coupled to a deep convolutional ann. but the deepmind team took a different approach that held more promise for a game as complex as go. they divided the process of training the value network into two stages. in the first stage they created the best policy they could by using reinforcement learning to train an rl policy network. this was a deep convolutional ann with the same structure as the sl policy network. it was initialized with the final weights of the sl policy network that were learned via supervised learning and then policy-gradient reinforcement learning was used to improve upon the sl policy. in the second stage of training the value network the team used monte carlo policy evaluation on data obtained from a large number of simulated self-play games with moves selected by the rl policy network. figure illustrates the networks used by alphago and the steps taken to train them in what the deepmind team called the alphago pipeline. all these networks were trained before any live game play took place and their weights remained fixed throughout live play. figure alphago pipeline. adapted with permission from macmillan publishers ltd nature vol. p. copyright here is some more detail about alphago s anns and their training. the identicallystructured sl and rl policy networks were similar to dqn s deep convolutional network described in section for playing atari games except that they had convolutional layers with the final layer consisting of a soft-max unit for each point on the go board. the networks input was a image stack in which each point on the go board was represented by the values of binary or integer-valued features. for example for each point one feature indicated if the point was occupied by one of alphago s stones one of its opponent s stones or was unoccupied thus providing the raw representation of the board configuration. other features were based on the rules of go such as the number of adjacent points that were empty the number of opponent stones that would be captured by placing a stone there the number of turns since a stone rollout policy sl policy network rl policy network value networkpolicy gradientsupervised learningmc policy evaluationself playsupervised learningnetworksdata chapter applications and case studies was placed there and other features that the design team considered to be important. training the sl policy network took approximately weeks using a distributed implementation of stochastic gradient ascent on processors. the network achieved accuracy where the best accuracy achieved by other groups at the time of publication was training the rl policy network was done by policy gradient reinforcement learning over simulated games between the rl policy network s current policy and opponents using policies randomly selected from policies produced by earlier iterations of the learning algorithm. playing against a randomly selected collection of opponents prevented overfitting to the current policy. the reward signal was if the current policy won if it lost and zero otherwise. these games directly pitted the two policies against one another without involving mcts. by simulating many games in parallel on processors the deepmind team trained the rl policy network on a million games in a single day. in testing the final rl policy they found that it won more than of games played against the sl policy and it won of games played against a go program using mcts that simulated games per move. the value network whose structure was similar to that of the sl and rl policy networks except for its single output unit received the same input as the sl and rl policy networks with the exception that there was an additional binary feature giving the current color to play. monte carlo policy evaluation was used to train the network from data obtained from a large number of self-play games played using the rl policy. to avoid overfitting and instability due to the strong correlations between positions encountered in self-play the deepmind team constructed a data set of million positions each chosen randomly from a unique self-play game. then training was done using million mini-batches each of positions drawn from this data set. training took one week on gpus. the rollout policy was learned prior to play by a simple linear network trained by supervised learning from a corpus of million human moves. the rollout policy network had to output actions quickly while still being reasonably accurate. in principle the sl or rl policy networks could have been used in the rollouts but the forward propagation through these deep networks took too much time for either of them to be used in rollout simulations a great many of which had to be carried out for each move decision during live play. for this reason the rollout policy network was less complex than the other policy networks and its input features could be computed more quickly than the features used for the policy networks. the rollout policy network allowed approximately complete game simulations per second to be run on each of the processing threads that alphago used. one may wonder why the sl policy was used instead of the better rl policy to select actions in the expansion phase of apv-mcts. these policies took the same amount of time to compute because they used the same network architecture. the team actually found that alphago played better against human opponents when apv-mcts used as the sl policy instead of the rl policy. they conjectured that the reason for this was that the latter was tuned to respond to optimal moves rather than to the broader set of moves characteristic of human play. interestingly the situation was reversed for the value function used by apv-mcts. they found that when apv-mcts used the value mastering the game of go function derived from the rl policy it performed better than if it used the value function derived from the sl policy. several methods worked together to produce alphago s impressive playing skill. the deepmind team evaluated different versions of alphago in order to assess the contributions made by these various components. the parameter in controlled the mixing of game state evaluations produced by the value network and by rollouts. with alphago used just the value network without rollouts and with evaluation relied just on rollouts. they found that alphago using just the value network played better than the rollout-only alphago and in fact played better than the strongest of all other go programs existing at the time. the best play resulted from setting indicating that combining the value network with rollouts was particularly important to alphago s success. these evaluation methods complemented one another the value network evaluated the high-performance rl policy that was too slow to be used in live play while rollouts using the weaker but much faster rollout policy were able to add precision to the value network s evaluations for specific states that occurred during games. overall alphago s remarkable success fueled a new round of enthusiasm for the promise of artificial intelligence specifically for systems combining reinforcement learning with deep anns to address problems in other challenging domains. alphago zero building upon the experience with alphago a deepmind team developed alphago zero et al. in contrast to alphago this program used no human data or guidance beyond the basic rules of the game the zero in its name. it learned exclusively from self-play reinforcement learning with input giving just raw descriptions of the placements of stones on the go board. alphago zero implemented a form of policy iteration interleaving policy evaluation with policy improvement. figure is an overview of alphago zero s algorithm. a significant difference between alphago zero and alphago is that alphago zero used mcts to select moves throughout self-play reinforcement learning whereas alphago used mcts for live play after but not during learning. other differences besides not using any human data or human-crafted features are that alphago zero used only one deep convolutional ann and used a simpler version of mcts. alphago zero s mcts was simpler than the version used by alphago in that it did not include rollouts of complete games and therefore did not need a rollout policy. each iteration of alphago zero s mcts ran a simulation that ended at a leaf node of the current search tree instead of at the terminal position of a complete game simulation. but as in alphago each iteration of mcts in alphago zero was guided by the output of a deep convolutional network labeled f in figure were is the network s weight vector. the input to the network whose architecture we describe below consisted of raw representations of board positions and its output had two parts a scalar value v an estimate of the probability that the current player will win from from the current board position and a vector p of move probabilities one for each possible stone placement on the current board plus the pass or resign move. chapter applications and case studies figure alphago zero self-play reinforcement learning. a the program played many games against itself one shown here as a sequence of board positions si i t with moves ai i t and winner z. each move ai was determined by action probabilities i returned by mcts executed from root node si and guided by a deep convolutional network here labeled f with latest weights shown here for just one position s but repeated for all si the network s inputs were raw representations of board positions si with several past positions though not shown here and its outputs were vectors p of move probabilities that guided mcts s forward searches and scalar values v that estimated the probability of the current player winning from each position si. b deep convolutional network training. training examples were randomly sampled steps from recent self-play games. weights were updated to move the policy vector p toward the probabilities returned by mcts and to include the winners z in the estimated win probability v. reprinted from draft of silver et al. with permission of the authors and deepmind. instead of selecting self-play actions according to the probabilities p however alphago zero used these probabilities together with the network s value output to direct each execution of mcts which returned new move probabilities shown in figure as the policies i. these policies benefitted from the many simulations that mcts conducted each time it executed. the result was that the policy actually followed by alphago zero was an improvement over the policy given by the network s outputs p. silver et al. wrote that mcts may therefore be viewed as a powerful policy improvement operator. here is more detail about alphago zero s ann and how it was trained. the network took as input a image stack consisting of binary feature planes. the first feature planes were raw representations of the positions of the current player s stones in the current and seven past board configurations a feature value was if a player s stone was on the corresponding point and was otherwise. the next feature planes t.theterminalpositionstisscoredtocomputethegamewinnerz.bneuralnetworktraininginalphagozero.theneuralnetworktakestherawboardpositionsasitsinputpassesitthroughmanyconvolutionallayerswithparameters areupdatedsoastomaximisethesimilarityofthepolicyvectorptothesearchprobabilities mastering the game of go similarly coded the positions of the opponent s stones. a final input feature plane had a constant value indicating the color of the current play for black for white. because repetition is not allowed in go and one player is given some number of compensation points for not getting the first move the current board position is not a markov state of go. this is why features describing past board positions and the color feature were needed. the network was two-headed meaning that after a number of initial layers the network split into two separate heads of additional layers that separately fed into two sets of output units. in this case one head fed output units producing move probabilities p one for each possible stone placement plus pass the other head fed just one output unit producing the scalar v an estimate of the probability that the current player will win from the current board position. the network before the split consisted of convolutional layers each followed by batch normalization and with skip connections added to implement residual learning by pairs of layers section overall move probabilities and values were computed by and layers respectively. starting with random weights the network was trained by stochastic gradient descent momentum regularization and step-size parameter decreasing as training continues using batches of examples sampled uniformly at random from all the steps of the most recent games of self-play with the current best policy. extra noise was added to the network s output p to encourage exploration of all possible moves. at periodic checkpoints during training which silver et al. chose to be at every training steps the policy output by the ann with the latest weights was evaluated by simulating games mcts with iterations to select each move against the current best policy. if the new policy won a margin set to reduce noise in the outcome then it became the best policy to be used in subsequent self-play. the network s weights were updated to make the network s policy output p more closely match the policy returned by mcts and to make its value output v more closely match the probability that the current best policy wins from the board position represented by the network s input. the deepmind team trained alphago zero over million games of self-play which took about days. each move of each game was selected by running mcts for iterations taking approximately second per move. network weights were updated over batches each consisting of board configurations. they then ran tournaments with the trained alphago zero playing against the version of alphago that defeated fan hui by games to and against the version that defeated lee sedol by games to they used the elo rating system to evaluate the relative performances of the programs. the difference between two elo ratings is meant to predict the outcome of games between the players. the elo ratings of alphago zero the version of alphago that played against fan hui and the version that played against lee sedol were respectively and the gaps in these elo ratings translate into predictions that alphago zero would defeat these other programs with probabilities very close to one. in a match of games between alphago zero trained as described and the exact version of alphago that defeated lee sedol held under the same conditions that were used in that match alphago zero defeated alphago in all games. chapter applications and case studies the deepmind team also compared alphago zero with a program using an ann with the same architecture but trained by supervised learning to predict human moves in a data set containing nearly million positions from games. they found that the supervised-learning player initially played better than alphago zero and was better at predicting human expert moves but played less well after alphago zero was trained for a day. this suggested that alphago zero had discovered a strategy for playing that was different from how humans play. in fact alphago zero discovered and came to prefer some novel variations of classical move sequences. final tests of alphago zero s algorithm were conducted with a version having a larger ann and trained over million self-play games which took about days again starting with random weights. this version achieved an elo rating of the team pitted this version of alphago zero against a program called alphago master the strongest program at the time that was identical to alphago zero but like alphago used human data and features. alphago master s elo rating was and it had defeated the strongest human professional players to in online games. in a game match alphago zero with the larger network and more extensive learning defeated alphago master games to thus providing a convincing demonstration of the problem-solving power of alphago zero s algorithm. alphago zero soundly demonstrated that superhuman performance can be achieved by pure reinforcement learning augmented by a simple version of mcts and deep anns with very minimal knowledge of the domain and no reliance on human data or guidance. we will surely see systems inspired by the deepmind accomplishments of both alphago and alphago zero applied to challenging problems in other domains. recently yet a better program alphazero was described by silver et al. that does not even incorporate knowledge of go. alphazero is a general reinforcement learning algorithm that improves over the world s hitherto best programs in the diverse games of go chess and shogi. personalized web services personalizing web services such as the delivery of news articles or advertisements is one approach to increasing users satisfaction with a website or to increase the yield of a marketing campaign. a policy can recommend content considered to be the best for each particular user based on a profile of that user s interests and preferences inferred from their history of online activity. this is a natural domain for machine learning and in particular for reinforcement learning. a reinforcement learning system can improve a recommendation policy by making adjustments in response to user feedback. one way to obtain user feedback is by means of website satisfaction surveys but for acquiring feedback in real time it is common to monitor user clicks as indicators of interest in a link. a method long used in marketing called ab testing is a simple type of reinforcement learning used to decide which of two versions a or b of a website users prefer. because it is non-associative like a two-armed bandit problem this approach does not personalize content delivery. adding context consisting of features describing individual users and personalized web services the content to be delivered allows personalizing service. this has been formalized as a contextual bandit problem an associative reinforcement learning problem section with the objective of maximizing the total number of user clicks. li chu langford and schapire applied a contextual bandit algorithm to the problem of personalizing the yahoo! front page today webpage of the most visited pages on the internet at the time of their research by selecting the news story to feature. their objective was to maximize the click-through rate which is the ratio of the total number of clicks all users make on a webpage to the total number of visits to the page. their contextual bandit algorithm improved over a standard non-associative bandit algorithm by theocharous thomas and ghavamzadeh argued that better results are possible by formulating personalized recommendation as a markov decision problem with the objective of maximizing the total number of clicks users make over repeated visits to a website. policies derived from the contextual bandit formulation are greedy in the sense that they do not take long-term effects of actions into account. these policies effectively treat each visit to a website as if it were made by a new visitor uniformly sampled from the population of the website s visitors. by not using the fact that many users repeatedly visit the same websites greedy policies do not take advantage of possibilities provided by long-term interactions with individual users. as an example of how a marketing strategy might take advantage of long-term user interaction theocharous et al. contrasted a greedy policy with a longer-term policy for displaying ads for buying a product say a car. the ad displayed by the greedy policy might offer a discount if the user buys the car immediately. a user either takes the offer or leaves the website and if they ever return to the site they would likely see the same offer. a longer-term policy on the other hand can transition the user down a sales funnel before presenting the final deal. it might start by describing the availability of favorable financing terms then praise an excellent service department and then on the next visit offer the final discount. this type of policy can result in more clicks by a user over repeated visits to the site and if the policy is suitably designed more eventual sales. working at adobe systems incorporated theocharous et al. conducted experiments to see if policies designed to maximize clicks over the long term could in fact improve over short-term greedy policies. the adobe marketing cloud a set of tools that many companies use to run digital marketing campaigns provides infrastructure for automating user-targed advertising and fund-raising campaigns. actually deploying novel policies using these tools entails significant risk because a new policy may end up performing poorly. for this reason the research team needed to assess what a policy s performance would be if it were to be actually deployed but to do so on the basis of data collected under the execution of other policies. a critical aspect of this research then was offpolicy evaluation. further the team wanted to do this with high confidence to reduce the risk of deploying a new policy. although high confidence off-policy evaluation was a central component of this research also thomas thomas theocharous and ghavamzadeh here we focus only on the algorithms and their results. theocharous et al. compared the results of two algorithms for learning ad recommendation policies. the first algorithm which they called greedy optimization had the goal chapter applications and case studies of maximizing only the probability of immediate clicks. as in the standard contextual bandit formulation this algorithm did not take the long-term effects of recommendations into account. the other algorithm a reinforcement learning algorithm based on an mdp formulation aimed at improving the number of clicks users made over multiple visits to a website. they called this latter algorithm life-time value optimization. both algorithms faced challenging problems because the reward signal in this domain is very sparse because users usually do not click on ads and user clicking is very random so that returns have high variance. data sets from the banking industry were used for training and testing these algorithms. the data sets consisted of many complete trajectories of customer interaction with a bank s website that showed each customer one out of a collection of possible offers. if a customer clicked the reward was and otherwise it was one data set contained approximately interactions from a month of a bank s campaign that randomly offered one of offers. the other data set from another bank s campaign contained interactions involving possible offers. all interactions included customer features such as the time since the customer s last visit to the website the number of their visits so far the last time the customer clicked geographic location one of a collection of interests and features giving demographic information. greedy optimization was based on a mapping estimating the probability of a click as a function of user features. the mapping was learned via supervised learning from one of the data sets by means of a random forest algorithm rf algorithms have been widely used for large-scale applications in industry because they are effective predictive tools that tend not to overfit and are relatively insensitive to outliers and noise. theocharous et al. then used the mapping to define an policy that selected with probability the offer predicted by the rf algorithm to have the highest probability of producing a click and otherwise selected from the other offers uniformly at random. ltv optimization used a batch-mode reinforcement learning algorithm called fitted q iteration it is a variant of fitted value iteration adapted to q-learning. batch mode means that the entire data set for learning is available from the start as opposed to the online mode of the algorithms we focus on in this book in which data are acquired sequentially while the learning algorithm executes. batchmode reinforcement learning algorithms are sometimes necessary when online learning is not practical and they can use any batch-mode supervised learning regression algorithm including algorithms known to scale well to high-dimensional spaces. the convergence of fqi depends on properties of the function approximation algorithm for their application to ltv optimization theocharous et al. used the same rf algorithm they used for the greedy optimization approach. because in this case fqi convergence is not monotonic theocharous et al. kept track of the best fqi policy by off-policy evaluation using a validation training set. the final policy for testing the ltv approach was the policy based on the best policy produced by fqi with the initial actionvalue function set to the mapping produced by the rf for the greedy optimization approach. to measure the performance of the policies produced by the greedy and ltv ap personalized web services proaches theocharous et al. used the ctr metric and a metric they called the ltv metric. these metrics are similar except that the ltv metric critically distinguishes between individual website visitors ctr total of clicks total of visits ltv total of clicks total of visitors figure illustrates how these metrics differ. each circle represents a user visit to the site black circles are visits at which the user clicks. each row represents visits by a particular user. by not distinguishing between visitors the ctr for these sequences is whereas the ltv is because ltv is larger than ctr to the extent that individual users revisit the site it is an indicator of how successful a policy is in encouraging users to engage in extended interactions with the site. figure click through rate versus life-time value each circle represents a user visit black circles are visits at which the user clicks. adapted from theocharous et al. testing the policies produced by the greedy and ltv approaches was done using a high confidence off-policy evaluation method on a test data set consisting of real-world interactions with a bank website served by a random policy. as expected results showed that greedy optimization performed best as measured by the ctr metric while ltv optimization performed best as measured by the ltv metric. furthermore although we have omitted its details the high confidence off-policy evaluation method provided probabilistic guarantees that the ltv optimization method would with high probability produce policies that improve upon policies currently deployed. assured by these probabilistic guarantees adobe announced in that the new ltv algorithm would be a standard component of the adobe marketing cloud so that a retailer could issue a sequence of offers following a policy likely to yield higher return than a policy that is insensitive to long-term results. chapter applications and case studies thermal soaring birds and gliders take advantage of upward air currents thermals to gain altitude in order to maintain flight while expending little or no energy. thermal soaring as this behavior is called is a complex skill requiring responding to subtle environmental cues to increase altitude by exploiting a rising column of air for as long as possible. reddy celani sejnowski and vergassola used reinforcement learning to investigate thermal soaring policies that are effective in the strong atmospheric turbulence usually accompanying rising air currents. their primary goal was to provide insight into the cues birds sense and how they use them to achieve their impressive thermal soaring performance but the results also contribute to technology relevant to autonomous gliders. reinforcement learning had previously been applied to the problem of navigating efficiently to the vicinity of a thermal updraft dunn and valasek but not to the more challenging problem of soaring within the turbulence of the updraft itself. reddy et al. modeled the soaring problem as a continuing mdp with discounting. the agent interacted with a detailed model of a glider flying in turbulent air. they devoted significant effort toward making the model generate realistic thermal soaring conditions including investigating several different approaches to atmospheric modeling. for the learning experiments air flow in a three-dimensional box with one kilometer sides one of which was at ground level was modeled by a sophisticated physics-based set of partial differential equations involving air velocity temperature and pressure. introducing small random perturbations into the numerical simulation caused the model to produce analogs of thermal updrafts and accompanying turbulence left glider flight was modeled by aerodynamic equations involving velocity lift drag and figure thermal soaring model left snapshot of the vertical velocity field of the simulated cube of air in red is a region of large upward flow. right diagram of powerless flight showing bank angle and angle of attack adapted with permission from pnas vol. p. reddy celani sejnowski and vergassola learning to soar in turbulent environments. contributesignificantlyandmoreexploratorystrategiesarepreferred.thesarsaalgorithmfindstheoptimalpolicybyestimatingforeverystate actionpairitsqfunctiondefinedastheexpectedsumoffuturerewardsgiventhecurrentstatesandtheactiona.ateachsteptheqfunctionisupdatedasfollowsq sa q sa r q s q sa isthelearningrate.theupdateismadeonlineanddoesnotrequireanypriormodeloftheflowortheflight.thisfeatureisparticularlyrelevantinmodelingdecision-makingprocessesinanimals.whenthealgo-rithmisclosetoconvergencetheqfunctionapproachesthesolutiontobellman aswhichencodestheprobabilityofchoosingactionaatstatesapproachestheoptimalone pandisobtainedfromtheqfunctionviaaboltzmann-likeexpression as exp sa sa q sa q sa maxa q sa mina q sa tempisaneffective temperature temp approximately lzxlift ldrag dvelocity directionwing directionbank angleglide angleangle of b nardconvection.fortheverticalvelocityfieldtheredandbluecolorsindicateregionsoflargeupwardanddownwardflowrespectively.forthetemperaturefieldtheredandbluecolorsindicateregionsofhighandlowtemperaturerespectively.noticethatthehotandcoldregionsdrivetheupwardanddownwardbranchesoftheconvectivecellinagreementwiththebasicphysicsofconvection.ctheforce-bodydiagramofflightwithnothrustthatiswithoutanyengineorflappingofwings.thefigurealsoshowsthebankangle actionpairitsqfunctiondefinedastheexpectedsumoffuturerewardsgiventhecurrentstatesandtheactiona.ateachsteptheqfunctionisupdatedasfollowsq sa q sa r q s q sa isthelearningrate.theupdateismadeonlineanddoesnotrequireanypriormodeloftheflowortheflight.thisfeatureisparticularlyrelevantinmodelingdecision-makingprocessesinanimals.whenthealgo-rithmisclosetoconvergencetheqfunctionapproachesthesolutiontobellman aswhichencodestheprobabilityofchoosingactionaatstatesapproachestheoptimalone pandisobtainedfromtheqfunctionviaaboltzmann-likeexpression as exp sa sa q sa q sa maxa q sa mina q sa tempisaneffective temperature temp approximately lzxlift ldrag dvelocity directionwing directionbank angleglide angleangle of b nardconvection.fortheverticalvelocityfieldtheredandbluecolorsindicateregionsoflargeupwardanddownwardflowrespectively.forthetemperaturefieldtheredandbluecolorsindicateregionsofhighandlowtemperaturerespectively.noticethatthehotandcoldregionsdrivetheupwardanddownwardbranchesoftheconvectivecellinagreementwiththebasicphysicsofconvection.ctheforce-bodydiagramofflightwithnothrustthatiswithoutanyengineorflappingofwings.thefigurealsoshowsthebankangle thermal soaring other factors governing powerless flight of a fixed-wing aircraft. maneuvering the glider involved changing its angle of attack angle between the glider s wing and the direction of air flow and its bank angle right. the interface between the agent and the environment required defining the agent s actions the state information the agent receives from the environment and the reward signal. by experimenting with various possibilities reddy et al. decided that three actions each for the angle of attack and the bank angle were enough for their purposes increment or decrement the current bank angle and angle of attack by and respectively or leave them unchanged. this resulted in possible actions. the bank angle was bounded to remain between and because a goal of their study was to try to determine what minimal set of sensory cues are necessary for effective soaring both to shed light on the cues birds might use for soaring and to minimize the sensing complexity required for automated glider soaring the authors tried various sets of signals as input to the reinforcement learning agent. they started by using state aggregation of a four-dimensional state space with dimensions giving local vertical wind speed local vertical wind acceleration torque depending on the difference between the vertical wind velocities at the left and right wing tips and the local temperature. each dimension was discretized into three bins positive high negative high and small. results described below showed that only two of these dimensions were critical for effective soaring behavior. the overall objective of thermal soaring is to gain as much altitude as possible from each rising column of air. reddy et al. tried a straightforward reward signal that rewarded the agent at the end of each episode based on the altitude gained over the episode a large negative reward signal if the glider touched the ground and zero otherwise. they found that learning was not successful with this reward signal for episodes of realistic duration and that eligibility traces did not help. by experimenting with various reward signals they found that learning was best with a reward signal that at each time step linearly combined the vertical wind velocity and vertical wind acceleration observed on the previous time step. learning was by one-step sarsa with actions selected according to a soft-max distribution based on normalized action values. specifically the action probabilities were computed according to with action preferences hs a qs a minb qs b qs b minb qs b where is a parameter vector with one component for each action and aggregated group of states and qs a merely returned the component corresponding to s a in the usual way for state aggregation methods. the above equation forms the action preferences by normalizing the approximate action values to the interval then dividing by a positive temperature parameter. as increases the probability of selecting an action becomes less dependent on its preference as decreases toward zero the probability of selecting the most highly-preferred action approaches one making the policy approach the greedy policy. the temperature parameter was initialized to and incrementally et al. described this slightly differently but our version is equivalent to theirs. chapter applications and case studies decreased to during learning. action preferences were computed from the current estimates of the action values the action with the maximum estimated action value was given preference the action with the minimum estimated action value was given preference and the preferences of the other actions were scaled between these extremes. the step-size and discount-rate parameters were fixed at and respectively. each learning episode took place with the agent controlling simulated flight in an independently generated period of simulated turbulent air currents. each episode lasted minutes simulated with a second time step. learning effectively converged after a few hundred episodes. the left panel of figure shows a sample trajectory before learning where the agent selects actions randomly. starting at the top of the volume shown the glider s trajectory is in the direction indicated by the arrow and quickly loses altitude. figure s right panel is a trajectory after learning. the glider starts at the same place appearing at the bottom of the volume and gains altitude by spiraling within the rising column of air. although reddy at al. found that performance varied widely over different simulated periods of air flow the number of times the glider touched the ground consistently decreased to nearly zero as learning progressed. after experimenting with different sets of features available to the learning agent it turned out that the combination of just vertical wind acceleration and torques worked best. the authors conjectured that because these features give information about the gradient of vertical wind velocity in two different directions they allow the controller to select between turning by changing the bank angle or continuing along the same course by leaving the bank angle alone. this allows the glider to stay within a rising column of figure sample thermal soaring trajectories with arrows showing the direction of flight from the same starting point that the altitude scales are shifted. left before learning the agent selects actions randomly and the glider descends. right after learning the glider gains altitude by following a spiral trajectory. adapted with permission from pnas vol. p. reddy celani sejnowski and vergassola learning to soar in turbulent environments. thermal soaring air. vertical wind velocity is indicative of the strength of the thermal but does not help in staying within the flow. they found that sensitivity to temperature was of little help. they also found that controlling the angle of attack is not helpful in staying within a particular thermal being useful instead for traveling between thermals when covering large distances as in cross-country gliding and bird migration. due to the fact that soaring in different levels of turbulence requires different policies training was done in conditions ranging from weak to strong turbulence. in strong turbulence the rapidly changing wind and glider velocities allowed less time for the controller to react. this reduced the amount of control possible compared to what was possible for maneuvering when fluctuations were weak. reddy at al. examined the policies sarsa learned under these different conditions. common to policies learned in all regimes were these features when sensing negative wind acceleration bank sharply in the direction of the wing with the higher lift when sensing large positive wind acceleration and no torque do nothing. however different levels of turbulence led to policy differences. policies learned in strong turbulence were more conservative in that they preferred small bank angles whereas in weak turbulence the best action was to turn as much as possible by banking sharply. systematic study of the bank angles preferred by the policies learned under the different conditions led the authors to suggest that by detecting when vertical wind acceleration crosses a certain threshold the controller can adjust its policy to cope with different turbulence regimes. reddy et al. also conducted experiments to investigate the effect of the discount-rate parameter on the performance of the learned policies. they found that the altitude gained in an episode increased as increased reaching a maximum for suggesting that effective thermal soaring requires taking into account long-term effects of control decisions. this computational study of thermal soaring illustrates how reinforcement learning can further progress toward different kinds of objectives. learning policies having access to different sets of environmental cues and control actions contributes to both the engineering objective of designing autonomous gliders and the scientific objective of improving understanding of the soaring skills of birds. in both cases hypotheses resulting from the learning experiments can be tested in the field by instrumenting real gliders and by comparing predictions with observed bird soaring behavior. chapter frontiers in this final chapter we touch on some topics that are beyond the scope of this book but that we see as particularly important for the future of reinforcement learning. many of these topics bring us beyond what is reliably known and some bring us beyond the mdp framework. general value functions and auxiliary tasks over the course of this book our notion of value function has become quite general. with off-policy learning we allowed a value function to be conditional on an arbitrary target policy. then in section we generalized discounting to a termination function s so that a different discount rate could be applied at each time step in determining the return this allowed us to express predictions about how much reward we will get over an arbitrary state-dependent horizon. the next and perhaps final step is to generalize beyond rewards to permit predictions about arbitrary signals. rather than predicting the sum of future rewards we might predict the sum of the future values of a sound or color sensation or of an internal highly processed signal such as another prediction. whatever signal is added up in this way in a value-function-like prediction we call it the cumulant of that prediction. we formalize it in a cumulant signal ct r. using this a general value function or gvf is written v st s at as with conventional value functions as v or q this is an ideal function that we seek to approximate with a parameterized form which we might continue to denote vsw although of course there would have to be a different w for each prediction that is for each choice of and ct. because a gvf has no necessary connection to reward it is perhaps a misnomer to call it a value function. one could simply call it a prediction or to make it more distinctive a forecast in preparation. whatever it is called chapter frontiers it is in the form of a value function and thus can be learned in the usual ways using the methods developed in this book for learning approximate value functions. along with the learned predictions we might also learn policies to maximize the predictions in the usual ways by generalized policy iteration or by actor critic methods. in this way an agent could learn to predict and control great numbers of signals not just long-term reward. why might it be useful to predict and control signals other than long-term reward? these are auxiliary tasks in that they are extra in-addition-to the main task of maximizing reward. one answer is that the ability to predict and control a diverse multitude of signals can constitute a powerful kind of environmental model. as we saw in chapter a good model can enable the agent to get reward more efficiently. it takes a couple of further concepts to develop this answer clearly so we postpone it to the next section. first let s consider two simpler ways in which a multitude of diverse predictions can be helpful to a reinforcement learning agent. one simple way in which auxiliary tasks can help on the main task is that they may require some of the same representations as are needed on the main task. some of the auxiliary tasks may be easier with less delay and a clearer connection between actions and outcomes. if good features can be found early on easy auxilary tasks then those features may significantly speed learning on the main task. there is no necessary reason why this has to be true but in many cases it seems plausible. for example if you learn to predict and control your sensors over short time scales say seconds then you might plausibly come up with part of the idea of objects which would then greatly help with the prediction and control of long-term reward. we might imagine an artificial neural network in which the last layer is split into multiple parts or heads each working on a different task. one head might produce the approximate value function for the main task reward as its cumulant whereas the others would produce solutions to various auxilary tasks. all heads could propagate errors by stochastic gradient descent into the same body the shared preceding part of the network which would then try to form representations in its next-to-last layer to support all the heads. researchers have experimented with auxiliary tasks such as predicting change in pixels predicting the next time step s reward and predicting the distribution of the return. in many cases this approach has been shown to greatly accelerate learning on the main task et al. multiple predictions have similarly been repeatedly proposed as a way of directing the construction of state estimates section another simple way in which the learning of auxiliary tasks can improve performance is best explained by analogy to the psychological phenomena of classical conditioning one way of understanding classical conditioning is that evolution has built in a reflexive association to a particular action from the prediction of a particular signal. for example humans and many other animals appear to have a built-in reflex to blink whenever their prediction of being poked in the eye exceeds some threshold. the prediction is learned but the association from prediction to eye closure is built in and thus the animal is saved many unprotected pokes in its eye. similarly the association from fear to increased heart rate or to freezing can be built in. agent temporal abstraction via options designers can do something similar connecting by design learning predictions of specific events to predetermined actions. for example a self-driving car that learns to predict whether going forward will produce a collision could be given a built-in reflex to stop or to turn away whenever the prediction is above some threshold. or consider a vacuum-cleaning robot that learned to predict whether it might run out of battery power before returning to the charger and that reflexively headed back to the charger whenever the prediction became non-zero. the correct prediction would depend on the size of the house the room the robot was in and the age of the battery all of which would be hard for the robot designer to know. it would be difficult for the designer to build in a reliable algorithm for deciding whether to head back to the charger in sensory terms but it might be easy to do this in terms of the learned prediction. we foresee many possible ways like this in which learned predictions might combine usefully with built-in algorithms for controlling behavior. finally perhaps the most important role for auxiliary tasks is in moving beyond the assumption we have made throughout this book that the state representation is fixed and given to the agent. to explain this role we first have to take a few steps back to appreciate the magnitude of this assumption and the implications of removing it. we do that in section temporal abstraction via options an appealing aspect of the mdp formalism is that it can be applied usefully to tasks at many different time scales. one can use it to formalize the task of deciding which muscles to twitch to grasp an object which airplane flight to take to arrive conveniently at a distant city and which job to take to lead a satisfying life. these tasks differ greatly in their time scales yet each can be usefully formulated as an mdp that can be solved by planning or learning processes as described in this book. all involve interaction with the world sequential decision making and a goal usefully conceived of as accumulating rewards over time and so all can be formulated as mdps. although all these tasks can be formulated as mdps one might think that they cannot be formulated as a single mdp. they involve such different time scales such different notions of choice and action! it would be no good for example to plan a flight across a continent at the level of muscle twitches. yet for other tasks grasping throwing darts or hitting a baseball low-level muscle twitches may be just the right level. people do all these things seamlessly without appearing to switch between levels. can the mdp framework be stretched to cover all the levels simultaneously? perhaps it can. one popular idea is to formalize an mdp at a detailed level with a small time step yet enable planning at higher levels using extended courses of action that correspond to many base-level time steps. to do this we need a notion of course of action that extends over many time steps and includes a notion of termination. a general way to formulate these two ideas is as a policy and a state-dependent termination function as in gvfs. we define a pair of these as a generalized notion of action termed an option. to execute an option at time t is to obtain the action to take at from then terminate at time t with probability if the option does chapter frontiers not terminate at t then is selected from and the option terminates at t with probability and so on until eventual termination. it is convenient to consider low-level actions to be special cases of options each action a corresponds to an option whose policy picks the action a for all s s and whose termination function is zero for all s s. options effectively extend the action space. the agent can either select a low-level actionoption terminating after one time step or select an extended option that might execute for many time steps before terminating. options are designed so that they are interchangable with low-level actions. for example the notion of an action-value function q naturally generalizes to an optionvalue function that takes a state and option as input and returns the expected return starting from that state executing that option to termination and thereafter following the policy we can also generalize the notion of policy to a hierarchical policy that selects from options rather than actions where options when selected execute until termination. with these ideas many of the algorithms in this book can be generalized to learn approximate option-value functions and hierarchical policies. in the simplest case the learning process jumps from option initiation to option termination with an update only occurring when an option terminates. more subtly updates can be made on each time step using intra-option learning algorithms which in general require off-policy learning. perhaps the most important generalization made possible by option ideas is that of the environmental model as developed in chapters and the conventional model of an action is the state-transition probabilities and the expected immediate reward for taking the action in each state. how do conventional action models generalize to option models? for options the appropriate model is again of two parts one corresponding to the state transition resulting from executing the option and one corresponding to the expected cumulative reward along the way. the reward part of an option model analogous to the expected reward for state action pairs is rs s for all options and all states s s where is the random time step at which the option terminates according to note the role of the overall discounting parameter in this equation discounting is according to but termination of the option is according to the state-transition part of an option model is a little more subtle. this part of the model characterizes the probability of each possible resulting state in but now this state may result after various numbers of time steps each of which must be discounted differently. the model for option specifies for each state s that might start executing in and for each state that might terminate in k prsk k s note that because of the factor of k this is no longer a transition probability and no longer sums to one over all values of we continue to use the notation in p. temporal abstraction via options the above definition of the transition part of an option model allows us to formulate bellman equations and dynamic programming algorithms that apply to all options including low-level actions as a special case. for example the general bellman equation for the state values of a hierarchical policy is v where denotes the set of options available in state s. if includes only the low-level actions then this equation reduces to a version of the usual bellman equation except of course is included in the new p and thus does not appear. similarly the corresponding planning algorithms also have no for example the value iteration algorithm with options analogous to is max for all s s. if includes all the low-level actions available in each s then this algorithm converges to the conventional v from which the optimal policy can be computed. however it is particularly useful to plan with options when only a subset of the possible options are considered in each state. value iteration will then converge to the best hierarchical policy limited to the restricted set of options. although this policy may be sub-optimal convergence can be much faster because fewer options are considered and because each option can jump over many time steps. to plan with options one must either be given the option models or learn them. one natural way to learn an option model is to formulate it as a collection of gvfs defined in the preceding section and then learn the gvfs using the methods presented in this book. it is not difficult to see how this could be done for the reward part of the option model. one merely chooses one gvf s cumulant to be the reward rt its policy to be the the option s policy and its termination function to be the discount rate times the option s termination function the true gvf then equals the reward part of the option model v rs and the learning methods described in this book can be used to approximate it. the state-transition part of the option model is only a little more complicated. one needs to allocate one gvf for each state that the option might terminate in. we don t want these gvfs to accumulate anything except when the option terminates and then only when the termination is in the appropriate state. this can be achieved by choosing the cumulant of the gvf that predicts transition to state to be ct the gvf s policy and termination functions are chosen the same as for the reward part of the option model. the true gvf then equals the portion of the option s state-transition model v and again this book s methods could be employed to learn it. although each of these steps is seemingly natural putting them all together function approximation and other essential components is quite challenging and beyond the current state of the art. chapter frontiers exercise this section has presented options for the discounted case but discounting is arguably inappropriate for control when using function approximation what is the natural bellman equation for a hierarchical policy analogous to but for the average reward setting what are the two parts of the option model analogous to and for the average reward setting? observations and state throughout this book we have written the learned approximate value functions the policies in chapter as functions of the environment s state. this is a significant limitation of the methods presented in part i in which the learned value function was implemented as a table such that any value function could be exactly approximated that case is tantamount to assuming that the state of the environment is completely observed by the agent. but in many cases of interest and certainly in the lives of all natural intelligences the sensory input gives only partial information about the state of the world. some objects may be occluded by others or behind the agent or miles away. in these cases potentially important aspects of the environment s state are not directly observable and it is a strong unrealistic and limiting assumption to assume that the learned value function is implemented as a table over the environment s state space. the framework of parametric function approximation that we developed in part ii is far less restrictive and arguably no limitation at all. in part ii we retained the assumption that the learned value functions policies are functions of the environment s state but allowed these functions to be arbitrarily restricted by the parameterization. it is somewhat surprising and not widely recognized that function approximation includes important aspects of partial observability. for example if there is some state variable that is not observable then the parameterization can be chosen such that the approximate value does not depend on that state variable. the effect is just as if that state variable were not observable. because of this all the results obtained for the parameterized case apply to partial observability without change. in this sense the case of parameterized function approximation includes the case of partial observability. nevertheless there are many issues that cannot be investigated without a more explicit treatment of partial observability. although we cannot give them a full treatment here we can outline the changes that would be needed to do so. there are four steps. first we would change the problem. the environment would emit not its states but only observations signals that depend on its state but like a robot s sensors provide only partial information about it. for convenience without loss of generality we assume that the reward is a direct known function of the observation the observation is a vector and the reward is one of is components. the environmental interaction would then have no explicit states or rewards but would simply be an alternating sequence of actions at a and observations ot o going on forever equation or forming episodes each ending with a special terminal observation. observations and state second we can recover the idea of state as used in this book from the sequence of observations and actions. let us use the word history and the notation ht for an initial portion of the trajectory up to an observation ht at ot. the history represents the most that we can know about the past without looking outside of the data stream the history is the whole past data stream. of course the history grows with t and can become large and unwieldy. the idea of state is that of some compact summary of the history that is as useful as the actual history for predicting the future. let us be clear about exactly what this means. to be a summary of the history the state must be a function of history st f and to be as useful for predicting the future as the whole history it must have what is known as the markov property. formally this is a property of the function f a function f has the markov property if and only if any two histories h and that are mapped by f to the same state f also have the same probabilities for their next observation f f oht h at a oht at a for all o o and a a. if f is markov then st f is a state as we have used the term in this book. let us henceforth call it a markov state to distinguish it from states that are summaries of the history but fall short of the markov property we will consider shortly. a markov state is a good basis for predicting the next observation but more importantly it is also a good basis for predicting or controlling anything. for example let a test be any specific sequence of alternating actions and observations that might occur in the future. for example a three-step test is denoted the probability of this test given a specific history h is defined as p ht h at if f is markov and h and are any two histories that map to the same state under f then for any test of any length its probabilities given the two histories must also be the same f f p p in other words a markov state summarizes all the information in the history necessary for determining any test s probability. in fact it summarizes all that is necessary for making any prediction including any gvf and for behaving optimally f is markov then there is always a deterministic function such that choosing at is optimal. the third step in extending reinforcement learning to partial observability is to deal with certain computational considerations. in particular we want the state to be a compact summary of the history. for example the identity function completely satisfies the conditions for a markov f but would nevertheless be of little use because the corresponding state st ht would grow with time and become unwieldy as mentioned earlier but more fundamentally because it would never recur the agent would never chapter frontiers encounter the same state twice a continuing task and thus could never benefit from a tabular learning method. we want our states to be compact as well as markov. there is a similar issue regarding how state is obtained and updated. we don t really want a function f that takes whole histories. instead for computational reasons we prefer to obtain the same effect as f with an incremental recursive update that computes from st incorporating the next increment of data at and ust at for all t with the first state given. the function u is called the state-update function. for example if f were the identity ht then u would merely extend st by appending at and to it. given f it is always possible to construct a corresponding u but it may not be computationally convenient and as in the identity example it may not produce a compact state. the state-update function is a central part of any agent architecture that handles partial observability. it must be efficiently computatible as no actions or predictions can be made until the state is available. an example of obtaining markov states through a state-update function is provided by the popular bayesian approach known as partially observable mdps or pomdps. in this approach the environment is assumed to have a well defined latent state xt that underlies and produces the environment s observations but is never available to the agent is not to be confused with the state st used by the agent to make predictions and decisions. the natural markov state st for a pomdp is the distribution over the latent states given the history called the belief state. for concreteness assume the usual case in which there are a finite number of hidden states xt d. then the belief state is the vector st st rd with components sti prxt i ht for all possible latent states i d. the belief state remains the same size number of components however t grows. it can also be incrementally updated by bayes rule assuming one has complete knowledge of the internal workings of the environment. specifically the ith component of the belief-state update function is sxpi ox a ox a us a oi for all a a o o and belief states s rd with components sx where the fourargument p function here is not the usual one for mdps in chapter but the anal. ogous one for pomdps in terms of the latent state ox a prxt ot o x at a. this approach is popular in theoretical work and has many significant applications but its assumptions and computational complexity scale poorly and we do not recommend it as an approach to artificial intelligence. another example of markov states is provided by predictive state representations or psrs. psrs address the weakness of the pomdp approach that the semantics of its agent state st are grounded in the environment state xt which is never observed and thus is difficult to learn about. in psrs and related approaches the semantics of observations and state the agent state is instead grounded in predictions about future observations and actions which are readily observable. in psrs a markov state is defined as a d-vector of the probabilities of d specially chosen core tests as defined above the vector is then updated by a state-update function u that is analogous to bayes rule but with a semantics grounded in observable data which arguably makes it easier to learn. this approach has been extended in many ways including end-tests compositional tests powerful spectral methods and closed-loop and temporally abstract tests learned by td methods. some of the best theoretical developments are for systems known as observable operator models and sequential systems the fourth and final step in our brief outline of how to handle partial observability in reinforcement learning is to re-introduce approximation. as discussed in the introduction to part ii to approach artificial intelligence ambitiously one must embrace approximation. this is just as true for states as it is for value functions. we must accept and work with an approximate notion of state. the approximate state will play the same role in our algorithms as before so we continue to use the notation st for the state used by the agent even though it may not be markov. perhaps the simplest example of an approximate state is just the latest observation st ot. of course this approach cannot handle any hidden state information. it would be better to use the last k observations and actions st ot at ot at k for some k which can be achieved by a state-update function that just shifts the new data in and the oldest data out. this kth-order history approach is still very simple but can greatly increase the agent s capabilities compared to trying to use the single immediate observation directly as the state. what happens when the markov property is only approximately satisfied? unfortunately long-term prediction performance can degrade dramatically when the onestep predictions defining the markov property become even slightly inaccurate. longerterm tests gvfs and state-update functions may all approximate poorly. the shortterm and long-term approximation objectives are just different and there are no useful theoretical guarantees at present. nevertheless there are still reasons to think that the general idea outlined in this section applies to the approximate case. the general idea is that a state that is good for some predictions is also good for others particular that a markov state sufficient for one-step predictions is also sufficient for all others. if we step back from that specific result for the markov case the general idea is similar to what we discussed in section with multi-headed learning and auxiliary tasks. we discussed how representations that were good for the auxiliary tasks were often also good for the main task. taken together these suggest an approach to both partial observability and representation learning in which multiple predictions are pursued and used to direct the construction of state features. the guarantee provided by the perfect-but-impractical markov property is replaced by the heuristic that what s good for some predictions may be good for others. this approach scales well with computational resources. with a large machine one could experiment with large numbers of predictions perhaps favoring those that are most similar to the ones of ultimate interest or that are easiest to learn reliably or according to some other criteria. it is important here to move beyond selecting the predictions chapter frontiers manually. the agent should do it. this would require a general language for predictions so that the agent can systematically explore a large space of possible predictions sifting through them for the ones that are most useful. in particular both pomdp and psr approaches can be applied with approximate states. the semantics of the state is useful in forming the state-update function as it is in these two approaches and in the k-order approach. there is not a strong need for the semantics to be correct in order to retain useful information in the state. some approaches to state augmentation such as echo state networks keep almost arbitrary information about the history and can nevertheless perform well. there are many possibilities and we expect more work and ideas in this area. learning the state-update function for an approximate state is a major part of the representation learning problem as it arises in reinforcement learning. designing reward signals a major advantage of reinforcement learning over supervised learning is that reinforcement learning does not rely on detailed instructional information generating a reward signal does not depend on knowledge of what the agent s correct actions should be. but the success of a reinforcement learning application strongly depends on how well the reward signal frames the goal of the application s designer and how well the signal assesses progress in reaching that goal. for these reasons designing a reward signal is a critical part of any application of reinforcement learning. by designing a reward signal we mean designing the part of an agent s environment that is responsible for computing each scalar reward rt and sending it to the agent at each time t. in our discussion of terminology at the end of chapter we said that rt is more like a signal generated inside an animal s brain than it is like an object or event in the animal s external environment. the parts of our brains that generate these signals for us evolved over millions of years to be well suited to the challenges our ancestors had to face in their struggles to propagate their genes to future generations. we should therefore not think that designing a good reward signal is always an easy thing to do! one challenge is to design a reward signal so that as an agent learns its behavior approaches and ideally eventually achieves what the application s designer actually desires. this can be easy if the designer s goal is simple and easy to identify such as finding the solution to a well-defined problem or earning a high score in a well-defined game. in cases like these it is usual to reward the agent according to its success in solving the problem or its success in improving its score. but some problems involve goals that are difficult to translate into reward signals. this is especially true when the problem requires the agent to skillfully perform a complex task or set of tasks such as would be required of a useful household robotic assistant. further reinforcement learning agents can discover unexpected ways to make their environments deliver reward some of which might be undesirable or even dangerous. this is a longstanding and critical challenge for any method like reinforcement learning that is based on optimization. we discuss this issue more in section the final section of this book. even when there is a simple and easily identifiable goal the problem of sparse reward designing reward signals often arises. delivering non-zero reward frequently enough to allow the agent to achieve the goal once let alone to learn to achieve it efficiently from multiple initial conditions can be a daunting challenge. state action pairs that clearly deserve to trigger reward may be few and far between and rewards that mark progress toward a goal can be infrequent because progress is difficult or even impossible to detect. the agent may wander aimlessly for long periods of time minsky called the plateau problem in practice designing a reward signal is often left to an informal trial-and-error search for a signal that produces acceptable results. if the agent fails to learn learns too slowly or learns the wrong thing then the designer of the application tweaks the reward signal and tries again. to do this the designer judges the agent s performance by criteria that he or she is attempting to translate into a reward signal so that the agent s goal matches his or her own. and if learning is too slow the designer may try to design a non-sparse reward signal that effectively guides learning throughout the agent s interaction with its environment. it is tempting to address the sparse reward problem by rewarding the agent for achieving subgoals that the designer thinks are important way stations to the overall goal. but augmenting the reward signal with well-intentioned supplemental rewards may lead the agent to behave very differently from what is intended the agent may end up not achieving the overall goal at all. a better way to provide such guidance is to leave the reward signal alone and instead augment the value-function approximation with an initial guess of what it should ultimately be or augment it with initial guesses as to what certain parts of it should be. for example suppose one wants to offer s r as an initial guess at the true optimal value function v and that one is using linear function approximation with features x s rd. then one would define the initial value function approximation to be vsw and update the weights w as usual. if the initial weight vector is then the initial value function will be but the asymptotic solution quality will be determined by the feature vectors as usual. this initialization can be done for arbitrary nonlinear approximators and arbitrary forms of though it is not guaranteed to always accelerate learning. a particularly effective approach to the sparse reward problem is the shaping technique introduced by the psychologist b. f. skinner and described in section the effectiveness of this technique relies on the fact that sparse reward problems are not just problems with the reward signal they are also problems with an agent s policy in preventing the agent from frequently encountering rewarding states. shaping involves changing the reward signal as learning proceeds starting from a reward signal that is not sparse given the agent s initial behavior and gradually modifying it toward the reward signal suited to problem of original interest. each modification is made so that the agent is frequently rewarded given its current behavior. the agent faces a sequence of increasingly-difficult reinforcement learning problems where what is learned at each stage makes the next-harder problem relatively easy because the agent now encounters reward more frequently than it would if it did not have prior experience with easier problems. this kind of shaping is an essential technique in training animals and it is effective in computational reinforcement learning as well. chapter frontiers what if one has no idea what the rewards should be but there is another agent perhaps a person who is already expert at the task and whose behavior can be observed? in this case one can use methods known variously as imitation learning learning from demonstration and apprenticeship learning. the idea here is to benefit from the expert agent but leave open the possibility of eventually performing better. learning from an expert s behavior can be done either by learning directly by supervised learning or by extracting a reward signal using what is known as inverse reinforcement learning and then using a reinforcement learning algorithm with that reward signal to learn a policy. the task of inverse reinforcement learning as explored by ng and russell is to try to recover the expert s reward signal from the expert s behavior alone. this cannot be done exactly because a policy can be optimal with respect to many different reward signals example any reward signal that gives the same reward for all states and actions but it is possible to find plausible reward signal candidates. unfortunately strong assumptions are required including knowledge of the environment s dynamics and of the feature vectors in which the reward signal is linear. the method also requires completely solving the problem by dynamic programming methods multiple times. these difficulties notwithstanding abbeel and ng argue that the inverse reinforcement learning approach can sometimes be more effective than supervised learning for benefiting from the behavior of an expert. another approach to finding a good reward signal is to automate the trial-and-error search for a good signal that we mentioned above. from an application perspective the reward signal is a parameter of the learning algorithm. as is true for other algorithm parameters the search for a good reward signal can be automated by defining a space of feasible candidates and applying an optimization algorithm. the optimization algorithm evaluates each candidate reward signal by running the reinforcement learning system with that signal for some number of steps and then scoring the overall result by a high-level objective function intended to encode the designer s true goal ignoring the limitations of the agent. reward signals can even be improved via online gradient ascent where the gradient is that of the high-level objective function lewis and singh relating this approach to the natural world the algorithm for optimizing the high-level objective function is analogous to evolution where the high-level objective function is an animal s evolutionary fitness determined by the number of its offspring that survive to reproductive age. computational experiments with this bilevel optimization approach one level analogous to evolution and the other due to reinforcement learning by individual agents have confirmed that intuition alone is not always adequate to devise a good reward signal lewis and barto the performance of a reinforcement learning agent as evaluated by the high-level objective function can be very sensitive to details of the agent s reward signal in subtle ways determined by the agent s limitations and the environments in which it acts and learns. these experiments also demonstrated that an agent s goal should not always be the same as the goal of the agent s designer. at first this seems counterintuitive but it may be impossible for the agent to achieve the designer s goal no matter what its reward signal is. the agent has to learn under various kinds of constraints such as limited computational power limited access to infor remaining issues mation about its environment or limited time to learn. when there are constraints like these learning to achieve a goal that is different from the designer s goal can sometimes end up getting closer to the designer s goal than if that goal were pursued directly singh and lewis sorg examples of this in the natural world are easy to find. because we cannot directly assess the nutritional value of most foods evolution the designer of our reward signal gave us a reward signal that makes us seek certain tastes. though certainly not infallible possibly detrimental in environments that differ in certain ways from ancestral environments this compensates for many of our limitations our limited sensory abilities the limited time over which we can learn and the risks involved in finding a healthy diet through personal experimentation. similarly because an animal cannot observe its own evolutionary fitness that objective function does not work as a reward signal for learning. evolution instead provides reward signals that are sensitive to observable predictors of evolutionary fitness. finally remember that a reinforcement learning agent is not necessarily like a complete organism or robot it can be a component of a larger behaving system. this means that reward signals may be influenced by things inside the larger behaving agent such as motivational states memories ideas or even hallucinations. reward signals may also depend on properties of the learning process itself such as measures of how much progress learning is making. making reward signals sensitive to information about internal factors such as these makes it possible for an agent to learn how to control the cognitive architecture of which it is a part as well as to acquire knowledge and skills that would be difficult to learn from a reward signal that depended only on external events. possibilities like these led to the idea of intrinsically-motivated reinforcement learning that we briefly discuss further at the end of the following section. remaining issues in this book we have presented the foundations of a reinforcement learning approach to artificial intelligence. roughly speaking that approach is based on model-free and model-based methods working together as in the dyna architecture of chapter combined with function approximation as developed in part ii. the focus has been on online and incremental algorithms which we see as fundamental even to model-based methods and on how these can be applied in off-policy training situations. the full rationale for the latter has been presented only in this last chapter. that is we have all along presented off-policy learning as an appealing way to deal with the exploreexploit dilemma but only in this chapter have we discussed learning about many diverse auxiliary tasks simultaneously with gvfs and learning about the world hierarchically in terms of temporally-abstract option models both of which involve off-policy learning. much remains to be worked out as we have indicated throughout the book and as evidenced by the directions for additional research discussed in this chapter. but suppose we are generous and grant the broad outlines of everything that we have done in the book and everything that has been outlined so far in this chapter. what would remain even after that? of course we can t know for sure what will be required but we can make some guesses. in this section we highlight six further issues which it seems to us chapter frontiers will still need to be addressed by future research. first we still need powerful parametric function approximation methods that work well in fully incremental and online settings. methods based on deep learning and artificial neural networks are a major step in this direction but still only work well with batch training on large data sets with training from extensive off-line self play or with learning from the interleaved experience of multiple agents on the same task. these and other settings are ways of working around a basic limitation of today s deep learning methods which struggle to learn rapidly in the incremental online settings that are most natural for the reinforcement learning algorithms emphasized in this book. the problem is sometimes described as one of catastrophic interference or correlated data. when something new is learned it tends to replace what has previously been learned rather than adding to it with the result that the benefit of the older learning is lost. techniques such as replay buffers are often used to retain and replay old data so that its benefits are not permanently lost. an honest assessment has to be that current deep learning methods are not well suited to online learning. we see no reason that this limitation is insurmountable but algorithms that address it while at the same time retaining the advantages of deep learning have not yet been devised. most current deep learning research is directed toward working around this limitation rather than removing it. second perhaps closely related we still need methods for learning features such that subsequent learning generalizes well. this issue is an instance of a general problem variously called representation learning constructive induction and metalearning how can we use experience not just to learn a given desired function but to learn inductive biases such that future learning generalizes better and is thus faster? this is an old problem dating back to the origins of artificial intelligence and pattern recognition in the and such age should give one pause. perhaps there is no solution. but it is equally likely that the time for finding a solution and demonstrating its effectiveness has not yet arrived. today machine learning is conducted at a far larger scale than it has been in the past and the potential benefits of a good representation learning method have become much more apparent. we note that a new annual conference the international conference on learning representations has been exploring this and related topics every year since it is also less common to explore representation learning within a reinforcement learning context. reinforcement learning brings some new possibilities to this old issue such as the auxiliary tasks discussed in section in reinforcement learning the problem of representation learning can be identified with the problem of learning the state-update function discussed in section third we still need scalable methods for planning with learned environment models. planning methods have proven extremely effective in applications such as alphago zero and computer chess in which the model of the environment is known from the rules of the game or can otherwise be supplied by human designers. but cases of full model-based reinforcement learning in which the environment model is learned from data and then used for planning are rare. the dyna system described in chapter is one example but would claim that deep learning solves this problem for example that dqn as described in section illustrates a solution but we are unconvinced. there is as yet little evidence that deep learning alone solves the representation learning problem in a general and efficient way. remaining issues as described there and in most subsequent work it uses a tabular model without function approximation which greatly limits its applicability. only a few studies have included learned linear models and even fewer have also explored including temporally-abstract models using options as discussed in section more work is needed before planning with learned models can be effective. for example the learning of the model needs to be selective because the scope of a model strongly affects planning efficiency. if a model focuses on the key consequences of the most important options then planning can be efficient and rapid but if a model includes details of unimportant consequences of options that are unlikely to be selected then planning may be almost useless. environment models should be constructed judiciously with regard to both their states and dynamics with the goal of optimizing the planning process. the various parts of the model should be continually monitored as to the degree to which they contribute to or detract from planning efficiency. the field has not yet addressed this complex of issues or designed model-learning methods that take into account their implications. a fourth issue that needs to be addressed in future research is that of automating the choice of tasks on which an agent works and uses to structure its developing competence. it is usual in machine learning for human designers to set the tasks that the learning agent is expected to master. because these tasks are known in advance and remain fixed they can be built into the learning algorithm code. however looking ahead we will want the agent to make its own choices about what tasks it should try to master. these might be subtasks of a specific overall task that is already known or they might be intended to create building blocks that permit more efficient learning of many different tasks that the agent is likely to face in the future but which are currently unknown. these tasks may be like the auxiliary tasks or the gvfs discussed in section or tasks solved by options as discussed in section in forming a gvf for example what should the cumulant the policy and the termination function be? the current state of the art is to select these manually but far greater power and generality would come from making these task choices automatically particularly when they derive from what the agent has previously constructed as a result of representation learning or experience with previous subproblems. if gvf design is automated then the design choices themselves will have to be explicitly represented. rather than the task choices being in the mind of the designer and built into the code they will have to be in the machine itself in such a way that they can be set and changed monitored filtered and searched among automatically. tasks could then be built hierarchically upon others much like features are in an artificial neural network. the tasks are the questions and the contents of the neural network are the answers to those questions. we expect there will need to be a full hierarchy of questions to match the hierarchy of answers provided by modern deep learning methods. the fifth issue that we would like to highlight for future research is that of the interaction between behavior and learning via some computational analog of curiosity. in this chapter we have been imagining a setting in which many tasks are being learned simultaneously using off-policy methods from the same stream of experience. the actions taken will of course influence this stream of experience which in turn will determine chapter frontiers how much learning occurs and which tasks are learned. when reward is not available or not strongly influenced by behavior the agent is free to choose actions that maximize in some sense the learning on the tasks that is to use some measure of learning progress as an internal or intrinsic reward implementing a computational form of curiosity. in addition to measuring learning progress intrinsic reward can among other possibilities signal the receipt of unexpected novel or otherwise interesting input or can assess the agent s ability to cause changes in its environment. intrinsic reward signals generated in these ways can be used by an agent to pose tasks for itself by defining auxiliary tasks gvfs or options as discussed above so that skills learned in this way can contribute to the agent s ability to master future tasks. the result is a computational analog of something like play. many preliminary studies of such uses of intrinsic reward signals have been conducted and exciting topics for future research remain in this general area. a final issue that demands attention in future research is that of developing methods to make it acceptably safe to embed reinforcement learning agents into physical environments thereby helping to ensure that the benefits of reinforcement learning outweigh harm it can cause. this is one of the most pressing areas for future research and we discuss it further in the following section. reinforcement learning and the future of arti ficial intelligence when we were writing the first edition of this book in the artificial intelligence was making significant progress and was having an impact on society though it was mostly still the promise of artificial intelligence that was inspiring developments. machine learning was part of that outlook but it had not yet become indispensable to artificial intelligence. by today that promise has transitioned to applications that are changing the lives of millions of people and machine learning has come into its own as a key technology. as we write this second edition some of the most remarkable developments in artificial intelligence have involved reinforcement learning most notably deep reinforcement learning reinforcement learning with function approximation by deep neural networks. we are at the beginning of a wave of real-world applications of artificial intelligence many of which will include reinforcement learning deep and otherwise that will impact our lives in ways that are hard to predict. but an abundance of successful real-world applications does not mean that true artificial intelligence has arrived. despite great progress in many areas the gulf between artificial intelligence and the intelligence of humans and even of other animals remains great. superhuman performance can be achieved in some domains even formidable domains like go but it remains a significant challenge to develop systems that are like us in being complete interactive agents having general adaptability and problem-solving skills emotional sophistication creativity and the ability to learn quickly from experience. with its focus on learning by interacting with dynamic environments reinforcement learning as it develops over the future will be a critical component of agents with these abilities. reinforcement learning and the future of artificial intelligence reinforcement learning s connections to psychology and neuroscience and underscore its relevance to another longstanding goal of artificial intelligence shedding light on fundamental questions about the mind and how it emerges from the brain. reinforcement learning theory is already contributing to our understanding of the brain s reward motivation and decision-making processes and there is good reason to believe that through its links to computational psychiatry reinforcement learning theory will contribute to methods for treating mental disorders including drug abuse and addiction. another contribution that reinforcement learning can make over the future is as an aid to human decision making. policies derived by reinforcement learning in simulated environments can advise human decision makers in such areas as education healthcare transportation energy and public-sector resource allocation. particularly relevant is the key feature of reinforcement learning that it takes long-term consequences of decisions into account. this is very clear in games like backgammon and go where some of the most impressive results of reinforcement learning have been demonstrated but it is also a property of many high-stakes decisions that affect our lives and our planet. reinforcement learning follows related methods for advising human decision making that have been developed in the past by decision analysts in many disciplines. with advanced function approximation methods and massive computational power reinforcement learning methods have the potential to overcome some of the difficulties of scaling up traditional decision-support methods to larger and more complex problems. the rapid pace of advances in artificial intelligence has led to warnings that artificial intelligence poses serious threats to our societies even to humanity itself. the renowned scientist and artificial intelligence pioneer herbert simon anticipated the warnings we are hearing today in a presentation at the earthware symposium at cmu in he spoke of the eternal conflict between the promise and perils of any new knowledge reminding us of the greek myths of prometheus the hero of modern science who stole fire from the gods for the benefit of mankind and pandora whose box could be opened by a small and innocent action to release untold perils on the world. while accepting that this conflict is inevitable simon urged us to recognize that as designers of our future and not mere spectators the decisions we make can tilt the scale in prometheus favor. this is certainly true for reinforcement learning which can benefit society but can also produce undesirable outcomes if it is carelessly deployed. thus the safety of artificial intelligence applications involving reinforcement learning is a topic that deserves careful attention. a reinforcement learning agent can learn by interacting with either the real world or with a simulation of some piece of the real world or by a mixture of these two sources of experience. simulators provide safe environments in which an agent can explore and learn without risking real damage to itself or to its environment. in most current applications policies are learned from simulated experience instead of direct interaction with the real world. in addition to avoiding undesirable real-world consequences learning from simulated experience can make virtually unlimited data available for learning generally at less cost than needed to obtain real experience and because simulations typically run much faster than real time learning can often occur more quickly than if it relied on real experience. chapter frontiers nevertheless the full potential of reinforcement learning requires reinforcement learning agents to be embedded into the flow of real-world experience where they act explore and learn in our world and not just in their worlds. after all reinforcement learning algorithms at least those upon which we focus in this book are designed to learn online and they emulate many aspects of how animals are able to survive in nonstationary and hostile environments. embedding reinforcement learning agents in the real world can be transformative in realizing the promises of artificial intelligence to amplify and extend human abilities. a major reason for wanting a reinforcement learning agent to act and learn in the real world is that it is often difficult sometimes impossible to simulate real-world experience with enough fidelity to make the resulting policies whether derived by reinforcement learning or by other methods work well and safely when directing real actions. this is especially true for environments whose dynamics depend on the behavior of humans such as in education healthcare transportation and public policy domains that can surely benefit from improved decision making. however it is for real-world embedded agents that warnings about potential dangers of artificial intelligence need to be heeded. some of these warnings are particularly relevant to reinforcement learning. because reinforcement learning is based on optimization it inherits the pluses and minuses of all optimization methods. on the minus side is the problem of devising objective functions or reward signals in the case of reinforcement learning so that optimization produces the desired results while avoiding undesirable results. we said in section that reinforcement learning agents can discover unexpected ways to make their environments deliver reward some of which might be undesirable or even dangerous. when we specify what we want a system to learn only indirectly as we do in designing a reinforcement learning system s reward signal we will not know how closely the agent will fulfill our desire until its learning is complete. this is hardly a new problem with reinforcement learning recognition of it has a long history in both literature and engineering. for example in goethe s poem the sorcerer s apprentice the apprentice uses magic to enchant a broom to do his job of fetching water but the result is an unintended flood due to the apprentice s inadequate knowledge of magic. in the engineering context norbert wiener the founder of cybernetics warned of this problem more than half a century ago by relating the supernatural story of the monkey s paw it grants what you ask for not what you should have asked for or what you intend the problem has also been discussed at length in a modern context by nick bostrom anyone having experience with reinforcement learning has likely seen their systems discover unexpected ways to obtain a lot of reward. sometimes the unexpected behavior is good it solves a problem in a nice new way. in other instances what the agent learns violates considerations that the system designer may never have thought about. careful design of reward signals is essential if an agent is to act in the real world with no opportunity for human vetting of its actions or means to easily interrupt its behavior. despite the possibility of unintended negative consequences optimization has been used for hundreds of years by engineers architects and others whose designs have posi reinforcement learning and the future of artificial intelligence tively impacted the world. we owe much that is good in our environment to the application of optimization methods. many approaches have been developed to mitigate the risk of optimization such as adding hard and soft constraints restricting optimization to robust and risk-sensitive policies and optimizing with multiple objective functions. some of these approaches have been adapted to reinforcement learning and more research is needed to address these concerns. the problem of ensuring that a reinforcement learning agent s goal is attuned to our own remains a challenge. another challenge if reinforcement learning agents are to act and learn in the real world is not just about what they might learn eventually but about how they will behave while they are learning. how do you make sure that an agent gets enough experience to learn a high-performing policy all the while not harming its environment other agents or itself more realistically while keeping the probability of harm acceptably low? this problem is also not novel or unique to reinforcement learning. risk management and mitigation for embedded reinforcement learning is similar to what control engineers have had to confront from the beginning of using automatic control in situations where a controller s behavior can have unacceptable possibly catastrophic consequences as in the control of an aircraft or a delicate chemical process. control applications rely on careful system modeling model validation and extensive testing and there is a highly-developed body of theory aimed at ensuring convergence and stability of adaptive controllers designed for use when the dynamics of the system to be controlled are not fully known. theoretical guarantees are never iron-clad because they depend on the validity of the assumptions underlying the mathematics but without this theory combined with risk-management and mitigation practices automatic control adaptive and otherwise would not be as beneficial as it is today in improving the quality efficiency and cost-effectiveness of processes on which we have come to rely. one of the most pressing areas for future reinforcement learning research is to adapt and extend methods developed in control engineering with the goal of making it acceptably safe to fully embed reinforcement learning agents into physical environments. in closing we return to simon s call for us to recognize that we are designers of our future and not simply spectators. by decisions we make as individuals and by the influence we can exert on how our societies are governed we can work toward ensuring that the benefits made possible by a new technology outweigh the harm it can cause. there is ample opportunity to do this in the case of reinforcement learning which can help improve the quality fairness and sustainability of life on our planet but which can also release new perils. a threat already here is the displacement of jobs caused by applications of artificial intelligence. still there are good reasons to believe that the benefits of artificial intelligence can outweigh the disruption it causes. as to safety hazards possible with reinforcement learning are not completely different from those that have been managed successfully for related applications of optimization and control methods. as reinforcement learning moves out into the real world in future applications developers have an obligation to follow best practices that have evolved for similar technologies while at the same time extending them to make sure that prometheus keeps the upper hand. chapter frontiers bibliographical and historical remarks general value functions were first explicitly identified by sutton and colleagues sutton et al. modayil white and sutton ring preparation developed an extensive thought experiment with gvfs forecasts that has been influential despite not yet having been published. the first demonstrations of multi-headed learning in reinforcement learning were by jaderberg et al. bellemare dabney and munos showed that predicting more things about the distribution of reward could significantly speed learning to optimize its expectation an instance of auxiliary tasks. many others have since taken up this line of research. the general theory of classical conditioning as learned predictions together with built-in reflexive reactions to the predictions has not to our knowledge been clearly articulated in the psychological literature. modayil and sutton describe it as an approach to the engineering of robots and other agents calling it pavlovian control to allude to its roots in classical conditioning. the formalization of temporally abstract courses of action as options was introduced by sutton precup and singh building on prior work by parr and sutton and on classical work on semi-mdps see puterman precup s phd thesis developed option ideas fully. an important limitation of these early works is that they did not treat the off-policy case with function approximation. intra-option learning in general requires offpolicy learning which could not be done reliably with function approximation at that time. although now we have a variety of stable off-policy learning methods using function approximation their combination with option ideas had not been significantly explored at the time of publication of this book. barto and mahadevan and hengst review the options formalism and other approaches to temporal abstraction. using gvfs to implement option models has not previously been described. our presentation uses the trick introduced by modayil white and sutton for predicting signals at the termination of policies. among the few works that have learned option models with function approximation are those by bacon harb and precup the extension of options and option models to the average-reward setting has not yet been developed in the literature. a good presentation of the pomdp approach is given by monahan psrs and tests were introduced by littman sutton and singh ooms were introduced by jaeger sequential systems which unify psrs ooms and many other works were introduced in the phd thesis of michael thon thon and jaeger the theory of reinforcement learning with a non-markov state representation was developed explicitly by singh jaakkola and jordan jaakkola singh and reinforcement learning and the future of artificial intelligence jordan early reinforcement learning approaches to partial observability were developed by chrisman mccallum parr and russell littman cassandra and kaelbling and by lin and mitchell early efforts to include advice and teaching in reinforcement learning include those by lin maclin and shavlik clouse and clouse and utgoff skinner s shaping should not be confused with the potential-based shaping technique introduced by ng harada and russell their technique has been shown by wiewiora to be equivalent to the simpler idea of providing an initial approximation to the value function as in we recommend the book by goodfellow bengio and courville for discussion of today s deep learning techniques. the problem of catastrophic interference in artificial neural networks was developed by mccloskey and cohen ratcliff and french the idea of a replay buffer was introduced by lin and used prominently in deep learning in the atari game playing system mnih et al. minsky was one of the first to identify the problem of representation learning. among the few works to consider planning with learned approximate models are those by kuvayev and sutton sutton szepesvari geramifard and bowling nouri and littman and hester and stone the need to be selective in model construction to avoid slowing planning is well known in artificial intelligence. some of the classic work is by minton and tambe newell and rosenbloom hauskrecht meuleau kaelbling dean and boutilier showed this effect in mdps with deterministic options. schmidhuber b proposed how something like curiosity would result if reward signals were a function of how quickly an agent s environment model is improving. the empowerment function proposed by klyubin polani and nehaniv is an information-theoretic measure of an agent s ability to control its environment that can function as an intrinsic reward signal. baldassarre and mirolli is a collection of contributions by researchers studying intrinsic reward and motivation from both biological and computational perspectives including a perspective on intrinsically-motivated reinforcement learning to use the term introduced by singh barto and chentenez see also oudeyer and kaplan oudeyer kaplan and hafner and barto references abbeel p. ng a. y. apprenticeship learning via inverse reinforcement learning. in proceedings of the international conference on machine learning acm new york. abramson b. expected-outcome a general model of static evaluation. ieee trans actions on pattern analysis and machine intelligence adams c. d. variations in the sensitivity of instrumental responding to reinforcer devaluation. the quarterly journal of experimental psychology adams c. d. dickinson a. instrumental responding following reinforcer devaluation. the quarterly journal of experimental psychology adams r. a. huys q. j. m. roiser j. p. computational psychiatry towards a mathematically informed understanding of mental illness. journal of neurology neurosurgery psychiatry. agrawal r. sample mean based index policies with ologn regret for the multi-armed bandit problem. advances in applied probability agre p. e. the dynamic structure of everyday life. ph.d. thesis massachusetts institute of technology cambridge ma. ai-tr mit artificial intelligence laboratory. agre p. e. chapman d. what are plans for? robotics and autonomous systems aizerman m. a. braverman e. i. rozonoer l. i. probability problem of pattern recognition learning and potential functions method. avtomat. i telemekh albus j. s. a theory of cerebellar function. mathematical biosciences albus j. s. brain behavior and robotics. byte books peterborough nh. aleksandrov v. m. sysoev v. i. shemeneva v. v. stochastic optimization of systems. izv. akad. nauk sssr tekh. amari s. i. natural gradient works efficiently in learning. neural computation an p. c. e. an improved multi-dimensional cmac neural network receptive field function and placement. ph.d. thesis university of new hampshire durham. an p. c. e. miller w. t. parks p. c. design improvements in associative memories for cerebellar model articulation controllers artificial neural networks pp. elsevier north-holland. anderson c. w. learning and problem solving with multilayer connectionist systems. ph.d. thesis university of massachusetts amherst. anderson c. w. strategy learning with multilayer connectionist representations. in references proceedings of the international workshop on machine learning pp. morgan kaufmann. anderson c. w. learning to control an inverted pendulum using neural networks. ieee control systems magazine anderson j. a. silverstein j. w. ritz s. a. jones r. s. distinctive features categorical perception and probability learning some applications of a neural model. psychological review andreae j. h. stella a scheme for a learning machine. in proceedings of the ifac congress basle pp. butterworths london. andreae j. h. a learning machine with monologue. international journal of man machine studies andreae j. h. learning machines a unified view. in a. r. meetham and r. a. hudson encyclopedia of information linguistics and control pp. pergamon oxford. andreae j. h. thinking with the teachable machine. academic press london. arthur w. b. designing economic agents that act like human agents a behavioral approach to bounded rationality. the american economic review atkeson c. g. memory-based approaches to approximating continuous functions. in sante fe institute studies in the sciences of complexity proceedings vol. pp. addison-wesley. atkeson c. g. moore a. w. schaal s. locally weighted learning. artificial intelli gence review auer p. cesa-bianchi n. fischer p. finite-time analysis of the multiarmed bandit problem. machine learning bacon p. l. harb j. precup d. the option-critic architecture. in proceedings of the association for the advancement of artificial intelligence pp. baird l. c. residual algorithms reinforcement learning with function approximation. in proceedings of the international conference on machine learning pp. morgan kaufmann. baird l. c. reinforcement learning through gradient descent. ph.d. thesis carnegie mellon university pittsburgh pa. baird l. c. klopf a. h. reinforcement learning with high-dimensional continuous actions. wright laboratory wright-patterson air force base tech. rep. baird l. moore a. w. gradient descent for general reinforcement learning. in advances in neural information processing systems pp. mit press cambridge ma. baldassarre g. mirolli m. intrinsically motivated learning in natural and artificial systems. springer-verlag berlin heidelberg. balke a. pearl j. counterfactual probabilities computational methods bounds and applications. in proceedings of the tenth international conference on uncertainty in artificial intelligence pp. morgan kaufmann. baras d. meir r. reinforcement learning spike-time-dependent plasticity and the bcm rule. neural computation barnard e. temporal-difference methods and markov models. ieee transactions on systems man and cybernetics barreto a. s. precup d. pineau j. reinforcement learning using kernel-based stochastic factorization. in advances in neural information processing systems references pp. curran associates inc. bartlett p. l. baxter j. hebbian synaptic modifications in spiking neurons that learn. technical report research school of information sciences and engineering australian national university. bartlett p. l. baxter j. a biologically plausible and locally optimal learning algorithm for spiking neurons. rapport technique australian national university. barto a. g. learning by statistical cooperation of self-interested neuron-like computing elements. human neurobiology barto a. g. game-theoretic cooperativity in networks of self-interested units. in j. s. denker neural networks for computing pp. american institute of physics new york. barto a. g. from chemotaxis to cooperativity abstract exercises in neuronal learning strategies. in r. durbin r. maill and g. mitchison the computing neuron pp. addison-wesley reading ma. barto a. g. connectionist learning for control an overview. in t. miller r. s. sutton and p. j. werbos neural networks for control pp. mit press cambridge ma. barto a. g. some learning tasks from a control perspective. in l. nadel and d. l. stein lectures in complex systems pp. addison-wesley redwood city ca. barto a. g. reinforcement learning and adaptive critic methods. in d. a. white and d. a. sofge handbook of intelligent control neural fuzzy and adaptive approaches pp. van nostrand reinhold new york. barto a. g. adaptive critics and the basal ganglia. in j. c. houk j. l. davis and d. g. beiser models of information processing in the basal ganglia pp. mit press cambridge ma. barto a. g. reinforcement learning. in m. a. arbib handbook of brain theory and neural networks pp. mit press cambridge ma. barto a. g. adaptive real-time dynamic programming. in c. sammut and g. i webb encyclopedia of machine learning pp. springer science and business media. barto a. g. intrinsic motivation and reinforcement learning. in g. baldassarre and m. mirolli intrinsically motivated learning in natural and artificial systems pp. springer-verlag berlin heidelberg. barto a. g. anandan p. pattern recognizing stochastic learning automata. ieee transactions on systems man and cybernetics barto a. g. anderson c. w. structural learning in connectionist systems. in program of the seventh annual conference of the cognitive science society pp. barto a. g. anderson c. w. sutton r. s. synthesis of nonlinear control surfaces by a layered associative search network. biological cybernetics barto a. g. bradtke s. j. singh s. p. real-time learning and control using asynchronous dynamic programming. technical report department of computer and information science university of massachusetts amherst. barto a. g. bradtke s. j. singh s. p. learning to act using real-time dynamic programming. artificial intelligence barto a. g. duff m. monte carlo matrix inversion and reinforcement learning. in advances in neural information processing systems pp. morgan kaufmann san francisco. references barto a. g. jordan m. i. gradient following without back-propagation in layered in m. caudill and c. butler proceedings of the ieee first annual networks. conference on neural networks pp. sos printing san diego. barto a. g. mahadevan s. recent advances in hierarchical reinforcement learning. discrete event dynamic systems barto a. g. singh s. p. on the computational economics of reinforcement learning. in connectionist models proceedings of the summer school. morgan kaufmann. barto a. g. sutton r. s. goal seeking components for adaptive intelligence an initial assessment. technical report air force wright aeronautical laboratoriesavionics laboratory wright-patterson afb oh. barto a. g. sutton r. s. landmark learning an illustration of associative search. biological cybernetics barto a. g. sutton r. s. simulation of anticipatory responses in classical conditioning by a neuron-like adaptive element. behavioural brain research barto a. g. sutton r. s. anderson c. w. neuronlike elements that can solve difficult learning control problems. ieee transactions on systems man and cybernetics reprinted in j. a. anderson and e. rosenfeld neurocomputing foundations of research pp. mit press cambridge ma barto a. g. sutton r. s. brouwer p. s. associative search network a reinforcement learning associative memory. biological cybernetics barto a. g. sutton r. s. watkins c. j. c. h. learning and sequential decision in m. gabriel and j. moore learning and computational neuroscience making. foundations of adaptive networks pp. mit press cambridge ma. baxter j. bartlett p. l. infinite-horizon policy-gradient estimation. journal of arti ficial intelligence research baxter j. bartlett p. l. weaver l. experiments with infinite-horizon policy-gradient estimation. journal of artificial intelligence research bellemare m. g. dabney w. munos r. a distributional perspective on reinforcement learning. arxiv preprint bellemare m. g. naddaf y. veness j. bowling m. the arcade learning environment journal of artificial intelligence research an evaluation platform for general agents. bellemare m. g. veness j. bowling m. investigating contingency awareness using in proceedings of the twenty-sixth aaai conference on artificial atari games. intelligence pp. aaai press menlo park ca. bellman r. e. a problem in the sequential design of experiments. sankhya bellman r. e. dynamic programming. princeton university press princeton. bellman r. e. a markov decision process. journal of mathematics and mechanics bellman r. e. dreyfus s. e. functional approximations and dynamic programming. mathematical tables and other aids to computation bellman r. e. kalaba r. kotkin b. polynomial approximation a new computational technique in dynamic programming allocation processes. mathematical computation bengio y. learning deep architectures for ai. foundations and trends in machine learning bengio y. courville a. c. vincent p. unsupervised feature learning and deep learn references ing a review and new perspectives. corr arxiv bentley j. l. multidimensional binary search trees used for associative searching. communications of the acm berg h. c. chemotaxis in bacteria. annual review of biophysics and bioengineering berns g. s. mcclure s. m. pagnoni g. montague p. r. predictability modulates human brain response to reward. the journal of neuroscience berridge k. c. kringelbach m. l. affective neuroscience of pleasure reward in humans and animals. psychopharmacology berridge k. c. robinson t. e. what is the role of dopamine in reward hedonic impact reward learning or incentive salience? brain research reviews berry d. a. fristedt b. bandit problems. chapman and hall london. bertsekas d. p. distributed dynamic programming. ieee transactions on automatic control bertsekas d. p. distributed asynchronous computation of fixed points. mathematical programming bertsekas d. p. dynamic programming deterministic and stochastic models. prentice hall englewood cliffs nj. bertsekas d. p. dynamic programming and optimal control volume third edition. athena scientific belmont ma. bertsekas d. p. dynamic programming and optimal control volume approximate dynamic programming fourth edition. athena scientific belmont ma. bertsekas d. p. rollout algorithms for discrete optimization a survey. in handbook of combinatorial optimization pp. springer new york. bertsekas d. p. tsitsiklis j. n. parallel and distributed computation numerical methods. prentice-hall englewood cliffs nj. bertsekas d. p. tsitsiklis j. n. neuro-dynamic programming. athena scientific belmont ma. bertsekas d. p. tsitsiklis j. n. wu c. rollout algorithms for combinatorial opti mization. journal of heuristics bertsekas d. p. yu h. projected equation methods for approximate solution of large linear systems. journal of computational and applied mathematics bhat n. farias v. moallemi c. c. non-parametric approximate dynamic programin advances in neural information processing systems ming via the kernel method. pp. curran associates inc. bhatnagar s. sutton r. ghavamzadeh m. lee m. natural actor critic algorithms. automatica biermann a. w. fairfield j. r. c. beres t. r. signature table systems and learning. ieee transactions on systems man and cybernetics bishop c. m. neural networks for pattern recognition. clarendon oxford. bishop c. m. pattern recognition and machine learning. springer science business media new york llc. blodgett h. c. the effect of the introduction of reward upon the maze performance of rats. university of california publications in psychology boakes r. a. costa d. s. j. temporal contiguity in associative learning iinterference journal of experimental psychology animal and decay from an historical perspective. learning and cognition references booker l. b. intelligent behavior as an adaptation to the task environment. ph.d. the sis university of michigan ann arbor. bostrom n. superintelligence paths dangers strategies. oxford university press oxford. bottou l. vapnik v. local learning algorithms. neural computation boyan j. a. least-squares temporal difference learning. in proceedings of the international conference on machine learning pp. boyan j. a. technical update least-squares temporal difference learning. machine learning boyan j. a. moore a. w. generalization in reinforcement learning safely approximating the value function. in advances in neural information processing systems pp. mit press cambridge ma. bradtke s. j. reinforcement learning applied to linear quadratic regulation. in advances in neural information processing systems pp. morgan kaufmann. bradtke s. j. incremental dynamic programming for on-line adaptive optimal control. ph.d. thesis university of massachusetts amherst. appeared as cmpsci technical report bradtke s. j. barto a. g. linear least squares algorithms for temporal difference learning. machine learning bradtke s. j. ydstie b. e. barto a. g. adaptive linear quadratic control using policy in proceedings of the american control conference pp. american iteration. automatic control council evanston il. brafman r. i. tennenholtz m. r-max a general polynomial time algorithm for near-optimal reinforcement learning. journal of machine learning research breiman l. random forests. machine learning breiter h. c. aharon i. kahneman d. dale a. shizgal p. functional imaging of neural responses to expectancy and experience of monetary gains and losses. neuron breland k. breland m. the misbehavior of organisms. american psychologist bridle j. s. training stochastic model recognition algorithms as networks can lead to maximum mutual information estimates of parameters. in advances in neural information processing systems pp. morgan kaufmann san mateo ca. broomhead d. s. lowe d. multivariable functional interpolation and adaptive net works. complex systems bromberg-martin e. s. matsumoto m. hong s. hikosaka o. a pallidus-habenuladopamine pathway signals inferred stimulus values. journal of neurophysiology browne c.b. powley e. whitehouse d. lucas s.m. cowling p.i. rohlfshagen p. tavener s. perez d. samothrakis s. colton s. a survey of monte carlo tree search methods. ieee transactions on computational intelligence and ai in games brown j. bullock d. grossberg s. how the basal ganglia use parallel excitatory and inhibitory learning pathways to selectively respond to unexpected rewarding cues. the journal of neuroscience bryson a. e. jr. optimal control to ieee control systems buchanan b. g. mitchell t. smith r. g. johnson c. r. jr. models of learning references systems. encyclopedia of computer science and technology buhusi c. v. schmajuk n. a. timing in simple conditioning and occasion setting a neural network approach. behavioural processes bu soniu l. lazaric a. ghavamzadeh m. munos r. babu ska r. de schutter b. in m. wiering and m. van otterlo least-squares methods for policy iteration. reinforcement learning state-of-the-art pp. springer-verlag berlin heidelberg. bush r. r. mosteller f. stochastic models for learning. wiley new york. byrne j. h. gingrich k. j. baxter d. a. computational capabilities of single neurons relationship to simple forms of associative and nonassociative learning in aplysia. in r. d. hawkins and g. h. bower computational models of learning pp. academic press new york. calabresi p. picconi b. tozzi a. filippo m. d. dopamine-mediated regulation of corticostriatal synaptic plasticity. trends in neuroscience camerer c. behavioral game theory experiments in strategic interaction. princeton university press. campbell d. t. knowledge-processes. pp. pergamon new york. blind variation and selective survival as a general strategy in in m. c. yovits and s. cameron self-organizing systems cao x. r. stochastic learning and optimization a sensitivity-based approach. annual reviews in control cao x. r. chen h. f. perturbation realization potentials and sensitivity analysis of markov processes. ieee transactions on automatic control carlstr om j. nordstr om e. control of self-similar atm call traffic by reinforcement learning. in proceedings of the international workshop on applications of neural networks to telecommunications pp. erlbaum hillsdale nj. chapman d. kaelbling l. p. input generalization in delayed reinforcement learning an algorithm and performance comparisons. in proceedings of the twelfth international conference on artificial intelligence pp. morgan kaufmann san mateo ca. chaslot g. bakkes s. szita i. spronck p. monte-carlo tree search a new framework for game ai. in proceedings of the fourth aaai conference on artificial intelligence and interactive digital entertainment pp. aaai press menlo park ca. chow c.-s. tsitsiklis j. n. an optimal one-way multigrid algorithm for discrete-time stochastic control. ieee transactions on automatic control chrisman l. reinforcement learning with perceptual aliasing the perceptual distinctions approach. in proceedings of the tenth national conference on artificial intelligence pp. aaaimit press menlo park ca. christensen j. korf r. e. a unified theory of heuristic evaluation functions and in proceedings of the fifth national conference on artificial its application to learning. intelligence pp. morgan kaufmann. cichosz p. truncating temporal differences on the efficient implementation of td for reinforcement learning. journal of artificial intelligence research claridge-chang a. roorda r. d. vrontou e. sjulson l. li h. hirsh j. miesenb ock g. writing memories with light-addressable reinforcement circuitry. cell clark r. e. squire l. r. classical conditioning and brain systems the role of awareness. science references clark w. a. farley b. g. generalization of pattern recognition in a self-organizing system. in proceedings of the western joint computer conference pp. clouse j. on integrating apprentice learning and reinforcement learning ph.d. thesis university of massachusetts amherst. appeared as cmpsci technical report clouse j. utgoff p. a teaching method for reinforcement learning systems. in proceedings of the international workshop on machine learning pp. morgan kaufmann. cobo l. c. zang p. isbell c. l. thomaz a. l. automatic state abstraction from in proceedings of the twenty-second international joint conference on demonstration. artificial intelligence pp. aaai press. connell j. a colony architecture for an artificial creature. technical report ai-tr mit artificial intelligence laboratory cambridge ma. connell m. e. utgoff p. e. learning to control a dynamic physical system. compu tational intelligence contreras-vidal j. l. schultz w. a predictive reinforcement model of dopamine neurons for learning approach behavior. journal of computational neuroscience coulom r. efficient selectivity and backup operators in monte-carlo tree search. in proceedings of the international conference on computers and games pp. springer-verlag berlin heidelberg. courville a. c. daw n. d. touretzky d. s. bayesian theories of conditioning in a changing world. trends in cognitive science craik k. j. w. the nature of explanation. cambridge university press cambridge. cross j. g. a stochastic learning model of economic behavior. the quarterly journal of economics crow t. j. cortical synapses and reinforcement a hypothesis. nature curtiss j. h. a theoretical comparison of the efficiencies of two classical methods and a monte carlo method for computing one component of the solution of a set of linear algebraic equations. in h. a. meyer symposium on monte carlo methods pp. wiley new york. cybenko g. approximation by superpositions of a sigmoidal function. mathematics of control signals and systems cziko g. without miracles universal selection theory and the second darvinian revolution. mit press cambridge ma. dabney w. adaptive step-sizes for reinforcement learning. phd thesis university of massachusetts amherst. dabney w. barto a. g. adaptive step-size for online temporal difference learning. in proceedings of the annual conference of the association for the advancement of artificial intelligence daniel j. w. splines and efficiency in dynamic programming. journal of mathematical analysis and applications dann c. neumann g. peters j. policy evaluation with temporal differences a survey and comparison. journal of machine learning research daw n. d. courville a. c. touretzky d. s. timing and partial observability in the dopamine system. in advances in neural information processing systems references pp. mit press cambridge ma. daw n. d. courville a. c. touretzky d. s. representation and timing in theories of the dopamine system. neural computation daw n. d. niv y. dayan p. uncertainty based competition between prefrontal and dorsolateral striatal systems for behavioral control. nature neuroscience daw n. d. shohamy d. the cognitive neuroscience of motivation and learning. social cognition dayan p. reinforcement comparison. in d. s. touretzky j. l. elman t. j. sejnowski and g. e. hinton connectionist models proceedings of the summer school pp. morgan kaufmann. dayan p. the convergence of td for general machine learning dayan p. matters temporal. trends in cognitive sciences dayan p. abbott l. f. theoretical neuroscience computational and mathematical modeling of neural systems. mit press cambridge ma. dayan p. berridge k. c. model-based and model-free pavlovian reward learning revaluation revision and revaluation. cognitive affective behavioral neuroscience dayan p. niv y. reinforcement learning the good the bad and the ugly. current opinion in neurobiology dayan p. niv y. seymour b. daw n. d. the misbehavior of value and the discipline of the will. neural networks dayan p. sejnowski t. td converges with probability machine learning de asis k. hernandez-garcia j. f. holland g. z. sutton r. s. multi-step rein forcement learning a unifying algorithm. arxiv preprint dean t. lin s.-h. decomposition techniques for planning in stochastic domains. in proceedings of the fourteenth international joint conference on artificial intelligence pp. morgan kaufmann. see also technical report brown university department of computer science degris t. white m. sutton r. s. off-policy actor critic. in proceedings of the international conference on machine learning arxiv preprint denardo e. v. contraction mappings in the theory underlying dynamic programming. siam review dennett d. c. why the law of effect will not go away. brainstorms pp. bradfordmit press cambridge ma. derthick m. variations on the boltzmann machine learning algorithm. carnegie-mellon university department of computer science technical report no. deutsch j. a. a new type of behaviour theory. british journal of psychology. general section deutsch j. a. a machine with insight. quarterly journal of experimental psychology dick t. policy gradient reinforcement learning without regret. m.sc. thesis uni versity of alberta edmonton. dickinson a. contemporary animal learning theory. cambridge university press cambridge. dickinson a. actions and habits the development of behavioral autonomy. phil. references trans. r. soc. lond. b dickinson a. balleine b. w. the role of learning in motivation. in c. r. gallistel stevens handbook of experimental psychology volume pp. wiley ny. dietterich t. g. buchanan b. g. the role of the critic in learning systems. in o. g. selfridge e. l. rissland and m. a. arbib adaptive control of ill-defined systems pp. plenum press ny. proceedings of the nato advanced research institute on adaptive control of ill-defined systems nato conference series ii systems science vol. dietterich t. g. flann n. s. explanation-based learning and reinforcement learning a unified view. in a. prieditis and s. russell proceedings of the international conference on machine learning pp. morgan kaufmann. dietterich t. g. wang x. batch value function approximation via support vectors. in advances in neural information processing systems pp. mit press cambridge ma. diuk c. cohen a. littman m. l. an object-oriented representation for efficient in proceedings of the international conference on machine reinforcement learning. learning pp. acm new york. dolan r. j. dayan p. goals and habits in the brain. neuron doll b. b. simon d. a. daw n. d. the ubiquity of model-based reinforcement learning. current opinion in neurobiology donahoe j. w. burgos j. e. behavior analysis and revaluation. journal of the experimental analysis of behavior dorigo m. colombetti m. robot shaping developing autonomous agents through learning. artificial intelligence doya k. temporal difference learning in continuous time and space. in advances in neural information processing systems pp. mit press cambridge ma. doya k. sejnowski t. j. a novel reinforcement model of birdsong vocalization learning. in advances in neural information processing systems pp. mit press cambridge ma. doya k. sejnowski t. j. a computational model of birdsong learning by auditory in p. w. f. poon and j. f. brugge central experience and auditory feedback. auditory processing and neural modeling pp. springer boston ma. doyle p. g. snell j. l. random walks and electric networks. the mathematical association of america. carus mathematical monograph dreyfus s. e. law a. m. the art and theory of dynamic programming. academic press new york. duda r. o. hart p. e. pattern classification and scene analysis. wiley new york. duff m. o. q-learning for bandit problems. in proceedings of the international conference on machine learning pp. morgan kaufmann. egger d. m. miller n. e. secondary reinforcement in rats as a function of information value and reliability of the stimulus. journal of experimental psychology eshel n. tian j. bukwich m. uchida n. dopamine neurons share common response function for reward prediction error. nature neuroscience estes w. k. discriminative conditioning. i. a discriminative property of conditioned anticipation. journal of experimental psychology estes w. k. discriminative conditioning. ii. effects of a pavlovian conditioned stimulus references upon a subsequently established operant response. journal of experimental psychology estes w. k. toward a statistical theory of learning. psychololgical review farley b. g. clark w. a. simulation of self-organizing systems by digital computer. ire transactions on information theory farries m. a. fairhall a. l. reinforcement learning with modulated spike timingde pendent synaptic plasticity. journal of neurophysiology feldbaum a. a. optimal control systems. academic press new york. finch g. culler e. higher order conditioning with constant motivation. the american journal of finnsson h. bj ornsson y. simulation-based approach to general game playing. in proceedings of the association for the advancement of artificial intelligence pp. fiorillo c. d. yun s. r. song m. r. diversity and homogeneity in responses of midbrain dopamine neurons. the journal of neuroscience florian r. v. reinforcement learning through modulation of spike-timing-dependent synaptic plasticity. neural computation fogel l. j. owens a. j. walsh m. j. artificial intelligence through simulated evo lution. john wiley and sons. french r. m. catastrophic forgetting in connectionist networks. trends in cognitive sciences frey u. morris r. g. m. synaptic tagging and long-term potentiation. nature fr emaux n. sprekeler h. gerstner w. functional requirements for reward-modulated spike-timing-dependent plasticity. the journal of neuroscience friedman j. h. bentley j. l. finkel r. a. an algorithm for finding best matches in logarithmic expected time. acm transactions on mathematical software friston k. j. tononi g. reeke g. n. sporns o. edelman g. m. value-dependent selection in the brain simulation in a synthetic neural model. neuroscience ieee transactions on fu k. s. learning control systems review and outlook. automatic control galanter e. gerstenhaber m. on thought the extrinsic theory. psychological review gallistel c. r. deconstructing the law of effect. games and economic behavior gardner m. mathematical games. scientific american geist m. scherrer b. off-policy learning with eligibility traces a survey. journal of machine learning research gelly s. silver d. combining online and o ine knowledge in uct. proceedings of the international conference on machine learning pp. gelperin a. hopfield j. j. tank d. w. the logic of limax learning. in a. selverston model neural networks and behavior pp. plenum press new york. genesereth m. thielscher m. general game playing. synthesis lectures on artificial intelligence and machine learning gershman s. j. moustafa a. a. ludvig e. a. time representation in reinforcement learning models of the basal ganglia. frontiers in computational neuroscience references gershman s. j. pesaran b. daw n. d. human reinforcement learning subdivides structured action spaces by learning effector-specific values. the journal of neuroscience ghiassian s. rafiee b. sutton r. s. a first empirical study of emphatic temporal difference learning. workshop on continual learning and deep learning at the conference on neural information processing systems gibbs c. m. cool v. land t. kehoe e. j. gormezano i. second-order conditioning of the rabbits nictitating membrane response. integrative physiological and behavioral science gittins j. c. jones d. m. a dynamic allocation index for the sequential design of experiments. in j. gani k. sarkadi and i. vincze progress in statistics pp. north-holland amsterdam london. glimcher p. w. understanding dopamine and reinforcement learning the dopamine proceedings of the national academy of sciences reward prediction error hypothesis. glimcher p. w. decisions uncertainty and the brain the science of neuroeconomics. mit press cambridge ma. glimcher p. w. fehr e. neuroeconomics decision making and the brain second edition. academic press. goethe j. w. v. the sorcerers apprentice. in the permanent goethe p. the dial press inc. new york. goldstein h. classical mechanics. addison-wesley reading ma. goodfellow i. bengio y. courville a. deep learning. mit press cambridge ma. goodwin g. c. sin k. s. adaptive filtering prediction and control. prentice-hall englewood cliffs nj. gopnik a. glymour c. sobel d. schulz l. e. kushnir t. danks d. a theory of causal learning in children causal maps and bayes nets. psychological review gordon g. j. stable function approximation in dynamic programming. in a. prieditis and s. russell proceedings of the international conference on machine learning pp. morgan kaufmann. an expanded version was published as technical report carnegie mellon university pittsburgh pa gordon g. j. chattering in sarsa cmu learning lab internal report. gordon g. j. stable fitted reinforcement learning. in advances in neural information processing systems pp. mit press cambridge ma. gordon g. j. approximate solutions to markov decision processes. ph.d. thesis carnegie mellon university pittsburgh pa. pittsburgh pa. gordon g. j. reinforcement learning with function approximation converges to a region. in advances in neural information processing systems pp. mit press cambridge ma. graybiel a. m. the basal ganglia. current biology greensmith e. bartlett p. l. baxter j. variance reduction techniques for gradient estimates in reinforcement learning. in advances in neural information processing systems pp. mit press cambridge ma. greensmith e. bartlett p. l. baxter j. variance reduction techniques for gradient estimates in reinforcement learning. journal of machine learning research griffith a. k. a new machine learning technique applied to the game of checkers. references technical report project mac artificial intelligence memo massachusetts institute of technology cambridge ma. griffith a. k. a comparison and evaluation of three machine learning procedures as applied to the game of checkers. artificial intelligence grondman i. busoniu l. lopes g. a. babuska r. a survey of actor critic reinforcement learning standard and natural policy gradients. ieee transactions on systems man and cybernetics part c and reviews grossberg s. a neural model of attention reinforcement and discrimination learning. international review of neurobiology grossberg s. schmajuk n. a. neural dynamics of adaptive timing and temporal discrimination during associative learning. neural networks gullapalli v. a stochastic reinforcement algorithm for learning real-valued functions. neural networks gullapalli v. barto a. g. shaping as a method for accelerating reinforcement learning. in proceedings of the ieee international symposium on intelligent control pp. ieee. gurvits l. lin l.-j. hanson s. j. incremental learning of evaluation functions for absorbing markov chains new methods and theorems. siemans corporate research princeton nj. hackman l. faster gradient-td algorithms. m.sc. thesis university of alberta edmonton. hallak a. tamar a. mannor s. emphatic td bellman operator is a contraction. hallak a. tamar a. munos r. mannor s. generalized emphatic temporal difference learning bias-variance analysis. in proceedings of the thirtieth aaai conference on artificial intelligence pp. aaai press menlo park ca. hammer m. the neural basis of associative reward learning in honeybees. trends in neuroscience hammer m. menzel r. learning and memory in the honeybee. the journal of neuroscience hampson s. e. a neural model of adaptive behavior. ph.d. thesis university of california irvine. hampson s. e. connectionist problem solving computational aspects of biological learning. birkhauser boston. hare t. a. o doherty j. camerer c. f. schultz w. rangel a. dissociating the role of the orbitofrontal cortex and the striatum in the computation of goal values and prediction errors. the journal of neuroscience harth e. tzanakou e. alopex a stochastic method for determining visual receptive fields. vision research hassabis d. maguire e. a. deconstructing episodic memory with construction. trends in cognitive sciences hauskrecht m. meuleau n. kaelbling l. p. dean t. boutilier c. hierarchical solution of markov decision processes using macro-actions. in proceedings of the fourteenth conference on uncertainty in artificial intelligence pp. morgan kaufmann. hawkins r. d. kandel e. r. is there a cell-biological alphabet for simple forms of learning? psychological review haykin s. neural networks a comprehensive foundation macmillan college publish references ing company new york. he k. huertas m. hong s. z. tie x. hell j. w. shouval h. kirkwood a. distinct eligibility traces for ltp and ltd in cortical synapses. neuron he k. zhang x. ren s. sun j. deep residual learning for image recognition. in proceedings of the ieee conference on computer vision and pattern recognition pp. hebb d. o. the organization of behavior a neuropsychological theory. john wiley and sons inc. new york. reissued by lawrence erlbaum associates inc. mahwah nj hengst b. hierarchical approaches. in m. wiering and m. van otterlo rein forcement learning state-of-the-art pp. springer-verlag berlin heidelberg. herrnstein r. j. on the law of effect. journal of the experimental analysis of behavior hersh r. griego r. j. brownian motion and potential theory. scientific american hester t. stone p. learning and using models. in m. wiering and m. van otterlo reinforcement learning state-of-the-art pp. springer-verlag berlin heidelberg. hesterberg t. c. advances in importance sampling ph.d. thesis statistics depart ment stanford university. hilgard e. r. theories of learning second edition. appleton-century-cofts inc. new york. hilgard e. r. bower g. h. theories of learning. prentice-hall englewood cliffs nj. hinton g. e. distributed representations. technical report depart ment of computer science carnegie-mellon university pittsburgh pa. hinton g. e. osindero s. teh y. a fast learning algorithm for deep belief nets. neural computation hochreiter s. schmidhuber j. ltsm can solve hard time lag problems. in advances in neural information processing systems pp. mit press cambridge ma. holland j. h. adaptation in natural and artificial systems. university of michigan press ann arbor. holland j. h. adaptation. in r. rosen and f. m. snell progress in theoretical biology vol. pp. academic press new york. holland j. h. escaping brittleness the possibility of general-purpose learning algorithms applied to rule-based systems. in r. s. michalski j. g. carbonell and t. m. mitchell machine learning an artificial intelligence approach vol. pp. morgan kaufmann. hollerman j. r. schultz w. dopmine neurons report an error in the temporal prediction of reward during learning. nature neuroscience houk j. c. adams j. l. barto a. g. a model of how the basal ganglia generates and uses neural signals that predict reinforcement. in j. c. houk j. l. davis and d. g. beiser models of information processing in the basal ganglia pp. mit press cambridge ma. howard r. dynamic programming and markov processes. mit press cambridge ma. references hull c. l. the goal-gradient hypothesis and maze learning. psychological review hull c. l. principles of behavior. appleton-century new york. hull c. l. a behavior system. wiley new york. ioffe s. szegedy c. batch normalization accelerating deep network training by reducing internal covariate shift. ipek e. mutlu o. mart nez j. f. caruana r. self-optimizing memory controllers a reinforcement learning approach. in isca of the annual international symposium on computer architecture pp. ieee computer society washington dc usa. izhikevich e. m. solving the distal reward problem through linkage of stdp and dopamine signaling. cerebral cortex jaakkola t. jordan m. i. singh s. p. on the convergence of stochastic iterative dynamic programming algorithms. neural computation jaakkola t. singh s. p. jordan m. i. reinforcement learning algorithm for partially observable markov decision problems. in advances in neural information processing systems pp. mit press cambridge ma. jacobs r. a. increased rates of convergence through learning rate adaptation. neural networks jaderberg m. mnih v. czarnecki w. m. schaul t. leibo j. z. silver d. kavukcuoglu k. reinforcement learning with unsupervised auxiliary tasks. arxiv preprint jaeger h. observable operator models and conditioned continuation representations. arbeitspapiere der gmd gmd forschungszentrum informationstechnik sankt augustin germany. jaeger h. discrete time discrete valued observable operator models a tutorial. gmd-forschungszentrum informationstechnik. jaeger h. observable operator models for discrete stochastic time series. neural computation jaeger h. tutorial on training recurrent neural networks covering bppt rtrl ekf and the echo state network approach. german national research center for information technology technical report gmd report joel d. niv y. ruppin e. actor critic models of the basal ganglia new anatomical and computational perspectives. neural networks johnson a. redish a. d. neural ensembles in transiently encode paths forward of the animal at a decision point. the journal of neuroscience kaelbling l. p. hierarchical learning in stochastic domains preliminary results. in proceedings of the international conference on machine learning pp. morgan kaufmann. kaelbling l. p. learning in embedded systems. mit press cambridge ma. kaelbling l. p. special triple issue on reinforcement learning machine learning kaelbling l. p. littman m. l. moore a. w. reinforcement learning a survey. journal of artificial intelligence research kakade s. m. a natural policy gradient. in advances in neural information processing systems pp. mit press cambridge ma. kakade s. m. on the sample complexity of reinforcement learning. ph.d. thesis university of london. references kakutani s. markov processes and the dirichlet problem. proceedings of the japan academy kalos m. h. whitlock p. a. monte carlo methods. wiley new york. kamin l. j. attention-like processes in classical conditioning. in m. r. jones miami symposium on the prediction of behavior aversive stimulation pp. university of miami press coral gables florida. kamin l. j. predictability surprise attention and conditioning. in b. a. campbell and r. m. church punishment and aversive behavior pp. appletoncentury-crofts new york. kandel e. r. schwartz j. h. jessell t. m. siegelbaum s. a. hudspeth a. j. principles of neural science fifth edition. mcgraw-hill companies inc. karampatziakis n. langford j. online importance weight aware updates. kashyap r. l. blaydon c. c. fu k. s. stochastic approximation. in j. m. mendel and k. s. fu adaptive learning and pattern recognition systems theory and applications pp. academic press new york. kearney a. veeriah v travnik j sutton r. s. pilarski p. m. preparation. tidbd adapting temporal-difference step-sizes through stochastic meta-descent. kearns m. singh s. near-optimal reinforcement learning in polynomial time. machine learning keerthi s. s. ravindran b. reinforcement learning. in e. fieslerm and r. beale handbook of neural computation oxford university press new york. kehoe e. j. conditioning with serial compound stimuli theoretical and empirical issues. experimental animal behavior kehoe e. j. schreurs b. g. graham p. temporal primacy overrides prior training in serial compound conditioning of the rabbits nictitating membrane response. animal learning behavior keiflin r. janak p. h. dopamine prediction errors in reward learning and addiction ffrom theory to neural circuitry. neuron kimble g. a. hilgard and marquis conditioning and learning. appleton-century crofts new york. kimble g. a. foundations of conditioning and learning. appleton-century-crofts new york. kingma d. ba j. adam a method for stochastic optimization. klopf a. h. brain function and adaptive systems a heterostatic theory. technical report air force cambridge research laboratories bedford ma. a summary appears in proceedings of the international conference on systems man and cybernetics ieee systems man and cybernetics society dallas tx. klopf a. h. a comparison of natural and artificial intelligence. sigart newsletter klopf a. h. the hedonistic neuron a theory of memory learning and intelligence. hemisphere washington dc. klopf a. h. a neuronal model of classical conditioning. psychobiology klyubin a. s. polani d. nehaniv c. l. empowerment a universal agent-centric measure of control. in proceedings of the ieee congress on evolutionary computation pp. ieee. kober j. peters j. reinforcement learning in robotics a survey. in m. wiering m. van otterlo reinforcement learning state-of-the-art pp. springer-verlag references berlin heidelberg. kocsis l. szepesv ari cs. bandit based monte-carlo planning. in proceedings of the european conference on machine learning pp. springer-verlag berlin heidelberg. kohonen t. associative memory a system theoretic approach. springer-verlag berlin. koller d. friedman n. probabilistic graphical models principles and techniques. mit press. kolodziejski c. porr b. w org otter f. on the asymptotic equivalence between differential hebbian and temporal difference learning. neural computation kolter j. z. the fixed points of off-policy td. in advances in neural information processing systems pp. curran associates inc. konda v. r. tsitsiklis j. n. actor-critic algorithms. in advances in neural informa tion processing systems pp. mit press cambridge ma. konda v. r. tsitsiklis j. n. on actor-critic algorithms. siam journal on control and optimization konidaris g. d. osentoski s. thomas p. s. value function approximation in reinforcement learning using the fourier basis in proceedings of the twenty-fifth conference of the association for the advancement of artificial intelligence pp. korf r. e. optimal path finding algorithms. in l. n. kanal and v. kumar search in artificial intelligence pp. springer-verlag berlin. korf r. e. real-time heuristic search. artificial intelligence koshland d. e. bacterial chemotaxis as a model behavioral system. raven press new york. koza j. r. genetic programming on the programming of computers by means of natural selection mit press. cambridge ma. kraft l. g. campagna d. p. a summary comparison of cmac neural network and traditional adaptive control systems. in t. miller r. s. sutton and p. j. werbos neural networks for control pp. mit press cambridge ma. kraft l. g. miller w. t. dietz d. development and application of cmac neural network-based control. in d. a. white and d. a. sofge handbook of intelligent control neural fuzzy and adaptive approaches pp. van nostrand reinhold new york. kumar p. r. varaiya p. stochastic systems estimation identification and adaptive control. prentice-hall englewood cliffs nj. kumar p. r. a survey of some results in stochastic adaptive control. siam journal of control and optimization kumar v. kanal l. n. the cdp a unifying formulation for heuristic search dynamic in l. n. kanal and v. kumar search in programming and branch-and-bound. artificial intelligence pp. springer-verlag berlin. kushner h. j. dupuis p. numerical methods for stochastic control problems in continuous time. springer-verlag new york. kuvayev l. sutton r.s. model-based reinforcement learning with an approximate learned model. proceedings of the ninth yale workshop on adaptive and learning systems pp. yale university new haven ct. lagoudakis m. parr r. least squares policy iteration. journal of machine learning research references lai t. l. robbins h. asymptotically efficient adaptive allocation rules. advances in applied mathematics lakshmivarahan s. narendra k. s. learning algorithms for two-person zero-sum siam journal of stochastic games with incomplete information a unified approach. control and optimization lammel s. lim b. k. malenka r. c. reward and aversion in a heterogeneous midbrain dopamine system. neuropharmacology lane s. h. handelman d. a. gelfand j. j. theory and development of higher-order cmac neural networks. ieee control systems lecun y. une procdure d apprentissage pour rseau a seuil asymmetrique learning scheme for asymmetric threshold networks. in proceedings of cognitiva paris france. lecun y. bottou l. bengio y. haffner p. gradient-based learning applied to document recognition. proceedings of the ieee legenstein r. w. maass d. p. a learning theory for reward-modulated spike-timingdependent plasticity with application to biofeedback. plos computational biology levy w. b. steward d. temporal contiguity requirements for long-term associative potentiationdepression in the hippocampus. neuroscience lewis f. l. liu d. reinforcement learning and approximate dynamic pro gramming for feedback control. john wiley and sons. lewis r. l. howes a. singh s. computational rationality linking mechanism and behavior through utility maximization. topics in cognitive science li l. sample complexity bounds of exploration. in m. wiering and m. van otterlo reinforcement learning state-of-the-art pp. springer-verlag berlin heidelberg. li l. chu w. langford j. schapire r. e. a contextual-bandit approach to personin proceedings of the international conference alized news article recommendation. on world wide web pp. acm new york. lin c.-s. kim h. cmac-based adaptive critic self-learning control. ieee transac tions on neural networks lin l.-j. self-improving reactive agents based on reinforcement learning planning and teaching. machine learning lin l.-j. mitchell t. reinforcement learning with hidden states. in proceedings of the second international conference on simulation of adaptive behavior from animals to animats pp. mit press cambridge ma. littman m. l. cassandra a. r. kaelbling l. p. learning policies for partially in proceedings of the international conference observable environments scaling up. on machine learning pp. morgan kaufmann. littman m. l. dean t. l. kaelbling l. p. on the complexity of solving markov in proceedings of the eleventh annual conference on uncertainty in decision problems. artificial intelligence pp. littman m. l. sutton r. s. singh predictive representations of state. in advances in neural information processing systems pp. mit press cambridge ma. liu j. s. monte carlo strategies in scientific computing. springer-verlag berlin. ljung l. system identification. in a. proch azka j. uhl r p. w. j. rayner and n. g. kingsbury signal analysis and prediction pp. springer science business media new york llc. references ljung l. s oderstrom t. theory and practice of recursive identification. mit press cambridge ma. ljungberg t. apicella p. schultz w. responses of monkey dopamine neurons during learning of behavioral reactions. journal of neurophysiology lovejoy w. s. a survey of algorithmic methods for partially observed markov decision processes. annals of operations research luce d. individual choice behavior. wiley new york. ludvig e. a. bellemare m. g. pearson k. g. a primer on reinforcement learning in the brain psychological computational and neural perspectives. in e. alonso and e. mondrag on computational neuroscience for advancing artificial intelligence models methods and applications pp. medical information science reference hershey pa. ludvig e. a. sutton r. s. kehoe e. j. stimulus representation and the timing of reward-prediction errors in models of the dopamine system. neural computation ludvig e. a. sutton r. s. kehoe e. j. evaluating the td model of classical conditioning. learning behavior machado a. learning the temporal dynamics of behavior. psychological review mackintosh n. j. a theory of attention variations in the associability of stimuli with reinforcement. psychological review mackintosh n. j. conditioning and associative learning. clarendon press oxford. maclin r. shavlik j. w. incorporating advice into agents that learn from reinin proceedings of the twelfth national conference on artificial intelligence forcements. pp. aaai press menlo park ca. maei h. r. gradient temporal-difference learning algorithms. ph.d. thesis univer sity of alberta edmonton. maei h. r. sutton r. s. gq a general gradient algorithm for temporal-difference prediction learning with eligibility traces. in proceedings of the third conference on artificial general intelligence pp. maei h. r. szepesv ari cs. bhatnagar s. precup d. silver d. sutton r. s. convergent temporal-difference learning with arbitrary smooth function approximation. in advances in neural information processing systems pp. curran associates inc. maei h. r. szepesv ari cs. bhatnagar s. sutton r. s. toward off-policy learning control with function approximation. in proceedings of the international conference on machine learning pp. mahadevan s. average reward reinforcement learning foundations algorithms and empirical results. machine learning mahadevan s. liu b. thomas p. dabney w. giguere s. jacek n. gemp i. liu j. proximal reinforcement learning a new theory of sequential decision making in primal-dual spaces. arxiv preprint mahadevan s. connell j. automatic programming of behavior-based robots using reinforcement learning. artificial intelligence mahmood a. r. incremental off-policy reinforcement learning algorithms. ph.d. thesis university of alberta edmonton. mahmood a. r. sutton r. s. off-policy learning based on weighted importance references sampling with linear computational complexity. in proceedings of the conference on uncertainty in artificial intelligence pp. auai press corvallis oregon. mahmood a. r. sutton r. s. degris t. pilarski p. m. tuning-free step-size adaptation. in ieee international conference on acoustics speech and signal processing proceedings pp. ieee. mahmood a. r. yu h sutton r. s. multi-step off-policy learning without importance sampling ratios. arxiv mahmood a. r. van hasselt h. sutton r. s. weighted importance sampling for off-policy learning with linear function approximation. advances in neural information processing systems pp. curran associates inc. marbach p. tsitsiklis j. n. simulation-based optimization of markov reward processes. mit technical report marbach p. tsitsiklis j. n. simulation-based optimization of markov reward processes. ieee transactions on automatic control markram h. l ubke j. frotscher m. sakmann b. regulation of synaptic efficacy by coincidence of postsynaptic aps and epsps. science mart nez j. f. ipek e. dynamic multicore resource management a machine learning approach. micro ieee mataric m. j. reward functions for accelerated learning. in proceedings of the international conference on machine learning pp. morgan kaufmann. matsuda w. furuta t. nakamura k. c. hioki h. fujiyama f. arai r. kaneko t. single nigrostriatal dopaminergic neurons form widely spread and highly dense axonal arborizations in the neostriatum. the journal of neuroscience mazur j. e. learning and behavior ed. prentice-hall englewood cliffs nj. mccallum a. k. overcoming incomplete perception with utile distinction memory. in proceedings of the international conference on machine learning pp. morgan kaufmann. mccallum a. k. reinforcement learning with selective perception and hidden state. ph.d. thesis university of rochester rochester ny. mccloskey m. cohen n. j. catastrophic interference in connectionist networks the sequential learning problem. psychology of learning and motivation mcclure s. m. daw n. d. montague p. r. a computational substrate for incentive salience. trends in neurosciences mcculloch w. s. pitts w. a logical calculus of the ideas immanent in nervous activity. bulletin of mathematical biophysics mcmahan h. b. gordon g. j. fast exact planning in markov decision processes. in proceedings of the international conference on automated planning and scheduling pp. melo f. s. meyn s. p. ribeiro m. i. an analysis of reinforcement learning with function approximation. in proceedings of the international conference on machine learning pp. mendel j. m. a survey of learning control systems. isa transactions mendel j. m. mclaren r. w. reinforcement learning control and pattern recognition systems. in j. m. mendel and k. s. fu adaptive learning and pattern recognition systems theory and applications pp. academic press new york. references michie d. trial and error. in s. a. barnett and a. mclaren science survey part pp. penguin harmondsworth. michie d. experiments on the mechanisation of game learning. characterization of the model and its parameters. the computer journal michie d. on machine intelligence. edinburgh university press edinburgh. michie d. chambers r. a. boxes an experiment in adaptive control. in e. dale and d. michie machine intelligence pp. oliver and boyd edinburgh. miller r. meaning and purpose in the intact brain a philosophical psychological and biological account of conscious process. clarendon press oxford. miller w. t. an e. glanz f. carter m. the design of cmac neural networks for control. adaptive and learning systems miller w. t. glanz f. h. unh cmac verison the university of new hampshire implementation of the cerebellar model arithmetic computer cmac. robotics laboratory technical report university of new hampshire durham. miller s. williams r. j. learning to control a bioreactor using a neural net dyna-q system. in proceedings of the seventh yale workshop on adaptive and learning systems pp. center for systems science dunham laboratory yale university new haven. miller w. t. scalera s. m. kim a. neural network control of dynamic balance for a biped walking robot. in proceedings of the eighth yale workshop on adaptive and learning systems pp. center for systems science dunham laboratory yale university new haven. minton s. quantitative results concerning the utility of explanation-based learning. artificial intelligence minsky m. l. theory of neural-analog reinforcement systems and its application to the brain-model problem. ph.d. thesis princeton university. minsky m. l. steps toward artificial intelligence. proceedings of the institute of radio engineers reprinted in e. a. feigenbaum and j. feldman computers and thought pp. mcgraw-hill new york minsky m. l. computation finite and infinite machines. prentice-hall englewood cliffs nj. mnih v. kavukcuoglu k. silver d. graves a. antonoglou i. wierstra d. riedmiller m. playing atari with deep reinforcement learning. arxiv preprint mnih v. kavukcuoglu k. silver d. rusu a. a. veness j. bellemare m. g. graves a. riedmiller m. fidjeland a. k. ostrovski g. petersen s. beattie c. sadik a. antonoglou i. king h. kumaran d. wierstra d. legg s. hassabis d. humanlevel control through deep reinforcement learning. nature modayil j. sutton r. s. prediction driven behavior learning predictions that drive fixed responses. in workshop on artificial intelligence and robotics quebec city canada. modayil j. white a. sutton r. s. multi-timescale nexting in a reinforcement learning robot. adaptive behavior monahan g. e. state of the art a survey of partially observable markov decision processes theory models and algorithms. management science montague p. r. dayan p. nowlan s. j. pouget a. sejnowski t. j. using aperiodic in advances in neural reinforcement for directed self-organization during development. information processing systems pp. morgan kaufmann. montague p. r. dayan p. person c. sejnowski t. j. bee foraging in uncertain references environments using predictive hebbian learning. nature montague p. r. dayan p. sejnowski t. j. a framework for mesencephalic dopamine systems based on predictive hebbian learning. the journal of neuroscience montague p. r. dolan r. j. friston k. j. dayan p. computational psychiatry. trends in cognitive sciences montague p. r. sejnowski t. j. the predictive brain temporal coincidence and temporal order in synaptic learningmechanisms. learning memory moore a. w. efficient memory-based learning for robot control. ph.d. thesis university of cambridge. moore a. w. atkeson c. g. prioritized sweeping reinforcement learning with less data and less real time. machine learning moore a. w. schneider j. deng k. efficient locally weighted polynomial regression predictions. in proceedings of the international conference on machine learning morgan kaufmann. moore j. w. blazis d. e. j. simulation of a classically conditioned response a in j. h. byrne and w. o. cerebellar implementation of the sutton-barto-desmond model. berry neural models of plasticity pp. academic press san diego ca. moore j. w. choi j.-s. brunzell d. h. predictive timing under temporal uncertainty in d. a. rosenbaum and c. e. the time derivative model of the conditioned response. collyer timing of behavior pp. mit press cambridge ma. moore j. w. desmond j. e. berthier n. e. blazis e. j. sutton r. s. barto a. g. simulation of the classically conditioned nictitating membrane response by a neuronlike adaptive element i. response topography neuronal firing and interstimulus intervals. behavioural brain research moore j. w. marks j. s. castagna v. e. polewan r. j. parameter stability in the td model of complex cr topographies. in society for neuroscience abstracts moore j. w. schmajuk n. a. kamin blocking. scholarpedia moore j. w. stickney k. j. formation of attentional-associative networks in real timerole of the hippocampus and implications for conditioning. physiological psychology mukundan j. mart nez j. f. morse multi-objective reconfigurable self-optimizing memory scheduler. in ieee international symposium on high performance computer architecture pp. m uller m. computer go. artificial intelligence munos r. stepleton t. harutyunyan a. bellemare m. safe and efficient off-policy reinforcement learning. in advances in neural information processing systems pp. curran associates inc. naddaf y. game-independent ai agents for playing atari console games. ph.d. thesis university of alberta edmonton. narendra k. s. thathachar m. a. l. learning automata a survey. ieee transac tions on systems man and cybernetics narendra k. s. thathachar m. a. l. learning automata an introduction. prentice hall englewood cliffs nj. narendra k. s. wheeler r. m. an n-player sequential stochastic game with identical payoffs. ieee transactions on systems man and cybernetics narendra k. s. wheeler r. m. decentralized learning in finite markov chains. ieee references transactions on automatic control nedi c a. bertsekas d. p. least squares policy evaluation algorithms with linear function approximation. discrete event dynamic systems shaping and policy search in reinforcement learning. ng a. y. ph.d. thesis university of california berkeley. ng a. y. harada d. russell s. policy invariance under reward transformations theory and application to reward shaping. in i. bratko and s. dzeroski proceedings of the international conference on machine learning pp. ng a. y. russell s. j. algorithms for inverse reinforcement learning. in proceedings of the international conference on machine learning pp. niv y. reinforcement learning in the brain. journal of mathematical psychology niv y. daw n. d. dayan p. how fast to work response vigor motivation and in advances in neural information processing systems tonic dopamine. pp. mit press cambridge ma. niv y. daw n. d. joel d. dayan p. tonic dopamine opportunity costs and the control of response vigor. psychopharmacology niv y. joel d. dayan p. a normative perspective on motivation. trends in cognitive sciences nouri a. littman m. l. multi-resolution exploration in continuous spaces. in advances in neural information processing systems pp. curran associates inc. now e a. vrancx p. hauwere y.-m. d. game theory and multi-agent reinforcement learning. in m. wiering and m. van otterlo reinforcement learning state-of-theart pp. springer-verlag berlin heidelberg. nutt d. j. lingford-hughes a. erritzoe d. stokes p. r. a. the dopamine theory of addiction years of highs and lows. nature reviews neuroscience o doherty j. p. dayan p. friston k. critchley h. dolan r. j. temporal difference models and reward-related learning in the human brain. neuron o doherty j. p. dayan p. schultz j. deichmann r. friston k. dolan r. j. science dissociable roles of ventral and dorsal striatum in instrumental conditioning. olafsd ottir h. f. barry c. saleem a. b. hassabis d. spiers h. j. hippocampal place cells construct reward related sequences through unexplored space. elife oh j. guo x. lee h. lewis r. l. singh s. action-conditional video prediction using deep networks in atari games. in advances in neural information processing systems pp. curran associates inc. olds j. milner p. positive reinforcement produced by electrical stimulation of the septal area and other regions of rat brain. journal of comparative and physiological psychology o reilly r. c. frank m. j. making working memory work a computational model of learning in the prefrontal cortex and basal ganglia. neural computation o reilly r. c. frank m. j. hazy t. e. watz b. pvlv the primary value and learned value pavlovian learning algorithm. behavioral neuroscience omohundro s. m. efficient algorithms with neural network behavior. technical report department of computer science university of illinois at urbana-champaign. ormoneit d. sen s. kernel-based reinforcement learning. machine learning references oudeyer p.-y. kaplan f. what is intrinsic motivation? a typology of computational approaches. frontiers in neurorobotics oudeyer p.-y. kaplan f. hafner v. v. intrinsic motivation systems for autonomous mental development. ieee transactions on evolutionary computation padoa-schioppa c. assad j. a. neurons in the orbitofrontal cortex encode economic value. nature page c. v. heuristics for signature table analysis as a pattern recognition technique. ieee transactions on systems man and cybernetics pagnoni g. zink c. f. montague p. r. berns g. s. activity in human ventral striatum locked to errors of reward prediction. nature neuroscience pan w.-x. schmidt r. wickens j. r. hyland b. i. dopamine cells respond to predicted events during classical conditioning evidence for eligibility traces in the rewardlearning network. the journal of neuroscience park j. kim j. kang d. an rls-based natural actor critic algorithm for locomotion of a two-linked robot arm. computational intelligence and parks p. c. militzer j. improved allocation of weights for associative memory storage in learning control systems. in ifac design methods of control systems zurich switzerland pp. parr r. hierarchical control and learning for markov decision processes. ph.d. thesis university of california berkeley. parr r. russell s. approximating optimal policies for partially observable stochastic in proceedings of the fourteenth international joint conference on artificial domains. intelligence pp. morgan kaufmann. pavlov p. i. conditioned reflexes. oxford university press london. pawlak v. kerr j. n. d. dopamine receptor activation is required for corticostriatal spike-timing-dependent plasticity. the journal of neuroscience pawlak v. wickens j. r. kirkwood a. kerr j. n. d. timing is not everything neuromodulation opens the stdp gate. frontiers in synaptic neuroscience pearce j. m. hall g. a model for pavlovian learning variation in the effectiveness of conditioning but not unconditioned stimuli. psychological review pearl j. heuristics intelligent search strategies for computer problem solving. addison-wesley reading ma. pearl j. causal diagrams for empirical research. biometrika pecevski d. maass w. legenstein r. a. theoretical analysis of learning with rewardmodulated spike-timing-dependent plasticity. in advances in neural information processing systems pp. curran associates inc. peng j. efficient dynamic programming-based learning for control. ph.d. thesis northeastern university boston ma. peng j. efficient memory-based dynamic programming. in proceedings of the international conference on machine learning pp. peng j. williams r. j. efficient learning and planning within the dyna framework. adaptive behavior peng j. williams r. j. in proceedings of the international conference on machine learning pp. morgan kaufmann san francisco. incremental multi-step q-learning. references peng j. williams r. j. incremental multi-step q-learning. machine learning perkins t. j. pendrith m. d. on the existence of fixed points for q-learning and sarsa in partially observable domains. in proceedings of the international conference on machine learning pp. perkins t. j. precup d. a convergent form of approximate policy iteration. in advances in neural information processing systems pp. mit press cambridge ma. peters j. b uchel c. neural representations of subjective reward value. behavioral brain research peters j. schaal s. natural actor critic. neurocomputing peters j. vijayakumar s. schaal s. natural actor critic. in european conference on machine learning pp. springer berlin heidelberg. pezzulo g. van der meer m. a. a. lansink c. s. pennartz c. m. a. internally generated sequences in learning and executing goal-directed behavior. trends in cognitive science pfeiffer b. e. foster d. j. hippocampal place-cell sequences depict future paths to remembered goals. nature phansalkar v. v. thathachar m. a. l. local and global optimization algorithms for generalized learning automata. neural computation poggio t. girosi f. a theory of networks for approximation and learning. a.i. memo artificial intelligence laboratory massachusetts institute of technology cambridge ma. poggio t. girosi f. regularization algorithms for learning that are equivalent to multilayer networks. science polyak b. t. new stochastic approximation type procedures. automat. i telemekh russian. polyak b. t. juditsky a. b. acceleration of stochastic approximation by averaging. siam journal on control and optimization powell m. j. d. radial basis functions for multivariate interpolation a review. in j. c. mason and m. g. cox algorithms for approximation pp. clarendon press oxford. powell w. b. approximate dynamic programming solving the curses of dimension ality second edition. john wiley and sons. powers w. t. behavior the control of perception. aldine de gruyter chicago. expanded edition precup d. temporal abstraction in reinforcement learning. ph.d. thesis university of massachusetts amherst. precup d. sutton r. s. dasgupta s. off-policy temporal-difference learning with function approximation. in proceedings of the international conference on machine learning pp. precup d. sutton r. s. paduraru c. koop a. singh s. off-policy learning with options and recognizers. in advances in neural information processing systems pp. mit press cambridge ma. precup d. sutton r. s. singh s. eligibility traces for off-policy policy evaluation. in proceedings of the international conference on machine learning pp. morgan kaufmann. references puterman m. l. markov decision problems. wiley new york. puterman m. l. shin m. c. modified policy iteration algorithms for discounted markov decision problems. management science quartz s. dayan p. montague p. r. sejnowski t. j. expectation learning in the brain using diffuse ascending connections. in society for neuroscience abstracts randl v j. alstr m p. learning to drive a bicycle using reinforcement learning and shaping. in proceedings of the international conference on machine learning pp. rangel a. camerer c. montague p. r. a framework for studying the neurobiology of value-based decision making. nature reviews neuroscience rangel a. hare t. neural computations associated with goal-directed choice. current opinion in neurobiology rao r. p. sejnowski t. j. spike-timing-dependent hebbian plasticity as temporal difference learning. neural computation ratcliff r. connectionist models of recognition memory constraints imposed by learning and forgetting functions. psychological review reddy g. celani a. sejnowski t. j. vergassola m. learning to soar in turbulent environments. proceedings of the national academy of sciences redish d. a. addiction as a computational process gone awry. science reetz d. approximate solutions of a discounted markovian decision process. bonner mathematische schriften rescorla r. a. wagner a. r. a theory of pavlovian conditioning variations in the in a. h. black and w. f. prokasy effectiveness of reinforcement and nonreinforcement. classical conditioning ii pp. appleton-century-crofts new york. revusky s. garcia j. learned associations over long delays. in g. bower the psychology of learning and motivation v. pp. academic press inc. new york. reynolds j. n. j. wickens j. r. dopamine-dependent plasticity of corticostriatal synapses. neural networks ring m. b. preparation. representing knowledge as forecasts state as knowledge. ripley b. d. pattern recognition and neural networks. cambridge university press. rixner s. memory controller optimizations for web servers. in proceedings of the annual ieeeacm international symposium on microarchitecture p. ieee computer society. robbins h. some aspects of the sequential design of experiments. bulletin of the american mathematical society robertie b. carbon versus silicon matching wits with td-gammon. inside backgam mon romo r. schultz w. dopamine neurons of the monkey midbrain contingencies of responses to active touch during self-initiated arm movements. journal of neurophysiology rosenblatt f. principles of neurodynamics perceptrons and the theory of brain mechanisms. spartan books washington dc. ross s. introduction to stochastic dynamic programming. academic press new york. ross t. machines that think. scientific american rubinstein r. y. simulation and the monte carlo method. wiley new york. rumelhart d. e. hinton g. e. williams r. j. learning internal representations references by error propagation. in d. e. rumelhart and j. l. mcclelland parallel distributed processing explorations in the microstructure of cognition vol. i foundations. bradfordmit press cambridge ma. rummery g. a. problem solving with reinforcement learning. ph.d. thesis university of cambridge. rummery g. a. niranjan m. on-line q-learning using connectionist systems. technical report cuedf-infengtr engineering department cambridge university. ruppert d. efficient estimations from a slowly convergent robbins-monro process. cornell university operations research and industrial engineering technical report no. russell s. norvig p. artificial intelligence a modern approach edition. prentice hall englewood cliffs nj. rust j. numerical dynamic programming in economics. in h. amman d. kendrick and j. rust handbook of computational economics pp. elsevier amsterdam. saddoris m. p. cacciapaglia f. wightmman r. m. carelli r. m. differential dopamine release dynamics in the nucleus accumbens core and shell reveal complementary signals for error prediction and incentive motivation. the journal of neuroscience saksida l. m. raymond s. m. touretzky d. s. shaping robot behavior using principles from instrumental conditioning. robotics and autonomous systems samuel a. l. some studies in machine learning using the game of checkers. ibm journal on research and development reprinted in e. a. feigenbaum and j. feldman computers and thought pp. mcgraw-hill new york samuel a. l. some studies in machine learning using the game of checkers. ii recent progress. ibm journal on research and development schaal s. atkeson c. g. robot juggling implementation of memory-based learning. ieee control systems schmajuk n. a. computational models of classical conditioning. scholarpedia schmidhuber j. curious model-building control systems. in proceedings of the ieee international joint conference on neural networks pp. ieee. schmidhuber j. a possibility for implementing curiosity and boredom in modelin from animals to animats proceedings of the first mit press building neural controllers. ternational conference on simulation of adaptive behavior pp. cambridge ma. schmidhuber j. deep learning in neural networks an overview. neural networks schmidhuber j. storck j. hochreiter s. reinforcement driven information acquisition in nondeterministic environments. technical report fakult at f ur informatik technische universit at m unchen m unchen germany. schraudolph n. n. local gain adaptation in stochastic gradient descent. in proceedings of the international conference on artificial neural networks pp. ieee london. schraudolph n. n. fast curvature matrix-vector products for second-order gradient descent. neural computation schraudolph n. n. yu j. aberdeen d. fast online policy gradient learning with smd gain vector adaptation. in advances in neural information processing systems pp. references schultz d. g. melsa j. l. state functions and linear control systems. mcgraw-hill new york. schultz w. predictive reward signal of dopamine neurons. journal of neurophysiology schultz w. apicella p. ljungberg t. responses of monkey dopamine neurons to reward and conditioned stimuli during successive steps of learning a delayed response task. the journal of neuroscience schultz w. dayan p. montague p. r. a neural substrate of prediction and reward. science schultz w. romo r. dopamine neurons of the monkey midbrain contingencies of responses to stimuli eliciting immediate behavioral reactions. journal of neurophysiology schultz w. romo r. ljungberg t. mirenowicz j. hollerman j. r. dickinson a. reward-related signals carried by dopamine neurons. in j. c. houk j. l. davis and d. g. beiser models of information processing in the basal ganglia pp. mit press cambridge ma. schwartz a. a reinforcement learning method for maximizing undiscounted rewards. in proceedings of the international conference on machine learning pp. morgan kaufmann. schweitzer p. j. seidmann a. generalized polynomial approximations in markovian decision processes. journal of mathematical analysis and applications selfridge o. g. tracking and trailing adaptation in movement strategies. technical report bolt beranek and newman inc. unpublished report. selfridge o. g. some themes and primitives in ill-defined systems. in o. g. selfridge e. l. rissland and m. a. arbib adaptive control of ill-defined systems pp. plenum press ny. proceedings of the nato advanced research institute on adaptive control of ill-defined systems nato conference series ii systems science vol. selfridge o. j. sutton r. s. barto a. g. training and tracking in robotics. in a. joshi proceedings of the ninth international joint conference on artificial intelligence pp. morgan kaufmann. seo h. barraclough d. lee d. dynamic signals related to choices and outcomes in the dorsolateral prefrontal cortex. cerebral cortex seung h. s. learning in spiking neural networks by reinforcement of stochastic synaptic transmission. neuron shah a. psychological and neuroscientific connections with reinforcement learning. in m. wiering and m. van otterlo reinforcement learning state-of-the-art pp. springer-verlag berlin heidelberg. shannon c. e. programming a computer for playing chess. philosophical magazine and journal of science shannon c. e. presentation of a maze-solving machine. in h. v. forester cyber netics. transactions of the eighth conference pp. josiah macy jr. foundation. shannon c. e. theseus maze-solving mouse. shelton c. r. importance sampling for reinforcement learning with multiple objec tives. ph.d. thesis massachusetts institute of technology cambridge ma. shepard d. a two-dimensional interpolation function for irregularly-spaced data. in references proceedings of the acm national conference pp. acm new york. sherman j. morrison w. j. adjustment of an inverse matrix corresponding to changes in the elements of a given column or a given row of the original matrix annals of mathematical statistics shewchuk j. dean t. towards learning time-varying functions with high input in proceedings of the fifth ieee international symposium on intelligent dimensionality. control pp. ieee computer society press los alamitos ca. shimansky y. p. biologically plausible learning in neural networks a lesson from bacterial chemotaxis. biological cybernetics si j. barto a. powell w. wunsch d. handbook of learning and approximate dynamic programming. john wiley and sons. silver d. reinforcement learning and simulation based search in the game of go. ph.d. thesis university of alberta edmonton. silver d. huang a. maddison c. j. guez a. sifre l. van den driessche g. schrittwieser j. antonoglou i. panneershelvam v. lanctot m. dieleman s. grewe d. nham j. kalchbrenner n. sutskever i. lillicrap t. leach m. kavukcuoglu k. graepel t. hassabis d. mastering the game of go with deep neural networks and tree search. nature silver d. lever g. heess n. degris t. wierstra d. riedmiller m. deterministic policy gradient algorithms. in proceedings of the international conference on machine learning pp. silver d. schrittwieser j. simonyan k. antonoglou i. huang a. guez a. hubert t. baker l. lai m. bolton a. chen y. lillicrap l. hui f. sifre l. van den driessche g. graepel t. hassibis d. mastering the game of go without human knowledge. nature silver d. hubert t. schrittwieser j. antonoglou i. lai m. guez a. lanctot m. sifre l. kumaran d. graepel t. lillicrap t. simoyan k. hassibis d. mastering chess and shogi by self-play with a general reinforcement learning algorithm. s im sek o. alg orta s. kothiyal a. why most decisions are easy in tetris and perhaps in other sequential decision problems as well. in proceedings of the international conference on machine learning pp. simon h. lecture at the earthware symposium carnegie mellon university. httpswww.youtube.comwatch?vezhyi singh s. p. reinforcement learning with a hierarchy of abstract models. in proceedings of the tenth national conference on artificial intelligence pp. aaaimit press menlo park ca. singh s. p. scaling reinforcement learning algorithms by learning variable temporal resolution models. in proceedings of the international workshop on machine learning pp. morgan kaufmann. singh s. p. learning to solve markovian decision processes. ph.d. thesis university of massachusetts amherst. singh s. p. special double issue on reinforcement learning machine learning singh s. barto a. g. chentanez n. intrinsically motivated reinforcement learning. in advances in neural information processing systems pp. mit press cambridge ma. singh s. p. bertsekas d. reinforcement learning for dynamic channel allocation in references cellular telephone systems. in advances in neural information processing systems pp. mit press cambridge ma. singh s. p. jaakkola t. jordan m. i. learning without state-estimation in parin proceedings of the international tially observable markovian decision problems. conference on machine learning pp. morgan kaufmann. singh s. jaakkola t. littman m. l. szepesvri c. convergence results for single-step on-policy reinforcement-learning algorithms. machine learning singh s. p. jaakkola t. jordan m. i. reinforcement learning with soft state aggregation. in advances in neural information processing systems pp. mit press cambridge ma. singh s. lewis r. l. barto a. g. where do rewards come from? in n. taatgen and h. van rijn proceedings of the annual conference of the cognitive science society pp. cognitive science society. singh s. lewis r. l. barto a. g. sorg j. intrinsically motivated reinforcement learning an evolutionary perspective. ieee transactions on autonomous mental development special issue on active learning and intrinsically motivated exploration in robots advances and challenges. singh s. p. sutton r. s. reinforcement learning with replacing eligibility traces. machine learning skinner b. f. the behavior of organisms an experimental analysis. appleton century new york. skinner b. f. reinforcement today. american psychologist skinner b. f. operant behavior. american psychologist sofge d. a. white d. a. applied learning optimal control for manufacturing. in d. a. white and d. a. sofge handbook of intelligent control neural fuzzy and adaptive approaches pp. van nostrand reinhold new york. sorg j. d. the optimal reward problemdesigning effective reward for bounded agents. ph.d. thesis university of michigan ann arbor. sorg j. lewis r. l. singh s. p. reward design via online gradient ascent. in advances in neural information processing systems pp. curran associates inc. sorg j. singh s. lewis r. internal rewards mitigate agent boundedness. in proceedings of the international conference on machine learning pp. spence k. w. the role of secondary reinforcement in delayed reward learning. psy chological review srivastava n. hinton g. krizhevsky a. sutskever i. salakhutdinov r. dropout a simple way to prevent neural networks from overfitting. journal of machine learning research staddon j. e. r. adaptive behavior and learning. cambridge university press. stanfill c. waltz d. toward memory-based reasoning. communications of the acm steinberg e. e. keiflin r. boivin j. r. witten i. b. deisseroth k. janak p. h. a causal link between prediction errors dopamine neurons and learning. nature neuroscience sterling p. laughlin s. principles of neural design. mit press cambridge ma. sugiyama m. hachiya h. morimura t. statistical reinforcement learning modern machine learning approaches. chapman hallcrc. references suri r. e. bargas j. arbib m. a. modeling functions of striatal dopamine modulation in learning and planning. neuroscience suri r. e. schultz w. learning of sequential movements by neural network model with dopamine-like reinforcement signal. experimental brain research suri r. e. schultz w. a neural network model with dopamine-like reinforcement signal that learns a spatial delayed response task. neuroscience sutton r. s. unpublished report. learning theory support for a single channel theory of the brain. sutton r. s. single channel theory a neuronal theory of learning. brain theory newsletter center for systems neuroscience university of massachusetts amherst ma. sutton r. s. a unified theory of expectation in classical and instrumental conditioning. bachelors thesis stanford university. sutton r. s. temporal credit assignment in reinforcement learning. ph.d. thesis university of massachusetts amherst. sutton r. s. learning to predict by the method of temporal differences. machine learning erratum p. sutton r. s. integrated architectures for learning planning and reacting based on approximating dynamic programming. in proceedings of the international workshop on machine learning pp. morgan kaufmann. sutton r. s. dyna an integrated architecture for learning planning and reacting. sigart bulletin acm new york. sutton r. s. planning by incremental dynamic programming. in proceedings of the international workshop on machine learning pp. morgan kaufmann. sutton r. s. reinforcement learning. kluwer academic press. reprinting of a special double issue on reinforcement learning machine learning sutton r.s. adapting bias by gradient descent an incremental version of delta-bardelta. proceedings of the tenth national conference on artificial intelligence pp. mit press. sutton r.s. gain adaptation beats least squares? proceedings of the seventh yale workshop on adaptive and learning systems pp. yale university new haven ct. sutton r. s. td models modeling the world at a mixture of time scales. in proceedings of the international conference on machine learning pp. morgan kaufmann. sutton r. s. on the virtues of linear learning and trajectory distributions. in proceedings of the workshop on value function approximation at the international conference on machine learning sutton r. s. generalization in reinforcement learning successful examples using in advances in neural information processing systems sparse coarse coding. pp. mit press cambridge ma. sutton r. s. the grand challenge of predictive empirical abstract knowledge. working notes of the workshop on grand challenges for reasoning from experiences. sutton r. s. introduction to reinforcement learning with function approximation. tutorial at the conference on neural information processing systems montreal december sutton r. s. true online emphatic td quick reference and implementation guide. references code is available in python and c by downloading the source files of this arxiv paper as a zip archive. sutton r. s. barto a. g. toward a modern theory of adaptive networks expectation and prediction. psychological review sutton r. s. barto a. g. an adaptive network that constructs and uses an internal model of its world. cognition and brain theory sutton r. s. barto a. g. a temporal-difference model of classical conditioning. in proceedings of the ninth annual conference of the cognitive science society pp. erlbaum hillsdale nj. sutton r. s. barto a. g. time-derivative models of pavlovian reinforcement. in m. gabriel and j. moore learning and computational neuroscience foundations of adaptive networks pp. mit press cambridge ma. sutton r. s. maei h. r. precup d. bhatnagar s. silver d. szepesv ari cs. wiewiora e. fast gradient-descent methods for temporal-difference learning with linear function approximation. in proceedings of the international conference on machine learning pp. acm new york. sutton r. s. szepesv ari cs. maei h. r. a convergent temporal-difference algorithm for off-policy learning with linear function approximation. in advances in neural information processing systems pp. curran associates inc. sutton r. s. mahmood a. r. precup d. van hasselt h. a new q with interim forward view and monte carlo equivalence. in proceedings of the international conference on machine learning jmlr wcp sutton r. s. mahmood a. r. white m. an emphatic approach to the problem of off-policy temporal-difference learning. journal of machine learning research sutton r. s. mcallester d. a. singh s. p. mansour y. policy gradient methods for reinforcement learning with function approximation. in advances in neural information processing systems pp. mit press cambridge ma. sutton r. s. modayil j. delp m. degris t. pilarski p. m. white a. precup d. horde a scalable real-time architecture for learning knowledge from unsupervised sensorimotor interaction. in proceedings of the tenth international conference on autonomous agents and multiagent systems pp. taipei taiwan. sutton r. s. pinette b. the learning of world models by connectionist networks. in proceedings of the seventh annual conference of the cognitive science society pp. sutton r. s. precup d. singh s. between mdps and semi-mdps a framework for temporal abstraction in reinforcement learning. artificial intelligence sutton r. s. singh s. p. mcallester d. a. comparing policy-gradient algorithms. unpublished manuscript. sutton r. s. szepesv ari cs. geramifard a. bowling m. dyna-style planning in proceedings of the with linear function approximation and prioritized sweeping. conference on uncertainty in artificial intelligence pp. szepesv ari cs. algorithms for reinforcement learning. in synthesis lectures on artifi cial intelligence and machine learning morgan and claypool. szita i. reinforcement learning in games. in m. wiering and m. van otterlo reinforcement learning state-of-the-art pp. springer-verlag berlin heidelberg. tadepalli p. ok d. h-learning a reinforcement learning method to optimize undiscounted average reward. technical report oregon state university computer science department corvallis. references tadepalli p. ok d. scaling up average reward reinforcement learning by approximating the domain models and the value function. in proceedings of the international conference on machine learning pp. takahashi y. schoenbaum g. and niv y. silencing the critics understanding the effects of cocaine sensitization on dorsolateral and ventral striatum in the context of an actorcritic model. frontiers in neuroscience tambe m. newell a. rosenbloom p. s. the problem of expensive chunks and its solution by restricting expressiveness. machine learning tan m. learning a cost-sensitive internal representation for reinforcement learning. in l. a. birnbaum and g. c. collins proceedings of the international workshop on machine learning pp. morgan kaufmann. taylor g. parr r. kernelized value function approximation for reinforcement learning. in proceedings of the international conference on machine learning pp. acm new york. taylor m. e. stone p. transfer learning for reinforcement learning domains a survey. journal of machine learning research tesauro g. simple neural models of classical conditioning. biological cybernetics tesauro g. practical issues in temporal difference learning. machine learning tesauro g. td-gammon a self-teaching backgammon program achieves master-level play. neural computation tesauro g. temporal difference learning and td-gammon. communications of the acm tesauro g. programming backgammon using self-teaching neural nets. artificial intelligence tesauro g. galperin g. r. on-line policy improvement using monte-carlo search. in advances in neural information processing systems pp. mit press cambridge ma. tesauro g. gondek d. c. lechner j. fan j. prager j. m. simulation learning ibm journal of research and and optimization techniques in watson s game strategies. development tesauro g. gondek d. c. lenchner j. fan j. prager j. m. analysis of watson s strategies for playing jeopardy! journal of artificial intelligence research tham c. k. modular on-line function approximation for scaling up reinforcement learning. ph.d. thesis university of cambridge. thathachar m. a. l. sastry p. s. a new approach to the design of reinforcement ieee transactions on systems man and cybernetics schemes for learning automata. thathachar m. sastry p. s. varieties of learning automata an overview. ieee transactions on systems man and cybernetics part b cybernetics thathachar m. sastry p. s. networks of learning automata techniques for online stochastic optimization. springer science business media. theocharous g. thomas p. s. ghavamzadeh m. personalized ad recommendation for life-time value optimization guarantees. in proceedings of the twenty-fourth international joint conference on artificial intelligence aaai press palo alto ca. thistlethwaite d. a critical review of latent learning and related experiments. psy references chological bulletin thomas p. s. bias in natural actor critic algorithms. in proceedings of the international conference on machine learning jmlr wcp pp. thomas p. s. safe reinforcement learning. ph.d. thesis university of massachusetts amherst. thomas p. s. theocharous g. ghavamzadeh m. high-confidence off-policy evalin proceedings of the twenty-ninth aaai conference on artificial intelligence uation. pp. aaai press menlo park ca. thompson w. r. on the likelihood that one unknown probability exceeds another in view of the evidence of two samples. biometrika thompson w. r. on the theory of apportionment. american journal of mathematics thon m. spectral learning of sequential systems. ph.d. thesis jacobs university bremen. thon m. jaeger h. links between multiplicity automata observable operator models and predictive state representations a unified learning framework. the journal of machine learning research thorndike e. l. animal intelligence an experimental study of the associative processes in animals. the psychological review series of monograph supplements thorndike e. l. animal intelligence. hafner darien ct. thorp e. o. beat the dealer a winning strategy for the game of twenty-one. random house new york. tian t. preparation an empirical study of sliding-step methods in temporal difference learning. m.sc thesis university of alberta edmonton. tieleman t. hinton g. lecture rmsprop. coursera neural networks for machine learning tolman e. c. purposive behavior in animals and men. century new york. tolman e. c. cognitive maps in rats and men. psychological review tsai h.-s. zhang f. adamantidis a. stuber g. d. bonci a. de lecea l. deisseroth k. phasic firing in dopaminergic neurons is sufficient for behavioral conditioning. science tsetlin m. l. automaton theory and modeling of biological systems. academic press new york. tsitsiklis j. n. asynchronous stochastic approximation and q-learning. machine learning tsitsiklis j. n. on the convergence of optimistic policy iteration. journal of machine learning research tsitsiklis j. n. van roy b. feature-based methods for large scale dynamic program ming. machine learning tsitsiklis j. n. van roy b. an analysis of temporal-difference learning with function approximation. ieee transactions on automatic control tsitsiklis j. n. van roy b. average cost temporal-difference learning. automatica turing a. m. intelligent machinery a heretical theory. the turing test verbal behavior as the hallmark of intelligence p. ungar l. h. a bioreactor benchmark for adaptive network-based process control. in references w. t. miller r. s. sutton and p. j. werbos neural networks for control pp. mit press cambridge ma. unnikrishnan k. p. venugopal k. p. alopex a correlation-based learning algorithm for feedforward and recurrent neural networks. n eural computation urbanczik r. senn w. reinforcement learning in populations of spiking neurons. nature neuroscience urbanowicz r. j. moore j. h. learning classifier systems a complete introduction review and roadmap. journal of artificial evolution and applications. valentin v. v. dickinson a. o doherty j. p. determining the neural substrates of goal-directed learning in the human brain. the journal of neuroscience in advances in neural information processing van hasselt h. double q-learning. systems pp. curran associates inc. van hasselt h. insights in reinforcement learning formal analysis and empirical evaluation of temporal-difference learning. siks dissertation series number van hasselt h. reinforcement learning in continuous state and action spaces. in m. wiering and m. van otterlo reinforcement learning state-of-the-art pp. springer-verlag berlin heidelberg. van hasselt h. sutton r. s. learning to predict independent of span. arxiv van roy b. bertsekas d. p. lee y. tsitsiklis j. n. a neuro-dynamic programming approach to retailer inventory management. in proceedings of the ieee conference on decision and control vol. pp. van seijen h. effective multi-step temporal-difference learning for non-linear function approximation. arxiv preprint van seijen h. sutton r. s. efficient planning in mdps by small backups. in proceedings of the international conference on machine learning pp. van seijen h. sutton r. s. true online td in proceedings of the international conference on machine learning pp. jmlr wcp van seijen h. mahmood a. r. pilarski p. m. machado m. c. sutton r. s. true online temporal-difference learning. journal of machine learning research van seijen h. van hasselt h. whiteson s. wiering m. a theoretical and empirical analysis of expected sarsa. in ieee symposium on adaptive dynamic programming and reinforcement learning pp. varga r. s. matrix iterative analysis. englewood cliffs nj prentice-hall. vasilaki e. fr emaux n. urbanczik r. senn w. gerstner w. spike-based reinforcement learning in continuous state and action space when policy gradient methods fail. plos computational biology viswanathan r. narendra k. s. games of stochastic automata. ieee transactions on systems man and cybernetics walter w. g. an imitation of life. scientific american walter w. g. a machine that learns. scientific american waltz m. d. fu k. s. a heuristic approach to reinforcement learning control systems. ieee transactions on automatic control watkins c. j. c. h. learning from delayed rewards. ph.d. thesis university of cambridge. watkins c. j. c. h. dayan p. q-learning. machine learning werbos p. j. advanced forecasting methods for global crisis warning and models of references intelligence. general systems yearbook werbos p. j. applications of advances in nonlinear sensitivity analysis. in r. f. drenick and f. kozin system modeling and optimization pp. springer-verlag berlin. werbos p. j. building and understanding adaptive systems a statisticalnumerical approach to factory automation and brain research. ieee transactions on systems man and cybernetics werbos p. j. generalization of back propagation with applications to a recurrent gas market model. neural networks werbos p. j. neural networks for control and system identification. in proceedings of the conference on decision and control pp. ieee control systems society. werbos p. j. approximate dynamic programming for real-time control and neural modeling. in d. a. white and d. a. sofge handbook of intelligent control neural fuzzy and adaptive approaches pp. van nostrand reinhold new york. werbos p. j. the roots of backpropagation from ordered derivatives to neural networks and political forecasting john wiley and sons. wiering m. van otterlo m. reinforcement learning state-of-the-art. springer verlag berlin heidelberg. white a. developing a predictive approach to knowledge. ph.d. thesis university of alberta edmonton. white d. j. dynamic programming. holden-day san francisco. white d. j. real applications of markov decision processes. interfaces white d. j. interfaces further real applications of markov decision processes. white d. j. a survey of applications of markov decision processes. journal of the operational research society white a. white m. investigating practical linear temporal difference learning. in proceedings of the international conference on autonomous agents and multiagent systems pp. whitehead s. d. ballard d. h. learning to perceive and act by trial and error. machine learning whitt w. approximations of dynamic programs i. mathematics of operations re search whittle p. optimization over time vol. wiley new york. whittle p. optimization over time vol. wiley new york. wickens j. k otter r. cellular models of reinforcement. in j. c. houk j. l. davis and d. g. beiser models of information processing in the basal ganglia pp. mit press cambridge ma. widrow b. gupta n. k. maitra s. punishreward learning with a critic in adaptive threshold systems. ieee transactions on systems man and cybernetics widrow b. hoff m. e. adaptive switching circuits. in wescon convention record part iv pp. institute of radio engineers new york. reprinted in j. a. anderson and e. rosenfeld neurocomputing foundations of research pp. mit press cambridge ma widrow b. smith f. w. pattern-recognizing control systems. in j. t. tou and r. h. wilcox computer and information sciences pp. spartan washington dc. references widrow b. stearns s. d. adaptive signal processing. prentice-hall englewood cliffs nj. wiener n. god and golem inc a comment on certain points where cybernetics impinges on religion. mit press cambridge ma. wiewiora e. potential-based shaping and q-value initialization are equivalent. journal of artificial intelligence research williams r. j. reinforcement learning in connectionist networks a mathematical analysis. technical report ics institute for cognitive science university of california at san diego la jolla. williams r. j. reinforcement-learning connectionist systems. technical report nu college of computer science northeastern university boston. williams r. j. on the use of backpropagation in associative reinforcement learning. in proceedings of the ieee international conference on neural networks pp. ieee san diego section and ieee tab neural network committee. williams r. j. simple statistical gradient-following algorithms for connectionist rein forcement learning. machine learning williams r. j. baird l. c. a mathematical analysis of actor critic architectures for learning optimal controls through incremental dynamic programming. in proceedings of the sixth yale workshop on adaptive and learning systems pp. center for systems science dunham laboratory yale university new haven. wilson r. c. takahashi y. k. schoenbaum g. niv y. orbitofrontal cortex as a cognitive map of task space. neuron wilson s. w. zcs a zeroth order classifier system. evolutionary computation wise r. a. dopamine learning and motivation. nature reviews neuroscience witten i. h. the apparent conflict between estimation and control a survey of the two-armed problem. journal of the franklin institute witten i. h. an adaptive optimal controller for discrete-time markov environments. information and control witten i. h. corbin m. j. human operators and automatic adaptive controllers a comparative study on a particular control task. international journal of man machine studies woodbury t. dunn c. and valasek j. autonomous soaring using reinforcement learning for trajectory generation. in aerospace sciences meeting p. woodworth r. s. experimental psychology. new york henry holt and company. xie x. seung h. s. learning in neural networks by reinforcement of irregular spiking. physical review e xu x. xie t. hu d. lu x. kernel least-squares temporal difference learning. international journal of information technology yagishita s. hayashi-takagi a. ellis-davies g. c. r. urakubo h. ishii s. kasai h. a critical time window for dopamine actions on the structural plasticity of dendritic spines. science yee r. c. saxena s. utgoff p. e. barto a. g. explaining temporal differences to create useful concepts for evaluating states. in proceedings of the eighth national conference on artificial intelligence pp. aaai press menlo park ca. yin h. h. knowlton b. j. the role of the basal ganglia in habit formation. nature references reviews neuroscience young p. recursive estimation and time-series analysis. springer-verlag berlin. yu h. convergence of least squares temporal difference methods under general condi tions. international conference on machine learning pp. yu h. least squares temporal difference methods an analysis under general conditions. siam journal on control and optimization yu h. on convergence of emphatic temporal-difference learning. in proceedings of the annual conference on learning theory jmlr wcp also yu h. weak convergence properties of constrained emphatic temporal-difference learning with constant and slowly diminishing stepsize. journal of machine learning research yu h. on convergence of some gradient-based temporal-differences algorithms for off policy learning. yu h. mahmood a. r. sutton r. s. on generalized bellman equations and temporaldifference learning. a summary appeared in proceedings of the canadian conference on artificial intelligence pp. springer. zhang m. yum t. p. comparisons of channel-assignment strategies in cellular mobile telephone systems. ieee transactions on vehicular technology zhang w. reinforcement learning for job-shop scheduling. ph.d. thesis oregon state university corvallis. technical report zhang w. dietterich t. g. a reinforcement learning approach to job-shop scheduling. in proceedings of the fourteenth international joint conference on artificial intelligence pp. morgan kaufmann. zhang w. dietterich t. g. high-performance job-shop scheduling with a time delay in advances in neural information processing systems td network. pp. mit press cambridge ma. zweben m. daun b. deale m. scheduling and rescheduling with iterative repair. in m. zweben and m. s. fox intelligent scheduling pp. morgan kaufmann. index page numbers in italics are recommended to be consulted first. page numbers in bold contain boxed algorithms. k-armed bandits absorbing state access-control queuing example action preferences in bandit problems action-value function see value function ac tion action-value methods for bandit problems actor critic one-step with eligibility traces with eligibility traces neural addiction afterstates agent environment interface alphago alphago zero alphazero andreae john applications and case studies approximate dynamic programming artificial intelligence xv artificial neural networks associative reinforcement learning associative search asynchronous dynamic programming atari video game play auxiliary tasks average reward setting averagers backgammon backpropagation backup diagram for dynamic programming for monte carlo methods for q-learning for for sarsa for expected sarsa for sarsa for td for q for tree backup for truncated td for n-step q for n-step expected sarsa for n-step sarsa for n-step td for n-step tree backup for samuel s checker player compound half backups backward view of eligibility traces baird s counterexample bandit algorithm simple bandit problems basal ganglia baseline behavior policy see off-policy learn ing bellman equation for v for q for optimal value functions v and q differential for options bellman error learnability of vector bellman operator bellman residual see bellman error bellman richard binary features bioreactor example blackjack example blocking maze example bootstrapping n-step and dynamic programming and function approximation index and monte carlo methods and stability and td learning assessment of in psychology parameter or n boxes branching factor breakfast example bucket-brigade algorithm catastrophic interference certainty-equivalence estimate chess classical conditioning blocking and higher-order conditioning delay and trace conditioning rescorla-wagner model td model classifier systems cliff walking example cmac see tile coding coarse coding cognitive maps collective reinforcement learning complex backup complex backups see compound update compound stimulus compound updatebackup conditioned stimulus unconditioned stimulus conditioned response us cr constant- mc contextual bandits continuing tasks continuous action continuous state continuous time control and prediction control theory control variates and eligibility traces credit assignment in psychology structural critic see actor critic curiosity curse of dimensionality cybernetics xv deadly triad deep learning deep reinforcement learning deep residual learning delayed reinforcement delayed reward dimensions of reinforcement learning methods direct and indirect rl discounting in pole balancing rate parameter state dependent deprecated distribution models dopamine and addiction double learning dp see dynamic programming driving-home example dyna architecture dynamic programming and artificial intelligence and function approximation and options and the deadly triad computational efficiency of eligibility traces accumulating replacing dutch contingent and non-contingent off-policy with state-dependent and emphatic-td methods off-policy environment episodes episodic tasks error reduction property evaluative feedback evolution evolutionary methods expected approximate value expected sarsa see also sarsa expected index expected update experience replay exploreexploit dilemma exploring starts feature construction final time step fourier basis function approximation gambler s example game theory gazelle calf example general value functions generalized policy iteration genetic algorithms gittins index glidingsoaring case study goal see reward signal golf example gradient gradient descent see stochastic gradient de and eligibility traces and infinite variance discounting aware incremental implementation per-decision n-step incremental implementation of averages of weighted averages instrumental conditioning see also law of effect motivation thorndike s puzzle boxes interest and emphasis inverse reinforcement learning jack s car rental example kernel-based function approximation klopf a. harry xi xv latent learning law of effect scent gradient-td methods greedy or learning automata least mean square algorithm as exploiting as shortsighted policies least-squares td linear function approximation gridworld examples cliff walking dyna blocking maze dyna maze dyna shortcut maze windy habitual and goal-directed control hedonistic neurons heuristic search as sequences of backups in samuel s checkers player in td-gammon history of reinforcement learning holland john hull clark importance sampling ratio weighted and ordinary local and global optima markov decision process markov property markov reward process maximization bias maximum-likelihood estimate mc see monte carlo methods mean squared bellman error be projected bellman error pbe return error re td error tde value error ve memory-based function approx. michie donald minsky marvin model of the environment model-based and model-free methods index in animal learning reducing variance model-based reinforcement learning on-policy distribution in neuroscience monte carlo methods first- and every-visit mc first-visit mc control first-visit mc prediction gradient method for v monte carlo es starts off-policy control off-policy prediction monte carlo tree search motivation mountain car example multi-armed bandits n-step methods q sarsa differential off-policy td tree backup truncated naughts and crosses see tic-tac-toe neural networks see artificial neural networks neurodynamic programming neuroeconomics neuroscience nonstationarity inherent notation ix xvii off-policy methods vs on-policy methods monte carlo q-learning expected sarsa n-step n-step q n-step sarsa n-step tree backup and eligibility traces emphatic-td gq gtd htd q tree backup vs uniform distribution on-policy methods actor critic approximate control prediction monte carlo n-step sarsa with eligibility traces operant conditioning see instrumental learn ing optimal control optimistic initial values optimizing memory control pain and pleasure partially observable mdps pavlov ivan pavlovian conditioning see classical conditioning control personalizing web services planning with learned models with options policy soft and policy approximation policy evaluation see also prediction iterative policy gradient methods reinforce actor critic policy gradient theorem proof episodic case proof continuing case policy improvement theorem policy iteration polynomial basis prediction see also policy evaluation and control monte carlo off-policy index td with approximation prior knowledge prioritized sweeping projected bellman error vector pseudo termination psychology q watkins s q-function see action-value function q-learning double q-planning q queuing example r-learning racetrack exercise radial basis functions random walk td results on fourier and polynomial bases real-time dynamic programming recycling robot example reinforce with baseline reinforcement learning reinforcement signal representation learning residual-gradient algorithm naive return n-step for q for action values for expected sarsa for tree backup with control variates with function approximation differential flat partial with state-dependent termination truncated reward prediction error hypothesis reward signal and reinforcement design of intrinsic sparse rod maneuvering example rollout algorithms root mean-squared error sample and expected updates sample or simulation model sample-average method samuel s checkers player sarsa vs q-learning differential one-step expected n-step n-step off-policy double n-step differential off-policy sarsa true online schultz wolfram search control secondary reinforcement selective bootstrap adaptation semi-gradient methods shannon claude shaping skinner b. f. soap bubble example soft and policies soft-max for bandits spike-timing-dependent plasticity state and observations kth-order history approach belief state latent state markov property observable operator models partially observable mdps predictive state representations index truncated n-step thorndike edward see law of effect tic-tac-toe tile coding tolman edward trace-decay parameter state dependent trajectory sampling transition probabilities tree backup n-step tree-backup trial-and-error see also instrumental conditioning true online td tsitsiklis and van roy s counterexample undiscounted continuing tasks see average re ward setting unsupervised learning value value function for a given policy v and q for an optimal policy v and q action approximate action values qs a w approximate state values vsw differential vs evolutionary methods value iteration value-function approximation watkins chris watson player werbos paul witten ian state-update function state aggregation step-size parameter automatic adaptation in dqn in psychological models selecting manually with coarse coding with fourier features with tile coding stochastic approx. convergence conditions stochastic gradient-descent in the bellman error strong and weak methods supervised learning xv sweeps see also prioritized sweeping synaptic plasticity hebbian two-factor and three factor system identification tabular solution methods target policy of update td see temporal-difference learning td error n-step differential with function approximation td true online td-gammon temporal abstraction hierarchical policy option models options planning with options temporal-difference learning history of advantages of optimality of td true online methods off-line online