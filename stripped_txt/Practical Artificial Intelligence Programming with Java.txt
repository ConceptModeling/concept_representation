practical artificial intelligence programming with java third edition mark watson copyright mark watson. all rights reserved. this work is licensed under a creative commons attribution-noncommercial-no derivative works version united states license. november contents preface introduction other jvm languages why is a pdf version of this book available free on the web? book software use of java generics and native types notes on java coding styles used in this book book summary search representation of search state space and search operators finding paths in mazes finding paths in graphs adding heuristics to breadth first search search and game playing alpha-beta search a java framework for search and game playing tic-tac-toe using the alpha-beta search algorithm chess using the alpha-beta search algorithm reasoning logic history of logic examples of different logic types powerloom overview running powerloom interactively using the powerloom apis in java programs suggestions for further study semantic web relational database model has problems dealing with rapidly chang ing data requirements rdf the universal data format extending rdf with rdf schema the sparql query language using sesame xi iii contents owl the web ontology language knowledge representation and rest material for further study expert systems production systems the drools rules language using drools in java applications example drools expert system blocks world pojo object models for blocks world example drools rules for blocks world example java code for blocks world example example drools expert system help desk system object models for an example help desk drools rules for an example help desk java code for an example help desk notes on the craft of building expert systems genetic algorithms theory finding the maximum value of a function java library for genetic algorithms neural networks hopfield neural networks java classes for hopfield neural networks testing the hopfield neural network class back propagation neural networks a java class library for back propagation adding momentum to speed up back-prop training machine learning with weka using weka s interactive gui application interactive command line use of weka embedding weka in a java application suggestions for further study statistical natural language processing tokenizing stemming and part of speech tagging text named entity extraction from text using the wordnet linguistic database tutorial on wordnet example use of the jaws wordnet library suggested project using a part of speech tagger to use the correct wordnet synonyms iv contents suggested project using wordnet synonyms to improve document clustering automatically assigning tags to text text clustering spelling correction gnu aspell library and jazzy peter norvig s spelling algorithm extending the norvig algorithm by using word pair training hidden markov models using the trained markov model to tag text hidden markov models information gathering open calais information discovery in relational databases creating a test derby database using the cia world fact book and data on us states using the jdbc meta data apis using the meta data apis to discern entity relationships down to the bare metal in-memory index and search indexing and search using embedded lucene indexing and search with nutch clients nutch server fast start setup using the nutch opensearch web apis conclusions v contents vi list of figures solution a directed graph representation is shown on the left and a twodimensional grid maze representation is shown on the right. in both representations the letter r is used to represent the current position reference point and the arrowheads indicate legal moves generated by a search operator. in the maze representation the two grid cells marked with an x indicate that a search operator cannot generate this grid location. uml class diagram for the maze search java classes using depth first search to find a path in a maze finds a non-optimal using breadth first search in a maze to find an optimal solution uml class diagram for the graph search classes using depth first search in a sample graph using breadth first search in a sample graph alpha-beta algorithm applied to part of a game of tic-tac-toe uml class diagrams for game search engine and tic-tac-toe uml class diagrams for game search engine and chess the example chess program does not contain an opening book so it plays to maximize the mobility of its pieces and maximize material advantage using a two-move lookahead. the first version of the chess program contains a few heuristics like wanting to control the center four squares. continuing the first sample game the computer is looking ahead two moves and no opening book is used. second game with a move lookahead. continuing the second game with a two and a half move lookahead. we will add more heuristics to the static evaluation method to reduce the value of moving the queen early in the game. overview of how we will use powerloom for development and de. ployment layers of data models used in implementing semantic web applications java utility classes and interface for using sesame vii list of figures using drools for developing rule-based systems and then deploying them. initial state of a blocks world problem with three blocks stacked on top of each other. the goal is to move the blocks so that block c is on top of block a. block c has been removed from block b and placed on the table. block b has been removed from block a and placed on the table. the goal is solved by placing block c on top of block a. the test function evaluated over the interval the maxi mum value of occurs at crossover operation physical structure of a neuron two views of the same two-layer neural network the view on the right shows the connection weights between the input and output layers as a two-dimensional array. sigmoid and derivative of the sigmoid functions. this plot was produced by the file src-neural-networksgraph.java. capabilities of zero one and two hidden neuron layer neural networks. the grayed areas depict one of two possible output values based on two input neuron activation values. note that this is a two-dimensional case for visualization purposes if a network had ten input neurons instead of two then these plots would have to be ten-dimensional instead of two-dimensional. example backpropagation neural network with one hidden layer. example backpropagation neural network with two hidden layers. running the weka data explorer running the weka data explorer viii list of tables runtimes by method for chess program random chromosomes and the floating point numbers that they most commonly used part of speech tags sample part of speech tags transition counts from the first tag in row to the second tag in column. we see that the transition from nnp to vb is common. normalize data in table to get probability of one tag in row transitioning to another tag in column probabilities of words having specific tags. only a few tags are shown in this table. ix list of tables x preface i wrote this book for both professional programmers and home hobbyists who already know how to program in java and who want to learn practical artificial intelligence programming and information processing techniques. i have tried to make this an enjoyable book to work through. in the style of a cook book the chapters can be studied in any order. each chapter follows the same pattern a motivation for learning a technique some theory for the technique and a java example program that you can experiment with. i have been interested in ai since reading bertram raphael s excellent book thinking computer mind inside matter in the early i have also had the good fortune to work on many interesting ai projects including the development of commercial expert system tools for the xerox lisp machines and the apple macintosh development of commercial neural network tools application of natural language and expert systems technology medical information systems application of ai technologies to nintendo and pc video games and the application of ai technologies to the financial markets. i enjoy ai programming and hopefully this enthusiasm will also infect the reader. software licenses for example programs in this book my example programs for chapters using open source libraries are released under the same licenses as the libraries drools expert system demos apache style license powerloom reasoning lgpl sesame semantic web lgpl the licenses for the rest of my example programs are in the directory licenses-forbook-code license for commercial use if you purchase a print version of this book or the for-fee pdf version from lulu.com then you can use any of my code and data used in the book examples under a non-restrictive license. this book can be purchaed at free for non-commercial and academic use if you use the free pdf version xi preface of this book you can use the code and data used in the book examples free for activities that do not generate revenue. acknowledgements i would like to thank kevin knight for writing a flexible framework for game search algorithms in common lisp knight and for giving me permission to reuse his framework rewritten in java for some of the examples in chapter i have a library full of books on ai and i would like to thank the authors of all of these books for their influence on my professional life. i frequently reference books in the text that have been especially useful to me and that i recommend to my readers. in particular i would like to thank the authors of the following two books that have had the most influence on me stuart russell and peter norvig s artificial intelligence a modern approach which i consider to be the best single reference book for ai theory john sowa s book knowledge representation is a resource that i frequently turn to for a holistic treatment of logic philosophy and knowledge representation in general book editor carol watson thanks to the following people who found typos carol watson james fysh joshua cranmer jack marsh jeremy burt jean-marc vanel xii introduction there are many fine books on artificial intelligence and good tutorials and software on the web. this book is intended for professional programmers who either already have an interest in ai or need to use specific ai technologies at work. the material is not intended as a complete reference for ai theory. instead i provide enough theoretical background to understand the example programs and to provide a launching point if you want or need to delve deeper into any of the topics covered. other jvm languages the java language and jvm platform are very widely used so that techniques that you learn can be broadly useful. there are other jvm languages like jruby clojure jython and scala that can use existing java classes. while the examples in this book are written in java you should have little trouble using my java example classes and the open source libraries with these alternative jvm languages. why is a pdf version of this book available free on the web? i have written books that have been published by the traditional publishers springerverlag mcgraw-hill j. wiley morgan kaufman hungry minds mcp and sybex. this is my first book that i have produced and published on my own and my motivation for this change is the ability to write for smaller niche markets on topics that most interest me. as an author i want to both earn a living writing and have many people read and enjoy my books. by offering for sale both a print version and a for-fee pdf version for purchase at i can earn some money for my efforts and also allow readers who can not afford to buy many books or may only be interested in a few chapters of this book to read the free pdf version that is available from my web site. introduction please note that i do not give permission to post the free pdf version of this book on other people s web sites i consider this to be commercial exploitation in violation of the creative commons license that i have chosen for this book. having my free web books only available on my web site brings viewers to my site and helps attract customers for my consulting business. i do encourage you to copy the pdf for this book onto your own computer for local reading and it is fine to email copies of the free pdf to friends. if you enjoy reading the no-cost pdf version of this book i would also appreciate it if you would purchase a print copy using the purchase link i thank you for your support. book software you can download a large zip file containing all code and test data used in this book from the url all the example code that i have written is covered by the licenses discussed in the preface. the code examples usually consist of reusable gui libraries and throwaway text-based test programs to solve a specific application problem in some cases the test code will contain a test or demonstration gui. use of java generics and native types in general i usually use java generics and the new collection classes for almost all of my java programming. that is also the case for the examples in this book except when using native types and arrays provides a real performance advantage example in the search examples. since arrays must contain reifiable types they play poorly with generics so i prefer not to mix coding styles in the same code base. there are some obvious cases where not using primitive types leads to excessive object creation and boxingunboxing. that said i expect java compilers hotspot and the jvm in general to keep getting better and this may be a non-issue in the future. notes on java coding styles used in this book notes on java coding styles used in this book many of the example programs do not strictly follow common java programming idioms this is usually done for brevity. for example when a short example is all in one java package i will save lines of code and programing listing space by not declaring class data private with public getters and setters instead i will sometimes simply use package visibility as in this example public static class problem constants for appliance types enum appliance microwave tv dvd constants for problem types enum problemtype smoking on_fire makes_noise constants for environmental data enum environmentaldescription lights_off_in_room appliance appliancetype listproblemtype problemtypes new arraylistproblemtype listenvironmentaldescription environmentaldata new arraylistenvironmentaldescription etc. please understand that i do not advocate this style of programming in large projects but one challenge in writing about software development is the requirement to make the examples short and easily read and understood. many of the examples started as large code bases for my own projects that i whittled down to a small size to show one or two specific techniques. forgoing the use of getters and setters in many of the examples is just another way to shorten the examples. authors of programming books are faced with a problem in formatting program snippets limited page width. you will frequently see what would be a single line in a java source file split over two or three lines to accommodate limited page width as seen in this example private static void createtestfactsworkingmemory workingmemory throws exception introduction book summary chapter is the introduction for this book. chapter deals with heuristic search in two domains two-dimensional grids example mazes and graphs by nodes and edges connecting nodes. chapter covers logic knowledge representation and reasoning using the powerloom system. chapter covers the semantic web. you will learn how to use rdf and rdfs data for knowledge representation and how to use the popular sesame open source semantic web system. chapter introduces you to rule-based or production systems. we will use the open source drools system to implement simple expert systems for solving blocks world problems and to simulate a help desk system. chapter gives an overview of genetic algorithms provides a java library and solves a test problem. the chapter ends with suggestions for projects you might want to try. chapter introduces hopfield and back propagation neural networks. in addition to java libraries you can use in your own projects we will use two swing-based java applications to visualize how neural networks are trained. chapter introduces you to the gpled weka project. weka is a best of breed toolkit for solving a wide range of machine learning problems. chapter covers several statistical natural language processing techniques that i often use in my own work processing text stemming and determining part of speech named entity extraction from text using the wordnet lexical database automatically assigning tags to text text clustering three different approaches to spelling correction and a short tutorial on markov models. chapter provides useful techniques for gathering and using information using the open calais web services for extracting semantic information from text information discovery in relational databases and three different approaches to indexing and searching text. search early ai research emphasized the optimization of search algorithms. this approach made a lot of sense because many ai tasks can be solved effectively by defining state spaces and using search algorithms to define and explore search trees in this state space. search programs were frequently made tractable by using heuristics to limit areas of search in these search trees. this use of heuristics converts intractable problems to solvable problems by compromising the quality of solutions this trade off of less computational complexity for less than optimal solutions has become a standard design pattern for ai programming. we will see in this chapter that we trade off memory for faster computation time and better results often by storing extra data we can make search time faster and make future searches in the same search space even more efficient. what are the limitations of search? early on search applied to problems like checkers and chess misled early researchers into underestimating the extreme difficulty of writing software that performs tasks in domains that require general world knowledge or deal with complex and changing environments. these types of problems usually require the understanding and then the implementation of domain specific knowledge. in this chapter we will use three search problem domains for studying search algorithms path finding in a maze path finding in a graph and alpha-beta search in the games tic-tac-toe and chess. representation of search state space and search operators we will use a single search tree representation in graph search and maze search examples in this chapter. search trees consist of nodes that define locations in state space and links to other nodes. for some small problems the search tree can be easily specified statically for example when performing search in game mazes we can compute and save a search tree for the entire state space of the maze. for many problems it is impossible to completely enumerate a search tree for a state space so we must define successor node search operators that for a given node produce all nodes that can be reached from the current node in one step for example in the search game of chess we can not possibly enumerate the search tree for all possible games of chess so we define a successor node search operator that given a board position by a node in the search tree calculates all possible moves for either the white or black pieces. the possible chess moves are calculated by a successor node search operator and are represented by newly calculated nodes that are linked to the previous node. note that even when it is simple to fully enumerate a search tree as in the game maze example we still might want to generate the search tree dynamically as we will do in this chapter. for calculating a search tree we use a graph. we will represent graphs as node with links between some of the nodes. for solving puzzles and for game related search we will represent positions in the search space with java objects called nodes. nodes contain arrays of references to both child and parent nodes. a search space using this node representation can be viewed as a directed graph or a tree. the node that has no parent nodes is the root node and all nodes that have no child nodes a called leaf nodes. search operators are used to move from one point in the search space to another. we deal with quantized search spaces in this chapter but search spaces can also be continuous in some applications. often search spaces are either very large or are infinite. in these cases we implicitly define a search space using some algorithm for extending the space from our reference position in the space. figure shows representations of search space as both connected nodes in a graph and as a twodimensional grid with arrows indicating possible movement from a reference point denoted by r. when we specify a search space as a two-dimensional array search operators will move the point of reference in the search space from a specific grid location to an adjoining grid location. for some applications search operators are limited to moving updownleftright and in other applications operators can additionally move the reference location diagonally. when we specify a search space using node representation search operators can move the reference point down to any child node or up to the parent node. for search spaces that are represented implicitly search operators are also responsible for determining legal child nodes if any from the reference point. note that i use different libraries for the maze and graph search examples. finding paths in mazes the example program used in this section is mazesearch.java in the directory srcsearchmaze and i assume that the reader has downloaded the entire example zip file for this book and placed the source files for the examples in a convenient place. finding paths in mazes figure a directed graph representation is shown on the left and a twodimensional grid maze representation is shown on the right. in both representations the letter r is used to represent the current position reference point and the arrowheads indicate legal moves generated by a search operator. in the maze representation the two grid cells marked with an x indicate that a search operator cannot generate this grid location. figure shows the uml class diagram for the maze search classes depth first and breadth first search. the abstract base class abstractsearchengine contains common code and data that is required by both the classes depthf irstsearch and breadthf irstsearch. the class m aze is used to record the data for a twodimensional maze including which grid locations contain walls or obstacles. the class m aze defines three static short integer values used to indicate obstacles the starting location and the ending location. the java class m aze defines the search space. this class allocates a two-dimensional array of short integers to represent the state of any grid location in the maze. whenever we need to store a pair of integers we will use an instance of the standard java class java.awt.dimension which has two integer data components width and height. whenever we need to store an x-y grid location we create a new dimension object required and store the x coordinate in dimension.width and the y coordinate in dimension.height. as in the right-hand side of figure the operator for moving through the search space from given x-y coordinates allows a transition to any adjacent grid location that is empty. the maze class also contains the x-y location for the starting location and goal location note that for these examples the class maze sets the starting location to grid coordinates left corner of the maze in the figures to follow and the goal node in right corner in the following figures. rr search figure uml class diagram for the maze search java classes the abstract class abstractsearchengine is the base class for both the depth first a stack to store moves search class depthf irstsearchengine and the breadth first a queue to store moves search class breadthf irstsearchengine. we will start by looking at the common data and behavior defined in abstractsearchengine. the class constructor has two required arguments the width and height of the maze measured in grid cells. the constructor defines an instance of the m aze class of the desired size and then calls the utility method initsearch to allocate an array searchp ath of dimension objects which will be used to record the path traversed through the maze. the abstract base class also defines other utility methods checks to see if two arguments of type dimension are the same. getp ossiblem ovesdimensionlocation returns an array of dimension objects that can be moved to from the specified location. this implements the movement operator. now we will look at the depth first search procedure. the constructor for the derived class depthf irstsearchengine calls the base class constructor and then solves the search problem by calling the method iteratesearch. we will look at this method in some detail. the arguments to iteratesearch specify the current location and the current search depth mazegetvalue shortsetvalue voidmazeabstractsearchenginegetpath dimension main test programs using finding paths in mazes private void iteratesearchdimension loc int depth the class variable issearching is used to halt search avoiding more solutions once one path to the goal is found. if false return we set the maze value to the depth for display purposes only maze.setvalueloc.width loc.height here we use the super class getp ossiblem oves method to get an array of possible neighboring squares that we could move to we then loop over the four possible moves null value in the array indicates an illegal move dimension moves getpossiblemovesloc for i if null break out of possible moves from this location record the next move in the search path array and check to see if we are done searchpathdepth movesi if goalloc system.out.printlnfound the goal at movesi.width movesi.height issearching false maxdepth depth return else if the next possible move is not the goal move we recursively call the iteratesearch method again but starting from this new location and increasing the depth counter by one iteratesearchmovesi depth if false return search figure using depth first search to find a path in a maze finds a non-optimal solution figure shows how poor a path a depth first search can find between the start and goal locations in the maze. the maze is a grid. the letter s marks the starting location in the upper left corner and the goal position is marked with a g in the lower right corner of the grid. blocked grid cells are painted light gray. the basic problem with the depth first search is that the search engine will often start searching in a bad direction but still find a path eventually even given a poor start. the advantage of a depth first search over a breadth first search is that the depth first search requires much less memory. we will see that possible moves for depth first search are stored on a stack in first out data structure and possible moves for a breadth first search are stored in a queue in first out data structure. the derived class breadthf irstsearch is similar to the depthf irstsearch procedure with one major difference from a specified search location we calculate all possible moves and make one possible trial move at a time. we use a queue data structure for storing possible moves placing possible moves on the back of the queue as they are calculated and pulling test moves from the front of the queue. the finding paths in mazes effect of a breadth first search is that it fans out uniformly from the starting node until the goal node is found. the class constructor for breadthf irstsearch calls the super class constructor to initialize the maze and then uses the auxiliary method for performing a breadth first search for the goal. we will look at the class breadthf irstsearch in some detail. breadth first search uses a queue instead of a stack first search to store possible moves. the utility class dimensionqueue implements a standard queue data structure that handles instances of the class dimension. the method is not recursive it uses a loop to add new search positions to the end of an instance of class dimensionqueue and to remove and test new locations from the front of the queue. the two-dimensional array allreadyv isited keeps us from searching the same location twice. to calculate the shortest path after the goal is found we use the predecessor array private void int width maze.getwidth int height maze.getheight boolean alreadyvisitedflag new booleanwidthheight dimension predecessor new dimensionwidthheight dimensionqueue queue new dimensionqueue for iwidth i for jheight j alreadyvisitedflagij false predecessorij null we start the search by setting the already visited flag for the starting location to true value and adding the starting location to the back of the queue alreadyvisitedflagstartloc.widthstartloc.height true queue.addtobackofqueuestartloc boolean success false this outer loop runs until either the queue is empty or the goal is found outer while false search we peek at the dimension object at the front of the queue do not remove it and get the adjacent locations to the current position in the maze dimension head queue.peekatfrontofqueue dimension connected getpossiblemoveshead we loop over each possible move if the possible move is valid not null and if we have not already visited the possible move location then we add the possible move to the back of the queue and set the predecessor array for the new location to the last square visited is the value from the front of the queue. if we find the goal break out of the loop for i if null break int w connectedi.width int h connectedi.height if false alreadyvisitedflagwh true predecessorwh head queue.addtobackofqueueconnectedi if goalloc success true break outer we are done we have processed the location at the front of the queue the variable head so remove it queue.removefromfrontofqueue now that we are out of the main loop we need to use the predecessor array to get the shortest path. note that we fill in the searchp ath array in reverse order starting with the goal location maxdepth if searchpathmaxdepth goalloc finding paths in graphs for i searchpathmaxdepth predecessorsearchpathmaxdepth widthsearchpathmaxdepth height maxdepth if startloc break back to starting node figure shows a good path solution between starting and goal nodes. starting from the initial position the breadth first search engine adds all possible moves to the back of a queue data structure. for each possible move added to this queue in one search cycle all possible moves are added to the queue for each new move recorded. visually think of possible moves added to the queue as fanning out like a wave from the starting location. the breadth first search engine stops when this wave reaches the goal location. in general i prefer breadth first search techniques to depth first search techniques when memory storage for the queue used in the search process is not an issue. in general the memory requirements for performing depth first search is much less than breadth first search. to run the two example programs from this section change directory to srcsearchmaze and type javac java mazedepthfirstsearch java mazebreadthfirstsearch note that the classes m azedepthf irstsearch and m azebreadthf irstsearch are simple java jfc applications that produced figures and the interested reader can read through the source code for the gui test programs but we will only cover the core ai code in this book. if you are interested in the gui test programs and you are not familiar with the java jfc swing classes there are several good tutorials on jfc programming at java.sun.com. finding paths in graphs in the last section we used both depth first and breadth first search techniques to find a path between a starting location and a goal location in a maze. another common search figure using breadth first search in a maze to find an optimal solution type of search space is represented by a graph. a graph is a set of nodes and links. we characterize nodes as containing the following data a name andor other data zero or more links to other nodes a position in space is optional usually for display or visualization pur poses links between nodes are often called edges. the algorithms used for finding paths in graphs are very similar to finding paths in a two-dimensional maze. the primary difference is the operators that allow us to move from one node to another. in the last section we saw that in a maze an agent can move from one grid space to another if the target space is empty. for graph search a movement operator allows movement to another node if there is a link to the target node. figure shows the uml class diagram for the graph search java classes that we will use in this section. the abstract class abstractgraphsearch class is the base class for both depthf irstsearch and breadthf irstsearch. the classes graphdepthf irstsearch and graphbreadthf irstsearch and test programs also provide a java foundation class or swing based user interface. these two test programs produced figures and finding paths in graphs figure uml class diagram for the graph search classes name intgetnodenameint index stringaddnodestring name int x int y voidgetnodenameint index stringgetnodexint index intgetnodeyint index index index intaddlinkint int voidfindpath intabstractgraphsearchfindpathint start_node int goal_node intdepthfirstsearchfindpathint start_node int goal_node intbreadthfirstsearchmainstring args voidpaintnodegraphics g string name int x int y voidpaintgraphics g voidgraphdepthfirstsearchmainstring args voidpaintnodegraphics g string name int x int y voidpaintgraphics g voidgraphdepthfirstsearchjava main test programs using search as seen in figure most of the data for the search operations nodes links etc. is defined in the abstract class abstractgraphsearch. this abstract class is customized through inheritance to use a stack for storing possible moves the array path for depth first search and a queue for breadth first search. the abstract class abstractgraphsearch allocates data required by both derived classes final public static int max protected int path new intabstractgraphsearch.max protected int num_path for nodes protected string nodenames new stringmax protected int node_x new intmax protected int node_y new intmax for links between nodes protected int new intmax protected int new intmax protected int lengths new intmax protected int numnodes protected int numlinks protected int goalnodeindex startnodeindex the abstract base class also provides several common utility methods addnodestring name int x int y adds a new node addlinkint int adds a bidirectional link between nodes indexed by and node indexes start at zero and are in the order of calling addnode. addlinkstring string adds a bidirectional link between nodes spec ified by their names getnumnodes returns the number of nodes getnumlinks returns the number of links getnodenameint index returns a node s name getnodex getnodey return the coordinates of a node getnodeindexstring name gets the index of a node given its name finding paths in graphs the abstract base class defines an abstract method f indp ath that must be overridden. we will start with the derived class depthf irstsearch looking at its implementation of findpath. the f indp ath method returns an array of node indices indicating the calculated path public int findpathint start_node int goal_node the class variable path is an array that is used for temporary storage we set the first element to the starting node index and call the utility method f indp athhelper start_node the starting node return findpathhelperpath goal_node the method findpathhelper is the interesting method in this class that actually performs the depth first search we will look at it in some detail the path array is used as a stack to keep track of which nodes are being visited during the search. the argument num path is the number of locations in the path which is also the search depth public int findpathhelperint path int num_path int goal_node first re-check to see if we have reached the goal node if we have make a new array of the current size and copy the path into it. this new array is returned as the value of the method if pathnum_path int ret new intnum_path for inum_path i reti pathi return ret we are done! we have not found the goal node so call the method connected nodes to find all nodes connected to the current node that are not already on the search path the source code for the implementation of connected nodes search int new_nodes connected_nodespath num_path if there are still connected nodes to search add the next possible node to visit to the top of the stack path in the program and recursively call the method f indp athhelper again if null for jnew_nodes.length j pathnum_path new_nodesj int test findpathhelpernew_path num_path goal_node if null if goal_node return test if we have not found the goal node return null instead of an array of node indices return null derived class breadthf irstsearch also must define abstract method f indp ath. this method is very similar to the breadth first search method used for finding a path in a maze a queue is used to store possible moves. for a maze we used a queue class that stored instances of the class dimension so for this problem the queue only needs to store integer node indices. the return value of f indp ath is an array of node indices that make up the path from the starting node to the goal. public int findpathint start_node int goal_node we start by setting up a flag array alreadyv isited to prevent visiting the same node twice and allocating a predecessors array that we will use to find the shortest path once the goal is reached data structures for depth first search finding paths in graphs boolean alreadyvisitedflag int predecessor new intnumnodes new booleannumnodes the class intqueue is a private class defined in the file breadthfirstsearch.java it implements a standard queue intqueue queue new intqueuenumnodes before the main loop we need to initialize the already visited and predecessor arrays set the visited flag for the starting node to true and add the starting node index to the back of the queue for inumnodes i alreadyvisitedflagi false predecessori alreadyvisitedflagstart_node true queue.addtobackofqueuestart_node the main loop runs until we find the goal node or the search queue is empty outer while false we will read removing the node index at the front of the queue and calculate the nodes that are connected to the current node not already on the visited list using the connected nodes method interested reader can see the implementation in the source code for this class int head queue.peekatfrontofqueue int connected connected_nodeshead if null if each node connected by a link to the current node has not already been visited set the predecessor array and add the new node index to the back of the search queue we stop if the goal is found for iconnected.length i if false predecessorconnectedi head search queue.addtobackofqueueconnectedi if goal_node break outer alreadyvisitedflaghead true queue.removefromqueue ignore return value now that the goal node has been found we can build a new array of returned node indices for the calculated path using the predecessor array int ret new intnumnodes int count retcount goal_node for inumnodes i retcount predecessorretcount count if start_node break int new intcount for icount i retcount i return in order to run both the depth first and breadth first graph search examples change directory to src-search-maze and type the following commands javac java graphdepthfirstsearch java graphbeadthfirstsearch figure shows the results of finding a route from node to node in the small test graph. like the depth first results seen in the maze search this path is not optimal. figure shows an optimal path found using a breadth first search. as we saw in the maze search example we find optimal solutions using breadth first search at the cost of extra memory required for the breadth first search. finding paths in graphs figure using depth first search in a sample graph figure using breadth first search in a sample graph search adding heuristics to breadth first search we can usually make breadth first search more efficient by ordering the search order for all branches from a given position in the search space. for example when adding new nodes from a specified reference point in the search space we might want to add nodes to the search queue first that are in the direction of the goal location in a two-dimensional search like our maze search we might want to search connected grid cells first that were closest to the goal grid space. in this case pre-sorting nodes order of closest distance to the goal added to the breadth first search queue could have a dramatic effect on search efficiency. in the next chapter we will build a simple real-time planning system around our breadth first maze search program this new program will use heuristics. the alpha-beta additions to breadth first search are seen in in the next section. search and game playing now that a computer program has won a match against the human world champion perhaps people s expectations of ai systems will be prematurely optimistic. game search techniques are not real ai but rather standard programming techniques. a better platform for doing ai research is the game of go. there are so many possible moves in the game of go that brute force look ahead is used in chess playing programs simply does not work. that said min-max type search algorithms with alpha-beta cutoff optimizations are an important programming technique and will be covered in some detail in the remainder of this chapter. we will design an abstract java class library for implementing alpha-beta enhanced min-max search and then use this framework to write programs to play tic-tac-toe and chess. alpha-beta search the first game that we will implement will be tic-tac-toe so we will use this simple game to explain how the min-max search alpha-beta cutoffs works. figure shows the possible moves generated from a tic-tac-toe position where x has made three moves and o has made two moves it is o s turn to move. this is level in figure at level o has four possible moves. how do we assign a fitness value to each of o s possible moves at level the basic min-max search algorithm provides a simple solution to this problem for each possible move by o in level make the move and store the resulting board positions. now at level it is x s turn to move. how do we assign values to each of x s possible three moves search and game playing figure alpha-beta algorithm applied to part of a game of tic-tac-toe in figure simple we continue to search by making each of x s possible moves and storing each possible board position for level we keep recursively applying this algorithm until we either reach a maximum search depth or there is a win loss or draw detected in a generated move. we assume that there is a fitness function available that rates a given board position relative to either side. note that the value of any board position for x is the negative of the value for o. to make the search more efficient we maintain values for alpha and beta for each search level. alpha and beta determine the best possibleworst possible move available at a given level. if we reach a situation like the second position in level where x has won then we can immediately determine that o s last move in level that produced this position allowing x an instant win is a low valued move for o a high valued move for x. this allows us to immediately prune the search tree by ignoring all other possible positions arising from the first o move in level this alpha-beta cutoff tree pruning procedure can save a large percentage of search time especially if we can set the search order at each level with probably best moves considered first. while tree diagrams as seen in figure quickly get complicated it is easy for a computer program to generate possible moves calculate new possible board positions and temporarily store them and recursively apply the same procedure to the next search level switching min-max sides in the board evaluation. we will see in the next section that it only requires about lines of java code to implement an abstract class framework for handling the details of performing an alpha-beta enhanced search. the additional game specific classes for tic-tac-toe require about an additional lines of code to implement chess requires an additional lines of code. xxxxxxxxxxxxxxxxxxxxxxxxxxooooooooooooooooooooooolevel to movelevel to movelevel to move search a java framework for search and game playing the general interface for the java classes that we will develop in this section was inspired by the common lisp game-playing framework written by kevin knight and described in knight the abstract class gamesearch contains the code for running a two-player game and performing an alpha-beta search. this class needs to be sub-classed to provide the eight methods public abstract boolean drawnpositionposition p public abstract boolean wonpositionposition p positionevaluationposition p boolean player boolean player public abstract void printpositionposition p public abstract position possiblemovesposition p boolean player public abstract position makemoveposition p boolean player move move public abstract boolean reachedmaxdepthposition p int depth public abstract move getmove the method drawnp osition should return a boolean true value if the given position evaluates to a draw situation. the method wonp osition should return a true value if the input position is won for the indicated player. by convention i use a boolean true value to represent the computer and a boolean false value to represent the human opponent. the method positionevaluation returns a position evaluation for a specified board position and player. note that if we call positionevaluation switching the player for the same board position then the value returned is the negative of the value calculated for the opposing player. the method possiblem oves returns an array of objects belonging to the class position. in an actual game like chess the position objects will actually belong to a chess-specific refinement of the position class for the chess program developed later in this chapter the method possiblem oves will return an array of chessp osition objects. the method makem ove will return a new position object for a specified board position side to move and move. the method reachedm axdepth returns a boolean true value if the search process has reached a satisfactory depth. for the tic-tac-toe program the method reachedm axdepth does not return true unless either side has won the game or the board is full for the chess program the method reachedm axdepth returns true if the search has reached a depth of half moves deep is not the best strategy but it has the advantage of making the example search and game playing program short and easy to understand. the method getm ove returns an object of a class derived from the class m ove t ict act oem ove or chessm ove. the gamesearch class implements the following methods to perform game search protected vector alphabetaint depth position p protected vector alphabetahelperint depth boolean player position p boolean player float alpha float beta public void playgameposition startingposition boolean humanplayfirst the method alphabeta is simple it calls the helper method alphabetahelper with initial search conditions the method alphabetahelper then calls itself recursively. the code for alphabeta is protected vector alphabetaint depth vector v alphabetahelperdepth p player position p boolean player return v it is important to understand what is in the vector returned by the methods alphabeta and alphabetahelper. the first element is a floating point position evaluation for the point of view of the player whose turn it is to move the remaining values are the best move for each side to the last search depth. as an example if i let the tic-tactoe program play first it places a marker at square index then i place my marker in the center of the board an index at this point to calculate the next computer move alphabeta is called and returns the following elements in a vector next element next element next element next element next element next element next element search next element next element here the alpha-beta enhanced min-max search looked all the way to the end of the game and these board positions represent what the search procedure calculated as the best moves for each side. note that the class t ict act oep osition from the abstract class p osition has a tostring method to print the board values to a string. the same printout of the returned vector from alphabeta for the chess program is next element next element next element next element next element next element search and game playing here the search procedure assigned the side to move computer a position evaluation score of this is an artifact of searching to a fixed depth. notice that the board representation is different for chess but because the gamesearch class manipulates objects derived from the classes p osition and m ove the gamesearch class does not need to have any knowledge of the rules for a specific game. we will discuss the format of the chess position class chessp osition in more detail when we develop the chess program. the classes move and position contain no data and methods at all. the classes move and position are used as placeholders for derived classes for specific games. the search methods in the abstract gamesearch class manipulate objects derived from the classes move and position. now that we have seen the debug printout of the contents of the vector returned from the methods alphabeta and alphabetahelper it will be easier to understand how the method alphabetahelper works. the following text shows code fragments from the alphabetahelper method interspersed with book text protected vector alphabetahelperint depth position p boolean player float alpha float beta here we notice that the method signature is the same as for alphabeta except that we pass floating point alpha and beta values. the important point in understanding min-max search is that most of the evaluation work is done while backing up the search tree that is the search proceeds to a leaf node node is a leaf if the method reachedm axdepth return a boolean true value and then a return vector for the leaf node is created by making a new vector and setting its first element to the position evaluation of the position at the leaf node and setting the second element of the return vector to the board position at the leaf node if depth vector v new float value positionevaluationp player v.addelementnew floatvalue v.addelementp return v if we have not reached the maximum search depth we are not yet at a leaf node in the search tree then we enumerate all possible moves from the current position using the method possiblem oves and recursively call alphabetahelper for each search new generated board position. in terms of figure at this point we are moving down to another search level from level to level the level in figure corresponds to depth argument in alphabetahelper vector best new vector position moves possiblemovesp player for imoves.length i vector alphabetahelperdepth movesi float value if beta ifgamesearch.debug system.out.println value value beta value best new vector best.addelementmovesi enumeration enum enum.nextelement skip previous value while object o enum.nextelement if null best.addelemento use the alpha-beta cutoff test to abort search if we found a move that proves that the previous move in the move chain was dubious if alpha break notice that when we recursively call alphabetahelper we are flipping the player argument to the opposite boolean value. after calculating the best move at this depth level we add it to the end of the return vector vector new vector floatbeta enumeration enum best.elements search and game playing while return when the recursive calls back up and the first call to alphabetahelper returns a vector to the method alphabeta all of the best moves for each side are stored in the return vector along with the evaluation of the board position for the side to move. the class gamesearch method playgame is fairly simple the following code fragment is a partial listing of playgame showing how to call alphabeta getm ove and makem ove public void playgameposition startingposition boolean humanplayfirst system.out.printlnyour move move move getmove startingposition makemovestartingposition human move printpositionstartingposition vector v startingposition program startingposition the debug printout of the vector returned from the method alphabeta seen earlier in this section was printed using the following code immediately after the call to the method alphabeta enumeration enum v.elements while system.out.println next element enum.nextelement in the next few sections we will implement a tic-tac-toe program and a chessplaying program using this java class framework. tic-tac-toe using the alpha-beta search algorithm using the java class framework of gamesearch p osition and m ove it is simple to write a basic tic-tac-toe program by writing three new derived classes figure search figure uml class diagrams for game search engine and tic-tac-toe t ict act oe from gamesearch t ict act oem ove from m ove and t ict act oep osition from p osition. i assume that the reader has the book example code installed and available for viewing. in this section i will only discuss the most interesting details of the tic-tactoe class refinements i assume that the reader can look at the source code. we will start by looking at the refinements for the position and move classes. the t ict act oem ove class is trivial adding a single integer value to record the square index for the new move public class tictactoemove extends move public int moveindex the board position indices are in the range of and can be considered to be in the following order the class t ict act oep osition is also simple movepositionmoveindex inttictactoemovetostring stringblank inthuman intprogram intboard inttictactoepositionalphabeta arraylistalphabetahelper arraylistplaygame voiddebug booleanprogram booleanhuman booleangamesearchdrawnposition booleanwonposition boolean-wincheck booleanpositionevaluation floatprintposition voidpossiblemoves positionmakemove positionreachedmaxdepth booleanmain voidmove movetictactoe search and game playing public class tictactoeposition extends position final static public int blank final static public int human final static public int program int board new public string tostring stringbuffer sb new stringbuffer for i sb.appendboardi sb.append return sb.tostring this class allocates an array of nine integers to represent the board defines constant values for blank human and computer squares and defines a tostring method to print out the board representation to a string. the t ict act oe class must define the following abstract methods from the base class gamesearch public abstract boolean drawnpositionposition p public abstract boolean wonpositionposition p public abstract float positionevaluationposition p boolean player public abstract void printpositionposition p public abstract position possiblemovesposition p boolean player boolean player public abstract position makemoveposition p public abstract boolean reachedmaxdepthposition p int depth public abstract move getmove boolean player move move the implementation of these methods uses the refined classes t ict act oem ove and t ict act oep osition. for example consider the method drawnp osition that is responsible for selecting a drawn tied position public boolean drawnpositionposition p boolean ret true tictactoeposition pos search for i if tictactoeposition.blank ret false break return ret the overridden methods from the gamesearch base class must always cast arguments of type p osition and m ove to t ict act oep osition and t ict act oem ove. note that in the method drawnp osition the argument of class p osition is cast to the class t ict act oep osition. a position is considered to be a draw if all of the squares are full. we will see that checks for a won position are always made before checks for a drawn position so that the method drawnp osition does not need to make a redundant check for a won position. the method wonp osition is also simple it uses a private helper method wincheck to test for all possible winning patterns in tic-tac-toe. the method positionevaluation uses the following board features to assign a fitness value from the point of view of either player the number of blank squares on the board if the position is won by either side if the center square is taken the method positionevaluation is simple and is a good place for the interested reader to start modifying both the tic-tac-toe and chess programs public float positionevaluationposition p boolean player int count tictactoeposition pos for i if count count count prefer the center square float base if tictactoeposition.human player base if tictactoeposition.program search and game playing base float ret if player return base count if return count return ret the only other method that we will look at here is possiblem oves the interested reader can look at the implementation of the other simple methods in the source code. the method possiblem oves is called with a current position and the side to move program or human public position possiblemovesposition p tictactoeposition pos int count for i boolean player if count if return null position ret new positioncount count for i if tictactoeposition new tictactoeposition for j pos.boardj if else retcount return ret it is very simple to generate possible moves every blank square is a legal move. method will not be as straightforward in the example chess program! search it is simple to compile and run the example tic-tac-toe program change directory to src-search-game and type javac java tictactoe when asked to enter moves enter an integer between and for a square that is currently blank has a zero value. the following shows this labeling of squares on the tic-tac-toe board chess using the alpha-beta search algorithm using the java class framework of gamesearch p osition and m ove it is reasonably easy to write a simple chess program by writing three new derived classes figure chess from gamesearch chessm ove from m ove and chessp osition from p osition. the chess program developed in this section is intended to be an easy to understand example of using alphabeta min-max search as such it ignores several details that a fully implemented chess program would implement allow the computer to play either side always plays black in this example. allow en-passant pawn captures. allow the player to take back a move after making a mistake. the reader is assumed to have read the last section on implementing the tic-tactoe game details of refining the gamesearch move and position classes are not repeated in this section. figure shows the uml class diagram for both the general purpose gamesearch framework and the classes derived to implement chess specific data and behavior. the class chessmove contains data for recording from and to square indices public class chessmove extends move public int from public int to search and game playing figure uml class diagrams for game search engine and chess movepositionfrom intto intchessmovetostring stringblank inthuman intprogram intpawn intknight intbishop introok intqueen intking intboard intchesspositionalphabeta arraylistalphabetahelper arraylistplaygame voiddebug booleanprogram booleanhuman booleangamesearchdrawnposition booleanwonposition boolean-wincheck booleanpositionevaluation floatprintposition voidpossiblemoves positionmakemove positionreachedmaxdepth booleanmain void-setcontroldata void-calcpossiblemoves int-calcpiecemoves intmove move-computercontrol float-humancontrol float-possiblemovelist move-piece_moves int-initialboard int-index int-piecemovementtable int-value intchess search figure the example chess program does not contain an opening book so it plays to maximize the mobility of its pieces and maximize material advantage using a two-move lookahead. the first version of the chess program contains a few heuristics like wanting to control the center four squares. the board is represented as an integer array with elements. a chessboard only has squares the remaining board values are set to a special value of which indicates an off board square. the initial board setup is defined statically in the chess class and the off-board squares have a value of private static int initialboard black pawns black pieces white pieces white pawns blank squares blank squares blank squares blank squares it is difficult to see from this listing of the board square values but in effect a regular chess board if padded on all sides with two rows and columns of values. search and game playing figure continuing the first sample game the computer is looking ahead two moves and no opening book is used. we see the start of a sample chess game in figure and the continuation of this same game in figure lookahead is limited to moves ply. the class chessp osition contains data for this representation and defines constant values for playing sides and piece types public class chessposition extends position final static public int blank final static public int human final static public int program final static public int pawn final static public int knight final static public int bishop final static public int rook final static public int queen final static public int king int board new public string tostring stringbuffer sb new stringbuffer for i sb.appendboardi sb.append return sb.tostring search the class chess also defines other static data. the following array is used to encode the values assigned to each piece type pawns are worth one point knights and bishops are worth points etc. private static int value the following array is used to codify the possible incremental moves for pieces private static int piecemovementtable the starting index into the piecemovementtable array is calculated by indexing the following array with the piece type index pawns are piece type knights are piece type bishops are piece type rooks are piece type etc. private static int index when we implement the method possiblem oves for the class chess we will see that except for pawn moves all other possible piece type moves are very easy to calculate using this static data. the method possiblem oves is simple because it uses a private helper method calcp iecem oves to do the real work. the method possiblem oves calculates all possible moves for a given board position and side to move by calling calcp iecem ove for each square index that references a piece for the side to move. we need to perform similar actions for calculating possible moves and squares that are controlled by each side. in the first version of the class chess that i wrote i used a single method for calculating both possible move squares and controlled squares. however the code was difficult to read so i split this initial move generating method out into three methods possiblemoves required because this was an abstract method in gamesearch. this method calls calcpiecemoves for all squares containing pieces for the side to move and collects all possible moves. search and game playing calcpiecemoves responsible to calculating pawn moves and other piece type moves for a specified square index. setcontroldata sets the global array computercontrol and humancontrol. this method is similar to a combination of possiblemoves and calcpiecemoves but takes into effect moves onto squares that belong to the same side for calculating the effect of one piece guarding another. this control data is used in the board position evaluation method positionevaluation. we will discuss calcp iecem oves here and leave it as an exercise to carefully read the similar method setcontroldata in the source code. this method places the calculated piece movement data in static storage array piece moves to avoid creating a new java object whenever this method is called method calcp iecem oves returns an integer count of the number of items placed in the static array piece moves. the method calcp iecem oves is called with a position and a square index first the piece type and side are determined for the square index private int calcpiecemoveschessposition pos int square_index int b pos.board int piece bsquare_index int piece_type piece if piece_type int piece_index indexpiece_type int move_index piecemovementtablepiece_index if side_index else side_index then a switch statement controls move generation for each type of chess piece generation code is not shown see the file chess.java switch case chessposition.pawn break case chessposition.knight case chessposition.bishop case chessposition.rook case chessposition.king case chessposition.queen break the logic for pawn moves is a little complex but the implementation is simple. we start by checking for pawn captures of pieces of the opposite color. then check for search initial pawn moves of two squares forward and finally normal pawn moves of one square forward. generated possible moves are placed in the static array piece moves and a possible move count is incremented. the move logic for knights bishops rooks queens and kings is very simple since it is all table driven. first we use the piece type as an index into the static array index this value is then used as an index into the static array piecem ovementt able. there are two loops an outer loop fetches the next piece movement delta from the piecem ovementt able array and the inner loop applies the piece movement delta set in the outer loop until the new square index is off the board or runs into a piece on the same side. note that for kings and knights the inner loop is only executed one time per iteration through the outer loop move_index piece if move_index move_index indexmove_index next_square square_index piecemovementtablemove_index outer while inner while if break inner if break inner if break inner check for piece on the same side if bnext_square break inner if bnext_square break inner piece_movescount next_square if break inner if chessposition.knight break inner if chessposition.king break inner next_square piecemovementtablemove_index move_index if break outer next_square square_index search and game playing figure second game with a move lookahead. piecemovementtablemove_index figure shows the start of a second example game. the computer was making too many trivial mistakes in the first game so here i increased the lookahead to moves. now the computer takes one to two seconds per move and plays a better game. increasing the lookahead to full moves yields a better game but then the program can take up to about ten seconds per move. the method setcontroldata is very similar to this method i leave it as an exercise to the reader to read through the source code. method setcontroldata differs in also considering moves that protect pieces of the same color calculated square control data is stored in the static arrays computercontrol and humancontrol. this square control data is used in the method positionevaluation that assigns a numerical rating to a specified chessboard position on either the computer or human side. the following aspects of a chessboard position are used for the evaluation material count count point knights and bishops points etc. count of which squares are controlled by each side extra credit for control of the center of the board credit for attacked enemy pieces notice that the evaluation is calculated initially assuming the computer s side to move. if the position if evaluated from the human player s perspective the evalua search figure continuing the second game with a two and a half move lookahead. we will add more heuristics to the static evaluation method to reduce the value of moving the queen early in the game. tion value is multiplied by minus one. the implementation of positionevaluation is public float positionevaluationposition p boolean player chessposition pos int b pos.board float ret adjust for material for i if bi ret bi adjust for positional advantages setcontroldatapos int control for i control humancontroli control computercontroli count center squares extra control control control control search and game playing control ret control credit for attacked pieces for i if bi continue if if computercontroli ret value-bi if if computercontroli ret valuebi adjust if computer side to move if ret return ret it is simple to compile and run the example chess program by changing directory to src-search-game and typing javac java chess when asked to enter moves enter string like to enter a move in chess algebraic notation. here is sample output from the program board position br bn bb bk bb bn br bp bp bp bp bp bp bp wp bp bq wp wp wp wp wp wp wp wr wn wb wq wk wb wr wn search your move class.method name chess.main gamesearch.playgame gamesearch.alphabeta gamesearch.alphabetahelper chess.positionevaluate chess.setcontroldata chess.possiblemoves chess.calcpossiblemoves chess.calcpiecemoves of total runtime in this method table runtimes by method for chess program the example chess program plays in general good moves but its play could be greatly enhanced with an opening book of common chess opening move sequences. if you run the example chess program depending on the speed of your computer and your java runtime system the program takes a while to move seconds per move on my pc. where is the time spent in the chess program? table shows the total runtime time for a method and recursively all called methods and method-only time for the most time consuming methods. methods that show zero percent method only time used less than percent of the time so they print as zero values. the interested reader is encouraged to choose a simple two-player game and using the game search class framework implement your own game-playing program. reasoning reasoning is a broad topic. in this chapter we will concentrate on the use of the powerloom descriptive logic reasoning system. powerloom is available with a java runtime and java api this is what i will use for the examples in this chapter. powerloom can also be used with jruby. powerloom is available in common lisp and c versions. additionally we will look briefly at different kinds of reasoning systems in chapter on the semantic web. while the material in this chapter will get you started with development using a powerful reasoning system and embedding this reasoning system in java applications you will likely want to dig deeper and i suggest sources for further study at the end of this chapter. powerloom is a newer version of the classic loom descriptive logic reasoning system written at isi. the required jar files for powerloom are included in the zip file for this book but at some point you will probably want to download the entire powerloom distribution to get more examples and access to documentation the powerloom web site can be found at httpwww.isi.eduisdloompowerloom. while we will look at an example of embedding the powerloom runtime and a powerloom model in a java example program i want to make a general comment on powerloom development you will spend most of your time interactively running powerloom in an interactive shell that lets you type in concepts relations rules and queries and immediately see the results. if you have ever programmed in lisp then this mode of interactive programming will be familiar to you. as seen in figure after interactive development you can deploy in a java application. this style of development supports entering facts and trying rules and relations interactively and as you get things working you can paste what works into a powerloom source file. if you have only worked with compiled langauges like java and c this development style may take a while to get used to and appreciate. as seen in figure the powerloom runtime system with relations and rules can be embedded in java applications that typically clear powerloom data memory assert facts from other live data sources and then use powerloom for inferencing. reasoning figure overview of how we will use powerloom for development and deployment logic we will look at different types of logic and reasoning systems in this section and then get into powerloom specific examples in section logic is the basis for both knowledge representation and for reasoning about knowledge. we will encode knowledge using logic and see that we can then infer new facts that are not explicitly asserted. first order logic was invented by the philosophers frege and peirce and is the most widely studied logic system. unfortunately full first order logic is not computationally tractable for most non-trivial problems so we use more restricted logics. we will use two reasoning systems in this book that support more limited logics we use powerloom is this chapter. powerloom supports a combination of limited first order predicate logic and features of description logic. powerloom is able to classify objects use rules to infer facts from existing facts and to perform subsumption class membership of instances. we will use rdf schema reasoning in chapter rdfs supports more limited reasoning than descriptive logic reasoners like powerloom and owl description logic reasoners. powerloomreasoning system runtimeconceptsrelationsrulesconcepts are likeclasses they canbe organized intohierarchiesdeveloperinteractivedevelopmentapplication programspowerloomapiweb services logic history of logic the greek philosopher aristotle studied forms of logic as part of his desire to improve the representation of knowledge. he started a study of logic and the definition of both terms subjects predicates nouns verbs and types of logical deduction. much later the philosopher frege defined predicate logic example all birds have feathers. brady is a bird therefore brady has feathers that forms the basis for the modern prolog programming language. examples of different logic types propositional logic is limited to atomic statements that can be either true or false brady-is-a-bird brady-has-feathers first order predicate logic allows access to the structure of logic statements dealing with predicates that operate on atoms. to use a prolog notation feathersx birdx. birdbrady. here feathers and bird are predicates and brady is an atom. the first example states that for all x if x is a bird then x has feathers. in the second example we state that brady is a bird. notice that in the prolog notation that we are using variables are capitalized and predicate names and literal atoms are lower case. here is a query that asks who has feathers feathersx. x brady in this example through inference we have determined a new fact that brady has feathers because we know that brady is a bird and we have the rule predicate stating that all birds have feathers. prolog is not strictly a pure logic programming language since the order in which rules are defined chnages the inference results. prolog is a great language for some types of projects have used prolog in both natural language processing and in planning projects. we will see that powerloom is considerably more flexible than prolog but does have a steep learning curve. reasoning description logic deals with descriptions of concepts and how these descriptions define the domain of concepts. in terms used in object oriented programming languages membership in a class is determined implicitly by the description of the object and not by explicitly stating something like brady is a member of the bird class. description logics divide statements into relations refered to as tbox and concepts called abox. we would say that a statement like all birds have feathers is stored in the tbox while a specific assertion like brady is a bird is stored in the abox. powerloom overview powerloom is designed to be an expressive language for knowledge representation and reasoning. as a result powerloom is not a complete reasoning system but makes tradeoffs for completeness of inferences and expressivity vs. computational efficiency. it is interesting to note that loom and powerloom were designed and implemented to solve real world problems and the tradeoffs to make these problems computationally tractable have informed the design and implementation of these systems. powerloom does not make all posible inferences from concepts that it operates on. the powerloom distribution contains two very detailed examples for representing relationships between companies and for information dealing with airplanes. these examples are more detailed than the simpler example of data from news stories used in this chapter. we will look one of these examples rules and relations and after working through this chapter i encourage you to interactively experiment with the two examples that ship with powerloom. we will start by defining some terms used in powerloom concept the java equivalent would be an instance of a class relation specifies a link between two concepts function functional mapping of one concept to another rule allows new concepts to be deduced without explicitly asserting them a relation can specify the types of concepts that a relation connects. an example will make this clear and introduce the lisp-like syntax of powerloom statements concepts person parent person running powerloom interactively relation parent-of parent person here i have defined two concepts person and parent. note that we have a hierarchy of concept types here the parent is a more specific concept type than the person concept. all instances that are parents are also of type person. the relation parentof links a parent concept to a person concept. we will learn more about basic powerloom functionality in the next two sections as we use powerloom in an interactive session and when we embed powerloom in a java example program. running powerloom interactively we will experiment with powerloom concepts relations and rules in this section in an interactive command shell. i will introduce more examples of powerloom functionality for asserting instances of concepts performing queries loading powerloom source files defining relations using separate modules and asking powerloom to explain the inference process that it used for query processing. you can run powerloom using the command line interface by changing directory to the lib subdirectory from the zip file for this book and trying java powerloom.jarstella.jar edu.isi.powerloom.powerloom this starts the powerloom standalone system and prints a prompt that includes the name of the current module. the default module name is pl-user in the first example when i enter the person concept at the interactive prompt then powerloom prints the result of the expression that just entered. pl-user person pl-user parent person pl-user parent-of parent person pl-user ken ken pl-user mark reasoning mark pl-user ken mark ken mark now that we have entered two concepts a test relation and asserted a few facts we can look at an example of powerloom s query language pl-user all there are solutions pl-user all there is solution pl-user the obvious point to note from this example is that we never specified that ken was a parent rather powerloom deduced this from the parent-of relation. powerloom s command line system prompts you with the string pl-user and you can type any definition or query. like lisp powerloom uses a prefix notation and expressions are contained in parenthesis. powerloom supports a module system for partitioning concepts relations functions and rules into different sets and as previously mentioned pl-user is the default module. powerloom modules can form a hierarchy inheriting concepts relations and rules from parent modules. the subdirectory test data contains the demo file business.plm written by robert macgregor that is supplied with the full powerloom distribution. you can load his complete example using pl-user this is a good example because it demonstrates most of the available functionality of powerloom in a short lines. when you are done reading this chapter please take a few minutes to read through this example file since i do not list it here. there are a few things to notice in this example. here we see a rule used to make the relation contains transitive contains geographic-location geographic-location running powerloom interactively transitive-contains the operator means that if the first clause is true then so is the second. in english this rule could be stated if an instance contains and if instance contains then we can infer that also contains to see how this rule works in practice we can switch to the example module business and find all locations contained inside another location pl-user business all there are solutions business here we have fifteen solutions even though there are only seven contains relations asserted in the business.plm file the other eight solutions were inferred. in addition to the retrieve function that finds solutions matching a query you can also use the ask function to determine if a specified relation is true for example business united-states dallas true business reasoning for complex queries you can use the why function to see how powerloom solved the last query business southern-us dallas true business follows by modus ponens with substitution since and and southern-us texas texas dallas business by default the explanation facility is turned off because it causes powerloom to run more slowly it was turned on in the file business.plm using the statement justifications using the powerloom apis in java programs once you interactively develop concepts rules and relations then it is likely that you may want to use them with powerloom in an embedded mode making powerloom a part of your application. i will get you started with a few java example programs. the source code for this chapter is in the subdirectory src-powerloom-reasoning. if you download the powerloom manual pdf file from the powerloom web site you will have the complete java api documentation for the java version of powerloom are also c and common lisp versions with separate documentation. i have found that i usually use just a small subset of the java powerloom apis and i have wrapped this subset in a wrapper class in the file powerloomutils.java. we will use my wrapper class for the examples in the rest of this chapter. my wrapper class has the follow public methods using the powerloom apis in java programs powerloomutils constructor initializes the java powerloom runtime sys tem. loadstring fpath load a source file. changemodulestring workingmodule set the current powerloom working module pl-user is the default module. assertpropositionstring proposition asserts a new proposition for example moms grocery note that quotation marks are escaped with a backslash character. you can also use single quote characters like moms grocery because i convert single quotes in my wrapper code. createrelationstring relation int arity create a new relation with a specified arity of arguments for example you could create a relation owns with arity and then assert elaine moms grocery i usually do not use this api since i prefer to place relations rules in a source code file ending in the extention doquerystring query returns a list of results from a query. each result in the list is itself a list. you will always want to work in an interactive powerloom console for writing and debugging powerloom models. i built the model in test.plm the subdirectory test data interactively and we will use it here in an embedded java example powerloomutils plu new powerloomutils plu.loadtest_datatest.plm plu.changemodulebusiness plu.assertproposition grocery plu.assertproposition plu.assertproposition list answers plu.doqueryall system.out.printlnanswers answers answers plu.doquery reasoning system.out.printlnanswers answers plu.createrelationceo plu.assertproposition grocery answers plu.doquery system.out.printlnanswers answers i have added the program output produced by printing the value of the list variable answers as comments after each system.out.println call. in the wrapper api calls that take a string argument i broke long strings over several lines for formatting to the width of a page you would not do this in your own programs because of the cost of the extra string concatenation. we will not look at the implementation of the p owerloomu tils class you can read the code if you are interested. that said i will make a few commments on the java powerloom apis. the class p li contains static methods for initializing the system loading powerloom source files. here are a few examples pli.initialize pli.loadtest.plm null pli.schangemodulebusiness null suggestions for further study this chapter has provided a brief introduction to powerloom one of my favorite ai tools. i also showed you how to go about embedding the powerloom knowledge representation and reasoning systems in your java programs. assuming that you see benefit to further study i recommend reading through the powerloom manual and the presentations files on the powerloom web site. as you read through this material it is best to have an interactive powerloom session open to try the examples as you read them. suggestions for further study knowledge representation and logic are huge subjects and i will close out this chapter by recommending a few books that have been the most helpful to me knowledge representation by john sowa. this has always been my favorite reference for knowledge representation logic and ontologies. artificial intelligence a modern approach by stuart russell and peter norvig. a very good theoretical treatment of logic and knowledge representation. the art of prolog by leon sterling and ehud shapiro. prolog implements a form of predicate logic that is less expressive than the descriptive logics supported by powerloom and owl that said prolog is very efficient and fairly easy to learn and so is sometimes a better choice. this book is one of my favorite general prolog references. the prolog language is a powerful ai development tool. both the open source swiprolog and the commercial amzi prolog systems have good java interfaces. i don t cover prolog in this book but there are several very good tutorials on the web if you decide to experiment with prolog. we will continue chapter with our study of logic-based reasoning systems in the context of the semantic web. reasoning semantic web the semantic web is intended to provide a massive linked set of data for use by software systems just as the world wide web provides a massive collection of linked web pages for human reading and browsing. the semantic web is like the web in that anyone can generate any content that they want. this freedom to publish anything works for the web because we use our ability to understand natural language to interpret what we read and often to dismiss material that based upon our own knowledge we consider to be incorrect. the core concept for the semantic web is data integration and use from different sources. as we will soon see the tools for implementing the semantic web are designed for encoding data and sharing data from many different sources. there are several very good semantic web toolkits for the java language and platform. i will use sesame because it is what i often use in my own work and i believe that it is a good starting technology for your first experiments with semantic web technologies. this chapter provides an incomplete coverage of semantic web technologies and is intended merely as a gentle introduction to a few useful techniques and how to implement those techniques in java. figure shows a layered set of data models that are used to implement semantic web applications. to design and implement these applications we need to think in terms of physical models and access of rdf rdfs and perhaps owl data logical models we use rdf and rdfs to define relationships between data represented as unique uris and string literals and how we logically combine data from different sources and conceptual modeling level knowledge representation using owl. i am currently writing a separate book practical semantic web programming in java that goes into much more detail on the use of sesame jena protege owlapis rdfrdfsowl modeling and descriptive logic reasoners. this chapter is meant to get you interested in this technology but is not intended as a detailed guide. semantic web figure layers of data models used in implementing semantic web applications relational database model has problems dealing with rapidly changing data requirements when people are first introduced to semantic web technologies their first reaction is often something like i can just do that with a database. the relational database model is an efficient way to express and work with slowly changing data models. there are some clever tools for dealing with data change requirements in the database world and migrations being a good example but it is awkward to have end users and even developers tagging on new data attributes to relational database tables. this same limitation also applies to object oriented programming and object modeling. even with dynamic languages that facilitate modifying classes at runtime the options for adding attributes to existing models is just too limiting. the same argument can be made against the use of xml constrained by conformance to either dtds or xml schemas. it is true that rdf and rdfs can be serialized to xml using many pre-existing xml namespaces for different knowledge sources and their schemas but it turns out that this is done in a way that does not reduce the flexibility for extending data models. xml storage is really only a serialization of rdf and many developers who are just starting to use semantic web technologies initially get confused trying to read xml serialization of rdf almost like trying to read a pdf file with a plain text editor and something to be avoided. owl extends rdfs to allow expression of richer class relationships cardinality etc.xml a syntax for tree structured documents xml schema a language for placing restrictions on xml documentsrdf modeling subject predicate and object linksrdfs vocabulary for describing properties and class membership by properties rdf the universal data format a major goal for the rest of this chapter is convincing you that modeling data with rdf and rdfs facilitates freely extending data models and also allows fairly easy integration of data from different sources using different schemas without explicitly converting data from one schema to another for reuse. rdf the universal data format the resource description framework is used to encode information and the rdf schema facilitates using data with different rdf encodings without the need to convert data formats. rdf data was originally encoded as xml and intended for automated processing. in this chapter we will use two simple to read formats called n-triples and sesame can be used to convert between all rdf formats so we might as well use formats that are easier to read and understand. rdf data consists of a set of triple values subject predicate object some of my work with semantic web technologies deals with processing news stories extracting semantic information from the text and storing it in rdf. i will use this application domain for the examples in this chapter. i deal with triples like subject a url uri of a news article predicate a relation like containsperson object a value like bill clinton as previously mentioned we will use either uris or string literals as values for subjects and objects. we will always use uris for the values of predicates. in any case uris are usually preferred to string literals because they are unique. we will see an example of this preferred use but first we need to learn the n-triple and rdf formats. in section i proposed the idea that rdf was more flexible than object modeling in programming languages relational databases and xml with schemas. if we can tag new attributes on the fly to existing data how do we prevent what i might call data chaos as we modify existing data sources? it turns out that the solution to this problem is also the solution for encoding real semantics meaning with data we usually use unique uris for rdf subjects predicates and objects and usually semantic web with a preference for not using string literals. i will try to make this idea more clear with some examples. any part of a triple predicate or object is either a uri or a string literal. uris encode namespaces. for example the containsperson predicate in the last example could properly be written as httpknowledgebooks.comontologycontainsperson the first part of this uri is considered to be the namespace for we will use as a predicate containsperson. when different rdf triples use this same predicate this is some assurance to us that all users of this predicate subscribe to the same meaning. furthermore we will see in section we can use rdfs to state equivalency between this predicate the namespace httpknowledgebooks.comontology with predicates represented by different uris used in other data sources. in an artificial intelligence sense software that we write does not understand a predicate like containsperson in the way that a human reader can by combining understood common meanings for the words contains and person but for many interesting and useful types of applications that is fine as long as the predicate is used consistently. we will see shortly that we can define abbreviation prefixes for namespaces which makes rdf and rdfs files shorter and easier to read. a statement in n-triple format consists of three uris string literals any combination followed by a period to end the statement. while statements are often written one per line in a source file they can be broken across lines it is the ending period which marks the end of a statement. the standard file extension for n-triple format files is and the standard format for format files is my preference is to use n-triple format files as output from programs that i write to save data as rdf. i often use sesame to convert n-triple files to if i will be reading them or even hand editing them. you will see why i prefer the format when we look at an example kb kbcontainscountry here we see the use of an abbreviation prefix kb for the namespace for my company knowledgebooks.com ontologies. the first term in the rdf statement subject is the uri of a news article. the second term predicate is containscountry in the kb namespace. the last item in the statement object is a string literal china. i would describe this rdf statement in english as the news article at uri mentions the country china. this was a very simple example which we will expand to show additional features of the notation. as another example suppose that this news article also rdf the universal data format mentions the usa. instead of adding a whole new statement like this kb kbcontainscountry kbcontainscountry we can combine them using notation. allows us to collapse multiple rdf statements that share the same subject and optionally the same predicate kb kbcontainscountry we can also add in additional predicates that use the same subject kb kbcontainscountry kbcontainsorganization nations kbcontainsperson ki-moon brown jintao w. bush musharraf putin ahmadinejad this single statement represents ten individual rdf triples. each section defining triples with the same subject and predicate have objects separated by commas and ending with a period. please note that whatever rdf storage system we use will be using sesame it makes no difference if we load rdf as xml n-triple of format files internally subject predicate and object triples are stored in the same way and are used in the same way. i promised you that the data in rdf data stores was easy to extend. as an example let us assume that we have written software that is able to read online news articles and create rdf data that captures some of the semantics in the articles. if we extend our program to also recognize dates when the articles are published we can simply reprocess articles and for each article add a triple to our rdf data store using a form like kbdatepublished semantic web furthermore if we do not have dates for all news articles that is often acceptable depending on the application. extending rdf with rdf schema rdfs supports the definition of classes and properties based on set inclusion. in rdfs classes and properties are orthogonal. we will not simply be using properties to define data attributes for classes this is different than object modeling and object oriented programming languages like java. rdfs is encoded as rdf the same syntax. because the semantic web is intended to be processed automatically by software systems it is encoded as rdf. there is a problem that must be solved in implementing and using the semantic web everyone who publishes semantic web data is free to create their own rdf schemas for storing data for example there is usually no single standard rdf schema definition for topics like news stories and stock market data. understanding the difficulty of integrating different data sources in different formats helps to understand the design decisions behind the semantic web. we will start with an example that is an extension of the example in the last section that also uses rdfs. we add a few additional rdf statements are rdfs kb rdfs kbcontainscity rdfssubpropertyof kbcontainsplace kbcontainscountry rdfssubpropertyof kbcontainsplace kbcontainsstate rdfssubpropertyof kbcontainsplace the last three lines declare that the property containscity is a subproperty of containsplace. the property containscountry is a subproperty of containsplace. the property containsstate is a subproperty of containsplace. why is this useful? for at least two reasons you can query an rdf data store for all triples that use property containsplace and also match triples with property equal to containscity containscountry or containsstate. there may not even be any triples that explicitly use the property containsplace. the sparql query language consider a hypothetical case where you are using two different rdf data stores that use different properties for naming cities cityname and city. you can define cityname to be a subproperty of city and then write all queries against the single property name city. this removes the necessity to convert data from different sources to use the same schema. in addition to providing a vocabulary for describing properties and class membership by properties rdfs is also used for logical inference to infer new triples combine data from different rdf data sources and to allow effective querying of rdf data stores. we will see examples of all of these features of rdfs when we start using the sesame libraries in the next section to perform sparql queries. the sparql query language sparql is a query language used to query rdf data stores. while sparql may initially look like sql we will see that there are some important differences like support for rdfs and owl inferencing section and graph-based instead of relational matching operations. we will cover the basics of sparql in this section and then see more examples in section when we learn how to embed sesame in java applications. we will use the format rdf file test for the examples in this section and in section this file was created automatically by spidering reuters news stories on the news.yahoo.com web site and automatically extracting named entities from the text of the articles. we will see techniques for extracting named entities from text in chapters and in this chapter we use these sample rdf files that i have created as input from another source. you have already seen snippets of this file in section and i list the entire file here for reference to fit line width you may find the file easier to read if you are at your computer and open the file in a text editor so you will not be limited to what fits on a book page kb rdfs kbcontainscity rdfssubpropertyof kbcontainsplace kbcontainscountry rdfssubpropertyof kbcontainsplace kbcontainsstate rdfssubpropertyof kbcontainsplace semantic web kbcontainscity paul chicago city kbcontainsregion midwest kbcontainscountry states kbcontainsstate kbcontainsorganization guard department of agriculture house board of trade of transportation kbcontainsperson gray-fisher miller hollander feltes w. bush kbcontainsindustryterm inflation ministers kbcontainscity kbcontainscountry states kbcontainsstate kbcontainsorganization house kbcontainsperson petraeus administration government mccain zebari obama w. bush fiorina kbcontainsindustryterm prices kbcontainscity kbcontainscountry states republic of iran the sparql query language kbcontainsstate kbcontainsorganization of maryland nations kbcontainsperson ki-moon brown jintao w. bush musharraf putin kull ahmadinejad kbcontainscity paulo lumpur kbcontainsregion kbcontainscountry states arabia india korea kbcontainsorganization reserve bank union central bank commission kbcontainsperson myung-bak nag kbcontainscompany bank managing inacio lula da silva lacker kbcontainsindustryterm bank federal reserve bank costs ministers oil prices prices shock prices ministers prices in the following examples we will look at queries but not the results. please be patient these same queries are used in the embedded java examples in the next section so it makes sense to only list the query return values in one place. besides that you will enjoy running the example programs yourself and experiment with modifying the queries. semantic web we will start with a simple sparql query for subjects article urls and objects countries with the value for the predicate equal to containscountry select where httpknowledgebooks.comontologycontainscountry variables in queries start with a question mark character and can have any names. we can make this query easier and reduce the chance of misspelling errors by using a namespace prefix prefix kb select where kbcontainscountry we could have filtered on any other predicate for instance containsp lace. here is another example using a match against a string literal to find all articles exactly matching the text maryland. the following queries were copied from java source files and were embedded as string literals so you will see quotation marks backslash escaped in these examples. if you were entering these queries into a query form you would not escape the quotation marks. prefix kb select where kbcontainsstate we can also match partial string literals against regular expressions prefix kb select where kbcontainsorganization filter regex?object using sesame prior to this last example query we only requested that the query return values for subject and predicate for triples that matched the query. however we might want to return all triples whose subject this case a news article uri is in one of the matched triples. note that there are two matching triples each terminated with a period prefix kb select where kbcontainsorganization filter regex?object distinct order by limit offset when where clauses contain more than one triple pattern to match this is equivalent to a boolean and operation. the distinct clause removes duplicate results. the order by clause sorts the output in alphabetical order in this case first by predicate containscountry etc. and then by object. the limit modifier limits the number of results returned and the offset modifier sets the number of matching results to skip. we are done with our quick tutorial on using the select query form. there are three other query forms that i am not covering in this chapter construct returns a new rdf graph of query results ask returns boolean true or false indicating if a query matches any triples describe returns a new rdf graph containing matched resources using sesame sesame is a complete java library for developing rdfrdfs applications and we will use it in this chapter. currently sesame s support for owl section is limited. other java libraries i have used that more fully support owl are jena owlapi and the protege library. semantic web figure java utility classes and interface for using sesame figure shows a uml diagram for the wrapper classes and interface that i wrote for sesame to make it easier for you to get started. my wrapper uses an in-memory rdf repository that supports inference loading rdfrdfsowl files and performing queries. if you decide to use semantic web technologies in your development you will eventually want to use the full sesame apis for programatically creating new rdf triples finer control of the type of repository are in-memory disk based and database and inferencing and programatically using query results. that said using my wrapper library is a good place for you to start to start experimenting. the class constructor t riplestoresesamem anager opens a new in-memory rdf triple store. i will not cover the internal implementation of the classes and interface seen in figure but you can read the source code in the subdirectory src-semanticweb. we will look in some detail at an example program that uses sesame and my wrapper library for sesame. the source code for this example is in the file examplesparqlqueries.java. this example class implements the isparqlp rocessresults interface public class examplesparqlqueries implements isparqlprocessresults and does this by defining the method public void processresultliststring data system.out.printnext result for s data system.out.prints system.out.println processresultliststring dataisparqlprocessresultsinterfaceloadrdfstring rdf_file_path_nameclosedosparqlquerystring sparql_query isparqlprocessresults handler output_file_pathtriplestoresesamemanager owl the web ontology language that simply prints out the subject predicate and object of each matched triple. the class t riplestoresesamem anager method public string dosparqlquerystring sparql_query isparqlprocessresults handler calls a defined processresult method once for each triple that matches a query. the examplesparqlqueries class makes several sparql queries and prints the results. these queries are the example queries from the last section. here is an example query with the program output triplestoresesamemanager ts new triplestoresesamemanager sparql_query kb kbcontainsstate ts.dosparqlquerysparql_query this here is the single line of output debug printout is not shown and the long line is split into two lines to fit the page width next result other queries in the last section return two or three values per result this example only returns the subject url. you can run the text program implemented in the class examplesparqlqueries to see all of the query results for the examples in the last section. there is a lot more to rdfs than what i have covered so far in this chapter but i believe you have a sufficient introduction in order to use the example programs to experiment with using rdf and rdfs to define data and use sesame in an imbedded mode in your java applications. owl the web ontology language we have already seen a few examples of using rdfs to define sub-properties in the this chapter. the web ontology language extends the expressive power of semantic web rdfs. we will not cover owl programming examples in this book but this section will provide some background material. sesame version included in the zip file for this book does not support owl dl reasoning out of the box. when i need to use owl dl reasoning in java applications i use one or more of the following protegeowlapis compatible with the protege ontology editor pellet dl reasoner owlim owl dl reasoner compatible with some versions of sesame jena general purpose library owlapi a simpler api using many other libraries owl is more expressive than rdfs in that it supports cardinality richer class relationships and descriptive logic reasoning. owl treats the idea of classes very differently than object oriented programming languages like java and smalltalk but similar to the way powerloom uses concepts s rough equivalent to a class. in owl instances of a class are referred to as individuals and class membership is determined by a set of properties that allow a dl reasoner to infer class membership of an individual is called entailment. we saw an example of expressing transitive relationships when we were using powerloom in section where we defined a powerloom rule to express that the relation contains is transitive. we will now look at a similar example using owl. we have been using the rdf file in previous examples and we will layer new examples by adding new triples that represent rdf rdfs and owl. we saw in the definition of three triples using rdfssubpropertyof properties to create a more general kbcontainsplace property kbcontainscity rdfssubpropertyof kbcontainsplace kbcontainscountry rdfssubpropertyof kbcontainsplace kbcontainsstate rdfssubpropertyof kbcontainsplace kbcontainsplace rdftype owltransitiveproperty kbplaceunitedstates kbcontainsstate kbplaceillinois kbplaceillinois kbcontainscity kbplacechicago we can also infer that kbplaceunitedstates kbcontainsplace kbplacechicago knowledge representation and rest we can also model inverse properties in owl. for example here we add an inverse property kbcontainedin adding it to the example in the last listing kbcontainedin owlinverseof kbcontainsplace given an rdf container that supported extended owl dl sparql queries we can now execute sparql queries matching the property kbcontainedin and match triples in the rdf triple store that have never been asserted. owl dl is a very large subject and owl is an even larger subject. from reading chapter and the very light coverage of owl in this section you should understand the concept of class membership not by explicitly stating that an object individual is a member of a class but rather because an individual has properties that can be used to infer class membership. the world wide web consortium has defined three versions of the owl language that are in increasing order of complexity owl lite owl dl and owl full. owl dl description logic is the most widely used recommended version of owl. owl full is not computationally decidable since it supports full logic multiple class inheritance and other things that probably make it computationally intractable for all but small problems. knowledge representation and rest a theme in this book is representing knowledge using logic expert system rules relational databases at the physical model level conceptual models like entity relation and in flexible data models like rdf and rdfs higher level conceptual models in owl. i want to make some comments about the rest architectural style and how it is complementary to distributed knowledge representation on the web. the rest model implies that resource providers have some internal model for the storage and maintenance of data but use a possibly different representation of their internal data model to transfer their internal data to clients. i would argue that rdf is often a good representation for resource providers to use for transferring data in their internal data formats to rest clients because of its flexibility in describing both data and relations between data. rdf is inherently a rich notation because rdfs and owl are themselves expressed as rdf data. i expect that conventional data sources like relational databases and conventional data-rich web sites will benefit from publishing rest style interfaces using rdf as the external representation of data. we are already seeing interesting and useful semantic web projects that utilize a data source to publish data as rdf embedded as rdfa xhtml notation for embedding rdf in xhtml web pages and i see this as a growth area for publishing information resources that are useful for both humans and software agents. material for further study writing semantic web applications in java is a very large topic worthy of an entire book. i have covered in this chapter what for my work have been the most useful semantic web techniques storing and querying rdf and rdfs for a specific application. we will see in chapter some useful techniques for gathering semantic information from the web. specifically in section i briefly talk about entering semantic data from the open calais system into a sesame rdf repository. i have already mentioned several java libraries that support owl descriptive logic reasoning in section when the expressive power of rdf and rdfs become insufficient for your application you will then need to use a library supporting the owl language and owl description logic reasoning. the combination of rdf and rdfs is sufficient for many applications and using this simpler technology is the right way to get started developing semantic web applications. because rdf and rdfs very few owl features commonly referred to as rdfs-plus are easier to implement and have a smaller learning curve i believe that the adoption of owl dl will be slow. i concentrated on using sesame in an embedded mode in java applications in this chapter but another common use is as an rdf repository web service. in either case the basic ideas of converting data to rdf storing rdf and allowing sparql queries are the same. expert systems we will be using the drools java expert system language and libraries in this chapter. earlier editions of this book used the jess expert system tool but due to the new more restrictive jess licensing terms i decided to switch to drools because it is released under the apache license. the primary web site for drools is www.jboss.orgdrools where you can download the source code and documentation. both jess and drools are forward chaining inference engines that use the rete algorithm and are derived from charles forgy s language. one thing to keep in mind whenever you are building a system based on the rete algorithm is that rete scales very well to large numbers of rules but scales at on where n is the number of facts in the system. i have a long history with porting it to xerox lisp machines and the apple macintosh as well as building custom versions supporting multiple worlds of data and rule spaces. one thing that i would like to make clear drools is the only technology that i am covering in this book that i have not used professionally. that said i spent some effort getting up to speed on drools as a replacement for jess on future projects. while there is some interest in using packages like drools for business rules to capture business process knowledge often as embedded components in large systems expert systems have historically been built to approach human level expertise for very specific tasks like configuring computer systems and medical diagnosis. the examples in this chapter are very simple and are intended to show you how to embed drools in your java applications and to show you a few tricks for using forward chaining rule-based systems. drools is a domain specific language that attempts to provide a syntax that is easier to use than a general purpose programming language. i do not usually recommend java ides personal choice! but if you already use eclipse then i suggest that you use the drools plugins for eclipse eclipse drools workbench which help setting up projects and understand the drools rule language syntax. the eclipse drools workbench can automatically generate a small demo which i will go over in some detail in the next two sections. i then design and implement two simple example rule systems for solving block world type problems and for answering help desk questions. the material in this chapter exclusively covers forward chaining production systems expert systems figure using drools for developing rule-based systems and then deploying them. called expert systems forward chaining systems start with a set of known facts and apply rules to work towards solving one or more goals. an alternative approach often used in prolog programs is to use backward chaining. backward chaining systems start with a final goal and attempt to work backwards towards currently known facts. the phrase expert systems was almost synonymous with artificial intelligence in the early and mid the application of expert system techniques to real problems like configuring dec vax minicomputers medical diagnosis and evaluating seismic data for planning oil exploration had everyone very excited. unfortunately expert systems were over hyped and there was an eventual backlash that affected the entire field of ai. still the knowledge of how to write expert systems is a useful skill. this chapter contains a tutorial for using the drools system and also shows how to use machine learning to help generate rules when training data is available. as seen in figure drools development is interactive you will work in an environment where you can quickly add and change rules and re-run test cases. this interactive style of development is similar to using powerloom as we saw in chapter droolsinferenceengineworking memoryfactsrulesdeveloperinteractivedevelopmenteclipse droolsworkbenchapplication programsdroolsapi production systems production systems i like to refer to expert systems by a more precise name production systems. productions are rules for transforming state. for example given the three production rules a b b c c d then if a production system is initialized with the state a the state d can be derived by applying these three production rules in order. the form of these production rules is side side or lhs rhs like the powerloom reasoning system used in chapter much of the power of a rule-based system comes from the ability to use variables so that the left-hand side patterns can match a variety of known facts working memory in drools. the values of these variables set in the lhs matching process are substituted for the variables on the right-hand side patterns. production rule systems are much less expressive than description logic style reasoners like powerloom. the benefits of production rule systems is that they should have better runtime efficiency and are easier to use a smaller learning curve. good advice is to use production systems when they are adequate and if not use a more expressive knowledge representation and reasoning system like powerloom. the drools rules language the basic syntax out optional components of a drools rule is rule name for the rule when lhs expert systems then rhs end what might sample lhs and rhs statements look like? drools rules reference pojos plain old java objects in both the lhs matching expressions and rhs actions. if you use the eclipse drools workbench and create a new demo project the workbench will automatically create for you sample.drl a sample rule file. com.sample.droolstest.java defines a simple java pojo class m essage that is used in the sample.drl rule file a utility method for loading rules and a main method that loads rules and creates an instance of the m essage class that fires the first rule in sample.drl. even if you decide not to use the eclipse drools workbench i include these two auto-generated files in the zip file for this book and we will use these files to introduce both the syntax of rues and using rules and drools in java applications in the next section. here is the sample.drl file package com.sample import com.sample.droolstest.message rule world when m messagestatus message.hello message message then system.out.printlnmessage m.setmessagegoodbye cruel world m.setstatusmessage.goodbye updatem end rule no-loop true when m messagestatus message.goodbye message message then system.out.printlnmessage using drools in java applications m.setmessagemessage end this example rule file defines which java package it has visibility in we will see in the next section that the java code that defines the pojo m essage class and code that uses these rules will be in the same java package. this class has private data public accessor methods using java bean protocol for attributes status and message. another thing that might surprise you in this example is the direct calls to the static java method system.out.println this is a hint that drools will end up compiling these rules into java byte code. when drools sees a reference to the class m essage since there are no java import statements in this example rule file the class m essage must be in the package com.sample. on the lhs of both rules any instance of class m essage that matches and thus allows the rule to fire sets a reference to the matched object to the local variable m that can then be used on the rhs of the rule. in the first rule the attribute message is also stored in a local variable confusingly also called message. note that the public attribute accessor methods like setm essage are used to change the state of a matched m essage object. we will see later that the first step in writing a drools based expert system is modeling java classes the data required to represent problem states. after you have defined these pojo classes you can then proceed with defining some initial test cases and start writing rules to handle the test cases. drools development of nontrivial projects will involve an iterative process of adding new test cases writing new rules or generalizing previously written rules and making sure that both the original and newer test cases work. there is a complete reference description of the drools rule syntax on the drools documentation wiki. the material in this chapter is tutorial in nature new features of the rule language and how to use drools will be introduced as needed for the examples. using drools in java applications we looked at the sample rules file sample.drl in the last section which is generated automatically when creating a demo project with the eclipse drools workbench. we will use the other generated file droolstest.java as an illustrative example in this section. the file droolstest.java is almost lines long so i will list it in small fragments followed by an explanation of each code fragment. the first thing to note is that the java client code is in the same package as the rules file expert systems package com.sample import java.io.inputstreamreader import java.io.reader import org.drools.rulebase import org.drools.rulebasefactory import org.drools.workingmemory import org.drools.compiler.packagebuilder import org.drools.rule.package this main function is an example showing how to use a rule package defined in a rule source file. we will see the definition of the utility method readrule that opens a rule file and returns an instance of class rulebase shortly. after creating an instance of rulebase we create an instance of the m essage class and add it to open memory public class droolstest public static final void mainstring args try rulebase rulebase readrule workingmemory workingmemory rulebase.newstatefulsession message message new message message.setmessage world message.setstatus message.hello workingmemory.insert message workingmemory.fireallrules catch t t.printstacktrace the main method creates a new rule base and working memory. working memory is responsible for maintaining the facts in the system in this case facts are plain old java objects that are maintained in a collection. an instance of class m essage is created and its status is set to the constant value m essage.hello. we saw in the last section how the first example rule has a condition that allows the rule to fire if there is any instance of class m essage that has its status attribute set to this value. the method f ireallrules will keep identifying rules that are eligible to fire choosing a rule from this active set using algorithms we will discuss later and then repeat using drools in java applications ing this process until no more rules are eligible to fire. there are other f ireallrules methods that have arguments for a maximum number of rules to fire and a filter to allow only some eligible rules to execute. please note that this is the level rule assembly api. private static rulebase readrule throws exception in the source reader source new inputstreamreader droolstest.class. getresourceasstreamsample.drl optionally read in the dsl if you are using one reader dsl getresourceasstreammylang.dsl new inputstreamreader droolstest.class. the method readrule is a utility for reading and compiling a rule file that was generated automatically by the eclipse drools workbench in general your projects will have one or more rules files that you will load as in this example. in method readrule we opened an input stream reader on the source code for the example drools rule file sample.drl. drools has the ability to modify the rule syntax to create domain specific languages that match your application or business domain. this can be very useful if you want domain experts to create rules since they can use their own language. we will not cover custom dsls in this chapter but the drools documentation covers this in detail. here is the rest of the definition of method readrule use package builder to build up a rule package packagebuilder builder new packagebuilder this will parse and compile in one step builder.addpackagefromdrlsource use the following instead of above if you are using a custom dsl source dsl expert systems get the compiled package is serializable package pkg builder.getpackage add the package to a rulebase the rule package. rulebase rulebase rulebasefactory.newrulebase rulebase.addpackage pkg return rulebase the readrule utility method can be copied to new rule projects that are not created using the eclipse drools workbench and modified as appropriate to get you started with the java boilerplate required by drools. this implementation uses drools defaults the most important being the conflict resolution strategy that defaults to first checking the most recently modified working memory pojo objects to see which rules can fire. this produces a depth first search behavior. we will modify the readrule utility method later in section when we will need to change this default drools reasoning behavior from depth first to breadth first search. we will need a plain old java object class to represent messages in the example rule set. this demo class was generated by the eclipse drools workbench public static class message public static final int hello public static final int goodbye private string message private int status public string getmessage return this.message public void setmessagestring message this.message message public int getstatus return this.status public void setstatus int status this.status status example drools expert system blocks world you might want to review the example rules using this pojo message class in section here is the sample output from running this example code and rule set hello world goodbye cruel world a simple example but it serves to introduce you the drools rule syntax and required java code. this is also a good example to understand because when you use the eclipse drools workbench to create a new drools rule project it generates this example automatically as a template for you to modify and re-use. in the next two sections i will develop two more complicated examples solving blocks world problems and supporting a help desk system. example drools expert system blocks world the example in this section solved simple blocks world problems see figures through for a very simple example problem. i like this example because it introduces the topic of conflict resolution and shows you that even solving simple problems with rule-based systems can be difficult. because of the difficulty of developing and debugging rule-based systems they are best for applications that have both high business value and offer an opportunity to encode business or application knowledge of experts in rules. so the example in the next section is a more real-life example of good application of expert systems but you will learn valuable techniques in this example. in the interest of intellectual honesty i should say that general blocks world problems like the towers of hanoi problem and block world problems as the one in this section are usually easily solved using breadth-first search techniques. the java source code and drools rule files for this example are in the files blockworld.drl and droolsbockworld.java. expert systems figure initial state of a blocks world problem with three blocks stacked on top of each other. the goal is to move the blocks so that block c is on top of block a. figure block c has been removed from block b and placed on the table. pojo object models for blocks world example we will use the following three pojo classes in the file droolsbockworld.java as static inner classes. the first pojo class block represents the state of one block public static class block protected string name protected string ontopof protected string supporting public blockstring name string ontopof string supporting this.name name this.ontopof ontopof this.supporting supporting public string tostring return this.hashcode name on top of ontopof supporting supporting public string getname abcabc example drools expert system blocks world return this.name public void setnamestring name this.name name public string getontopof return this.ontopof public void setontopofstring ontopof this.ontopof ontopof public string getsupporting return this.supporting public void setsupportingstring supporting this.supporting supporting the next pojo class oldblockstate is used to represent previous states of blocks as they are being moved as the rules in this example fire. we will later see rules that will not put a block into a state that it previously existed in public static class oldblockstate extends block public oldblockstatestring name string ontopof string supporting supername ontopof supporting public string tostring return this.hashcode name on top of ontopof supporting supporting the next pojo class goal is used to represent a goal state for the blocks that we are trying to reach public static class goal expert systems figure block b has been removed from block a and placed on the table. private string supportingblock private string supportedblock public goalstring supporting string supported this.supportingblock supporting this.supportedblock supported public string tostring return this.hashcode goal supporting block supportingblock and supported block supportedblock public void setsupportingblock string supportingblock this.supportingblock supportingblock public string getsupportingblock return supportingblock public void setsupportedblock string supportedblock this.supportedblock supportedblock public string getsupportedblock return supportedblock each block object has three string attributes a name the name of the block that this block is on top of and the block that this block supports under. we will also define a block instance with the name table. we need the pojo class oldblockstate that is a subclass of block to avoid cycles in the reasoning process. abc example drools expert system blocks world figure the goal is solved by placing block c on top of block a. drools rules for blocks world example we need four rules for this example and they are listed below with comments as appropriate package com.markwatson.examples.drool import com.markwatson.examples.drool.droolsblockworld import com.markwatson.examples.drool.droolsblockworld import com.markwatson.examples.drool.droolsblockworld we place the rules in the same java package as the java support code seen in the next section and the pojo model classes that we saw in the last section. the first rule has no preconditions so it can always fire. we use the special rule condition no-loop true to let the drools system know that we only want this rule to fire one time. this rule inserts facts into working memory for the simple problem seen in figures through rule rule no-loop true when then goalc test insertnew goalc test blockstring name string ontopof insertnew blocka insertnew blockb insertnew blockc insertnew blockd string supporting abc expert systems insertnew blocktable end the following rule looks for situations where it is possible to move a block with a few conditions find a block block that is on top of another block and is not itself supporting any other blocks find a second block block that is not block and is not itself supporting any other blocks find the block on top of that is under block and supporting block make sure that no previous block with the name in the variable block has already been on top of block on top of and supporting block if these conditions are met we can remove the three matching facts and create facts for the new block positions and a new oldblockstate fact in working memory. note that the fourth lhs matching pattern is prefixed with not so this matches if there are no objects in working memory that match this pattern rule block on move to when name ontopof supporting name ontopof supporting blockname ontopof supporting not oldblockstatename ontopof supporting then system.out.println system.out.println system.out.println insertnew insertnew example drools expert system blocks world insertnew insertnew system.out.printlnmoving from to end the next rule looks for opportunities to remove block from block if no other block is sitting on top of block is block is clear rule block remove from when name on_top_of ontopof supporting name ontopof supporting then system.out.println system.out.println insertnew insertnew insertnew blocktable system.out.printlnclearing remove from on_top_of to table end the next rule checks to see if the current goal is satisfied in which case it halts the drools engine rule on goal achieved salience when supportingblock supportedblock blockname supporting then expert systems system.out.printlndone! drools.halt end the java code in the next section can load and run these example rules. java code for blocks world example the example in this section introduces something new modifying the default way that drools chooses which rules to fire when more than one rule is eligible to fire. this is referred to as the conflict resolution strategy and this phrase dates back to the original production system. drools by default prefers rules that are instantiated by data that is newer in working memory. this is similar to depth first search. in the blocks world example in this section we will need to change the conflict resolution strategy to process rules in a first-in first-out order which is similar to a breadth first search strategy. first let us define the problem that we want to solve. consider labeled blocks sitting on a table as seen in figures through the java code in this section is similar to what we already saw in section so we will just look at the differences here. to start with in the utility method readrule we need to add a few lines of code to configure drools to use a breadth-first instead of a depth-first reasoning strategy private static rulebase readrule throws exception reader source new inputstreamreader droolsblockworld.class.getresourceasstream packagebuilder builder new packagebuilder builder.addpackagefromdrl source package pkg builder.getpackage change the default conflict resolution strategy rulebaseconfiguration rbc new rulebaseconfiguration rbc.setconflictresolvernew fifoconflictresolver rulebase rulebase rulebasefactory.newrulebaserbc rulebase.addpackagepkg example drools expert system blocks world return rulebase the drools class f if oconf lictresolver is not so well named but a first-in firstout strategy is like depth first search. the default conflict resolution strategy favors rules that are eligible to fire from data that has most recently changed. since we have already seen the definition of the java pojo classes used in the rules in section the only remaining java code to look at is in the static main method rulebase rulebase readrule workingmemory workingmemory system.out.printlnninitial working memorynn rulebase.newstatefulsession workingmemory.tostring just fire the first setup rule iteratorfacthandle iter workingmemory.iteratefacthandles while system.out.printlniter.next system.out.printlnnn before firing rules... limit cycles system.out.printlnnn after firing rules. system.out.printlnnfinal working memoryn workingmemory.tostring iter workingmemory.iteratefacthandles while system.out.printlniter.next for making rule debugging easier i wanted to run the first start up rule to define the initial problem facts in working memory and then print working memory. that is why i called workingm emory.f to ask the drools rule engine to just fire one rule. in the last example we called workingm emory.f ireallrules with no arguments so the rule engine runs forever as long as there are rules eligible to fire. after printing the facts in working memory i call the f with a limit of rule firings because blocks world problems can fail to terminate least the simple rules that i have written for this example often failed to terminate when i was debugging this example. limiting the number of rule firings is often a good idea. the output from this example with debug output removed is clearing remove c from b to table expert systems moving b from a to c clearing remove b from c to table moving a from table to c moving c from table to b done! note that this is not the best solution since it has unnecessary steps. if you are interested here is the output with debug printout showing the facts that enabled each rule to fire c on top of b supporting b on top of a supporting c clearing remove c from b to table b on top of a supporting c on top of table supporting a on top of table supporting b moving b from a to c b on top of c supporting c on top of table clearing remove b from c to table a on top of table c on top of table table on top of moving a from table to c c on top of table b on top of table table on top of moving c from table to b done! supporting supporting supporting a supporting c supporting b supporting supporting this printout does not show the printout of all facts before and after running this example. example drools expert system help desk system automating help desk functions can improve the quality of customer service and reduce costs. help desk software can guide human call operators through canned explanations that can be thought of as decision trees for example customer reports that their refrigerator is not running ask if the power is on and no circuit breakers are tripped. if customer reports that power source is ok ask if the light example drools expert system help desk system is on inside the refrigerator to determine if just the compressor motor is out. we will see in chapter that decision trees can be learned from training data. one method of implementing a decision tree approach to help desk support would be to capture customer interactions by skilled support staff factor operator responses into standard phrases and customer comments into standard questions and use a machine learning package like weka to learn the best paths through questions and answers. we will take a different approach in our example for this section we will assume that an expert customer service representative has provided us with use cases of common problems what customers tend to ask for each problem and the responses by customer service representatives. we will develop some sample drools rules to encode this knowledge. this approach is likely to be more difficult to implement than a decision tree system but has the potential advantage that if individual rules make sense in general they may end up being useful in contexts beyond those anticipated by rules developers. with this greater flexibility comes a potential for less accuracy. we will start in the next section by developing some pojo object models required for our example help desk expert system and then in the next section develop a few example rules. object models for an example help desk we will use a single java pojo class for this example. we want a problem type a description of a problem and a suggestion. a real help desk system might use additional classes for intermediate steps in diagnosing problems and offering advice but for this example we will chain problems together. here is an example customer my refrigerator is not running. service i want to know if the power is on. is the light on inside the refrigerator? customer no. service please check your circuit breaker i will wait. customer all my circuit breakers looked ok and everything else is running in the kitchen. service i will schedule a service call for you. we will not develop an interactive system a dialog with a customer is assumed to be converted into facts in working memory. these facts will be represented by instances of the class p roblem. the expert system will apply the rule base to the facts in working memory and make suggestions. here is the java class p roblem that is defined as an inner static class in the file droolshelpdesk.java expert systems public static class problem enums as match types so i use static integers here. in general using enums is much better. note drools has problems dealing with java final public static int none appliance types final public static int refrigerator final public static int microwave final public static int tv final public static int dvd environmentaldata possible values final public static int circuit_breaker_off final public static int lights_off_in_room problemtype possible values final public static int not_running final public static int smoking final public static int on_fire final public static int makes_noise long serviceid unique id for all problems dealing with customer problem int appliancetype none int problemtype none int environmentaldata none public problemlong serviceid int type this.serviceid serviceid this.appliancetype type public string tostring return enumnames.getappliancetype problem type enumnames.getproblemtype environmental data enumnames.getenvironmentaldata public long getserviceid return serviceid public int getenvironmentaldata return environmentaldata public int getproblemtype return problemtype static mapinteger string enumnames example drools expert system help desk system new hashmapinteger string static it is unfortunate that the current version of drools does not work well with java enums the p roblem class would have been about half as many lines of code need to map integers to meaningful descriptions for tostring and the example would also be more type safe. i used constant values like refrigerator and running to represent possible values for the member class attributes like appliancet ype problemt ype and environmentaldata. there is obviously a tight binding from the java pojo classes like p roblem to the rules that use these classes to represent objects in working memory. we will see a few example help desk rules in the next section. drools rules for an example help desk this demo help desk system is not interactive. the java code in the next section loads the rule set that we are about to develop and then programmatically adds test facts into working memory that simulate two help desk customer service issues. this is an important example since you will likely want to add data directly from java code into drools working memory. there are several rules defined in the example file helpdesk.drl and we will look at a few of them here. these rules are intended to be a pedantic example of both how to match attributes in java pojo classes and to show a few more techniques for writing drools rules. i used to use the lisp based to develop expert systems and i find the combination of java and drools is certainly less agile to use. i found myself writing a rule then editing the pojo class problem to add constants for things that i wanted to use in the rule. with more experience this less than interactive process might become expert systems more comfortable for me. as in the blocks world example we want to place the rules file in the same package as the java code using the rules file and import any pojo classes that we will use in working memory package com.markwatson.examples.drool import com.markwatson.examples.drool. droolshelpdesk.problem the first rule sets a higher than default rule salience so it will fire before any rules with the default rule salience value of zero. this rule has a feature that we have not seen before i have no matching expressions in the when clause. all java problem instances will match the left-hand side of this rule. rule all problems salience when p problem then system.out.printlnfrom rule print all problems end p the following rule matches an instance of the class p roblem in working memory that has a value of problem.circuit breaker off for the vakue of attribute environmentaldata. this constant has the integer value of but is is obviously more clear to use meaningful constant names rule circuit breaker when problemenvironmentaldata then system.out.printlnreset circuit breaker problem.circuit_breaker_off end the last rule could perhaps be improved by having it only fire if any appliance was not currently running we make this check in the next rule. notice that in the next rule we are matching different attributes ype and environmentaldata and it does not matter if these attributes match in a single working memory element or two different working memory elements example drools expert system help desk system rule for reset circuit breaker when problemproblemtype problem.not_running problemenvironmentaldata problem.circuit_breaker_off then system.out.printlncheck for power source the unit is not is not on and circuit breaker is tripped check circuit breaker for this room. end we will look at the java code to use these example rules in the next section. java code for an example help desk we will see another trick for using drools in this example creating working memory elements instances of the problem pojo class in java code instead of in a startup rule as we did for the blocks world example. the code in this section is also in the droolshelpdesk.java source file is the pojo class definition seen in section the static main method in the droolshelpdesk class is very similar to the main method in the blocks world example except that here we also call a new method createt estf acts public static final void mainstring args throws exception up the rulebase rulebase rulebase readrule workingmemory workingmemory rulebase.newstatefulsession createtestfactsworkingmemory same as the blocks world example we already looked at the utility method readrule in section so we will just look at the new method createt estf acts that creates two instance of the pojo class p roblem in working memory private static void expert systems createtestfactsworkingmemory workingmemory throws exception problem new problem.refrigerator problem.not_running problem.circuit_breaker_off problem new problem.tv problem.smoking in this code we created new instances of the class p roblem and set desired attributes. we then use the w orkingm emory method insert to add the ojects to the working memory collection that drools maintains. the output when running this example is to fit the page width from rule print all problems tv problem type smoking environmental data none from rule print all problems refrigerator problem type not_running environmental data circuit_breaker_off unplug appliance to prevent fire danger tv problem type smoking environmental data none check for power source refrigerator problem type not_running environmental data circuit_breaker_off the unit is not is not on and the circuit breaker is tripped check the circuit breaker for this room. notes on the craft of building expert systems notes on the craft of building expert systems it may seem like rule-based expert systems have a lot of programming overhead that is it will seem excessively difficult to solve simple problems using production systems. however for encoding large ill-structured problems production systems provide a convenient notation for collecting together what would otherwise be too large a collection of unstructured data and heuristic rules expert systems in an introduction to rule-based programming brownston et al. as a programming technique writing rule-based expert systems is not for everyone. some programmers find rule-based programming to be cumbersome while others find it a good fit for solving some types of problems. i encourage the reader to have some fun experimenting with drools both with the examples in this chapter and the many examples in the drools distribution package and documentation. before starting a moderate or large expert system project there are several steps that i recommend write a detailed description of the problem to be solved. decide what structured data elements best describe the problem space. try to break down the problem into separate modules of rules if possible try to develop and test these smaller modules independently preferably one source file per module. plan on writing specific rules that test parts of the system by initializing working memory for specific tests for the various modules these tests will be very important when testing all of the modules together because tests that work correctly for a single module may fail when all modules are loaded due to unexpected rule interactions. production systems model fairly accurately the stimulus-response behavior in people. the left-hand side terms represent environmental data that triggers a response or action represented by the right-hand side terms in production rules. simple stimulus-response types of production rules might be adequate for modeling simple behaviors but our goal in writing expert systems is to encode deep knowledge and the ability to make complex decisions in a very narrow limited problem domain. in order to model complex decision-making abilities we also often need to add higher-level control functionality to expert systems. this higher level or meta control can be the control of which rule modules are active. we did not look at the drools apis for managing modules in this chapter but these apis are covered in the drools documentation. hopefully this chapter both gave you a quickstart for experimenting with drools and enough experience to know if a rule-based system might be a good fit for your own development. expert systems genetic algorithms genetic algorithms are computer simulations to evolve a population of chromosomes that contain at least some very fit individuals. fitness is specified by a fitness function that rates each individual in the population. setting up a ga simulation is fairly easy we need to represent encode the state of a system in a chromosome that is usually implemented as a set of bits. ga is basically a search operation searching for a good solution to a problem where the solution is a very fit chromosome. the programming technique of using ga is useful for ai systems that must adapt to changing conditions because re-programming can be as simple as defining a new fitness function and re-running the simulation. an advantage of ga is that the search process will not often get stuck in local minimum because the genetic crossover process produces radically different chromosomes in new generations while occasional mutations a random bit in a chromosome cause small changes. another aspect of ga is supporting the evolutionary concept of survival of the fittest by using the fitness function we will preferentially breed chromosomes with higher fitness values. it is interesting to compare how gas are trained with how we train neural networks we need to manually supervise the training process for gas we need to supply a fitness function and for the two neural network models used in chapter we need to supply training data with desired sample outputs for sample inputs. theory gas are typically used to search very large and possibly very high dimensional search spaces. if we want to find a solution as a single point in an n dimensional space where a fitness function has a near maximum value then we have n parameters to encode in each chromosome. in this chapter we will be solving a simple problem that is one-dimensional so we only need to encode a single number floating point number for this example in each chromosome. using a ga toolkit like the one developed in section requires two problem-specific customizations characterize the search space by a set of parameters that can be encoded in a chromosome on this later. gas work with the coding of a parameter set not the parameters themselves algorithms in search optimiza genetic algorithms figure the test function evaluated over the interval the maximum value of occurs at tion and machine learning david goldberg provide a numeric fitness function that allows us to rate the fitness of each chromosome in a population. we will use these fitness values to determine which chromosomes in the population are most likely to survive and reproduce using genetic crossover and mutation operations. the ga toolkit developed in this chapter treats genes as a single bit while you can consider a gene to be an arbitrary data structure the approach of using single bit genes and specifying the number of genes bits in a chromosome is very flexible. a population is a set of chromosomes. a generation is defined as one reproductive cycle of replacing some elements of the chromosome population with new chromosomes produced by using a genetic crossover operation followed by optionally mutating a few chromosomes in the population. we will describe a simple example problem in this section write a general purpose library in section and finish the chapter in section by solving the problem posed in this section. for a sample problem suppose that we want to find the maximum value of the function f with one independent variable x in equation and as seen in figure f sinx x x the problem that we want to solve is finding a good value of x to find a near to possible maximum value of f to be clear we encode a floating point number java library for genetic algorithms figure crossover operation as a chromosome made up of a specific number of bits so any chromosome with randomly set bits will represent some random number in the interval the fitness function is simply the function in equation figure shows an example of a crossover operation. a random chromosome bit index is chosen and two chromosomes are cut at this this index and swap cut parts. the two original chromosomes in generationn are shown on the left of the figure and after the crossover operation they produce two new chromosomes in shown on the right of the figure. in addition to using crossover operations to create new chromosomes from existing chromosomes we will also use genetic mutation randomly flipping bits in chromosomes. a fitness function that rates the fitness value of each chromosome allows us to decide which chromosomes to discard and which to use for the next generation we will use the most fit chromosomes in the population for producing the next generation using crossover and mutation. we will implement a general purpose java ga library in the next section and then solve the example problem posed in this section in section java library for genetic algorithms the full implementation of the ga library is in the java source file genetic.java. the following code snippets shows the method signatures defining the public api for the library note that there are two constructors the first using default values for the fraction of chromosomes on which to perform crossover and mutation operations and the second constructor allows setting explicit values for these parameters abstract public class genetic public geneticint num_genes_per_chromosome genetic algorithms public geneticint num_genes_per_chromosome int num_chromosomes int num_chromosomes float crossover_fraction float mutation_fraction the method sort is used to sort the population of chromosomes in most fit first order. the methods getgene and setgene are used to fetch and change the value of any gene in any chromosome. these methods are protected but you will probably not need to override them in derived classes. protected void sort protected boolean getgeneint chromosome int gene protected void setgeneint chromosome int gene int value protected void setgeneint chromosome int gene boolean value the methods evolve docrossovers dom utations and doremoveduplicates are utilities for running ga simulations. these methods are protected but you will probably not need to override them in derived classes. protected void evolve protected void docrossovers protected void domutations protected void doremoveduplicates when you subclass class genetic you must implement the following abstract method calcf itness that will determine the evolution of chromosomes during the ga simulation. implement the following method in sub-classes abstract public void calcfitness the class chromosome represents a bit set with a specified number of bits and a floating point fitness value. java library for genetic algorithms class chromosome private chromosome public chromosomeint num_genes public boolean getbitint index public void setbitint index boolean value public float getfitness public void setfitnessfloat value public boolean equalschromosome c the class chromosomecomparator implements a comparator interface and is application specific it is used to sort a population in best first order class chromosomecomparator implements comparatorchromosome public int comparechromosome chromosome the last class chromosomecomparator is used when using the java collection class static sort method. the class genetic is an abstract class you must subclass it and implement the method calcf itness that uses an application specific fitness function you must supply to set a fitness value for each chromosome. this ga library provides the following behavior generates an initial random population with a specified number of bits genes per chromosome and a specified number of chromosomes in the population ability to evaluate each chromosome based on a numeric fitness function ability to create new chromosomes from the most fit chromosomes in the population using the genetic crossover and mutation operations there are two class constructors for genetic set up a new ga experiment by setting the number of genes bits per chromosome and the number of chromosomes in the population. the genetic class constructors build an array of integers roulettew heel which is used to weight the most fit chromosomes in the population for choosing the parents genetic algorithms of crossover and mutation operations. when a chromosome is being chosen a random integer is selected to be used as an index into the roulettew heel array the values in the array are all integer indices into the chromosome array. more fit chromosomes are heavily weighted in favor of being chosen as parents for the crossover operations. the algorithm for the crossover operation is fairly simple here is the implementation public void docrossovers int num crossoverfraction for i num i i-- don t overwrite the chromosome from current generation int math.random int math.random if int locus math.random for g gnumgenesperchromosome g if locus setgenei g g else setgenei g g the method dom utations is similar to docrossovers we randomly choose chromosomes from the population and for these selected chromosomes we randomly flip the value of one gene gene is a bit in our implementation public void domutations int num mutationfraction for i i num i don t overwrite the chromosome from current generation int c math.random finding the maximum value of a function int g math.random setgenec g g we developed a general purpose library in this section for simulating populations of chromosomes that can evolve to a more fit population given a fitness function that ranks individual chromosomes in order of fitness. in section we will develop an example ga application by defining the size of a population and the fitness function defined by equation finding the maximum value of a function we will use the java library in the last section to develop an example application to find the maximum of the function seen in figure which shows a plot of equation plotted in the interval while we could find the maximum value of this function by using newton s method even a simple brute force search over the range of the independent variable x the ga method scales very well to similar problems of higher dimensionality. the ga also helps us to not find just locally optimum solutions. in this example we are working in one dimension so we only need to encode a single variable in a chromosome. as an example of a higher dimensional system we might have products of sine waves using independent variables still the one-dimensional case seen in figure is a good example for showing you how to set up a ga simulation. our first task is to characterize the search space as one or more parameters. in general when we write ga applications we might need to encode several parameters in a single chromosome. for example if a fitness function has three arguments we would encode three numbers in a singe chromosome. in this example problem we have only one parameter the independent variable x. we will encode the parameter x using ten bits we have ten genes per chromosome. a good starting place is writing utility method for converting the representation to a floating-point number in the range float genetofloatint chromosomeindex int base float x for jnumgenesperchromosome j if j genetic algorithms x base base after summing up all on bits times their value we need to normalize what is an integer in the range of to a floating point number in the approximate range of x return x note that we do not need the reverse method! we use the ga library from section to create a population of chromosomes in order to evaluate the fitness of each chromosome in a population we only have to convert the representation to a floating-point number for evaluation using the following fitness function private float fitnessfloat x return x x table shows some sample random chromosomes and the floating point numbers that they encode. the first column shows the gene indices where the bit is on the second column shows the chromosomes as an integer number represented in binary notation and the third column shows the floating point number that the chromosome encodes. the center column in table shows the bits in order where index is the left-most bit and index if the right-most bit this is the reverse of the normal order for encoding integers but the ga does not care it works with any encoding we use. once again gas work with encodings. on bits in chromosome as binary number encoded table random chromosomes and the floating point numbers that they encode using methods genet of loat and f itness we now implement the abstract method calcf itness from our ga library class genetic so the derived class t estgenetic finding the maximum value of a function is not abstract. this method has the responsibility for calculating and setting the fitness value for every chromosome stored in an instance of class genetic public void calcfitness for inumchromosomes i float x genetofloati chromosomes.geti.setfitnessfitnessx while it was useful to make this example more clear with a separate genet of loat method it would have also been reasonable to simply place the formula in the method f itness in the implementation of the abstract the base class method calcf itness. in any case we are done with coding this example you can compile the two example java files genetic.java and testgenetic.java and run the t estgenetic class to verify that the example program quickly finds a near maximum value for this function. you can try setting different numbers of chromosomes in the population and try setting non-default crossover rates of and a mutation rates of we will look at a run with a small number of chromosomes in the population created with genetic_experiment new int num_cycles for inum_cycles i genetic_experiment.evolve if system.out.printlngeneration i genetic_experiment.print in this experiment of chromosomes will be sliced and diced with a crossover operation and will have one of their genes changed. we specified bits per chromosome and a population size of chromosomes. in this example i have run evolutionary cycles. after you determine a fitness function to use you will probably need to experiment with the size of the population and the crossover and mutation rates. since the simulation uses random numbers is thus nondeterministic you can get different results by simply rerunning the simulation. here is example program output much of the output removed for brevity count of slots in roulette genetic algorithms generation fitness for chromosome is occurs at fitness for chromosome is occurs at fitness for chromosome is occurs at fitness for chromosome is occurs at fitness for chromosome is occurs at fitness for chromosome is occurs at fitness for chromosome is occurs at average and best fitness for this generation fitness for chromosome is occurs at fitness for chromosome is occurs at this example is simple but is intended to be show you how to encode parameters for a problem where you want to search for values to maximize a fitness function that you specify. using the library developed in this chapter you should be able to set up and run a ga simulation for your own applications. neural networks neural networks can be used to efficiently solve many problems that are intractable or difficult using other ai programming techniques. i spent almost two years on a darpa neural network tools advisory panel wrote the first version of the ansim neural network product and have used neural networks for a wide range of application problems interpretation bomb detection and as controllers in computer games. mastering the use of simulated neural networks will allow you to solve many types of problems that are very difficult to solve using other methods. although most of this book is intended to provide practical advice some theoretical background on using ai programming techniques i cannot imagine being interested in practical ai programming without also wanting to think about the philosophy and mechanics of how the human mind works. i hope that my readers share this interest. in this book we have examined techniques for focused problem solving concentrating on performing one task at a time. however the physical structure and dynamics of the human brain is inherently parallel and distributed distributed processing explorations in the microstructure of cognition rumelhart mcclelland etc. we are experts at doing many things at once. for example i simultaneously can walk talk with my wife keep our puppy out of cactus and enjoy the scenery behind our house in sedona arizona. ai software systems struggle to perform even narrowly defined tasks well so how is it that we are able to simultaneously perform several complex tasks? there is no clear or certain answer to this question at this time but certainly the distributed neural architecture of our brains is a requirement for our abilities. unfortunately artificial neural network simulations do not currently address multi-tasking techniques that do address this issue are multi-agent systems with some form or mediation between agents. also interesting is the distinction between instinctual behavior and learned behavior. our knowledge of gas from chapter provides a clue to how the brains of especially lower order animals can be hardwired to provide efficient instinctual behavior under the pressures of evolutionary forces likely survival of more fit individuals. this works by using genetic algorithms to design specific neural wiring. i have used genetic algorithms to evolve recurrent neural networks for control applications. this work only had partial success but did convince me that biological genetic pressure is probably adequate to pre-wire some forms of behavior in natural neural networks. neural networks figure physical structure of a neuron while we will study supervised learning techniques in this chapter it is possible to evolve both structure and attributes of neural networks using other types of neural network models like adaptive resonance theory to autonomously learn to classify learning examples without intervention. we will start this chapter by discussing human neuron cells and which features of real neurons that we will model. unfortunately we do not yet understand all of the biochemical processes that occur in neurons but there are fairly accurate models available search neuron biochemical neurons are surrounded by thin hairlike structures called dendrites which serve to accept activation from other neurons. neurons sum up activation from their dendrites and each neuron has a threshold value if the activation summed over all incoming dendrites exceeds this threshold then the neuron fires spreading its activation to other neurons. dendrites are very localized around a neuron. output from a neuron is carried by an axon which is thicker than dendrites and potentially much longer than dendrites in order to affect remote neurons. figure shows the physical structure of a neuron in general the neuron s axon would be much longer than is seen in figure the axon terminal buttons transfer activation to the dendrites of neurons that are close to the individual button. an individual neuron is connected to up to ten thousand other neurons in this way. the activation absorbed through dendrites is summed together but the firing of a neuron only occurs when a threshold is passed. hopfield neural networks hopfield neural networks implement associative content addressable memory. a hopfield network is trained using a set of patterns. after training the network can be shown a pattern similar to one of the training inputs and it will hopefully associate the noisy pattern with the correct input pattern. hopfield networks are java classes for hopfield neural networks very different than back propagation networks later in section because the training data only contains input examples unlike back propagation networks that are trained to associate desired output patterns with input patterns. internally the operation of hopfield neural networks is very different than back propagation networks. we use hopfield neural networks to introduce the subject of neural nets because they are very easy to simulate with a program and they can also be very useful in practical applications. the inputs to hopfield networks can be any dimensionality. hopfield networks are often shown as having a two-dimensional input field and are demonstrated recognizing characters pictures of faces etc. however we will lose no generality by implementing a hopfield neural network toolkit with one-dimensional inputs because a two-dimensional image can be represented by an equivalent one-dimensional array. how do hopfield networks work? a simple analogy will help. the trained connection weights in a neural network represent a high dimensional space. this space is folded and convoluted with local minima representing areas around training input patterns. for a moment visualize this very high dimensional space as just being the three dimensional space inside a room. the floor of this room is a convoluted and curved surface. if you pick up a basketball and bounce it around the room it will settle at a low point in this curved and convoluted floor. now consider that the space of input values is a two-dimensional grid a foot above the floor. for any new input that is equivalent to a point defined in horizontal coordinates if we drop our basketball from a position above an input grid point the basketball will tend to roll down hill into local gravitational minima. the shape of the curved and convoluted floor is a calculated function of a set of training input vectors. after the floor has been trained with a set of input vectors then the operation of dropping the basketball from an input grid point is equivalent to mapping a new input into the training example that is closest to this new input using a neural network. a common technique in training and using neural networks is to add noise to training data and weights. in the basketball analogy this is equivalent to shaking the room so that the basketball finds a good minima to settle into and not a non-optimal local minima. we use this technique later when implementing back propagation networks. the weights of back propagation networks are also best visualized as defining a very high dimensional space with a manifold that is very convoluted near areas of local minima. these local minima are centered near the coordinates defined by each input vector. java classes for hopfield neural networks the hopfield neural network model is defined in the file hopfield.java. since this file only contains about lines of code we will look at the code and discuss the neural networks algorithms for storing and recall of patterns at the same time. in a hopfield neural network simulation every neuron is connected to every other neuron. consider a pair of neurons indexed by i and j. there is a weight wij between these neurons that corresponds in the code to the array element weighti j. we can define energy between the associations of these two neurons as energyi j weighti j activationi activationj in the hopfield neural network simulator we store activations the input values as floating point numbers that get clamped in value to off or on. in the energy equation we consider an activation that is not clamped to a value of one to be zero. this energy is like gravitational energy potential using a basketball court analogy think of a basketball court with an overlaid grid different grid cells on the floor are at different heights energy levels and as you throw a basketball on the court the ball naturally bounces around and finally stops in a location near to the place you threw the ball in a low grid cell in the floor that is it settles in a locally low energy level. hopfield networks function in much the same way when shown a pattern the network attempts to settle in a local minimum energy point as defined by a previously seen training example. when training a network with a new input we are looking for a low energy point near the new input vector. the total energy is a sum of the above equation over all the class constructor allocates storage for input values temporary storage and a two-dimensional array to store weights public hopfieldint numinputs this.numinputs numinputs weights new floatnuminputsnuminputs inputcells new floatnuminputs tempstorage new floatnuminputs remember that this model is general purpose multi-dimensional inputs can be converted to an equivalent one-dimensional array. the method addt rainingdata is used to store an input data array for later training. all input values get clamped to an off or on value by the utility method adjustinput. the utility method truncate truncates floating-point values to an integer value. the utility method deltaenergy has one argument an index into the input vector. the class variable tempstorage is set during training to be the sum of a row of trained weights. so the method deltaenergy returns a measure of the energy difference between the input vector in the current input cells and the training input examples private float deltaenergyint index java classes for hopfield neural networks float temp for jnuminputs j temp weightsindexj inputcellsj return temp tempstorageindex the method train is used to set the two-dimensional weight array and the onedimensional tempstorage array in which each element is the sum of the corresponding row in the two-dimensional weight array public void train for jnuminputs j for ij i for ntrainingdata.size n float data float adjustinputdatai adjustinputdataj weightsji float temp weightsij weightsji temp for inuminputs i tempstoragei for ji j tempstoragei weightsij once the arrays weight and tempstorage are defined it is simple to recall an original input pattern from a similar test pattern public float recallfloat pattern int numiterations for inuminputs i inputcellsi patterni for ii iinumiterations ii for inuminputs i if neural networks inputcellsi else inputcellsi return inputcells testing the hopfield neural network class the test program for the hopfield neural network class is t est hopf ield. this test program defined three test input patterns each with ten values static float data the following code fragment shows how to create a new instance of the hopf ield class and train it to recognize these three test input patterns test new test.train the static method helper is used to slightly scramble an input pattern then test the training hopfield neural network to see if the original pattern is re-created helpertest helpertest helpertest the following listing shows an implementation of the method helper called method pp simply formats a floating point number for printing by clamping it to zero or one. this version of the code randomly flips one test bit and we will see that the trained hopfield network almost always correctly recognizes the original testing the hopfield neural network class pattern. the version of method helper included in the zip file for this book is slightly different in that two bits are randomly flipped will later look at sample output with both one and two bits randomly flipped. private static void helperhopfield test string s float test_data float dd new for i ddi test_datai int index if ddindex else float rr test.recalldd system.out.printsnoriginal data for i i i ddindex system.out.printpptest_datai system.out.printnrandomized data for i i i system.out.printppddi system.out.printnrecognized pattern for i i i system.out.printpprri system.out.println the following listing shows how to run the program and lists the example output java test_hopfield pattern original data randomized data recognized pattern pattern original data randomized data recognized pattern pattern original data randomized data recognized pattern in this listing we see that the three sample training patterns in t est hopf ield.java are re-created after scrambling the data by changing one randomly chosen value to neural networks its opposite value. when you run the test program several times you will see occasional errors when one random bit is flipped and you will see errors occur more often with two bits flipped. here is an example with two bits flipped per test the first pattern is incorrectly reconstructed and the second and third patterns are reconstructed correctly pattern original data randomized data recognized pattern pattern original data randomized data recognized pattern pattern original data randomized data recognized pattern back propagation neural networks the next neural network model that we will use is called back propagation also known as back-prop and delta rule learning. in this model neurons are organized into data structures that we call layers. figure shows a simple neural network with two layers this network is shown in two different views just the neurons organized as two one-dimensional arrays and as two one-dimensional arrays with the connections between the neurons. in our model there is a connection between two neurons that is characterized by a single floating-point number that we will call the connection s weight. a weight wij connects input neuron i to output neuron j. in the back propagation model we always assume that a neuron is connected to every neuron in the previous layer. the key thing is to be able to train a back-prop neural network. training is performed by calculating sets of weights for connecting each layer. as we will see we will train networks by applying input values to the input layer allowing these values to propagate through the network using the current weight values and calculating the errors between desired output values and the output values from propagation of input values through the network. initially weights are set to small random values. you will get a general idea for how this is done in this section and then we will look at java implementation code in section in figure we only have two neuron layers one for the input neurons and one for the output neurons. networks with no hidden layers are not usually useful i back propagation neural networks figure two views of the same two-layer neural network the view on the right shows the connection weights between the input and output layers as a two-dimensional array. am using the network in figure just to demonstrate layer to layer connections through a weights array. to calculate the activation of the first output neuron we evaluate the sum of the products of the input neurons times the appropriate weight values this sum is input to a sigmoid activation function figure and the result is the new activation value for here is the formula for the simple network in figure w w w w figure shows a plot of the sigmoid function and the derivative of the sigmoid function we will use the derivative of the sigmoid function when training a neural network at least one hidden neuron layer with classified data examples. a neural network like the one seen in figure is trained by using a set of training data. for back propagation networks training data consists of matched sets of input with matching desired output values. we want to train a network to not only produce the same outputs for training data inputs as appear in the training data but also to generalize its pattern matching ability based on the training data to be able to match test patterns that are similar to training input patterns. a key here is to balance the size of the network against how much information it must hold. a common mistake when using back-prop networks is to use too large a network a network that contains too many neurons and connections will simply memorize the training input neuron layerinput neuron layeroutput neuron layeroutputneuron layer neural networks figure sigmoid and derivative of the sigmoid functions. this plot was produced by the file src-neural-networksgraph.java. examples including any noise in the training data. however if we use a smaller number of neurons with a very large number of training data examples then we force the network to generalize ignoring noise in the training data and learning to recognize important traits in input data while ignoring statistical noise. how do we train a back propagation neural network given that we have a good training data set? the algorithm is quite easy we will now walk through the simple case of a two-layer network like the one in figure and later in section we will review the algorithm in more detail when we have either one or two hidden neuron layers between the input and output layers. in order to train the network in figure we repeat the following learning cycle several times zero out temporary arrays for holding the error at each neuron. the error starting at the output layer is the difference between the output value for a specific output layer neuron and the calculated value from setting the input layer neuron s activation values to the input values in the current training example and letting activation spread through the network. update the weight wij i is the index of an input neuron and j is the index of an output neuron using the formula wij learning rate output errorj ii rate is a tunable parameter and output errorj was calculated in step and ii is the activation of input neuron at index i. this process is continued to either a maximum number of learning cycles or until the calculated output errors get very small. we will see later that the algorithm is similar but slightly more complicated when we have hidden neuron layers the difference is that we will back propagate output errors to the hidden layers in order to estimate errors for hidden neurons. we will cover more on this later. this type of neural a java class library for back propagation figure capabilities of zero one and two hidden neuron layer neural networks. the grayed areas depict one of two possible output values based on two input neuron activation values. note that this is a two-dimensional case for visualization purposes if a network had ten input neurons instead of two then these plots would have to be ten-dimensional instead of twodimensional. network is too simple to solve very many interesting problems and in practical applications we almost always use either one additional hidden neuron layer or two additional hidden neuron layers. figure shows the types of problems that can be solved by zero hidden layer one hidden layer and two hidden layer networks. a java class library for back propagation the back propagation neural network library used in this chapter was written to be easily understood and is useful for many problems. however one thing that is not in the implementation in this section is added in section is something usually called momentum to speed up the training process at a cost of doubling the storage requirements for weights. adding a momentum term not only makes learning faster but also increases the chances of sucessfully learning more difficult problems. we will concentrate in this section on implementing a back-prop learning algorithm that works for both one and two hidden layer networks. as we saw in figure a network with two hidden layers is capable of arbitrary mappings of input to output values so there is no theoretical reason that i know of for using networks with three hidden layers. the source directory src-neural-networks contains example programs for both back neural networks figure example backpropagation neural network with one hidden layer. figure example backpropagation neural network with two hidden layers. a java class library for back propagation propagation neural networks and hopfield neural networks which we saw at the beginning of this chapter. the relevant files for the back propagation examples are neural contains a class for simulating a neural network with one hidden neuron layer test a text-based test program for the class neural guitest a gui-based test program for the class neural neural contains a class for simulating a neural network with two hidden neuron layers neural momentum.java contains a class for simulating a neural network with two hidden neuron layers and implements momentum learning in section test a text-based test program for the class neural guitest a gui-based test program for the class neural guitest momentum.java a gui-based test program for the class neural momentum that uses momentum learning in section a java jfc graphics panel for the values of a one-dimensional array of floating point values a java jfc graphics panel for the values of a two-dimensional array of floating point values the gui files are for demonstration purposes only and we will not discuss the code for these classes if you are interested in the demo graphics code and do not know jfc java programming there are a few good jfc tutorials at the web site java.sun.com. it is common to implement back-prop libraries to handle either zero one or two hidden layers in the same code base. at the risk of having to repeat similar code in two different classes i decided to make the n eural and n eural classes distinct. i think that this makes the code a little easier for you to understand. as a practical point you will almost always start solving a neural network problem using only one hidden layer and only progress to trying two hidden layers if you cannot train a one hidden layer network to solve the problem at-hand with sufficiently small error when tested with data that is different than the original training data. one hidden layer networks require less storage space and run faster in simulation than two hidden layer networks. in this section we will only look at the implementation of the class n eural neural networks n eural is simpler and when you understand how n eural works the simpler class is easy to understand also. this class implements the serializable interface and contains a utility method save to write a trained network to a disk file class implements serializable there is a static factory method that reads a saved network file from disk and builds an instance of n eural and there is a class constructor that builds a new untrained network in memory given the number of neurons in each layer public static factorystring serialized_file_name public num_in int int int num_output an instance of n eural contains training data as transient data that is not saved by method save. transient protected arraylist inputtraining new vector transient protected arraylist outputtraining new vector i want the training examples to be native float arrays so i used generic arraylist containers. you will usually need to experiment with training parameters in order to solve difficult problems. the learning rate not only controls how large the weight corrections we make each learning cycle but this parameter also affects whether we can break out of local minimum. other parameters that affect learning are the ranges of initial random weight values that are hardwired in the method randomizew eights and the small random values that we add to weights during the training cycles these values are set in in slightlyrandomizew eights. i usually only need to adjust the learning rate when training back-prop networks public float training_rate i often decrease the learning rate during training that is i start with a large learning rate and gradually reduce it during training. the calculation for output neuron values given a set of inputs and the current weight values is simple. i placed the code for calculating a forward pass through the network in a separate method f orwardp ass because it is also used later in the method training a java class library for back propagation public float recallfloat in for i i numinputs i inputsi ini forwardpass float ret new floatnumoutputs for i i numoutputs i reti outputsi return ret public void forwardpass for h h h for h h h for i i numinputs i for h h h inputsi for i i i for h h h for o o numoutputs o outputso for h h h for o o numoutputs o outputso while the code for recall and f orwardp ass is almost trivial the training code in method train is more complex and we will go through it in some detail. before we get to the code i want to mention that there are two primary techniques for training back-prop networks. the technique that i use is to update the weight arrays after each individual training example. the other technique is to sum all output errors neural networks over the entire training set part of the training set and then calculate weight updates. in the following discussion i am going to weave my comments on the code into the listing. the private member variable current example is used to cycle through the training examples one training example is processed each time that the train method is called private int current_example public float trainarraylist ins arraylist v_outs before starting a training cycle for one example we zero out the arrays used to hold the output layer errors and the errors that are back propagated to the hidden layers. we also need to copy the training example input values and output values int i h o float error int num_cases ins.size examplenum_cases example zero out error arrays for h h for h h for o numoutputs o output_errorso copy the input values for i numinputs i inputsi ins.getcurrent_examplei copy the output values float outs v_outs.getcurrent_example we need to propagate the training example input values through the hidden layers to the output layers. we use the current values of the weights forwardpass after propagating the input values to the output layer we need to calculate the output error for each output neuron. this error is the difference between the desired output and the calculated output this difference is multiplied by the value of the calculated a java class library for back propagation output neuron value that is first modified by the sigmoid function that we saw in figure the sigmoid function is to clamp the calculated output value to a reasonable range. for o numoutputs o output_errorso outputso sigmoidpoutputso the errors for the neuron activation values in the second hidden layer hidden layer connected to the output layer are estimated by summing for each hidden neuron its contribution to the errors of the output layer neurons. the thing to notice is that if the connection weight value between hidden neuron h and output neuron o is large then hidden neuron h is contributing more to the error of output neuron o than other neurons with smaller connecting weight values for h h for o numoutputs o output_errorso we estimate the errors in activation energy for the first hidden layer neurons by using the estimated errors for the second hidden layers that we calculated in the last code snippet for h h for o o after we have scaled estimates for the activation energy errors for both hidden layers we then want to scale the error estimates using the derivative of the sigmoid function s value of each hidden neuron s activation energy neural networks for h h for h h now that we have estimates for the hidden layer neuron errors we update the weights connecting to the output layer and each hidden layer by adding the product of the current learning rate the estimated error of each weight s target neuron and the value of the weight s source neuron update the to output weights for o numoutputs o for h h training_rate output_errorso update the to weights for o o for h h training_rate update the input to weights for h h for i numinputs i training_rate inputsi for o numoutputs o error math.absoutso outputso the last step in this code snippet was to calculate an average error over all output neurons for this training example. this is important so that we can track the training adding momentum to speed up back-prop training status in real time. for very long running back-prop training experiments i like to be able to see this error graphed in real time to help decide when to stop a training run. this allows me to experiment with the learning rate initial value and see how fast it decays. the last thing that method train needs to do is to update the training example counter so that the next example is used the next time that train is called current_example if num_cases current_example return error you can look at the implementation of the swing gui test class gu t est to see how i decrease the training rate during training. i also monitor the summed error rate over all output neurons and occasionally randomize the weights if the network is not converging to a solution to the current problem. adding momentum to speed up back-prop training we did not use a momentum term in the java code in section for difficult to train problems adding a momentum term can drastically reduce the training time at a cost of doubling the weight storage requirements. to implement momentum we remember how much each weight was changed in the previous learning cycle and make the weight change larger if the current change in direction is the same as the last learning cycle. for example if the change to weight wij had a large positive value in the last learning cycle and the calculated weight change for wij is also a large positive value in the current learning cycle then make the current weight change even larger. adding a momentum term not only makes learning faster but also increases the chances of sucessfully learning more difficult problems. i modified two of the classes from section to use momentum neural momentum.java training and recall for two hidden layer backprop networks. the constructor has an extra argument alpha that is a scaling factor for how much of the previous cycle s weight change to add to the new calculated delta weight values. guitest momentum.java a gui test application that tests the new class n eural momentum. the code for class n eural momentum is similar to the code for n eural that we saw in the last section so here we will just look at the differences. the neural networks class constructor now takes another parameter alpha that determines how strong the momentum correction is when we modify weight values momentum scaling term that is applied to last delta weight private float alpha while this alpha term is used three times in the training code it suffices to just look at one of these uses in detail. when we allocated the three weight arrays w w and w we also now allocate three additional arrays of corresponding same size w last delta w last delta and w last delta. these three new arrays are used to store the weight changes for use in the next training cycle. here is the original code to update w from the last section training_rate output_errorso the following code snippet shows the additions required to use momentum training_rate output_errorso apply the momentum term alpha training_rate output_errorso i mentioned in the last section that there are two techniques for training back-prop networks updating the weights after processing each training example or waiting to update weights until all training examples are processed. i always use the first method when i don t use momentum. in many cases it is best to use the second method when using momentum. machine learning with weka weka is a standard java tool for performing both machine learning experiments and for embedding trained models in java applications. i have used weka since and it is usually my tool of choice on machine learning projects that are compatible with weka s use of the gpl license. in addition to the material in this chapter you should visit the primary weka web site www.cs.waikato.ac.nzmlweka for more examples and tutorials. good online documentation can also be found at weka.sourceforge.netwekadoc. weka can be run both as a gui application and for using a command line interface for running experiments. while the techniques of machine learning have many practical applications the example used in this chapter is simple and is mostly intended to show you the techniques for running weka and techniques for embedding weka in your java applications. full documentation of the many machine learning algorithms is outside the scope of this chapter. in addition to data cleansing and preprocessing utilities for data normalization resampling transformations etc. weka supports most machine-learning techniques for automatically calculating classification systems. i have used the following weka learning modules in my own work nave bayes uses bayes s rule for probability of a hypothesis given evidence. instance-based learner stores all training examples and use. a learning scheme by j ross quinlan that calculates decision trees from training data. we will use the algorithm in this chapter. weka can be used for both unsupervised and supervised learning. an example of unsupervised learning is processing a set of unlabeled data and automatically clustering the data into smaller sets containing similar items. we will use supervised learning as the example in this chapter data on daily stock prices is labeled as buy sell or hold. we will use the algorithm to automatically build a decision tree for deciding on how to process a stock given its cost data. this example is simplistic and should not be used to actually trade stocks. it is also possible to induce rules from training data that are equivalent to decision trees for the same training data. the learned model uses linear combinations of attribute values for classification. we are going to use a simple example to learn how to use weka interactively and machine learning with weka embedded in applications in the next two sections. weka uses a data file format call arff. the following listing shows the sample arff input file that we will use in the next two sections stock percent_change_since_open real percent_change_from_day_low real percent_change_from_day_high real action sell hold here the concept of a relation is similar to a relation in powerloom as we saw in chapter a relation has a name and a list of attributes each with an allowed data type. here the relation name is stock and we have three attributes that have floating point values and a fourth attribute that has an enumeration of discrete allowed values. the section defines data for initializing nine stock relations. using weka s interactive gui application the weka jar file is included with the zip file for this book. to run the weka gui application change directory to test data and type java once you have loaded possibly browsed the data as seen in figure you can then select the classifier tab and using the choose classifier option find under the trees submenu and click the start button. the results can be seen in figure using weka s interactive gui application figure running the weka data explorer figure running the weka data explorer machine learning with weka the decision tree is displayed in the classifier output window pane. we will run this same problem from the command line in the next section and then discuss the generated decision tree seen in the lower right panel of the gui display seen in figure interactive command line use of weka we will run the same problem as in the previous section and discuss the sections of the output report java stock_training_data.arff pruned tree percent_change_from_day_low percent_change_since_open sell percent_change_since_open hold percent_change_from_day_low buy number of leaves size of the tree the generated decision tree can be described in english as if the percent change of a stock from the day low is less than or equal to then if the percent change since the open is less than then sell the stock otherwise keep it. if the percent change from the day low is greater than then purchase more shares. time taken to build model seconds time taken to test model on training data seconds error on training data correctly classified instances incorrectly classified instances kappa statistic mean absolute error root mean squared error interactive command line use of weka relative absolute error root relative squared error total number of instances this output shows results for testing on the original training data so the classification is perfect. in practice you will test on separate data sets. confusion matrix classified as a b c a buy b sell c hold the confusion matrix shows the prediction for each data sample here we see the original data buy three sell and three hold samples. the following output shows random sampling testing stratified cross-validation correctly classified instances incorrectly classified instances kappa statistic mean absolute error root mean squared error relative absolute error root relative squared error total number of instances with random sampling we see in the confusion matrix that the three buy recommendations are still perfect but that both of the sell recommendations are wrong one buy and two holds and that two of what should have been hold recommendations are buy recommendations. confusion matrix classified as a b c a buy b sell c hold machine learning with weka embedding weka in a java application the example in this section is partially derived from documentation at the web site httpweka.sourceforge.netwiki. this example loads the training arff data file seen at the beginning of this chapter and loads a similar arff file for testing that is equivalent to the original training file except that small random changes have been made to the numeric attribute values in all samples. a decision tree model is trained and tested on the new test arff data. import weka.classifiers.meta.filteredclassifier import import weka.core.instances import weka.filters.unsupervised.attribute.remove import java.io.bufferedreader import java.io.filenotfoundexception import java.io.filereader import java.io.ioexception public class wekastocks public static void mainstring args throws exception we start by creating a new training instance by supplying a reader for the stock training arff file and setting the number of attributes to use instances training_data new instances new bufferedreader new filereader training_data.setclassindex training_data.numattributes we want to test with separate data so we open a separate examples arff file to test against instances testing_data new instances new bufferedreader new filereader testing_data.setclassindex training_data.numattributes embedding weka in a java application the method tosummarystring prints a summary of a set of training or testing instances. string summary training_data.tosummarystring int number_samples training_data.numinstances int number_attributes_per_sample training_data.numattributes system.out.println of attributes in model number_attributes_per_sample system.out.println of samples number_samples system.out.printlnsummary summary system.out.println now we create a new classifier classifier in this case and we see how to optionally filter samples. we build a classifier using the training data and then test it using the separate test data set a classifier for decision trees new filter for removing samples remove rm new remove remove first attribute filtered classifier filteredclassifier fc new filteredclassifier fc.setfilterrm train using stock_training_data.arff fc.buildclassifiertraining_data test using stock_testing_data.arff for i i testing_data.numinstances i double pred fc.classifyinstancetesting_data. instancei system.out.printgiven value testing_data.classattribute. valueinttesting_data.instancei. classvalue system.out.println. predicted value machine learning with weka testing_data.classattribute.valueintpred this example program produces the following output output not shown due to page width limits number of attributes in model number of samples summary relation name stock num instances num attributes name type percent_change_since_open num percent_change_from_day_l num percent_change_from_day_h num action nom nom int real given value hold. predicted value hold given value sell. predicted value sell given value buy. predicted value buy given value hold. predicted value buy given value sell. predicted value sell given value buy. predicted value buy given value hold. predicted value hold given value sell. predicted value buy given value buy. predicted value buy suggestions for further study weka is well documented in the book data mining practical machine learning tools and techniques second edition h. witten eibe frank. additional documentation can be found at weka.sourceforge.netwikiindex.php. statistical natural language processing we will cover a wide variety of techniques for processing text in this chapter. the part of speech tagger text categorization clustering spelling and entity extraction examples are all derived from either my open source projects or my commercial projects. i wrote the markov model example code for an earlier edition of this book. i am not offering you a very formal view of statistical natural language processing in this chapter rather i collected java code that i have been using for years on various projects and simplified it to make it easier for you to understand and modify for your own use. the web site httpnlp.stanford.edulinksstatnlp.html is an excellent resource for both papers when you need more theory and additional software for statistical natural language processing. for python programmers i can recommend the statistical nlp toolkit nltk that includes an online book and is licensed using the gpl. tokenizing stemming and part of speech tagging text tokenizing text is the process of splitting a string containing text into individual tokens. stemming is the reduction of words to abbreviated word roots that allow for easy comparison for equality of similar words. tagging is identifying what part of speech each word is in input text. tagging is complicated by many words having different parts of speech depending on context bank the airplane the river bank etc. you can find the code in this section in the code zip file for this book in the files srccomknowledgebooksnlpfasttagfasttag.java and srccomknowledgebooksnlputiltokenizer.java. the required data files are in the directory test data in the files lexicon.txt processing english text and lexicon medpost.txt processing medical text. the fasttag project can also be found on my open source web page httpwww.markwatson.comopensource we will also look at a public domain word stemmer that i frequently use in this statistical natural language processing section. before we can process any text we need to break text into individual tokens. tokens can be words numbers and punctuation symbols. the class t okenizer has two static methods both take an input string to tokenize and return a list of token strings. the second method has an extra argument to specify the maximum number of tokens that you want returned static public liststring wordstoliststring s static public liststring wordstoliststring s int maxr the following listing shows a fragment of example code using this class with the output string text ball rolling quickly went down the hill. liststring tokens tokenizer.wordstolisttext system.out.printlntext for token tokens system.out.printtoken system.out.println this code fragment produces the following output the ball rolling quickly went down the hill. for many applications it is better to stem word tokens to simplify comparison of similar words. for example run runs and running all stem to run. the stemmer that we will use which i believe to be in the public domain is in the file srcpublic domainstemmer.java. there are two convenient apis defined at the end of the class one to stem a string of multiple words and one to stem a single word token public liststring stemstringstring str public string stemonewordstring word we will use both the f astt ag and stemmer classes often in the remainder of this chapter. tokenizing stemming and part of speech tagging text the fasttag project resulted from my using the excellent tagger written by eric brill while he was at the university of pennsylvania. he used machine learning techniques to learn transition rules for tagging text using manually tagged text as training examples. in reading through his doctoral thesis i noticed that there were a few transition rules that covered most of the cases and i implemented a simple fast tagger in common lisp ruby scheme and java. the java version is in the file srccomknowledgebooksnlpfasttagfasttag.java. the file srccomknowledgebooksnlpfasttagreadme.txt contains information on where to obtain eric brill s original tagging system and also defines the tags for both his english language lexicon and the medpost lexicon. table shows the most commonly used tags the readme.txt file for a complete description. tag nn nns nnp nnps cc cd dt in jj jjr jjs pp rb rbr rp vb vbn vbg vbz wp wdt description singular noun plural noun singular proper noun plural proper noun conjunction cardinal number determiner preposition adjective comparative adjective superlative adjective proper pronoun adverb comparative adverb particle verb past participle verb gerund verb present verb wh pronoun wh determiner examples dog dogs california watsons and but or one two the some of in by large small green bigger biggest i he you slowly slowest up off eat eaten eating eats who what which that table most commonly used part of speech tags brill s system worked by processing manually tagged text and then creating a list of words followed by the tags found for each word. here are a few random lines selected from the test datalexicon.txt file arco nnp arctic nnp jj fair jj nn rb statistical natural language processing here arco is a proper noun because it is the name of a corporation. the word arctic can be either a proper noun or an adjective it is used most frequently as a proper noun so the tag nnp is listed before jj. the word fair can be an adjective singular noun or an adverb. the class t agger reads the file lexicon either as a resource stream for example you put lexicon.txt in the same jar file as the compiled t agger and t okenizer class files or as a local file. each line in the lexicon.txt file is passed through the utility method parseline that processes an input string using the first token in the line as a hash key and places the remaining tokens in an array that is the hash value. so we would process the line fair jj nn rb as a hash key of fair and the hash value would be the array of strings the first value is currently used but i keep the other values for future use when the tagger is processing a list of word tokens it looks each token up in the hash table and stores the first possible tag type for the word. in our example the word fair would be assigned temporarily the tag jj. we now have a list of word tokens and an associated list of possible tag types. we now loop through all of the word tokens applying eight transition rules that eric brill s system learned. we will look at the first rule in some detail i is the loop variable in the range number of word tokens and word is the current word at index i rule dt vbp dt nn if ret.geti if word.equalsvbp word.equalsvb ret.seti in english this rule states that if a determiner at word token index i is followed by either a past tense verb or a present tense verb then replace the tag type at index i with nn. i list the remaining seven rules in a short syntax here and you can look at the java source code to see how they are implemented rule convert a noun to a number if appears in the word rule convert a noun to a past participle if named entity extraction from text words.geti ends with rule convert any type to adverb if it ends in rule convert a common noun or nns to an adjective if it ends with rule convert a noun to a verb if the preceding work is rule if a word has been categorized as a common anoun nd it ends with then set its type to plural common noun rule convert a common noun to a present participle verb a gerund my fasttag tagger is not quite as accurate as brill s original tagger so you might want to use his system written in c but which can be executed from java as an external process or with a jni interface. in the next section we will use the tokenizer stemmer and tagger from this section to develop a system for identifying named entities in text. named entity extraction from text in this section we will look at identifying names of people and places in text. this can be useful for automatically tagging news articles with the people and place names that occur in the articles. the secret sauce for identifying names and places in text is the data in the file test datapropername.ser a serialized java data file containing hash tables for human and place names. this data is read in the constructor for the class n ames it is worthwhile looking at the code if you have not used the java serialization apis before objectinputstream p new objectinputstreamins hashtable lastnamehash p.readobject hashtable firstnamehash p.readobject hashtable placenamehash p.readobject hashtable prefixhash p.readobject if you want to see these data values use code like while object key keyse.nextelement system.out.printlnkey placenamehash.getkey statistical natural language processing to see data values like the following mauritius country port-vila country_capital hutchinson us_city mississippi us_state lithuania country before we look at the entity extraction code and how it works we will first look at an example of using the main apis for the n ames class. the following example uses the methods isp lacen ame ishumann ame and getp ropern ames system.out.printlnlos angeles names.isplacenamelos angeles system.out.printlnpresident bush names.ishumannamepresident bush system.out.printlnpresident george bush names.ishumannamepresident george bush system.out.printlnpresident george w. bush names.ishumannamepresident george w. bush scoredlist ret names.getpropernames bush played golf. president george w. bush went to london england and mexico to see mary smith in moscow. president bush will return home monday. system.out.printlnhuman names system.out.printlnplace names the output from running this example is los angeles true president bush true president george bush true president george w. bush true place name london placenamehash.getname country_capital place name mexico placenamehash.getname country_capital place name moscow named entity extraction from text placenamehash.getname country_capital human names george president george w mary president place names the complete implementation that you can read through in the source file extractnames.java is reasonably simple. the methods ishumann ame and isp lacen ame simply look up a string in either of the human or place name hash tables. for testing a single word this is very easy for example public boolean isplacenamestring name return placenamehash.getname null the versions of these apis that handle names containing multiple words are just a little more complicated we need to construct a string from the words between the starting and ending indices and test to see if this new string value is a valid key in the human names or place names hash tables. here is the code for finding multi-word place names public boolean isplacenameliststring words if numwords words.size int startindex int numwords return false if return isplacenamewords.getstartindex string s for istartindex istartindex numwords i if numwords s s words.getstartindex else s s words.getstartindex return isplacenames statistical natural language processing this same scheme is used to test for multi-word human names. the top-level utility method getp ropern ames is used to find human and place names in text. the code in getp ropern ames is intentionally easy to understand but not very efficient because of all of the temporary test strings that need to be constructed. using the wordnet linguistic database the home page for the wordnet project is httpwordnet.princeton.edu and you will need to download version and install it on your computer to use the example programs in this section and in chapter as you can see on the wordnet web site there are several java libraries for accessing the wordnet data files we will use the jaws library written by brett spell as a student project at the southern methodist university. i include brett s library and the example programs for this section in the directory src-jaws-wordnet in the zip file for this book. tutorial on wordnet the wordnet lexical database is an ongoing research project that includes many man years of effort by professional linguists. my own use of wordnet over the last ten years has been simple mainly using the database to determine synonyms synsets in wordnet and looking at the possible parts of speech of words. for reference taken from the wikipedia article on wordnet here is a small subset of the type of relationships contained in wordnet for verbs shown by examples from the wikipedia article hypernym travel general is an hypernym of movement general entailment to sleep is entailed by to snore because you must be asleep to snore here are a few of the relations supported for nouns hypernyms canine is a hypernym of dog since every dog is of type canine hyponyms dog general is a hyponym of canine general holonym building is a holonym of window because a window is part of a building meronym window is a meronym of building because a window is part of a building some of the related information maintained for adjectives is related nouns similar to using the wordnet linguistic database i find the wordnet book an electronic lexical database speech and communication by christiane fellbaum to be a detailed reference for wordnet but there have been several new releases of wordnet since the book was published. the wordnet site and the wikipedia article on wordnet are also good sources of information if you decide to make wordnet part of your toolkit httpwordnet.princeton.edu httpen.wikipedia.orgwikiwordnet we will brett s open source java wordnet utility library in the next section to experiment with wordnet. there are also good open source client applications for browsing the wordnet lexical database that are linked on the wordnet web site. example use of the jaws wordnet library assuming that you have downloaded and installed wordnet on your computer if you look at the data files themselves you will notice that the data is divided into index and data files for different data types. the jaws library other wordnet client libraries for many programming languages provides a useful view and convenient access to the wordnet data. you will need to define a java property for the location of the raw wordnet data files in order to use jaws on my system i set the example class w ordn ett est finds the different word senses for a given word and prints this data to standard output. we will tweak this code slightly in the next section where we will be combining wordnet with a part of speech tagger in another example program. accessing wordnet data using brett s library is easy so we will spend more time actually looking at the wordnet data itself. here is a sample program that shows how to use the apis. the class constructor makes a connection to the wordnet data files for reuse public class wordnettest public wordnettest database wordnetdatabase.getfileinstance here i wrap a jaws utility method to return lists of synsets instead of raw java arrays statistical natural language processing public listsynset getsynsetsstring word return arrays.aslistdatabase.getsynsetsword public static void mainstring args the constant p ropertyn ames.dat abase direct ory is equal to wordnet.database.dir. it is a good idea to make sure that you have this java property set if the value prints as null then either fix the way you set java properties or just set it explicitly system.setpropertypropertynames.database_directory wordnettest tester new wordnettest string word listsynset synset_list tester.getsynsetsword system.out.printlnnn process word word for synset synset_list system.out.printlnnsynset type synset_typessynset.gettype.getcode system.out.println definition synset.getdefinition word forms are synonyms for wordform synset.getwordforms if system.out.println synonym wordform antonyms are the opposites to synonyms. notice that antonyms are specific to individual senses for a word. this is why i have the following code to display antonyms inside the loop over word forms for each word sense for bank antonyms mean the opposite for antonym synset.getantonymswordform for opposite antonym.getsynset.getwordforms system.out.println wordform opposite antonym using the wordnet linguistic database system.out.printlnn private wordnetdatabase database private final static string synset_types using this example program we can see the word bank has different senses noun and verb senses process word bank synset type noun definition sloping land the slope synset type beside a body of water noun definition a financial institution that accepts deposits and channels the money into lending activities depository financial institution banking concern banking company noun synonym synonym synonym synset type definition a long ridge or pile synset type noun definition an arrangement of similar objects synset type in a row or in tiers noun definition a supply or stock held in reserve synset type for future use in emergencies noun definition the funds held by a gambling house synset type or the dealer in some gambling games noun definition a slope in the turn of a road or synonym synonym synset type track the outside is higher than the inside in order to reduce the effects of centrifugal force cant camber noun definition a container with a slot statistical natural language processing synonym synonym synonym synset type in the top for keeping money at home savings bank coin bank money box noun definition a building in which the business synonym synset type of banking transacted bank building noun definition a flight maneuver aircraft synset type tips laterally about its longitudinal axis in turning verb definition tip laterally synset type verb definition enclose with a bank synset type verb definition do business with a bank or synset type keep an account at a bank verb definition act as the banker in a game synset type or in gambling verb definition be in the banking business synset type verb definition put into a bank account synonym deposit antonym deposit withdraw antonym deposit draw antonym deposit take out antonym deposit draw off synset type verb definition cover with ashes so to control synset type the rate of burning verb definition have confidence or faith in synonym trust antonym trust distrust antonym trust mistrust antonym trust suspect antonym trust distrust antonym trust mistrust antonym trust suspect using the wordnet linguistic database synonym synonym swear rely wordnet provides a rich linguistic database for human linguists but although i have been using wordnet since i do not often use it in automated systems. i tend to use it for manual reference and sometimes for simple tasks like augmenting a list of terms with synonyms. in the next two sub-sections i suggest two possible projects both involving use of synsets i have used both of these suggested ideas in my own projects with some success. suggested project using a part of speech tagger to use the correct wordnet synonyms we saw in section that wordnet will give us both synonyms and antonyms meaning of words. the problem is that we can only get words with similar and opposite meanings for specific senses of a word. using the example in section synonyms of the word bank in the sense of a verb meaning have confidence or faith in are trust swear rely while synonyms for bank in the sense of a noun meaning a financial institution that accepts deposits and channels the money into lending activities are depository financial institution banking concern banking company so it does not make too much sense to try to maintain a data map of synonyms for a given word. it does make some sense to try to use some information about the context of a word. we can do this with some degree of accuracy by using the part of speech tagger from section to at least determine that a word in a sentence is a noun or a verb and thus limit the mapping of possible synonyms for the word in its current context. statistical natural language processing suggested project using wordnet synonyms to improve document clustering another suggestion for a wordnet-based project is to use the tagger to identify the probable part of speech for each word in all text documents that you want to cluster and augment the documents with sysnset data. you can then cluster the documents similarly to how we will calculate document similarity in section automatically assigning tags to text by tagging i mean assigning zero or more categories like politics economy etc. to text based on the words contained in the text. while the code for doing this is simple there is usually much work to do to build a word count database for different classifications. i have been working on commercial products for automatic tagging and semantic extraction for about ten years www.knowledgebooks.com if you are interested. in this section i will show you some simple techniques for automatically assigning tags or categories to text using some code snippets from my own commercial product. we will use a set of tags for which i have collected word frequency statistics. for example a tag of java might be associated with the use of the words java jvm sun etc. you can find my pre-trained tag data in the file test_dataclassification_tags.xml the java source code for the class autot agger is in the file src-statistical-nlp comknowledgebooksnlpautotagger.java the autot agger class uses a few data structures to keep track of both the names of tags and the word count statistics for words associated with each tag name. i use a temporary hash table for processing the xml input data private static hashtablestring hashtablestring float tagclasses the names of tags used are defined in the xml tag data file change this file and you alter both the tags and behavior of this utility class. here is a snippet of data automatically assigning tags to text defined in the xml tag data file describing some words their scores associated with the tag religion buddhism namereligion_buddhism namebuddhism namebuddhist namemind namemedit namebuddha namepractic nameteach namepath namemantra namethought nameschool namezen namemahayana namesuffer namedharma nametibetan notice that the term names are stemmed words and all lower case. there are tags defined in the input xml file included in the zip file for this book. for data access i also maintain an array of tag names and an associated list of the word frequency hash tables for each tag name private static string tagclassnames private static listhashtablestring float hashes new arraylisthashtablestring float the xml data is read and these data structures are filled during static class load time so creating multiple instances of the class autot agger has no performance penalty in either memory use or processing time. except for an empty default class constructor there is only one public api for this class the method gett ags public listnamevaluestring float gettagsstring text statistical natural language processing the utility class n amev alue is defined in the file src-statistical-nlp comknowledgebooksnlputilnamevalue.java to determine the tags for input text we keep a running score for each defined tag type. i use the internal class sf triple to hold triple values of word score and tag index. i choose the tags with the highest scores as the automatically assigned tags for the input text. scores for each tag are calculated by taking each word in the input text stemming it and if the stem is in the word frequency hash table for the tag then add the score value in the hash table to the running sum for the tag. you can refer to the autotagger.java source code for details. here is an example use of class autot agger autotagger test new autotagger string s president went to congress to argue for his tax bill before leaving on a vacation to las vegas to see some shows and gamble. listnamevaluestring float results for float result results system.out.printlnresult test.gettagss the output looks like news_economy news_politics text clustering the text clustering system that i have written for my own projects in simplified form will be used in the section. it is inherently inefficient when clustering a large number of text documents because i perform significant semantic processing on each text document and then compare all combinations of documents. the runtime performance is on where n is the number of text documents. if you need to cluster or compare a very large number of documents you will probably want to use a k-mean clustering algorithm for k-mean clustering java for some open source projects. text clustering i use a few different algorithms to rate the similarity of any two text documents and i will combine these depending on the requirements of the project that i am working on calculate the intersection of common words in the two documents. calculate the intersection of common word stems in the two documents. calculate the intersection of tags assigned to the two documents. calculate the intersection of human and place names in the two documents. in this section we will implement the second option calculate the intersection of word stems in two documents. without showing the package and import statements it takes just a few lines of code to implement this algorithm when we use the stemmer class. the following listing shows the implementation of class comparabledocument with comments. we start by defining constructors for documents defined by a f ile object and a string object public class comparabledocument disable default constructor calls private comparabledocument public comparabledocumentfile document throws filenotfoundexception thisnew scannerdocument. usedelimiterz.next public comparabledocumentstring text liststring stems new stemmer.stemstringtext for stem stems stem_count if integer count stemcountmap.getstem stemcountmap.putstem count else stemcountmap.putstem in the last constructor i simply create a count of how many times each stem occurs in the document. statistical natural language processing the public api allows us to get the stem count hash table the number of stems in the original document and a numeric comparison value for comparing this document with another is the first version we will add an improvement later public mapstring integer getstemmap return stemcountmap public int getstemcount return stem_count public float comparetocomparabledocument otherdocument long count mapstringinteger otherdocument.getstemmap iterator iter stemcountmap.keyset.iterator while object key iter.next integer stemcountmap.getkey integer if count return math.sqrt otherdocument.getstemcount private mapstring integer stemcountmap new hashmapstring integer private int stem_count i normalize the return value for the method comparet o to return a value of if compared documents are identical stemming and if they contain no common stems. there are four test text documents in the test data directory and the following test code compares various combinations. note that i am careful to test the case of comparing identical documents comparabledocument new comparabledocument text clustering new comparabledocument new comparabledocument new system.out.printlnnews system.out.printlnnews system.out.printlnnews system.out.printlnnews system.out.printlnecon system.out.printlnnews system.out.printlnecon system.out.printlnecon the following listing shows output that indicates mediocre results we will soon make an improvement that makes the results better. the output for this test code is news news news news econ news econ econ there is not as much differentiation in comparison scores between political news stories and economic news stories. what is up here? the problem is that i did not remove common words therefore common word stems when creating stem counts for each document. i wrote a utility class n oisew ords for identifying both common words and their stems you can see the implementation in the file noisewords.java. removing noise words improves the comparison results added a few tests since the last printout news statistical natural language processing news news news econ news econ much better results! the api for com.knowledgebooks.nlp.util.noisewords is public static boolean checkforstring stem you can add additional noise words to the data section in the file noisewords.java depending on your application. spelling correction automating spelling correction is a task that you may use for many types of projects. this includes both programs that involve users entering text that will be automatically processed with no further interaction with the user and for programs that keep the user in the loop by offering them possible spelling choices that they can select. i have used five different approaches in my own work for automating spelling correction and getting spelling suggestions an old project of mine complex but with good accuracy embedding the gnu aspell utility use the lgpl licensed jazzy spelling checker port of the gnu aspell spelling system to java using peter norvig s statistical spelling correction algorithm using norvig s algorithm adding word pair statistics we will use the last three options in the next sections and in section where we will extend norvig s algorithm by also using word pair statistics. this last approach is computationally expensive and is best used in applications with a highly specialized domain of discourse systems dealing just with boats sports etc.. section also provides a good lead in to section dealing with a similar but more general technique covered later in this chapter markov models. spelling correction gnu aspell library and jazzy the gnu aspell system is a hybrid system combining letter substitution and addition we will implement as a short example program in section the soundex algorithm and dynamic programming. i consider aspell to be a best of breed spelling utility and i use it fairly frequently with scripting languages like ruby where it is simple to shell out and run external programs. you can also shell out external commands to new processes in java but there is no need to do this if we use the lgpled jazzy library that is similar to aspell and written in pure java. for the sake of completeness here is a simple example of how you would use aspell as an external program first we will run aspell on in a command shell all output is shown markw echo doog international ispell really aspell ths th s this thus th doog dog doug dong door list this output is easy enough to parse here is an example in ruby perl or java would be similar def aspell text s echo list s s.splitn s.shift results s.each tokens line.split header results tokens.collect tt.strip if results end i include the source code to the lgpled jazzy library and a test class in the directory src-spelling-jazzy. the jazzy library source code is in the sub-directory comswabunga. we will spend no time looking at the implementation of the jazzy library this short section is simply meant to get you started quickly using jazzy. here is the test code from the file spellingjazzytester.java statistical natural language processing file dict new spellchecker checker new spellcheckernew spelldictionaryhashmapdict int threshold computational cost threshold system.out.printlnchecker.getsuggestionsrunnng system.out.printlnchecker.getsuggestionsseason system.out.printlnchecker.getsuggestions threshold threshold threshold the method getsuggestions returns an arraylist of spelling suggestions. this example code produces the following output seasons reason advantages the file test contains an alphabetically ordered list of words one per line. you may want to add words appropriate for the type of text that your applications use. for example if you were adding spelling correction to a web site for selling sailboats then you would want to insert manufacturer and product names to this word list in the correct alphabetical order. the title of this book contains the word practical so i feel fine about showing you how to use a useful open source package like jazzy without digging into its implementation or apsell s implementation. the next section contains the implementation of a simple algorithm and we will study its implementation some detail. peter norvig s spelling algorithm peter norvig designed and implemented a spelling corrector in about lines of python code. i will implement his algorithm in java in this section and in section i will extend my implementation to also use word pair statistics. the class spellingsuggestions uses static data to create an in-memory spelling dictionary. this initialization will be done at class load time so creating instances of this class will be inexpensive. here is the static initialization code with error handling removed for brevity private static mapstring integer wordcounts spelling correction new hashmapstring integer static use peter norvig s training file big.txt httpwww.norvig.comspell-correct.html fileinputstream fstream new fileinputstreamtmpbig.txt datainputstream in new datainputstreamfstream bufferedreader br new bufferedreadernew inputstreamreaderin string line while br.readline null liststring words tokenizer.wordstolistline for word words if integer count wordcounts.getword wordcounts.putword count else wordcounts.putword in.close the class has two static methods that implement the algorithm. the first method edits seen in the following listing is private and returns a list of permutations for a string containing a word. permutations are created by removing characters by reversing the order of two adjacent characters by replacing single characters with all other characters and by adding all possible letters to each space between characters in the word private static liststring editsstring word int wordl word.length wordl liststring possible new arrayliststring drop a character for i wordl i reverse order of characters for i i word.substringi statistical natural language processing replace a character in each location in the word for i wordl for ch a ch z i ch add in a character in each location in the word for i wordl for ch a ch z i ch word.substringi return possible here is a sample test case for the method edits where we call it with the word cat and get a list of permutations ct ca act cta aat bat cat fat cct cdt cet caty catz the public static method correct has four possible return values if the word is in the spelling hash table simply return the word. generate a permutation list of the input word using the method edits. build a hash table candidates from the permutation list with keys being the word count in the main hashtable wordcounts with values of the words in the permutation list. if the hash table candidates is not empty then return the permutation with the best key count value. for each new word in the permutation list call the method edits with the word creating a new candidates hash table with permutations of permutations. if candidates is not empty then return the word with the highest score. return the value of the original word suggestions. public static string correctstring word ifwordcounts.containskeyword return word liststring list editsword spelling correction candidate hash has word counts as keys word as value hashmapinteger string candidates new hashmapinteger string for testword list ifwordcounts.containskeytestword candidates.putwordcounts.gettestword testword if candidates is not empty then return the word with the largest key count value ifcandidates.size return candidates.get collections.maxcandidates.keyset if the edits method does not provide a candidate word that matches then we will call edits again with each previous permutation words. note this case occurs only about candidates.clear for editwords list of the time and obviously increases the runtime of method correct. for wrd editseditwords ifwordcounts.containskeywrd candidates.putwordcounts.getwrdwrd if return candidates.get collections.maxcandidates.keyset return word statistical natural language processing although peter norvig s spelling algorithm is much simpler than the algorithm used in aspell it works well. i have used norvig s spelling algorithm for one customer project that had a small specific vocabulary instead of using aspell. we will extend norvig s spelling algorithm in the next section to also take advantage of word pair statistics. extending the norvig algorithm by using word pair statistics it is possible to use statistics for which words commonly appear together to improve spelling suggestions. in my experience this is only worthwhile when applications have two traits the vocabulary for the application is specialized. for example a social networking site for people interested in boating might want a more accurate spelling system than one that has to handle more general english text. in this example common word pairs might be multi-word boat and manufacturer names boating locations etc. there is a very large amount of text in this limited subject area to use for training. this is because there will be many more combinations of word pairs than words and a very large training set helps to determine which pairs are most common rather than just coincidental. we will proceed in a similar fashion to the implementation in the last section but we will also keep an additional hash table containing counts for word pairs. since there will be many more word pair combinations than single words you should expect both the memory requirements and cpu time for training to be much larger. for one project there was so much training data that i ended up having to use diskbased hash tables to store word pair counts. to make this training process take less training time and less memory to hold the large word combination hash table we will edit the input file big.txt from the last section deleting the lines that contain random words added to the end of the project gutenberg texts. furthermore we will experiment with an even smaller version of this file small.txt that is about ten percent of the size of the original training file. because we are using a smaller training set we should expect marginal results. for your own projects you should use as much data as possible. in principle when we collect a word pair hash table where the hash values are the number of times a word pair occurs in the training test we would want to be sure that we do not collect word pairs across sentence boundaries and separate phrases occurring inside of parenthesis etc. for example consider the following text fragment spelling correction he went to paris. the weather was warm. optimally we would not want to collect statistics on word token pairs like paris or paris the that include the final period in a sentence or span a sentence. in a practical sense since we will be discarding seldom occurring word pairs it does not matter too much so in our example we will collect all tokenized word pairs at the same time that we collect single word frequency statistics pattern p pattern.compile. scanner scanner new scannernew filetmpsmall.txt scanner.usedelimiterp string last while string word scanner.next if integer count wordcounts.getword wordcounts.putword count else wordcounts.putword string pair last word if integer count wordpaircounts.getpair wordpaircounts.putpair count else wordpaircounts.putpair last word scanner.close for the first page of text in the test file if we print out word pairs that occur at least two times using this code for pair wordpaircounts.keyset if system.out.printlnpair wordpaircounts.getpair then we get this output statistical natural language processing arthur conan by sir of sherlock project gutenberg how to the adventures sherlock holmes sir arthur adventures of information about conan doyle the words conan and doyle tend to appear together frequently. if we want to suggest spelling corrections for the author conan doyyle wrote it seems intuitive that we can prefer the correction doyle since if we take the possible list of corrections for doyyle and combine each with the preceding word conan in the text then we notice that the hash table wordp aircounts has a relatively high count for the key conan doyle that is a single string containing a word pair. in theory this may look like a good approach but there are a few things that keep this technique from being generally practical it is computationally expensive to train the system for large training text. it is more expensive computationally to perform spelling suggestions. the results are not likely to be much better than the single word approach unless the text is in one narrow domain and you have a lot of training text. in the example of misspelling doyyle calling the method edits editsdoyyle returns a list with elements. the method edits is identical to the one word spelling corrector in the last section. i changed the method correct by adding an argument for the previous word factoring in statistics from the word pair count hash table and for this example by not calculating edits of edits as we did in the last section. here is the modified code public string correctstring word ifwordcounts.containskeyword return word liststring list editsword string previous_word spelling correction candidate hash has as word counts as keys word as value hashmapinteger string candidates for testword list new hashmapinteger string look for word pairs with testword in the second position string word_pair previous_word testword int int count_from_word_pairs ifwordcounts.containskeytestword wordcounts.gettestword candidates.putwordcounts.gettestword testword if count_from_word_pairs wordpaircounts.getword_pair look for word pairs with testword in the first position word_pair testword previous_word if count_from_word_pairs wordpaircounts.getword_pair int sum count_from_word_pairs if candidates.putsum testword if candidates is not empty then return the word with the largest key count value ifcandidates.size return candidates.get collections.maxcandidates.keyset return word statistical natural language processing using word pair statistics can be a good technique if you need to build an automated spelling corrector that only needs to work on text in one subject area. you will need a lot of training text in your subject area and be prepared for extra work performing the training as i mentioned before for one customer project i could not fit the word pair hash table in memory the server that i had to use so i had to use a disk-based hash table the training run took a long while. another good alternative for building systems for handling text in one subject area is to augment a standard spelling library like aspell or jazzy with custom word dictionaries. hidden markov models we used a set of rules in section to assign parts of speech tags to words in english text. the rules that we used were a subset of the automatically generated rules that eric brill s machine learning thesis project produced. his thesis work used markov modeling to calculate the most likely tag of words given precceding words. he then generated rules for taging some of which we saw in section where we saw brill s published results of the most useful learned rules made writing a fast tagger relatively easy. in this section we will use word-use statistics to assign word type tags to each word in input text. we will look in some detail at one of the most popular approaches to tagging text building hidden markov models and then evaluating these models against input text to assign word use part of speech tags to words. a complete coverage of the commonly used techniques for training and using hmm is beyond the scope of this section. a full reference for these training techniques is foundations of statistical natural language processing schutze we will discuss the training algorithms and sample java code that implements hmm. the example in this chapter is purposely pedantic the example code is intended to be easy to understand and experiment with. in hidden markov models we speak of an observable sequence of events that moves a system through a series of states. we attempt to assign transition probabilities based on the recent history of states of the system the last few events. in this example we want to develop an hmm that attempts to assign part of speech tags to english text. to train an hmm we will assume that we have a large set of training data that is a sequence of words and a parallel sequence of manually assigned part of speech tags. we will see an example of this marked up training text that looks like johnnnp chasedvb thedt dognn later in this section. for developing a sample java program to learn how to train a hmm we assume that we have two java lists words and tags that are of the same length. so we will have one list of words like john chased the dog and an associated list of part hidden markov models of speech tags like nnp vb dt nn once the hmm is trained we will write another method test model that takes as input a java vector of words and returns a java vector of calculated part of speech tags. we now describe the assumptions made for markov models and hidden markov models using this part of speech tagging problem. first assume that the desired part of speech tags are an observable sequence like tn and the original word sequence is wn we will also assume that the probability of tag tm having a specific value is only a function of tm and wmandwm here we are only using the last state in some applications instead of using the last observed state we might use the last two states greatly increasing the resources time and memory required for training. for our example we will assume that we have a finite lexicon of words. we will use a hash table that uses the words in the lexicon as keys and the values are the possible parts of speech. for example assuming the lexicon hash table is named lexicon we use the notation lexicon a-word list of possible tags table shows some of the possible tags used in our example system. tag name part of speech vb nn adj adv in nnp verb noun adjective adverb preposition noun table sample part of speech tags statistical natural language processing as an example we might have a lexicon entry lexicon bank nn vb where the work bank could be a noun i went to the bank or a verb to turn bank the airplane in the example program i use a hash table to hold the lexicon in the file markov.java mapstringliststring lexicon new hashtablestringliststring another hash table keeps a count of how frequently each tag is used mapstring integer tags new hashtablestring integer mapstring integer words new hashtablestring integer as you will see in tables and we will be operating on arrays where in the first two tables the rows and columns represent unique tag names and in the last table the columns represent unique words and the columns represent unique tag names. we use the following data structures to keep a list of unique tags and words hash table will not work since we need an ordered sequence liststring uniquetags new arrayliststring liststring uniquewords new arrayliststring we will look at the training algorithm and implementation in the next section. training hidden markov models we will be using code in the file markov.java and i will show snippets of this file with comments in this section. you can refer to the source code for the complete implementation. there are four main methods in the class m arkov build words and tags print statistics train model test model hidden markov models jj jj in vb vbn to nnp prp nn rb vbg dt in vb vbn to nnp prp nn rb vbg dt table transition counts from the first tag in row to the second tag in column. we see that the transition from nnp to vb is common. in order to train a markov model to tag parts of speech we start by building a twodimensional array using the method build words and tags that uses the following array to count transitions part of this array was seen in figure tagt ot agt ransitioncountuniquet agcountuniquet agcount where the first index is the index of tagn and the second index is the index of we will see later how to calculate the values in this array and then how the values in this two-dimensional array will be used to calculate the probabilities of transitioning from one tag to another. first however we simply use this array for counting transitions between pairs of tags. the purpose of the training process is to fill this array with values based on the hand-tagged training file training datamarkovtagged text.txt that looks like this johnnnp chasedvb thedt dognn downrp thedt streetnn iprp sawvb johnnnp dogvb marynnp andcc laterrb marynnp throwvb thedt ballnn toto johnnnp onin thedt streetnn the method build words and tags parses this text file and fills the uniquet ags and uniquew ords collections. the method train model starts by filling the tag to tag transition count arraysee table statistical natural language processing tagt ot agt ransitioncount the element tagt ot agt ransitioncountindext is incremented whenever we find a transition of tagn to in the input training text. the example program writes a spreadsheet style csv file for this and other two-dimensional arrays that are useful for viewing intermediate training results in any spreadsheet program. we normalized the data seen in table by dividing each element by the count of the total number of tags. this normalized data can be seen in table the code for this first step is start by filling in the tag to tag transition count matrix tagtotagtransitioncount new floatuniquetagcountuniquetagcount ptagcounttagcount puniquetagcountuniquetagcount for i i uniquetagcount i for j j uniquetagcount j tagtotagtransitioncountij string int inefficient int for i wordlist.size i i taglist.geti inefficient writecsvfileuniquetags uniquetags tagtotagtransitioncount note that all calls to the utility method w ritecsv f ile are for debug only if you use this example on a large training set a large text corpus like treebank of hand-tagged text then these arrays containing transition and probability values will be very large so viewing them with a spreadsheet is convenient. then the method train model calculates the probabilities of transitioning from tagn to tagm table here is the code for calculating these transition probabilities now calculate the probabilities of transitioning hidden markov models jj jj in vb vbn to nnp prp nn rb vbg dt in vb vbn to nnp prp nn rb vbg dt table normalize data in table to get probability of one tag in row transitioning to another tag in column from tagn to tagm new floatuniquetagcountuniquetagcount for i i uniquetagcount i int count ptag uniquetags.geti countcount for j j uniquetagcount j tagtotagtransitioncountij writecsvfileuniquetags uniquetags finally in the method train model we complete the training by defining the array probabilityw ordgivent aguniquew ordcountuniquet agcount which shows the probability of a tag at index n producing a word at index n in the input training text. here is the code for this last training step now calculate the probability of a word given statistical natural language processing went mary played river leave dog away chased at tired good had throw from so stayed absense street john ball on cat later she of with saw jj in vb vbn to nnp prp nn rb table probabilities of words having specific tags. only a few tags are shown in this table. hidden markov models a proceeding tag probabilitywordgiventag new floatuniquewordcountuniquetagcount for i i uniquewordcount i string tag uniquetags.getj for j j uniquetagcount j string tag uniquetags.getj note index of tag is one less than index of emitted word we are testing int counttagoccurence tags.gettag float wordwithtagoccurence for n string testword wordlist.getn string testtag taglist.getn if testtag.equalstag wordwithtagoccurence probabilitywordgiventagij wordwithtagoccurence writecsvfileuniquewords uniquetags probabilitywordgiventag using the trained markov model to tag text from section we have the probabilities of a given tag being assigned to words in the lexicon and we have the probability of a given tag given the preceding tag. we will use this information in a brute force way in the method test model we will iterate through all possible tagging possibilities and rate them using the formula from foundations of statistical natural language processing page rating p p p is the probability of word having a tag value tag and p is the probability of tagi following tagi we can simply implement two nested loops over all possible tags for each input word and use the tag for each word with the highest rating statistical natural language processing the arrays for these probabilities in markov.java are probabilityw ordgivent ag and probabilityt ot the logic for scoring a specific tagging possibility for a sequence of words in the method score. the method exponential tagging algorithm is the top level api for tagging words. please note that the word sequence that you pass to exponential tagging algorithm must not contain any words that were not in the original training data in the file tagged text.txt. public liststring exponential_tagging_algorithmliststring words possibletags new arraylistarrayliststring int num words.size indices new intnum counts new intnum int best_indices new intnum for inum i indicesi countsi for inum i string word words.geti liststring v lexicon.getword possible tags at index i arrayliststring new arrayliststring for jv.size j string tag v.getj if false countsi possible tags at index i system.out.print word word tag count countsi tags for j system.out.print system.out.println float best_score do system.out.printcurrent indices for knum k system.out.print indicesk hidden markov models system.out.println float score scorewords if best_score best_score score system.out.println new best score best_score for mnum m best_indicesm indicesm while see text below liststring tags new arrayliststringnum for inum i liststring v possibletags.geti tags.addv.getbest_indicesi return tags the method incrementindices is responsible for generating the next possible tagging for a sequence of words. each word in a sequence can have one or more possible tags. the method incrementindices counts with a variable base per digit position. for example if we had four words in an input sequence with the first and last words only having one possible tag value and the second having two possible tag values and the third word having three possible tag values then incrementindices would count like this the generated indices each row in this listing are stored in the class instance variable indices which is used in method score increment the class variable indices to point to the next possible set of tags to check. statistical natural language processing private boolean incrementindicesint num for inum i if indicesi for ji j indicesj return true return false we are not using an efficient algorithm if the word sequence is long. in practice this is not a real problem because you can break up long texts into smaller pieces for tagging for example you might want to tag just one sentence at a time. information gathering we saw techniques for extracting semantic information in chapter and we will augment that material with the use of reuters open calais web services for information extraction from text. we will then look at information discovery in relational database indexing and search tools and techniques. open calais the open calais system was developed by clear forest acquired by reuters. reuters allows free use registration of their named entity extraction web service you can make web service calls a day. you need to sign up and get an access key at www.opencalais.com. starting in i have developed a similar named entity extraction system www.knowledgebooks.com and i sometimes use both open calais and my own system together. the example program in this section expects the key to be set in your environment on my macbook i set i show a fake key get your own you will need to make sure that this value can be obtained from a system.getenv call. the open calais web services support json rest and soap calls. i will use the rest architectural style in this example. the open calais server returns an xml rdf payload that can be directly loaded into rdf data stores like sesame chapter the example class opencalaisclient depends on a trick that may break in future versions of the open calais web service an xml comment block at the top of the returned rdf payload lists the types of entities and their values. for example here is a sample of the header comments with most of the rdf payload removed for brevity information gathering xmlnshttpclearforest.com of the calais web service is governed by the terms of service located at httpwww.opencalais.com. by using this service or the results of the service you agree to these terms of service. country france united states spain person hillary clinton doug hattaway al gore city san francisco provinceorstate texas here we will simply parse out the relations from the comment block. if you want to use sesame to parse the rdf payload and load it into a local rdf repository then you can alternatively load the returned open calais response by modifying the example code from chapter using stringreader sr new stringreaderresult repositoryconnection connection repository.getconnection connection.addsr rdfformat.rdfxml here are a few code snippets code please see the java source file for more details from the file opencalaisclient.java public hashtablestring liststring getpropertynamesandvaluesstring text throws malformedurlexception ioexception hashtablestring liststring ret new hashtablestring liststring you need an open calais license key. the following code sets up the data for a rest style web service call and opens a connection to the server makes the request and retrieves the response in the string variable payload. the java libraries for handling http connections make it simple to make a architecture style web service call and get the response as a text string open calais string licenseid system.getenvopen_calais_key string content text string paramsxml stringbuilder sb new stringbuildercontent.length sb.appendlicenseid.appendlicenseid sb.appendcontent.appendcontent sb.appendparamsxml.appendparamsxml string payload sb.tostring urlconnection connection new urlhttpapi.opencalais.com openconnection connection.addrequestpropertycontent-type connection.addrequestpropertycontent-length string.valueofpayload.length connection.setdooutputtrue outputstream out connection.getoutputstream outputstreamwriter writer new outputstreamwriterout writer.writepayload writer.flush get response from open calais server string result new scanner connection.getinputstream. usedelimiterz.next result result.replacealllt replaceallgt the text that we are parsing looks like country france united states spain person hillary clinton doug hattaway al gore so the text response is parsed to extract a list of values for each property name contained in the string variable result int result.indexofterms of service.-- information gathering result.indexof!-- int result.indexof-- result string lines result.splitn for line lines int index line.indexof if string relation index.trim string entities line.substringindex for i size entities.length i size i entitiesi entitiesi.trim ret.putrelation arrays.aslistentities return ret again i want to point out that the above code depends on the format of xml comments in the returned xml payload so this code may break in the future and require modification. here is an example use of this api string content clinton likes to remind texans that mapstring liststring results new opencalaisclient. getpropertynamesandvaluescontent for key results.keyset system.out.println key results.getkey in this example the string value assigned to the variable content was about words of text from a news article the full text can be seen in the example data files. the output of this example code is person clinton doug hattaway al gore relations city francisco country united states spain provinceorstate information discovery in relational databases there are several ways that you might want to use named entity identification. one idea is to create a search engine that identifies people places and products in search results and offers users a linked set of documents or web pages that discuss the same people places andor products. another idea is to load the rdf payload returned by the open calais web service calls to an rdf repository and support sparql queries. you may also want to modify any content management systems that you use to add tags for documents maintained in a cms using open calais you are limited to the types of entities that they extract. this limitation is one reason why i maintain and support my own system for named entity and classification i like some flexibility in the type of semantic information that i extract from text data. i covered some of the techniques that i use in my own work in section if you decide to implement your own system to replace or augment open calais. information discovery in relational databases we will look at some techniques for using the jdbc meta-data apis to explore relational database resources where you at least have read access rights. in order to make installation of the example programs easier we will use the derby pure java database that is bundled with jdk if you are still using jdk please download the derby.jar file and copy it to the lib directory for the java book examples httpdb.apache.orgderby there are small differences in setting up a jdbc connection to an embedded derby instance rather than accessing a remote server these differences are not important to the material in this section it is mostly a matter of changing a connection call. i will use two xml data sources on us states and the cia world factbook for these examples and start with the program to insert these xml data files into the relational database src-info-disc-rdbscreatesampledatabase.java and continue with a program to print out all metadata that is implemented in the files src-info-disc-rdbsdumpmetadata.java src-info-disc-rdbsdatabasediscovery.java information gathering we will not implement any specific database spidering applications but i will provide some basic access techniques and give you some ideas for using database meta data in your own projects. creating a test derby database using the cia world factbook and data on us states the file test dataxmlfactbook.xml contains data that i obtained from the factbook web site and converted to xml. this xml file contains data for individual countries and a few general regions namearuba locationcaribbean island in the backgrounddiscovered and claimed climatetropical marine little seasonal terrainflat scant vegetation resourcesnegl white sandy beaches hazardslies outside the caribbean hurricane belt est. governmentparliamentary democracy economytourism is the mainstay of the aruban est. languagesdutch papiamento religionsroman catholic protestant capitaloranjestad est. industriestourism transshipment facilities agriculturealoes livestock fish billion oil reexports billion est. million million note the netherlands internet_code.aw information discovery in relational databases the other sample xml file usstates.xml contains information on individual states namealabama abbreval capitalmontgomery industrypaper lumber and wood products agriculturepoultry and eggs cattle the example class createsampledatabases reads both the files factbook.xml and ussattes.xml and creates two tables factbook and states in a test database. the implementation of this utility class is simple just parsing xml data and making jdbc calls to create and populate the two tables. you can look at the java source file for details. using the jdbc meta data apis this chapter is about processing and using data from multiple sources. with the wealth of data stored in relational database systems it is important to know how to spider databases much as you might need to spider data stored on specific web sites. the example class dumpm etadata shows you how to discover tables information about table columns and query all tables in a specific database. the constructor of class dumpm etadata is called with a database uri and prints meta data and data to standard output. this code should be portable to database systems other than derby by changing the driver name. class dumpmetadata public dumpmetadatastring connectionurl throws sqlexception classnotfoundexception class.fornameorg.apache.derby.jdbc.embeddeddriver connection conn drivermanager.getconnectionconnectionurl system.out.printlnconn conn statement s conn.createstatement databasemetadata md conn.getmetadata discovery all table names in this database liststring tablenames new information gathering we will use the method gett ables to fetch a list of all tables in the database. the four arguments are string catalog can be used when database systems support catalogs. we will use null to act as a wildcard match. string schemapattern can be used when database systems support schemas. we will use null to act as a wildcard match. string tablenamepattern a pattern to match table names we will use as a wildcard match. string types the types of table names to return. possible values include table view alias synonym and system table. the method gett ables returns a resultset so we iterate through returned values just as you would in a regular sql query using the jdbc apis resultset table_rs md.gettablesnull null new stringtable while system.out.printlntable loop over all tables printing column meta data and the first row for tablename tablenames system.out.printlnnn processing table tablename string query from tablename system.out.printlnquery resultset rs s.executequeryquery resultsetmetadata table_meta rs.getmetadata int columncount table_meta.getcolumncount system.out.printlnncolumn meta data for table liststring columnnames new columnnames.add for colcolumncount col system.out.printlncolumn col name table_meta.getcolumnlabelcol system.out.println column data type columnnames.addtable_meta.getcolumnlabelcol table_meta.getcolumntypenamecol information discovery in relational databases system.out.printlnnfirst row in table if for colcolumncount col system.out.println columnnames.getcol rs.getstringcol output looks like this table factbook table usstates processing table factbook select from factbook column meta data for table column name name column data type varchar column name location column data type varchar column name export column data type bigint column name import column data type bigint column name debt column data type bigint column name aid column data type bigint column name unemployment_percent column data type integer column name inflation_percent column data type integer first row in table name aruba location caribbean island in the caribbean sea north of venezuela export information gathering import debt aid unemployment_percent inflation_percent processing table usstates select from usstates column meta data for table column name name column data type varchar column name abbreviation column data type char column name industry column data type varchar column name agriculture column data type varchar column name population column data type bigint first row in table name alabama abbreviation al industry paper lumber and wood products mining rubber and plastic products transportation equipment apparel agriculture poultry and eggs cattle nursery stock peanuts cotton vegetables milk soybeans population using the jdbc meta data apis is a simple technique but can be very useful for both searching many tables for specific column names and for pulling meta data and row data into local search engines. while most relational databases provide support for free text search of text fields in a database it is often better to export specific text columns in a table to an external search engine. we will spend the rest of this chapter on index and search techniques. while we usually index web pages and local document repositories keep in mind that data in relational databases can also easily be indexed either with hand written export utilities or automated techniques using the jdbc meta-data apis that we used in this section. down to the bare metal in-memory index and search using the meta data apis to discern entity relationships when database schemas are defined it is usually a top down approach entities and their relationships are modeled and then represented as relational database tables. when automatically searching remote databases for information we might need to discern which entities and their relationships exist depending on table and column names. this is likely to be a domain specific development effort. while it is feasible and probably useful to build a database spider for databases in a limited domain example car parts or travel destinations to discern entity models and their relations it is probably not possible without requiring huge resources to build a system that handles multiple data domains. the expression dark web refers to information on the web that is usually not spidered information that lives mostly in relational databases and often behind query forms. while there are current efforts by search engine companies to determine the data domains of databases hidden behind user entry forms using surrounding text for most organizations this is simply too large a problem to solve. on the other hand using the meta data of databases that you or your organization have read access to for database spidering is a more tractable problem. down to the bare metal in-memory index and search indexing and search technology is used in a wide range of applications. in order to get a good understanding of index and search we will design and implement an in-memory library in this section. in section we will take a quick look at the lucene library and in section we will look at client programs using the nutch indexing and search system that is based on lucene. we need a way to represent data to be indexed. we will use a simple packagevisible class getterssetters assumed to be in the same package as the indexing and search class class testdocument int id string text static int count testdocumentstring text this.text text information gathering id count public string tostring int len text.length if len return id id we will write a class inm emorysearch that indexes instances of the t estdocument class and supplies an api for search. the first decision to make is how to store the index that maps search terms to documents that contain the search terms. one simple idea would be to use a map to maintain a set of document ids for each search term something like mapstring setinteger index this would be easy to implement but leaves much to be desired so we will take a different approach. we would like to rank documents by relevance but a relevance measure just based on containing all most of the search terms is weak. we will improve the index by also storing a score of how many times a search term occurs in a document scaled by the number of words in a document. since our document model does not contain links to other documents we will not use a google-like page ranking algorithm that increases the relevance of search results based on the number of incoming links to matched documents. we will use a utility class assuming same package data visibility to hold a document id and a search term count. i used generics for the first version of this class to allow alternative types for counting word use in a document and later changed the code to hardwiring the types for id and word count to native integer values for runtime efficiency and to use less memory. here is the second version of the code class idcount implements comparableidcount int id int count public idcountint k int v this.id k this.count v public string tostring return id count down to the bare metal in-memory index and search public int comparetoidcount o don t use o.count count avoid overflows if count return if count return return we can now define the data structure for our index mapstringtreesetidcount index new hashtablestring treesetidcount the following code is used to add documents to the index. i score word counts by dividing by the maximum word size i expect for documents in principle it would be better to use a f loat value but i prefer working with and debugging code using integers debug output is more readable. the reason why the number of times a word appears in a document needs to be scaled by the the size of the document is fairly obvious if a given word appears once in a document with words and once in another document with words then the word is much more relevant to finding the first document. public void addtestdocument document mapstringinteger wcount new hashtablestringinteger stringtokenizer st new stringtokenizerdocument.text.tolowercase int num_words st.counttokens if return while string word st.nexttoken system.out.printlnword if wcount.putword wcount.getword num_words else wcount.putword max_words_per_document num_words for word wcount.keyset treesetidcount ts information gathering if ts index.getword else ts new treesetidcount index.putword ts ts.addnew idcountdocument.id wcount.getword max_words_per_document num_words if a word is in the index hash table then the hash value will be a sorted t reeset of idcount objects. sort order is in decreasing size of the scaled word count. notice that i converted all tokenized words in document text to lower case but i did not stem the words. for some applications you may want to use a word stemmer as we did in section i used the temporary hash table wcount to hold word counts for the document being indexed and once wcount was created and filled then looked up the t reeset for each word it if it did not yet exist and added in new idcount objects to represent the currently indexed document and the scaled number of occurrences for the word that is the index hash table key. for development it is good to have a method that prints out the entire index the following method serves this purpose public void debug system.out.println debug dump of search indexn for word index.keyset system.out.printlnn word treesetidcount ts index.getword iteratoridcount iter ts.iterator while system.out.println iter.next here are a few lines of example code to create an index and add three test documents inmemorysearch ims new inmemorysearch testdocument new testdocumentthis is a test for index and a test for search. down to the bare metal in-memory index and search testdocument new testdocumentplease test the index code. testdocument new testdocumentplease test the index code before tomorrow. ims.debug the method debug produces the following output is not shown for brevity. remember that the variable idcount contains a data pair the document integer id and a scaled integer word count in the document. also notice that the t reeset is sorted in descending order of scaled word count. debug dump of search index code please index given the hash table index it is simple to take a list of search words and return a sorted list of matching documents. we will use a temporary hash table ordered results that maps document ids to the current search result score for that document. we tokenize the string containing search terms and for each search word we look up it exists a score count in the temporary map ordered results a new idcount object otherwise and increment the score count. note that the map ordered results is ordered later by sorting the keys by the hash table value public listinteger searchstring search_terms int max_terms listinteger ret new arraylistintegermax_terms information gathering temporary tree set to keep ordered search results final mapintegerinteger ordered_results new stringtokenizer st new stringtokenizersearch_terms.tolowercase while string word st.nexttoken iteratoridcount word_counts index.getword.iterator while idcount ts word_counts.next integer id ts.id if ordered_results.putid ordered_results.getid ts.count else ordered_results.putid ts.count listinteger keys new arraylistintegerordered_results.keyset collections.sortkeys new comparatorinteger public int compareinteger a integer b return comparetoordered_results.getb int count result_loop for id keys if max_terms break result_loop ret.addid return ret for the previous example using the three short test documents we can search the index in this case for a maximum of results using listinteger search_results system.out.printlnresult doc ids ims.searchtest index indexing and search using embedded lucene getting the results result doc ids if you want to use this bare metal indexing and search library there are a few details that still need to be implemented. you will probably want to persist the t estdocument objects and this can be done simply by tagging the class with the serializable interface and writing serialized files using the document id as the file name. you might also want to serialize the inm emorysearch class. while i sometimes implement custom indexing and search libraries for projects that require a lightweight and flexible approach to indexing and search as we did in this section i usually use either the lucene search library or a combination of the hibernate object relational mapping library with lucene search. we will look at lucene in section indexing and search using embedded lucene books have been written on the lucene indexing and search library and in this short section we will look at a brief application example that you can use for a quick reference for starting lucene based projects. i consider lucene to be an important tool for building intelligent text processing systems. lucene supports the concept of a document with one or more fields. fields can either be indexed or not and optionally stored in a disk-based index. searchable fields can be automatically tokenized using either one of lucene s built in text tokenizers or you can supply your customized tokenizer. when i am starting a new project using lucene i begin by using a template class lucenem anager that you can find in the file src-index-searchlucenemanager.java. i usually clone this file and make any quick changes for adding fields to documents etc. we will look at a few important code snippets in the class lucenem anager and you can refer to the source code for more details. we will start by looking at how indices are stored and managed on disk. the class constructor stores the file path to the lucene disk index. you can optionally use method createandclearluceneindex to delete an existing lucene index it exists and creates an empty index. public lucenemanagerstring data_store_file_root this.data_store_file_root data_store_file_root information gathering public void createandclearluceneindex throws corruptindexexception lockobtainfailedexception ioexception deletefilepathnew filedata_store_file_root file index_dir new filedata_store_file_root new indexwriterindex_dir new standardanalyzer true.close if you are using an existing disk-based index that you want to reuse then do not call method createandclearluceneindex. the last argument to the class indexw riter constructor is a flag to create a new index overwriting any existing indices. i use the utility method deletef ilep ath to make sure that all files from any previous indices using the same top level file path are deleted. the method adddocumentt oindex is used to add new documents to the index. here we call the constructor for the class indexw riter with a value of false for the last argument to avoid overwriting the index each time method adddocumentt oindex is called. public void adddocumenttoindex string document_original_uri string document_plain_text throws corruptindexexception ioexception file index_dir new filedata_store_file_root writer new indexwriterindex_dir new standardanalyzer false document doc new document store uri in index do not index doc.addnew fielduri document_original_uri field.store.yes field.index.no store text in index index doc.addnew fieldtext document_plain_text field.store.yes field.index.tokenized writer.adddocumentdoc writer.optimize optional writer.close indexing and search using embedded lucene you can add fields as needed when you create individual lucene document objects but you will want to add the same fields in your application it is not good to have different documents in an index with different fields. there are a few things that you may want to change if you use this class as an implementation example in your own projects. if you are adding many documents to the index in a short time period then it is inefficient to open the index add one document and then optimize and close the index. you might want to add a method that passes in collections of uris and document text strings for batch inserts. you also may not want to store the document text in the index if you are already storing document text somewhere else perhaps in a database. there are two search methods in my lucenem anager class one just returns the document uris for search matches and the other returns both uris and the original document text. both of these methods open an instance of indexreader for each query. for high search volume operations in a multi-threaded environment you may want to create a pool of indexreader instances and reuse them. there are several text analyzer classes in lucene and you should use the same analyzer class when adding indexed text fields to the index as when you perform queries. in the two search methods i use the same standardanalyzer class that i used when adding documents to the index. the following method returns a list of string uris for matched documents public liststring searchindexforurisstring search_query throws parseexception ioexception reader indexreader.opendata_store_file_root liststring ret new arrayliststring searcher searcher new indexsearcherreader analyzer analyzer new standardanalyzer queryparser parser new queryparsertext analyzer query query parser.parsesearch_query hits hits searcher.searchquery for i i hits.length i system.out.println searchindexforuris hit hits.doci document doc hits.doci string uri doc.geturi ret.adduri reader.close return ret information gathering the lucene class hits is used for returned search matches and here we use apis to get the number of hits and for each hit get back an instance of the lucene class document. note that the field values are retrieved by name in this case uri. the other search method in my utility class searchindexf oru risanddoct ext is almost the same as searchindexf oru ris so i will only show the differences public liststring searchindexforurisanddoctext string search_query throws exception liststring ret new arrayliststring for i i hits.length i document doc hits.doci system.out.println hit hits.doci string pair new stringdoc.geturi doc.gettext ret.addpair return ret here we also return the original text from matched documents that we get by fetching the named field text. the following code snippet is an example for using the lucenem anager class lucenemanager lm new lucenemanagertmp start fresh create a new index lm.createandclearluceneindex is a test for index and a test for search. please test the index code. test the index code before tomorrow. get uris of matching documents liststring doc_uris lm.searchindexforuristest index system.out.printlnmatched document uris get uris and document text for matching documents liststring doc_uris_with_text lm.searchindexforurisanddoctexttest index indexing and search with nutch clients for uri_and_text doc_uris_with_text system.out.printlnmatched document uri system.out.println document text and here is the sample output debug printout from deleting the old test diskbased index removed matched document uris matched document uri document text this is a test for index and a test for search. matched document uri document text please test the index code. matched document uri document text please test the index code before tomorrow. i use the lucene library frequently on customer projects and although tailoring lucene to specific applications is not simple the wealth of options for analyzing text and maintaining disk-based indices makes lucene a very good tool. lucene is also very efficient and scales well to very large indices. in section we will look at the nutch system that is built on top of lucene and provides a complete turnkey also highly customizable solution to implementing search in large scale projects where it does not make sense to use lucene in an embedded mode as we did in this section. indexing and search with nutch clients this is the last section in this book and we have a great topic for finishing the book the nutch system that is a very useful tool for information storage and retrieval. out of the box it only takes about minutes to set up a vanilla nutch server with the default web interface for searching documents. nutch can be configured to index documents on a local file system and contains utilities for processing a wide range of document types office openoffice.org pdf tml etc.. you can also configure nutch to spider remote and local private on a company lan web sites. information gathering the nutch web site httplucene.apache.orgnutch contains binary distributions and tutorials for quickly setting up a nutch system and i will not repeat all of these directions here. what i do want to show you is how i usually use the nutch system on customer projects after i configure nutch to periodically spider customer specific data sources i then use a web services client library to integrate nutch with other systems that need both document repository and search functionality. although you can tightly couple your java applications with nutch using the nutch api i prefer to use the opensearch api that is an extension of rss for performing search using web service calls. opensearch was originally developed for amazon s search engine and may become widely adopted since it is a reasonable standard. more information on the opensearch standard can be found at httpwww.opensearch.org but i will cover the basics here. nutch server fast start setup for completeness i will quickly go over the steps i use to set up tomcat version with nutch. for this discussion i assume that you have unpacked tomcat and changed the directory name to nutch that you have removed all files from the directory nutchwebapps and that you have then moved the file am using nutch version to the tomcat webapps directory changing its name to root.war i then move the directory to the file nutchnutchconfcrawl-urlfilter.txt needs to be edited to specify a combination of local and remote data sources here i have configured it to spider just my httpknowledgebooks.com web site only changes i had to make are the two lines one being a comment line containing the string knowledgebooks.com skip file ftp mailto urls skip image and other suffixes we can t yet parse skip urls containing certain characters as probable queries etc. indexing and search with nutch clients skip urls with slash-delimited segment that repeats times to break loops accept hosts in knowledgebooks.com skip everything else additional regular expression patterns can be added for more root web sites. nutch will not spider any site that does not match any regular expression pattern in the configuration file. it is important that web search spiders properly identify themselves so it is important that you also edit the file nutchnutchconfnutch-site.xml following the directions in the comments to identify yourself or your company to web sites that you spider. typetextxsl hrefconfiguration.xsl? name nutch spidervalue spiderdescription of spider serverdescription email addressvalue at markwatson dot comdescription then create an empty directory and create a text file file name is fine with a list of starting urls to spider in this case i will just add information gathering httpknowledgebooks.com then make a small test spider run to create local indices in the subdirectory and start the tomcat server interactively cd nutch binnutch crawl urls crawl run you can run tomcat as a background service using start instead of run in production mode. if you rerun the spidering process you will need to first delete the subdirectory or put the new index in a different location and copy it to when the new index is complete. the nutch web app running in tomcat will expect a subdirectory named in the directory where you start tomcat. just to test that you have nutch up and running with a valid index access the following url localhost assuming that you are running tomcat on your local computer to try this you can then try the opensearch web service interface by accessing the url since i indexed my own web site that i often change the rss xml that you get back may look different than what we see in this example xmlnsnutchhttpwww.nutch.org java rdftitle search results for query java rdfdescription rdfnutchquery indexing and search with nutch clients ai html snippet for multiple search results there are multiple elements in the returned xml data. we will write web service clients to submit remote queries and process the returned rss xml data in section using the nutch opensearch web apis a java opensearch web services client is fairly easy to write build a rest query url with the search phrase url encoded open a httpu rlconnection for this query url read the response and then use an xml parser to process the returned rss xml payload. we will first look at an implementation of a nutch client and then look at some interesting things you can do given your own nutch server installation and a client. the client class n utchclient has three public static apis search returns a list of maps each map having values for keys title description cache uri and link. the title is the web page title the description is an htm snippet showing search terms in original web page text the cache uri is a nutch cache of the original web page and the link is the url to the matched web page. searchgetcache like search but each map also contains a key cache content with a value equal to the cached html for the original web page. getcachecontent use this api if you first used search and later want the cached web page. the implementation is in the file src-index-searchnutchclient.java. here are a few code snippets showing the public apis static public listhashtablestringstring information gathering searchgetcachestring opensearch_url string query throws ioexception parserconfigurationexception saxexception return search_helperopensearch_url query true static public listhashtablestringstring searchstring opensearch_url string query throws ioexception parserconfigurationexception saxexception return search_helperopensearch_url query false static public string getcachecontentstring cache_uri throws ioexception url url new urlcache_uri urlconnection uc url.openconnection return new scanneruc.getinputstream. usedelimiterz.next the implementation of the private helper method is to fit the page width and with comments on the code static private listhashtablestringstring search_helperstring opensearch_url string query boolean return_cache throws listhashtablestringstring ret new arraylisthashtablestringstring we are using a rest style call so we need to url encode the search terms. this involves replacing space characters with etc. a search for java ai using a nutch server on my local laptop on port would look like string url_str opensearch_url urlencoder.encodequery url url new urlurl_str urlconnection uc url.openconnection indexing and search with nutch clients bufferedinputstream bis new bufferedinputstreamuc.getinputstream while i usually prefer sax xml parsers for less memory use and efficiency it is easier for small xml payloads just to use the dom-based apis documentbuilder docbuilder documentbuilderfactory.newinstance. newdocumentbuilder document doc docbuilder.parsebis doc.getdocumentelement.normalize here we use the dom xml apis to get all item tags and for each item tag get the text for the child nodes nodelist listitems doc.getelementsbytagnameitem int numitems listitems.getlength for inumitems i node item listitems.itemi hashtablestringstring new_item new hashtablestringstring ret.addnew_item nodelist item_data item.getchildnodes int num item_data.getlength for nnum n node data item_data.itemn string name data.getnodename nutch returns many extra parameters encoded as items that we do not need. here we just keep what we need if name.equalsdescription name.equalslink new_item.putname data.gettextcontent if new_item.putcache_uri data.gettextcontent we may want to optionally make another web service call to get the cached web page for this search result. doing this approximately doubles the time required for a search query information gathering if new_item.getcache_uri!null new_item.putcache_content getcachecontentnew_item.getcache_uri return ret here is a sample use of the client class listhashtablestringstring results nutchclient.search system.out.printlnresults results and the output for brevity results linkhttpknowledgebooks.com description java ai titleknowledgebooks.com ai technology for linkhttpknowledgebooks.comlicense.txt description using classhighlightjava titlehttpknowledgebooks.comlicense.txt the average time for a nutch client web service call on my macbook is milliseconds when i ran both tomcat and the nutch web services client are on the same laptop. average response times will only increase slightly when the client and the server are on the same local area network. average response times will be longer and less predictable when using any of the public opensearch servers on the internet. what can you use a search client for? here are a few ideas based on my own work projects roughly determine if two words or phrases are associated with each other by concatenating the words or phrases and counting the number of search results for the combined search query. determine if a product name or id code is spelled correctly or if a company carries a product by setting up a custom nutch instance that only spiders the indexing and search with nutch clients company s web sites. always follow the terms and conditions of a web site when setting up a spider. improve search results by adding a list of project-specific synonyms to the search client. expand search terms using the synonym list. if you need access to public information spider the information infrequently and then perform local search queries and use the local page caches. for very little effort you can set up nutch server instances that spider specific information servers. you can often add significant value to application programs by adding search functionality and by using nutch you can locally control the information. information gathering conclusions the material in this book was informed by my own work writing software for information processing. if you enjoyed reading it and you make practical use of at least some of the material i covered then i consider my effort to be worthwhile. writing software is a combination of a business activity promoting good for society and an exploration to try out new ideas for self improvement. i believe that there is sometimes a fine line between spending too many resources tracking many new technologies versus getting stuck using old technologies at the expense of lost opportunities. my hope is that reading this book was an efficient and pleasurable use of your time in learning some new techniques and technologies that you had not considered before. when we can expend resources to try new things it is almost always best to perform many small experiments and then dig deeper into areas that have a good chance for providing high value and capturing your interest. fail fast is a common meme but failure that we do not learn from is a waste. i have been using the java platform from the very beginning and although i also use many other programming languages in my work and studies both the java language and platform provide high efficiency scalability many well-trained developers and a wealth of existing infrastructure software and libraries. investment in java development also pays when using alternative jvm languages like jruby scala and clojure. if we never get to meet in person or talk on the telephone then i would like to thank you now for taking the time to read this book. conclusions index alpha-beta search chess dark web data source cia world factbook usa state data expert system backward chaining business process knowledge drools drools embedded java drools rule syntax forward chaining jess lhs production rules rhs game playing genetic algorithm chromosome crossover fitness library api mutation indexing lucene nutch jdbc derby knowledge representation logic aristotle description logic first order first order predicate frege peirce loom machine learning nave bayes weka neural network back propagation hopfield neuron open calais powerloom java embedded running interactively prolog reasoning relational database derby search lucene nutch search tree semantic web example rdf data jena index n-triple owl protege rdf rdfs sesame sparql statistical nlp auto-classification auto-tagging markov models named entity extraction spelling tagging text clustering tokenize wordnet tic-tac-toe