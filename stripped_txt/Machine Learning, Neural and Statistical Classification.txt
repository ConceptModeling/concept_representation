machine learning neural and statistical classification editors d. michie d.j. spiegelhalter c.c. taylor february contents introduction classification issues conclusions statistical approaches machine learning caution in the interpretations of comparisons introduction classification perspectives on classification neural networks the statlog project quality control the structure of this volume definition of classification rationale class definitions accuracy examples of classifiers fisher s linear discriminants decision tree and rule-based methods k-nearest-neighbour choice of variables classification of classification procedures extensions to linear discrimination transformations and combinations of variables decision trees and rule-based methods ii classical statistical methods modern statistical techniques density estimates separating classes linear discriminants by least squares regularisation and smoothed estimates choice of regularisation parameters a general structure for classification problems prior probabilities and the default rule misclassification costs bayes rule given data bayes rule in statistics reference texts introduction linear discriminants special case of two classes linear discriminants by maximum likelihood more than two classes quadratic discriminant quadratic discriminant programming details logistic discriminant logistic discriminant programming details bayes rules example logistic discriminant quadratic discriminant introduction density estimation example neighbour example projection pursuit classification example naive bayes causal networks example other recent approaches ace mars linear discriminant sec. iii machine learning of rules and trees decision trees stopping rules and class probability trees manufacturing new attributes rule-learning algorithms itrule rules and trees from data first principles data fit and mental fit of classifiers specific-to-general a paradigm for rule-learning general-to-specific top-down induction of trees splitting criteria getting a right-sized tree statlog s ml algorithms tree-learning further features of newid further features of cart bayes tree beyond the complexity barrier trees into rules inherent limits of propositional-level learning a human-machine compromise structured induction introduction supervised networks for classification multi layer perceptron structure and functionality improving the generalisation of feed-forward networks unsupervised learning the k-means clustering algorithm introduction pairwise linear regression clustering of classes description of the classification procedure kohonen networks and learning vector quantizers ramnets learning procedure radial basis function networks perceptrons and multi layer perceptrons neural networks iv methods for comparison train-and-test dataset descriptions and results review of previous empirical comparisons bootstrap evaluation assistant collection of datasets statistical measures information theoretic measures bootstrap optimisation of parameters large number of categories estimation of error rates in classification rules cross-validation organisation of comparative trials cross-validation characterisation of datasets simple measures pre-processing missing values feature selection and extraction bias in class proportions hierarchical attributes preprocessing strategy in statlog introduction basic toolbox of algorithms difficulties in previous studies previous empirical comparisons individual results machine learning vs. neural network studies involving ml k-nn and statistics some empirical studies relating to credit risk machine learning and neural networks introduction credit datasets australian credit image datasets handwritten digits karhunen-loeve digits vehicle silhouettes traditional and statistical approaches credit management letter recognition sec. v image segmentation german credit analysis of results head injury satellite image dataset shuttle control shuttle control diabetes belgian power belgian power ii chromosomes landsat satellite image cut datasets with costs head injury heart disease other datasets dna technical machine faults tsetse fly distribution statistical and information measures kl-digits dataset vehicle silhouettes heart disease technical belgian power ii introduction results by subject areas credit datasets image datasets datasets with costs top five algorithms multidimensional scaling hierarchical clustering of algorithms scaling of datasets performance related to measures theoretical normal distributions best algorithms for datasets clustering of datasets other datasets dominators absolute performance quadratic discriminants scaling of algorithms vi conclusions discriminants characterizing predictive power application assistant criticism of metalevel learning approach criticism of measures relative performance logdisc vs. pruning of decision trees rule based advice on algorithm application objectives using test results in metalevel learning rules generated in metalevel learning prediction of performance ml on ml vs. regression introduction user s guide to programs statistical algorithms nearest neighbour smart naive bayes castle decision trees and newid cart and indcart bayes tree rule-based methods neural networks backprop kohonen and lvq radial basis function neural network memory and time memory time general issues interpretation of error rates cost matrices structuring the results removal of irrelevant attributes itrule sec. vii knowledge representation special features diagnostics and plotting exploratory data from classification to knowledge organisation and synthesis introduction learning measurement and representation prototypes experiment experiment experiment discussion function approximation discussion genetic algorithms propositional learning systems discussion relations and background knowledge discussion conclusions introduction experimental domain learning to control from scratch boxes boxes refinements of boxes learning to control from scratch genetic learning robustness and adaptation exploiting partial explicit knowledge boxes with partial knowledge exploiting domain knowledge in genetic learning of control exploiting operator s skill learning to pilot a plane learning to control container cranes conclusions dataset availability software sources and details contributors a b c learning to control dynamic systems introduction of leeds d. michie d. j. spiegelhalter and c. c. taylor university of strathclyde mrc biostatistics unit cambridge and university introduction the aim of this book is to provide an up-to-date review of different approaches to classification compare their performance on a wide range of challenging data-sets and draw conclusions on their applicability to realistic industrial problems. before describing the contents we first need to define what we mean by classification give some background to the different perspectives on the task and introduce the european community statlog project whose results form the basis for this book. classification the task of classification occurs in a wide range of human activity. at its broadest the term could cover any context in which some decision or forecast is made on the basis of currently available information and a classification procedure is then some formal method for repeatedly making such judgments in new situations. in this book we shall consider a more restricted interpretation. we shall assume that the problem concerns the construction of a procedure that will be applied to a continuing sequence of cases in which each new case must be assigned to one of a set of pre-defined classes on the basis of observed attributes or features. the construction of a classification procedure from a set of data for which the true classes are known has also been variously termed pattern recognition discrimination or supervised learning order to distinguish it from unsupervised learning or clustering in which the classes are inferred from the data. contexts in which a classification task is fundamental include for example mechanical procedures for sorting letters on the basis of machine-read postcodes assigning individuals to credit status on the basis of financial and other personal information and the preliminary diagnosis of a patient s disease in order to select immediate treatment while awaiting definitive test results. in fact some of the most urgent problems arising in science industry address for correspondence mrc biostatistics unit institute of public health university forvie site robinson way cambridge u.k. introduction and commerce can be regarded as classification or decision problems using complex and often very extensive data. we note that many other topics come under the broad heading of classification. these include problems of control which is briefly covered in chapter perspectives on classification as the book s title suggests a wide variety of approaches has been taken towards this task. three main historical strands of research can be identified statistical machine learning and neural network. these have largely involved different professional and academic groups and emphasised different issues. all groups have however had some objectives in common. they have all attempted to derive procedures that would be able to equal if not exceed a human decision-maker s behaviour but have the advantage of consistency and to a variable extent explicitness to handle a wide variety of problems and given enough data to be extremely general to be used in practical settings with proven success. statistical approaches two main phases of work on classification can be identified within the statistical community. the first classical phase concentrated on derivatives of fisher s early work on linear discrimination. the second modern phase exploits more flexible classes of models many of which attempt to provide an estimate of the joint distribution of the features within each class which can in turn provide a classification rule. statistical approaches are generally characterised by having an explicit underlying probability model which provides a probability of being in each class rather than simply a classification. in addition it is usually assumed that the techniques will be used by statisticians and hence some human intervention is assumed with regard to variable selection and transformation and overall structuring of the problem. machine learning machine learning is generally taken to encompass automatic computing procedures based on logical or binary operations that learn a task from a series of examples. here we are just concerned with classification and it is arguable what should come under the machine learning umbrella. attention has focussed on decision-tree approaches in which classification results from a sequence of logical steps. these are capable of representing the most complex problem given sufficient data this may mean an enormous amount!. other techniques such as genetic algorithms and inductive logic procedures are currently under active development and in principle would allow us to deal with more general types of data including cases where the number and type of attributes may vary and where additional layers of learning are superimposed with hierarchical structure of attributes and classes and so on. machine learning aims to generate classifying expressions simple enough to be understood easily by the human. they must mimic human reasoning sufficiently to provide insight into the decision process. like statistical approaches background knowledge may be exploited in development but operation is assumed without human intervention. sec. neural networks perspectives on classification the field of neural networks has arisen from diverse sources ranging from the fascination of mankind with understanding and emulating the human brain to broader issues of copying human abilities such as speech and the use of language to the practical commercial scientific and engineering disciplines of pattern recognition modelling and prediction. the pursuit of technology is a strong driving force for researchers both in academia and industry in many fields of science and engineering. in neural networks as in machine learning the excitement of technological progress is supplemented by the challenge of reproducing intelligence itself. a broad class of techniques can come under this heading but generally neural networks consist of layers of interconnected nodes each node producing a non-linear function of its input. the input to a node may come from other nodes or directly from the input data. also some nodes are identified with the output of the network. the complete network therefore represents a very complex set of interdependencies which may incorporate any degree of nonlinearity allowing very general functions to be modelled. in the simplest networks the output from one node is fed into another node in such a way as to propagate messages through layers of interconnecting nodes. more complex behaviour may be modelled by networks in which the final output nodes are connected with earlier nodes and then the system has the characteristics of a highly nonlinear system with feedback. it has been argued that neural networks mirror to a certain extent the behaviour of networks of neurons in the brain. neural network approaches combine the complexity of some of the statistical techniques with the machine learning objective of imitating human intelligence however this is done at a more unconscious level and hence there is no accompanying ability to make learned concepts transparent to the user. conclusions the three broad approachesoutlined above form the basis of the grouping of procedures used in this book. the correspondence between type of technique and professional background is inexact for example techniques that use decision trees have been developed in parallel both within the machine learning community motivated by psychological research or knowledge acquisition for expert systems and within the statistical profession as a response to the perceived limitations of classical discrimination techniques based on linear functions. similarly strong parallels may be drawn between advanced regression techniques developed in statistics and neural network models with a background in psychology computer science and artificial intelligence. it is the aim of this book to put all methods to the test of experiment and to give an objective assessment of their strengths and weaknesses. techniques have been grouped according to the above categories. it is not always straightforward to select a group for example some procedures can be considered as a development from linear regression but have strong affinity to neural networks. when deciding on a group for a specific technique we have attempted to ignore its professional pedigree and classify according to its essential nature. introduction the statlog project the fragmentation amongst different disciplines has almost certainly hindered communi cation and progress. the statlog project was designed to break down these divisions by selecting classification procedures regardless of historical pedigree testing them on large-scale and commercially important problems and hence to determine to what extent the various techniques met the needs of industry. this depends critically on a clear understanding of measures of performance or benchmarks to monitor the success of the method in a the aims of each classificationdecision procedure the class of problems for which it is most suited particular application. about procedures were considered for about datasetsso that results were obtained from around large scale experiments. the set of methods to be considered was pruned after early experiments using criteria developed for multi-input many treatments and multiple criteria experiments. a management hierarchy led by daimler-benz controlled the full project. the objectives of the project were threefold to provide critical performance measurements on available classification procedures to indicate the nature and scope of further development which particular methods require to meet the expectations of industrial users to indicate the most promising avenues of development for the commercially immature approaches. quality control the project laid down strict guidelines for the testing procedure. first an agreed data format was established algorithms were deposited at one site with appropriate instructions this version would be used in the case of any future dispute. each dataset was then divided into a training set and a testing set and any parameters in an algorithm could be tuned or estimated only by reference to the training set. once a rule had been determined it was then applied to the test data. this procedure was validated at another site by another na ve user for each dataset in the first phase of the project. this ensured that the guidelines for parameter selection were not violated and also gave some information on the ease-of-use for a non-expert in the domain. unfortunately these guidelines were not followed for the radial basis function algorithm which for some datasets determined the number of centres and locations with reference to the test set so these results should be viewed with some caution. however it is thought that the conclusions will be unaffected. caution in the interpretations of comparisons there are some strong caveats that must be made concerning comparisons between techniques in a project such as this. first the exercise is necessarily somewhat contrived. in any real application there should be an iterative process in which the constructor of the classifier interacts with the esprit project comparative testing and evaluation of statistical and logical learning algorithms on large-scale applications to classification prediction and control sec. the structure of this volume expert in the domain gaining understanding of the problem and any limitations in the data and receiving feedback as to the quality of preliminary investigations. in contrast statlog datasets were simply distributed and used as test cases for a wide variety of techniques each applied in a somewhat automatic fashion. second the results obtained by applying a technique to a test problem depend on three factors the essential quality and appropriateness of the technique the actual implementation of the technique as a computer program the skill of the user in coaxing the best out of the technique. in appendix b we have described the implementations used for each technique and the availability of more advanced versions if appropriate. however it is extremely difficult to control adequately the variations in the background and ability of all the experimenters in statlog particularly with regard to data analysis and facility in tuning procedures to give their best. individual techniques may therefore have suffered from poor implementation and use but we hope that there is no overall bias against whole classes of procedure. the structure of this volume the present text has been produced by a variety of authors from widely differing backgrounds but with the common aim of making the results of the statlog project accessible to a wide range of workers in the fields of machine learning statistics and neural networks and to help the cross-fertilisation of ideas between these groups. after discussing the general classification problem in chapter the next chapters detail the methods that have been investigated divided up according to broad headings of classical statistics modern statistical techniques decision trees and rules and neural networks. the next part of the book concerns the evaluation experiments and includes chapters on evaluation criteria a survey of previous comparative studies a description of the data-sets and the results for the different methods and an analysis of the results which explores the characteristics of data-sets that make them suitable for particular approaches we might call this machine learning on machine learning the conclusions concerning the experiments are summarised in chapter the final chapters of the book broaden the interpretation of the basic classification problem. the fundamental theme of representing knowledge using different formalisms is discussed with relation to constructing classification techniques followed by a summary of current approaches to dynamic control now arising from a rephrasing of the problem in terms of classification and learning. classification r. j. henery university of strathclyde definition of classification classification has two distinct meanings. we may be given a set of observations with the aim of establishing the existence of classes or clusters in the data. or we may know for certain that there are so many classes and the aim is to establish a rule whereby we can classify a new observation into one of the existing classes. the former type is known as unsupervised learning clustering the latter as supervised learning. in this book when we use the term classification we are talking of supervised learning. in the statistical literature supervised learning is usually but not always referred to as discrimination by which is meant the establishing of the classification rule from given correctly classified data. the existence of correctly classified data presupposes that someone supervisor is able to classify without error so the question naturally arises why is it necessary to replace this exact classification by some approximation? rationale there are many reasons why we may wish to set up a classification procedure and some of these are discussed later in relation to the actual datasets used in this book. here we outline possible reasons for the examples in section mechanical classification procedures may be much faster for example postal code reading machines may be able to sort the majority of letters leaving the difficult cases to human readers. a mail order firm must take a decision on the granting of credit purely on the basis of information supplied in the application form human operators may well have biases i.e. may make decisions on irrelevant information and may turn away good customers. address for correspondence department of statistics and modelling science university of strathclyde glasgow u.k. sec. definition in the medical field we may wish to avoid the surgery that would be the only sure way of making an exact diagnosis so we ask if a reliable diagnosis can be made on purely external symptoms. the supervisor to above may be the verdict of history as in meteorology or stock-exchange transaction or investment and loan decisions. in this case the issue is one of forecasting. issues there are also many issues of concern to the would-be classifier. we list below a few of these. accuracy. there is the reliability of the rule usually represented by the proportion of correct classifications although it may be that some errors are more serious than others and it may be important to control the error rate for some key class. speed. in some circumstances the speed of the classifier is a major issue. a classifier that is accurate may be preferred over one that is accurate if it is times faster in testing such differences in time-scales are not uncommon in neural networks for example. such considerations would be important for the automatic reading of postal codes or automatic fault detection of items on a production line for example. comprehensibility. if it is a human operator that must apply the classification procedure the procedure must be easily understood else mistakes will be made in applying the rule. it is important also that human operators believe the system. an oft-quoted example is the three-mile island case where the automatic devices correctly recommended a shutdown but this recommendation was not acted upon by the human operators who did not believe that the recommendation was well founded. a similar story applies to the chernobyl disaster. time to learn. especially in a rapidly changing environment it may be necessary to learn a classification rule quickly or make adjustments to an existing rule in real time. quickly might imply also that we need only a small number of observations to establish our rule. at one extreme consider the na ve neighbour rule in which the training set is searched for the nearest a defined sense previous example whose class is then assumed for the new case. this is very fast to learn time at all! but is very slow in practice if all the data are used if you have a massively parallel computer you might speed up the method considerably. at the other extreme there are cases where it is very useful to have a quick-and-dirty method possibly for eyeball checking of data or for providing a quick cross-checking on the results of another procedure. for example a bank manager might know that the simple rule-of-thumb only give credit to applicants who already have a bank account is a fairly reliable rule. if she notices that the new assistant the new automated procedure is mostly giving credit to customers who do not have a bank account she would probably wish to check that the new assistant new procedure was operating correctly. classification class definitions an important question that is improperly understood in many studies of classification is the nature of the classes and the way that they are defined. we can distinguish three common cases only the first leading to what statisticians would term classification classes correspond to labels for different populations membership of the various populations is not in question. for example dogs and cats form quite separate classes or populations and it is known with certainty whether an animal is a dog or a cat neither. membership of a class or population is determined by an independent authority supervisor the allocation to a class being determined independently of any particular attributes or variables. classes result from a prediction problem. here class is essentially an outcome that must be predicted from a knowledge of the attributes. in statistical terms the class is a random variable. a typical example is in the prediction of interest rates. frequently the question is put will interest rates rise or not classes are pre-defined by a partition of the sample space i.e. of the attributes themselves. we may say that class is a function of the attributes. thus a manufactured item may be classed as faulty if some attributes are outside predetermined limits and not faulty otherwise. there is a rule that has already classified the data from the attributes the problem is to create a rule that mimics the actual rule as closely as possible. many credit datasets are of this type. in practice datasets may be mixtures of these types or may be somewhere in between. accuracy on the question of accuracy we should always bear in mind that accuracy as measured on the training set and accuracy as measured on unseen data test set are often very different. indeed it is not uncommon especially in machine learning applications for the training set to be perfectly fitted but performance on the test set to be very disappointing. usually it is the accuracy on the unseen data when the true classification is unknown that is of practical importance. the generally accepted method for estimating this is to use the given data in which we assume that all class memberships are known as follows. firstly we use a substantial proportion training set of the given data to train the procedure. this rule is then tested on the remaining data test set and the results compared with the known classifications. the proportion correct in the test set is an unbiased estimate of the accuracy of the rule provided that the training set is randomly sampled from the given data. examples of classifiers to illustrate the basic types of classifiers we will use the well-known iris dataset which is given in full in kendall stuart there are three varieties of iris setosa versicolor and virginica. the length and breadth of both petal and sepal were measured on flowers of each variety. the original problem is to classify a new iris flower into one of these three types on the basis of the four attributes and sepal length and width. to keep this example simple however we will look for a classification rule by which the varieties can be distinguished purely on the basis of the two measurements on petal length sec. examples of classifiers and width. we have available fifty pairs of measurements of each variety from which to learn the classification rule. fisher s linear discriminants this is one of the oldest classification procedures and is the most commonly implemented in computer packages. the idea is to divide sample space by a series of lines in two dimensions planes in and generally hyperplanes in many dimensions. the line dividing two classes is drawn to bisect the line joining the centres of those classes the direction of the line is determined by the shape of the clusters of points. for example to differentiate between versicolor and virginica the following rule is applied fisher s linear discriminants applied to the iris data are shown in figure six of the observations would be misclassified. if petal width if petal width petal length then versicolor. petal length then virginica. virginica t h d w i l t a e p setosa s s s s s ss s s ss ss s s ssss ss ss s s s ss ss s s s ss ss sss ss s s s s s s s s a e e e e e e e e e e e e e e e e e e e e e e ee e e e e ee e e e e e e e e e e e e e e a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a e a a a a a e aa a e e e a e versicolor petal length fig. classification by linear discriminants iris data. decision tree and rule-based methods one class of classification procedures is based on recursive partitioning of the sample space. space is divided into boxes and at each stage in the procedure each box is examined to see if it may be split into two boxes the split usually being parallel to the coordinate axes. an example for the iris data follows. if petal length then setosa. if petal length then virginica. classification if petal length then if petal width then versicolor if petal width then virginica. the resulting partition is shown in figure note that this classification rule has three mis-classifications. h t i d w l a t e p setosa s s s s s ss s s ss ss s s ssss ss ss s s s ss ss s s ss s ss sss ss s s s s s s s s a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a e a a a a a a aa e e e e a e virginica virginica a e e e e e e e e e e e e e e e e e e e e ee e e e e e ee e e e e e e e e e e e e e e e versicolor petal length fig. classification by decision tree iris data. otherwise versicolor. weiss kapouleas give an alternative classification rule for the iris data that is very directly related to figure their rule can be obtained from figure by continuing the dotted line to the left and can be stated thus notice that this rule while equivalent to the rule illustrated in figure is stated more concisely and this formulation may be preferred for this reason. notice also that the rule is if petal length then setosa. if petal length or petal width then virginica. ambiguous if petal length and petal width the quoted rules may be made unambiguous by applying them in the given order and they are then just a re-statement of the previous decision tree. the rule discussed here is an instance of a rule-based method such methods have very close links with decision trees. k-nearest-neighbour we illustrate this technique on the iris data. suppose a new iris is to be classified. the idea is that it is most likely to be near to observations from its own proper population. so we look at the five nearest observations from all previously recorded irises and classify sec. variable selection the observation according to the most frequent class among its neighbours. in figure the apparent elliptical shape is due to the differing horizontal and vertical scales but the proper scaling of the observations is a major difficulty of this method. and the nearest observations lie within the circle the new observation is marked by a centred on the this is illustrated in figure where an observation centred at would be classified as virginica since it has virginica among its nearest neighbours. a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a a e a a a a a a aa e e e e a e virginica a e e e e e e e e e e e e e e e e e e e e ee e e e e e ee e e e e e e e e e e e e e e e h t i d w l a t e p s s s s s ss s s ss ss s s ssss ss ss s s s ss ss s s ss s ss sss ss s s s s s s s s petal length fig. classification by iris data. choice of variables as we have just pointed out in relation to k-nearest neighbour it may be necessary to reduce the weight attached to some variables by suitable scaling. at one extreme we might remove some variables altogether if they do not contribute usefully to the discrimination although this is not always easy to decide. there are established procedures example forward stepwise selection for removing unnecessary variables in linear discriminants but for large datasets the performance of linear discriminants is not seriously affected by including such unnecessary variables. in contrast the presence of irrelevant variables is always a problem with k-nearest neighbour regardless of dataset size. transformations and combinations of variables often problems can be simplified by a judicious transformation of variables. with statistical procedures the aim is usually to transform the attributes so that their marginal density is approximately normal usually by applying a monotonic transformation of the power law type. monotonic transformations do not affect the machine learning methods but they can benefit by combining variables for example by taking ratios or differences of key variables. background knowledge of the problem is of help in determining what transformation or classification combination to use. for example in the iris data the product of the variables petal length and petal width gives a single attribute which has the dimensions of area and might be labelled as petal area. it so happens that a decision rule based on the single variable petal area is a good classifier with only four errors if petal area then setosa. if petal area then virginica. if petal area then virginica. this tree while it has one more error than the decision tree quoted earlier might be preferred on the grounds of conceptual simplicity as it involves only one concept namely petal area. also one less arbitrary constant need be remembered there is one less node or cut-point in the decision trees. classification of classification procedures the above three procedures discrimination decision-tree and rule-based k-nearest neighbour are prototypes for three types of classification procedure. not surprisingly they have been refined and extended but they still represent the major strands in current classification practice and research. the procedures investigated in this book can be directly linked to one or other of the above. however within this book the methods have been grouped around the more traditional headings of classical statistics modern statistical techniques machine learning and neural networks. chapters respectively are devoted to each of these. for some methods the classification is rather abitrary. extensions to linear discrimination we can include in this group those procedures that start from linear combinations of the measurements even if these combinations are subsequently subjected to some nonlinear transformation. there are procedures of this type linear discriminants logistic discriminants quadratic discriminants multi-layer perceptron and cascade and projection pursuit. note that this group consists of statistical and neural network multilayer perceptron methods only. decision trees and rule-based methods cart indcart bayes tree and itrule chapter this is the most numerous group in the book with procedures newid density estimates this group is a little less homogeneous but the members have this in common the procedure is intimately linked with the estimation of the local probability density at each point in sample space. the density estimate group contains k-nearest neighbour radial basis functions naive bayes polytrees kohonen self-organising net lvq and the kernel density method. this group also contains only statistical and neural net methods. a general structure for classification problems there are three essential components to a classification problem. the relative frequency with which the classes occur in the population of interest expressed formally as the prior probability distribution. sec. costs of misclassification an implicit or explicit criterion for separating the classes we may think of an underlying inputoutput relation that uses observed attributes to distinguish a random individual from each class. the cost associated with making a wrong classification. most techniques implicitly confound components and for example produce a classification rule that is derived conditional on a particular prior distribution and cannot easily be adapted to a change in class frequency. however in theory each of these components may be individually studied and then the results formally combined into a classification rule. we shall describe this development below. prior probabilities and the default rule is that with the least expected cost below. for the class be irrespective of the attributes of the example. this no-data or default rule may even be adopted in practice if the cost of gathering the data is too high. thus banks may give credit to all their established customers for the sake of good customer relations here the cost of gathering the data is the risk of losing customers. the default rule relies only on knowledge of the prior probabilities and clearly the decision rule that has the greatest chance of success is to allocate every new observation to the most frequent class. however if some classification errors are more serious than others we adopt the minimum risk we need to introduce some notation. let the classes be denoted! and let the prior probability. it is always possible to use the no-data rule classify any new observation as expected cost rule and the suppose we are able to observe data on an individual and that we know the probability distribution of within each then for any two to likelihood provides the theoretical optimal form for discriminating the classes on the basis of data object as class suppose the cost of misclassifying a class decisions should all new observations to the classi using suffixj as label for the decision class. when examples decision is made for all new examples a cost is incurred for class i of making decision so the expected cost and these occur with probability. the bayes minimum cost rule chooses that class that has the lowest expected cost. to see the relation between the minimum error and minimum cost rules suppose the cost of the majority of techniques featured in this book can be thought of as implicitly or explicitly deriving an approximate form for this likelihood ratio. be based on the principle that the total cost of misclassifications should be minimised for a new observation this means minimising the expected cost of misclassification. let us first consider the expected cost of applying the default decision rule allocate the is separating classes misclassification costs a i i i classification misclassifications to be the same for all errors and zero when a class is correctly identified foryzg then the expected cost is i.e. suppose forut fsf and the minimum cost rule is to allocate to the class with the greatest prior probability. misclassification costs are very difficult to obtain in practice. even in situations where it is very clear that there are very great inequalities in the sizes of the possible penalties or rewards for making the wrong or right decision it is often very difficult to quantify them. typically they may vary from individual to individual as in the case of applications for credit of varying amounts in widely differing circumstances. in one dataset we have assumed the misclassification costs to be the same for all individuals. practice creditgranting companies must assess the potential costs for each applicant and in this case the classification algorithm usually delivers an assessment of probabilities and the decision is left to the human operator. if we wish to use a minimum cost rule we must first calculate the expected costs of the we can now see how the three components introduced above may be combined into a classification procedure. about an individual the situation is in principle unchanged from the no-data situation. the difference is that all probabilities must now again the decision rule with least probability of error is to allocate to the class with the highest probability of occurrence but now the bayes rule given data when we are given information be interpreted as conditional on the data given the data of class relevant probability is the conditional given various decisions conditional on the given information is made for examples with attributes now when decision a cost examples and these occur with as the is incurred for class depend on i cost of making decision when bayes theorem is used to calculate the conditional for the are calculated from a knowledge of the prior probabilities.! and the of the data for each class! thus for suppose conditional that the probability of observing data bayes theorem gives the posterior as for class in the special case of equal misclassification costs the minimum cost rule is to allocate to the class with the greatest posterior probability. classes we refer to them as the posterior probabilities of the classes. then the posterior so too will the decision rule. so too will the expected i n n i n i i i i i n a a a for which is a minimum. assuming now that the attributes have continuous distributions the probabilities above if sec. bayes rule is proportional the divisor is common to all classes so we may use the fact i with minimum expected cost risk is therefore that the class to. have become probability densities. suppose that observations drawn from population probability density functionb and that the prior probability that an observation belongs to is.d! then bayes theorem computes the probability that an observation belongs to class! as a classification rule then assigns to the classi with maximal a posteriori probability given max! as before the classi with minimum expected cost risk is that for which a then and consider the problem of discriminating between just two classes we should allocate to class assuming as before rather than via bayes theorem we could also use the empirical frequency i with among these examples. the minimum error rule is to allocate to the class which shows the pivotal role of the likelihood ratio which must be greater than the ratio of prior probabilities times the relative costs of the errors. we note the symmetry in the above expression changes in costs can be compensated in changes in prior to keep constant the threshold that defines the classification rule this facility is exploited in some techniques although for more than two groups this property only exists under restrictive assumptions breiman et al. page version of bayes rule which in practice would require prohibitively large amounts of data. however in principle the procedure is to gather together all examples in the training set that have the same attributes as the given example and to find class proportions unless the number of attributes is very small and the training dataset very large it will be necessary to use approximations to estimate the posterior class probabilities. for example is a minimum. or equivalently bayes rule in statistics highest posterior probability. n b n a a b a i n a a b b a a classification one way of finding an approximate bayes rule would be to use not just examples with attributes matching exactly those of the given example but to use examples that were near the given example in some sense. the minimum error decision rule would be to allocate to the most frequent class among these matching examples. partitioning algorithms and decision trees in particular divide up attribute space into regions of self-similarity all data within a given box are treated as similar and posterior class probabilities are constant within the box. decision rules based on bayes rules are optimal no other rule has lower expected error rate or lower expected misclassification costs. although unattainable in practice they provide the logical basis for all statistical algorithms. they are unattainable because they assume complete information is known about the statistical distributions in each class. statistical procedures try to supply the missing distributional information in a variety of ways but there are two main lines parametric and non-parametric. parametric methods make assumptions about the nature of the distributions it is assumed that the distributions are gaussian and the problem is reduced to estimating the parameters of the distributions and variances in the case of gaussians. non-parametric methods make no assumptions about the specific distributions involved and are therefore described perhaps more accurately as distribution-free. reference texts there are several good textbooks that we can recommend. weiss kulikowski give an overall view of classification methods in a text that is probably the most accessible to the machine learning community. hand lachenbruch mickey and kendall et al. give the statistical approach. breiman et al. describe cart which is a partitioning algorithm developed by statisticians and silverman discusses density estimation methods. for neural net approaches the book by hertz et al. is probably the most comprehensive and reliable. two excellent texts on pattern recognition are those of fukunaga who gives a thorough treatment of classification problems and devijver kittler who concentrate on the k-nearest neighbour approach. a thorough treatment of statistical procedures is given in mclachlan who also mentions the more important alternative approaches. a recent text dealing with pattern recognition from a variety of perspectives is schalkoff classical statistical methods j. m. o. mitchell university of strathclyde introduction this chapter provides an introduction to the classical statistical discrimination techniques and is intended for the non-statistical reader. it begins with fisher s linear discriminant which requires no probability assumptionsand then introduces methods based on maximum likelihood. these are linear discriminant quadratic discriminant and logistic discriminant. next there is a brief section on bayes rules which indicates how each of the methods can be adapted to deal with unequal prior probabilities and unequal misclassification costs. finally there is an illustrative example showing the result of applying all three methods to a two class and two attribute problem. for full details of the statistical theory involved the reader should consult a statistical text book for example n methods require numerical attribute vectors and also require that none of the values is missing. where an attribute is categorical with two values an indicator is used i.e. an attribute which takes the value for one category and for the other. where there are more than two categorical values indicators are normally set up for each of the values. however there is then redundancy among these new attributes and the usual procedure is the training set will consist of examples drawn from known classes. will be the values numerically-valued attributes will be known for each ofj examples and these form the attribute it should be noted that these to drop one of them. in this way a single categorical attribute withg values is replaced by attributes whose values are or where the attribute values are ordered it may be address for correspondence department of statistics and modelling science university of strathclyde linear discriminants there are two quite different justifications for using fisher s linear discriminant rule the first as given by fisher is that it maximises the separation between the classes in acceptable to use a single numerical-valued attribute. care has to be taken that the numbers used reflect the spacing of the categories in an appropriate fashion. glasgow u.k. g classical statistical methods a least-squares sense the second is by maximum likelihood section we will give a brief outline of these approaches. for a proof that they arrive at the same solution we refer the reader to mclachlan line i.e. the wrong side of and this is easily seen to be linear discriminants by least squares fisher s linear discriminant is an empirical method for classification based purely on attribute vectors. a hyperplane in two dimensions plane in three dimensions the discriminant between the classes. we wish the discriminants for the two classes to the attribute vectors overall and for the two classes. suppose that we are given a set of between the mean discriminants for the two classes divided by the standard deviation of as possible. points are classified according to the side of the hyperplane that they fall on. for example see figure which illustrates discrimination between two digits with the continuous line as the discriminating hyperplane between the two populations. this procedure is also equivalent to a t-test or f-test for a significant difference between the mean discriminants for the two samples the t-statistic or f-statistic being constructed to have the largest possible value. etc. in attribute space is chosen to separate the known classes as well more precisely in the case of two classes leto be respectively the means of n and let us call the particular linear combination of attributes coefficientsp differ as much as possible and one measure for this is the differencer the discriminantsu?v say giving the following measure of discrimination the assumption of a multivariate normal distribution forr that the normal random variabler where we assume without loss of generality thatr are not of equal sizes or if as is very frequently the case the variance ofr of variance. the sum of squares ofr within class this measure of discrimination is related to an estimate of misclassification error based on that this is a weaker assumption than saying that x has a normal distribution. for the sake of argument we set the dividing line between the two classes at the midpoint between the two class means. then we may estimate the probability of misclassification for one class as the probability for that class is on the wrong side of the dividing is negative. if the classes is not the same for the two classes the dividing line is best drawn at some point other than the midpoint. rather than use the simple measure quoted above it is more convenient algebraically to use an equivalent measure defined in terms of sums of squared deviations as in analysis is k k k r p a a k r k r o k r o k u v r k r k x r o k r o k u v k r k sec. linear discrimination say is the sum of these quantities for the two classes is the quantity that would give where this last sum is now over both classes. by subtraction the pooled sum of squares calculate the f-statistic the pooled sum of squares within classesz the sum being over the examples in class v the total sum of squares ofr us a standard deviationu say z and this last quantity is proportional between classes is in terms of the f-test for the significance of the differencer we would clearly maximising the f-ratio statistic is equivalent to maximising the ratioldhz so the coefficientspa may be chosen to maximise the ratiold z this maximisation problem may be solved analytically giving an explicit solution for the coefficientsp is to normalise thep arbitrary multiplicative constant so that the separationr between the class ratio is now equivalent to minimising the total sum of squaresz put this way the problem there is however an arbitrary multiplicative constant in the solution and the usual practice in some way so that the solution is uniquely determined. often one coefficient is taken to be unity avoiding a multiplication. however the detail of this need not concern us here. the main point about this method is that it is a linear function of the attributes that is used to carry out the classification. this often works well but it is easy to see that it may work badly if a linear separator is not appropriate. this could happen for example if the data for one class formed a tight cluster and the the values for the other class were widely spread around it. however the coordinate system used is of no importance. equivalent results will be obtained after any linear transformation of the coordinates. is identical to a regression of class numerically on the attributes the dependent variable class being zero for one class and unity for the other. mean discriminants is equal to some predetermined value unity. maximising the f to justify the least squares of the title for this section note that we may choose the a practical complication is that for the algorithm to work the pooled sample covariance examples from matrix must be invertible. the covariance matrix for a dataset withj is class jy! is row-vector is thejy! matrix of attribute values ando of attribute means. the pooled covariance matrix where where the is summation is over all the classes and the divisorj is chosen to make the pooled covariance matrix unbiased. for invertibility the attributes must be linearly independent which means that no attribute may be an exact linear combination of other attributes. in order to achieve this some attributes may have to be dropped. moreover no attribute can be constant within each class. of course an attribute which is constant within each class but not overall may be an excellent discriminator and is likely to be utilised in decision tree algorithms. however it will cause the linear discriminant algorithm to fail. this situation can be treated by adding a small positive constant to the corresponding diagonal element of n r r r r o r o k r o k k r k a o k r o k o k o k classical statistical methods the pooled covariance matrix or by adding random noise to the attribute before applying the algorithm. in order to deal with the case of more than two classes fisher suggested the use of canonical variates. first a linear combination of the attributes is chosen to minimise the ratio of the pooled within class sum of squares to the total sum of squares. then further linear functions are found to improve the discrimination. coefficients in these functions are the eigenvectors corresponding to the non-zero eigenvalues of a certain matrix. in general there will be canonical variates. it may turn out that only a few of the canonical variates are important. then an observation can be assigned to the class whose centroid is closest in the subspace defined by these variates. it is especially useful when the class means are ordered or lie along a simple curve in attribute-space. in the simplest case the class means lie along a straight line. this is the case for the head injury data section for example and in general arises when the classes are ordered in some sense. in this book this procedure was not used as a classifier but rather in a qualitative sense to give some measure of reduced dimensionality in attribute space. since this technique can also be used as a basis for explaining differences in mean vectors as in analysis of variance the procedure may be called manova standing for multivariate analysis of variance. special case of two classes the linear discriminant procedure is particularly easy to program when there are just two classes for then the fisher discriminant problem is equivalent to a multiple regression problem with the attributes being used to predict the class value which is treated as for a numerical-valued variable. the class values are converted to numerical values is given the value a standard multiple regression package is then used to predict the class value. if the two classes are equiprobable the discriminating hyperplane bisects the line joining the class centroids. otherwise the discriminating hyperplane is closer to the less frequent class. the formulae are most easily derived by considering the multiple regression predictor as a single attribute that is to be used as a one-dimensional discriminant and then applying the formulae of the following section. the procedure is simple but the details cannot be expressed simply. see ripley for the explicit connection between discrimination and regression. is given the value and class example class linear discriminants by maximum likelihood the justification of the other statistical algorithms depends on the consideration of probability distributions and the linear discriminant procedure itself has a justification of this kind. new point with attribute vector x is then assigned to that class for which the probability is greatest. this is a maximum likelihood method. a frequently made assumption is that the distributions are normal gaussian with different means but the same covariance matrix. the probability density function of the normal distribution is are independent it is assumed that the attribute vectors for examples of class a and follow a certain probability distribution with probability density function density functionb sec. linear discrimination is vector denoting the mean for a class and positive definite matrix. the covariance matrix that we saw earlier is the sample analogue of this covariance matrix which is best thought of as a set of coefficients in the pdf or a set of parameters for the distribution. this means that the points for the class are distributed in a cluster centered each cluster has the same orientation and spread though their means will of course be different. should be noted that there is in theory no absolute boundary for the clusters but the contours for the probability density function in practice occurrences of examples outside a certain ellipsoid have ellipsoidal shape. will be extremely rare. in this case it can be shown that the boundary separating two classes defined by equality of the two pdfs is indeed a hyperplane and it passes through the mid-point of the two centres. its equation is where the covariance matrix is at of ellipsoidal shape described by where denotes the population mean for however in classification the exact the distributions. with two classes if the sample means are substituted for and the pooled sample covariance matrix for then fisher s linear discriminant is obtained. with more than two classes this method does not in general give the same results as fisher s discriminant. distribution is usually not known and it becomes necessary to estimate the parameters for is the probability density more than two classes when there are more than two classes it is no longer possible to use a single linear discriminant score to separate the classes. the simplest procedure is to calculate a linear discriminant for each class this discriminant being just the logarithm of the estimated probability density function for the appropriate class with constant terms dropped. sample values are substituted for population values where these are unknown gives the plugin estimates. where the prior class proportions are unknown they would be estimated by the relative frequencies in the training set. similarly the sample means and pooled covariance matrix are substituted for the population means and covariance matrix. suppose the prior probability of is.! and of in and is the normal density given in equation the joint probability of observing class! and attribute and the logarithm of the probability of observing class! and attributek log. are given by the coefficients of x to within an additive constant. so the coefficients by and the additive constant log.! to obtain the corresponding plug-in formulae substitute the rameters i and. corresponding sample estimators for for. i for examples. proportion of class the above formulae are stated in terms of the unknown population pa though these can be simplified by subtracting the coefficients for the last class. is the sample is k k classical statistical methods quadratic discriminant quadratic discrimination is similar to linear discrimination but the boundary between two discrimination regions is now allowed to be a quadratic surface. when the assumption of equal covariance matrices is dropped then in the maximum likelihood argument with normal distributions a quadratic surface example ellipsoid hyperboloid etc. is obtained. this type of discrimination can deal with classifications where the set of attribute values for one class to some extent surrounds that for another. clarke et al. find that the quadratic discriminant procedure is robust to small departures from normality and that heavy kurtosis tailed distributions than gaussian does not substantially reduce accuracy. however the number of parameters to be estimated and the difference between the variances would need to be considerable to justify the use of this method especially for small or moderate sized datasets dunn occasionally differences in the covariances are of scale only and some simplification may occur et al. linear discriminant is thought to be still effective if the departure from equality of covariances is small some aspects of quadratic dependence may be included in the linear or logistic form below by adjoining new attributes that are quadratic functions of the given attributes. quadratic discriminant programming details the quadratic discriminant function is most simply defined as the logarithm of the appropriate probability density function so that one quadratic discriminant is calculated for each class. the procedure used is to take the logarithm of the probability density function and to substitute the sample means and covariance matrices in place of the population values giving the so-called plug-in estimates. taking the logarithm of equation in classification the quadratic discriminant is calculated for each class and the class with the largest discriminant is chosen. to find the a posteriori class probabilities explicitly the exponential is taken of the discriminant and the resulting quantities normalised to sum we obtain and allowing for differing prior class probabilities. log. here it is understood that the suffix refers to as the quadratic discriminant for class the sample of values from class are given by to unity section thus the posterior class exp and associated expected costs explicitly using to calculate the class the formulae of section the most frequent problem with quadratic discriminants is caused when some attribute has zero variance in one class for then the covariance matrix cannot be inverted. one way of avoiding this problem is to add a small positive constant term to the diagonal terms in the covariance matrix corresponds to adding random noise to the attributes. another way adopted in our own implementation is to use some combination of the class covariance and the pooled covariance. if there is a cost matrix then no matter the number of classes the simplest procedure is apart from a normalising factor. b sec. quadratic discrimination is the sample for for i once again the above formulae are stated in terms of the unknown population pa has an option for quadratic discrimination sas also does quadratic discrimination. many statistical packages allow for quadratic discrimination example minitab to obtain the corresponding plug-in formulae substitute the rameters i and. corresponding sample estimators examples. proportion of class regularisation and smoothed estimates the main problem with quadratic discriminants is the large number of parameters that need to be estimated and the resulting large variance of the estimated discriminants. a related problem is the presence of zero or near zero eigenvalues of the sample covariance matrices. attempts to alleviate this problem are known as regularisation methods and the most practically useful of these was put forward by friedman who proposed a compromise between linear and quadratic discriminants via a two-parameter family of estimates. one parameter controls the smoothing of the class covariance matrix estimates. for. friedman makes the is the pooled covariance matrix. is a constant term that is added to the diagonals of the covariance matrices this is done to make the covariance matrix non-singular and also has the effect of smoothing out the covariance matrices. as we have already mentioned in connection with linear discriminants any singularity of the covariance matrix will cause problems and as there is now one covariance matrix for each class the likelihood of such a problem is much greater especially for the classes with small sample sizes. the smoothed estimate of the class covariance matrix is where is the class sample covariance matrix and when is zero there is no smoothing and the estimated class covariance matrix is just the i th sample covariance matrix when the are unity all classes have the same covariance matrix namely the pooled covariance matrix value of smaller for classes with larger numbers. for the i th sample withj observations where j the other parameter ordinary linear discriminants quadratic discriminants and the values w correspond to a minimum euclidean distance rule. error to choose the values of and and the default values of were adopted for the majority of statlog datasets default values were used for the head injury dataset and the dna dataset this type of regularisation has been incorporated in the strathclyde version of quadisc. very little extra programming effort is required. however it is up to the user by trial and friedman gives various shortcut methods for this two-parameter family of procedures is described by friedman as regularised discriminant analysis various simple procedures are included as special cases the exceptions were those cases where a covariance matrix was not invertible. non the philosophy being to keep the procedure pure quadratic. choice of regularisation parameters reducing the amount of computation. k classical statistical methods approx.. in practice great improvements in the performance of quadratic discriminants may result from the use of regularisation especially in the smaller datasets. logistic discriminant exactly as in section logistic regression operates by choosing a hyperplane to separate the classes as well as possible but the criterion for a good separation is changed. fisher s linear discriminants optimises a quadratic cost function whereas in logistic discrimination it is a conditional likelihood that is maximised. however in practice there is often very little difference between the two and the linear discriminants provide good starting values for the logistic. logistic discrimination is identical in theory to linear discrimination for normal distributions with equal covariances and also for independent binary attributes so the greatest differences between the two are to be expected when we are far from these two cases for example when the attributes have very non-normal distributions with very dissimilar covariances. the method is only partially parametric as the actual pdfs for the classes are not modelled but rather the ratios between them. likelihood. the model implies that given attribute values x the conditional class probabilities for classes times the ratios of the probability density functions for the classes are modelled as linear functions of the attributes. thus for two classes are the parameters of the model that are to be estimated. the case of normal distributions with equal covariance is a special case of this for which the parameters are functions of the prior probabilities the class means and the common covariance matrix. however the model covers other cases too such as that where the attributes are independent with values or one of the attractions is that the is specifically the logarithms of the prior odds. log. c k and vector where discriminant scale covers all real numbers. a large positive value indicates that class likely while a large negative value indicates that class in practice the parameters are estimated by maximumf? and parameters and bq c sample is defined to be and the parameter estimates are the values that maximise this likelihood. they are found by iterative methods as proposed by cox and day kerridge logistic models s sample respectively. given independent samples from the two classes the conditional likelihood for the d is likely. take the forms b b sec. logistic discrimination take the forms is defined to be belong to the class of generalised linear models which generalise the use of linear regression models to deal with non-normal random variables and in particular to deal with binomial variables. in this context the binomial variable is an indicator variable that counts again the parameters are estimated by maximum conditional likelihood. given at whether an example is class or not. when there are more than two classes one class is taken as a reference class and there are sets of parameters for the odds of each class relative to the reference class. to discuss this case we abbreviate the notation for w for the remainder of this section therefore x is to the simpler corresponds to the constant vector with leading term unity and the leading term in wheret and the tribute values x the conditional class probability for class conditional class probability for c c respectively. given independent samples from the classes the conditional likelihood for the parameters y! sample sample values occur it will generally be necessary when categorical attributes with binary attributes before using the algorithm especially if the to convert them into categories are not ordered. anderson points out that it may be appropriate to include transformations or products of the attributes in the linear function but for large datasets this may involve much computation. see mclachlan for useful hints. one way to increase complexity of model without sacrificing intelligibility is to add parameters in a hierarchical fashion and there are then links with graphical models and polytrees. in the basic form of the algorithm an example is assigned to the class for which the posterior is greatest if that is greater than or to the reference class if all posteriors are negative. more complicated models can be accommodated by adding transformations of the given attributes for example products of pairs of attributes. as mentioned in section once again the parameter estimates are the values that maximise this likelihood. s sample logistic discriminant programming details most statistics packages can deal with linear discriminant analysis for two classes. systat has in addition a version of logistic regression capable of handling problems with more than two classes. if a package has only binary logistic regression can only deal with two classes begg gray suggest an approximate procedure whereby classes are all compared to a reference class by means of logistic regressions and the results then combined. the approximation is fairly good in practice according to begg gray k k n a a n a a classical statistical methods many statistical packages splus genstat now include a generalised linear model function enabling logistic regression to be programmed easily in two or three lines of code. occurrences. the indicator variable is then declared to be a binomial variable with the logit link function and generalised regression performed on the attributes. we used the package splus for this purpose. this is fine for two classes and has the merit of requiring little extra programming effort. for more than two classes the complexity of the problem increases substantially and although it is technically still possible to use glm procedures the programming effort is substantially greater and much less efficient. the procedure is to define an indicator variable for class numbers in the various classes i.e. the maximum likelihood solution can be found via a newton-raphson iterative procedure as it is quite easy to write down the necessary derivatives of the likelihood first iteration. of course an alternative would be to use the linear discriminant parameters as starting values. in subsequent iterations the step size may occasionally have to be reduced but usually the procedure converges in about iterations. this is the procedure we adopted where possible. coeffiequivalently the log-likelihood. the simplest starting procedure is to set the which are set to the logarithms of the cients to zero except for the leading coefficients wherej is the number of class logj are those of the linear discriminant after the examples. this ensures that the values of rows and each term requires a summation over all the observations in the thus there are of order m in the kl digits dataset section for example so the number of operations is of order and om in each iteration. in such cases it is preferable to use a purely numerical search procedure or as we did when the newton-raphson procedure was too time-consuming to use a method based on an approximate hessian. the approximation uses the fact that the hessian for the zero th order iteration is simply a replicate of the design matrix covariance matrix used by the linear discriminant rule. this zero-order hessian is used for all iterations. in situations where there is little difference between the linear and logistic parameters the approximation is very good and convergence is fairly fast a few more iterations are generally required. however in the more interesting case that the linear and logistic parameters are very different convergence using this procedure is very slow and it may still be quite far from convergence after say iterations. we generally stopped after iterations although the parameter values were generally not stable the predicted classes for the data were reasonably stable so the predictive power of the resulting rule may not be seriously affected. this aspect of logistic regression has not been explored. however each iteration requires a separate calculation of the hessian and it is here that the bulk of the computational work is required. the hessian is a square matrix with whole dataset some saving can by achieved using the symmetries of the hessian. computations required to find the hessian matrix at each iteration. the final program used for the trials reported in this book was coded in fortran since the splus procedure had prohibitive memory requirements. availablility of the fortran code can be found in appendix b. linear discrimination has the equation sec. bayes rules bayes rules methods based on likelihood ratios can be adapted to cover the case of unequal misclassification costs andor unequal prior probabilities. let the prior probabilities be when there are more than two classes the simplest procedure is to calculate the as in section the minimum expected cost solution is to assign the data x to class and denote the cost incurred by classifying an example h. a into class of class i chosen to minimise in the case of two classes the hyperplane in k_ f and associated expected costs explicitly using the formulae of class example as illustration of the differences between the linear quadratic and logistic discriminants we consider a subset of the karhunen-loeve version of the digits data later studied in this book. for simplicity we consider only the digits and and to differentiate between them we use only the first two attributes are available so this is a substantial reduction in potential information. the full sample of points for each digit was used to estimate the parameters of the discriminants although only a subset of points for each digit is plotted in figure as much of the detail is obscured when the full set is plotted. log the right hand side replacing that we had in equation section linear discriminant also shown in figure are the sample centres of gravity by a cross. because there are equal numbers in the samples the linear discriminant boundary on the diagram by a full line intersects the line joining the centres of gravity at its mid-point. any new point is classified as a if it lies below the line i.e. is on the same side as the centre of the s. in the diagram there are s below the line so they would be misclassified. logistic discriminant the logistic discriminant procedure usually starts with the linear discriminant line and then adjusts the slope and intersect to maximise the conditional likelihood arriving at the dashed line of the diagram. essentially the line is shifted towards the centre of the s so as to reduce the number of misclassified s. this gives fewer misclassified s more misclassified s in the diagram. quadratic discriminant the quadratic discriminant starts by constructing for each sample an ellipse centred on the centre of gravity of the points. in figure it is clear that the distributions are of different shape and spread with the distribution of s being roughly circular in shape and the s being more elliptical. the line of equal likelihood is now itself an ellipse general a conic section as shown in the figure. all points within the ellipse are classified classical statistical methods as s. relative to the logistic boundary i.e. in the region between the dashed line and the ellipse the quadratic rule misclassifies an extra s the upper half of the diagram but correctly classifies an extra s the lower half of the diagram. so the performance of the quadratic classifier is about the same as the logistic discriminant in this case probably due to the skewness of the distribution. linear logistic and quadratic discriminants linear logistic e t a i r a v l k d n quadratic kl-variate fig. decision boundaries for the three discriminants quadratic linear line and logistic line. the data are the first two karhunen-loeve components for the digits and modern statistical techniques r. molina n. p erez de la blanca and c. c. taylor university of granada and university of leeds introduction in the previous chapter we studied the classification problem from the statistical point of view assuming that the form of the underlying density functions their ratio was known. however in most real problems this assumption does not necessarily hold. in this chapter we examine distribution-free called nonparametric classification procedures that can be used without assuming that the form of the underlying densities are known. the bayesian approach for allocating observations to classes has already been outlined in section it is clear that to apply the bayesian approach to classification we have recall denote the number of classes of examples and attributes respec tively. classes will be denoted by and attribute values for example n n elements in will be a nonparametric methods to do this job will be to will be denoted by vectorky! and. discussed in this chapter. we begin in section with kernel density estimation a close relative to this approach is the k-nearest neighbour which is outlined in section bayesian methods which either allow for or prohibit dependence between the variables are discussed in sections and a final section deals with promising methods which have been developed recently but for various reasons must be regarded as methods for the future. to a greater or lesser extent these methods have been tried out in the project but the results were disappointing. in some cases this is due to limitations of size and memory as implemented in splus. the pruned implementation of mars in splus also suffered in a similar way but a standalone version which also does classification is expected shortly. we believe that these methods will have a place in classification practice once some relatively minor technical problems have been resolved. as yet however we cannot recommend them on the basis of our empirical trials. address for correspondence department of computer science and ai facultad de ciencas university of granada granada spain a a modern statistical techniques is given by furthermore then is the length of the edge of the hypercube we have this leads to the following procedure to estimate density estimation a nonparametric approach proposed in fix hodges is to estimate the densities by nonparametric density estimation. then once we have estimated and the prior probabilities.pa we can use the formulae of section and the costs to classifyk by minimum risk or minimum error. dimensional density to introduce the method we assume that we have to estimate of an unknown distribution. note that we will have to perform this process for each of the densitiesb that a vectork then the probability will fall in a region m k_ suppose thatj observations are drawn independently according then we can is the number of thesej observations falling in approach does not vary appreciably within we can write where is the volume enclosed by be the number of samples falling in w the density atk let be the volume of w the estimate based on a sample of sizej and b d j b m dimensional is equation can be written in a much more suggestive way. if w hypercube and if m ky! b m m then expresses our estimate as an average function ofk and the samplesky! b where are kernel functions. for instance we could use instead of the parzen n exp is clear. for if the role played by m m changes very slowly withk resulting in a very smooth estimate on the other hand if b is the superposition ofj small then centered at the samples producing a very erratic estimate the analysis for the a! is very large is sharp normal distributions with small variances g where otherwise in general we could use window defined above parzen window is similar. a j n k a j n n a a sec. density estimation further details. independent coordinates i.e. is an averaged value of the unknown density. for the mean and variance of the estimator. these can be used to derive plug-in estimates before going into details about the kernel functions we use in the classification problem we briefly comment on the mean we now consider our classification problem. two choices have to be made in order to estimate the density the specification of the kernel and the value of the smoothing parameter. it is fairly widely recognised that the choice of the smoothing parameter is much more important. with regard to the kernel function we will restrict our attention to and about the estimation of the smoothing parameter we have behaviour of b m b and so the expected value of the estimate in a taylor series m about x one can derive asymptotic formulae b by expanding for which are well-suited to the goal of density estimation see silverman for kernels withw indicating the kernel function component of theg th attribute and being not a dependent ong it is very important to note that as stressed by aitchison aitken it is clear that kernels could have a more complex form and that the smoothing parameter could be coordinate dependent. we will not discuss in detail that possibility here mclachlan for details. some comments will be made at the end of this section. this factorisation does not imply the independence of the attributes for the density we are estimating. the kernels we use depend on the type of variable. for continuous variables a-! a ad for binary variables a-!- a-! a-! log exp a log a g q for nominal variables with ma nominal values a h g a-! log g q n a a a a a a a a modern statistical techniques continuous binary nominal ordinal a a-! a! defined depending on the type of variable by for the above expressions we can see that in all cases we can write for all the is whereu if where for ordinal variables with ad a-!- a a-! a the problem is that since we want to use the same smoothing parameter variables we have to normalise them. to do so we substitute by otherwise. a nominal values k q a! where denotes the number of examples for which attributeg has the ando is the sample mean of theg th attribute. with this selection ofu we have a-! u for discrete variables the range of the smoothness parameter is the one a pa a-! a-! a! have to be for continuous variables the range is and and regarded as limiting cases. as we get the uniform distribution over the real line we get the dirac spike function situated at the a! and as as having defined the kernels we will use we need to choose density approaches zero at allk except at the samples where it isd j function. this precludes choosing by maximizing the log likelihood with respect to where to maximise and takes the estimated times the dirac delta to estimate a good choice of smoothing parameter a jackknife modification of the maximum likelihood method can be used. this was proposed by habbema et al. and duin so we can understand the above process as rescaling all the variables to the same scale. extreme leads to the uniform distribution and the other to a one-point distribution if if a i o a o a j a j n o a j a g a a a t b j n n sec. density estimation this criterion makes the smoothness data dependent leads to an algorithm for an arbitrary dimensionality of the data and possesses consistency requirements as discussed by aitchison aitken tends to be constant over large regions roughly approximating the fixed kernel model. the variation in smoothness of the estimated density over the different regions. if for the euclidean distance measured after standardisation of all variables. the proportionality the smoothing value is now determined by two the so-called variable kernel model. an extensive description of this model was first given by breiman et al. this method has promising results especially when lognormal is thus proportional to the dependent on th nearest an extension of the above model for is to make so that we have a for each sample point. this gives rise to neighbour distance tok or skewed distributions are estimated. the kernel width denoted byj cj i.e. th nearest neighbour distance ink we take forj is dependent factor parameters can be though of as an overall smoothing parameter defines the smoothness will vary locally while for values the smoothness m exp a cj cj to optimise for dimensional optimisation problem of the likelihood function with one continuous parameter and one discrete parameter silverman sections and studies the advantages and disadvantages of this approach. he also proposes another method to estimate the smoothing parameters in a variable kernel model silverman and mclachlan for details. the jackknife modification of the maximum likelihood method can again be applied however for the variable kernel this leads to a more difficult two the algorithm we mainly used in our trials to classify by density estimation is by hermans at al. appendix b for source. we use a normal distribution for the component a-! a-! example we illustrate the kernel classifier with some simulated data which comprise observations from a standard normal distribution say and total values from an equal mixture of the resulting estimates can then be used as a basis for classifying future observations to one or other class. various scenarios are given in figure where a black segment indicates that observations will be allocated to class and otherwise to class in this example we have used equal priors for the classes they are not equally represented and hence allocations are based on maximum estimated likelihood. it is clear that the rule will depend on the smoothing parameters and can result in very disconnected sets. in higher dimensions these segments will become regions with potentially very nonlinear boundaries and possibly disconnected depending on the smoothing parameters used. for comparison we also draw the population probability densities and the true decision regions in figure which are still disconnected but very much smoother than some of those constructed from the kernels. a a a a modern statistical techniques true probability densities with decision regions f f f x x kernel estimates with decision regions smoothing values smoothing values smoothing values smoothing values x f f x x fig. classification regions for kernel classifier with true probability densities the smoothing parameters quoted in are the values of used in equation for class and class respectively. sec. k nearest neighbour neighbour this leads immediately there is a problem that is important to mention. in the above analysis it is assumed that however it could be the case that our sample did not estimate by a nearest neigh suppose we consider estimating the bour method. if we have training data in which there arejs observations from class with and the hypersphere aroundk containing nearest observations has volume jc j respectively then observations of classes and is estimated which then gives dhj is estimated byj by substitution as an estimate max to the classification rule classifyk as belonging to class this is known as neighbour classification rule. for the special case when it is simply termed the nearest-neighbour classification rule. d j is estimated byj the nearest-neighbour rule should work. to begin with note that the class e with the nearest neighbour is a random variable and the probability that e k_ e wherek_ b is is the sample nearest tok samples is very large it is reasonable to assume thatk_ b is sufficiently close tok k_ b in this case we can view the nearest-neighbour rule as a with probability randomised decision rule that classifiesk by selecting the category as a nonparametric density estimator the nearest neighbour approach yields a non-smooth curve which does not integrate to unity and as a method of density estimation it is unlikely to be appropriate. however these poor qualities need not extend to the domain of classification. note also that the nearest neighbour method is equivalent to the kernel density estimate as the smoothing parameter tends to zero when the normal kernel function is used. see scott for details. when the number of so properly the group-prior probabilities. this issue is studied in davies we study in some depth the nn rule. we first try to get a heuristic understanding of why associated it is obvious that the use of this rule involves choice of a suitable metric i.e. how is the distance to the nearest points to be measured? in some datasets there is no problem but for multivariate data where the measurements are measured on different scales some standardisation is usually required. this is usually taken to be either the standard deviation or the range of the variable. if there are indicator variables will occur for nominal data then the data is usually transformed so that all observations lie in the unit hypercube. note that the metric can also be class dependent so that one obtains a distance conditional on the class. this will increase the processing and classification time but may lead to a considerable increase in performance. for classes with few samples a compromise is to use a regularised value in which there is some trade-off between the within class value and the global value of the rescaling parameters. a study on the influence of data transformation and metrics on the k-nn rule can be found in todeschini to speed up the process of finding the nearest neighbours several approaches have been proposed. fukunaka narendra used a branch and bound algorithm to increase the speed to compute the nearest neighbour the idea is to divide the attribute space in regions and explore a region only when there are possibilities of finding there a nearest neighbour. the regions are hierarchically decomposed to subsets sub-subsets and so on. other ways to speed up the process are to use a condensed-nearest-neighbour rule modern statistical techniques a reduced-nearest-neighbour-rule or the edited-nearest-neighbour-rule batchelor these methods all reduce the training set by retaining those observations which are used to correctly classify the discarded points thus speeding up the classification process. however they have not been implemented in the k-nn programs used in this book. is split and the second part classified using a k-nn rule. however in large datasets this method can be prohibitive in cpu time. indeed for large datasets the method is very time classification. enas choi have looked at this problem in a simulation study and for the two classes problem. see mclachlan for the choice can be made by cross-validation methods whereby the training data consuming since all the training data must be stored and examined for each proposed rules for in the trials reported in this book we used the nearest neighbour classifier with was chosen by cross-validation. distances were scaled using the standard deviation for each attribute with the calculation conditional on the class. ties were broken by a majority vote or as a last resort the default rule. no condensing. exception to this was the satellite dataset see section in which details. example nearest neighbour classifier a e r a e s o c u g l relative weight fig. nearest neighbour classifier for one test example. the following example shows how the nearest neighbour classifier works. the data are a random subset of dataset in andrews herzberg which examines the relationship between chemical subclinical and overt nonketotic diabetes in patients above for more details. for ease of presentation we have used only patients and two of the six variables relative weight and glucose area and the data are shown in figure the classifications of patients are one of overt diabetic chemical diabetic and are labeled on the graph. in this example it can be seen that glucose area sec. projection pursuit classification is more useful in separating the three classes and that class is easier to distinguish than classes and a new patient whose condition is supposed unknown is assigned the same classification as his nearest neighbour on the graph. the distance as measured to each point needs to be scaled in some way to take account for different variability in the different directions. in this case the patient is classified as being in class and is classified correctly. the decision regions for the nearest neighbour are composed of piecewise linear boundaries which may be disconnected regions. these regions are the union of dirichlet cells each cell consists of points which are nearer an appropriate metric to a given observation than to any other. for this data we have shaded each cell according to the class of its centre and the resulting decision regions are shown in figure nearest neighbour decision regions a e r a e s o c u g l relative weight fig. decision regions for nearest neighbour classifier. projection pursuit classification as we have seen in the previous sections our goal has been to estimate minimum risk decision problem into a minimum error decision problem. to do so we when to class in order to assignk and to simplify problems transform our we assume that we know. such that and simply alter h. to h. and f- constraining ifgyt then an approximation to. to be of the form constant otherwise is a a n a n a a a a a a f a modern statistical techniques or breiman et al. for details. that we are trying to estimate. the problem can be put into a different setting that resolves the difficulty. let a with these new prior and costsk is assigned to classea when b b so our final goal is to build a good estimator we could use to define the quality of an however is obviously the best estimator useless since it contains the unknown quantities a random vector on h with and define new by variables if then we then define the mean square error by ky estimatorj we have and so to compare two estimatorsj andj we can compare the values of and when projection pursuit techniques are used in classification problems ky the coefficients and with and the functions ya if in observation the very interesting point is that it can be easily shown that for any class probability are parameters of the model and are estimated by least squares. equation is approximated by is ky a with otherwise otherwise modelled as n a g a g a a a a a a a a a a a a n a a a a n n n a a a n a a n j n n n n a sec. projection pursuit classification the projection part of the term projection pursuit indicates that the vector x is of the projections and the pursuit part indicates that the optimization technique is used functions are in order. they are special scatterplot smoother designed to have the following features they are very fast to compute and have a variable span. aee statsci for details. it is the purpose of the projection pursuit algorithm to minimise with respect to given the number of predictive terms comprising the model. increasing the number of terms decreases the bias specification error at the expense of increasing the variance of the and parameter estimates. then the above expression is minimised with respect to the parameters and the functions projected onto the direction vectors to get the lengths to find good direction vectors a few words on the the parameters and functions the training data. the principal task of the user is to choose and find and less. that is solutions that minimise the strategy is to start with a relatively large value of are found for all models of size in order of decreasing for the numerical search in each model are the solution values for the most important ofs e terms of the previous model. the importance is measured as all the is one. the starting point for the minimisation of the largest model is given by an normalised so that the most important term has unit importance. that the variance of term stagewise model stuetzle and statsci for the sequence of solutions generated in this manner is then examined by the user and a final model is chosen according to the guidelines above. a very precise description of the process. the algorithm we used in the trials to classify by projection pursuit is smart the starting parameter values friedman for details and appendix b for availability example this method is illustrated using a dataset with three classes relating to chemical and overt diabetes. the data can be found in dataset of andrews herzberg and were first published in reaven miller the smart model can be examined by plotting the smooth functions in the two projected data co-ordinates these are given in figure which also shows the class values given by the projected points of the selected training data of the patients. the remainder of the model to obtain a linear combination of the functions which can then be used to model the conditional probabilities. in this example we get chooses the values of y! t n a g n modern statistical techniques smooth functions with training data projections projected point f f projected point fig. projected training data with smooth functions. the remaining patients were used as a test data set and for each class the unscaled conditional probability can be obtained using the relevant coefficients for that class. these are shown in figure where we have plotted the predicted value against only one of the projected co-ordinate axes. it is clear that if we choose the model hence the class to maximise this value then we will choose the correct class each time. naive bayes all the nonparametric methods described so far in this chapter suffer from the requirements that all of the sample must be stored. since a large number of observations is needed to obtain good estimates the memory requirements can be severe. in this section we will make independence assumptions to be described later among the variables involved in the classification problem. in the next section we will address the problem of estimating the relations between the variables involved in a problem and display such relations by mean of a directed acyclic graph. the na ve bayes classifier is obtained as follows. we assume that the joint distribution of classes and attributes can be written as the problem is then to obtain the probabilities of independence makes it much easier to estimate these probabilities since each attribute can be treated separately. if an attribute takes a continuous value the usual procedure is to discretise the interval and to use the appropriate frequency of the interval although there is an option to use the normal distribution to calculate probabilities. the assumption the implementation used in our trials to obtain a na ve bayes classifier comes from the ind package of machine learning algorithms ind by wray buntine appendix b for availability. n a a a sec. causal networks estimated conditional probabilities projected point a finite state where we use the short notation is associated. the total set of configuration is the set fig. projected test data with conditional probablities for three classes. class class class causal networks we start this section by introducing the concept of causal network. be a directed acyclic graph with each nodez lete space are denoted we assume that typical elements of and elements of we have a probability over be a directed acyclic graph for eachzu definition be the set of all parents ofz be the set of all descendent ofz furthermore forz be the set of variables in excludingz andz s descendent. andz are conditionally independent the then if for every subset there are two key results establishing the relations between a causal the proofs can be found in neapolitan the first theorem establishes that g is a causal network can thus in a causal network if one knows the conditional probability distribution of each variable given its parents one can compute the joint probability distribution of all the variables in the network. this obviously can reduce the complexity of determining the is called a causal or bayesian network. be written as let modern statistical techniques distribution enormously. the theorem just established shows that if we know that a dag and a probability distribution constitute a causal network then the joint distribution can be retrieved from the conditional distribution of every variable given its parents. this does not imply however that if we arbitrarily specify a dag and conditional probability distributions of every variables given its parents we will necessary have a causal network. this inverse result can be stated as follows. is uniquely determined by we illustrate the notion of network with a simple example taken from cooper suppose that metastatic cancer is a cause of brain tumour and can also cause an increase in total serum calcium. suppose further that either a brain tumor or an increase in total serum calcium could cause a patient to fall into a coma and that a brain tumor could cause papilledema. let be a set of finite sets of alternatives are not yet calling the members of let variables since we do not yet have a probability distribution and let be a dag. in addition forz be the set of all parents ofz and let a conditional probability distribution ofz be specified for every event that is we have then a joint probability distribution of the vertices a probability distribution in constitutes a causal network. and metastatic cancer present serum calcium increased brain tumor present coma present papilledema present cancer not present serum calcium not increased brain tumor not present coma not present papilledema not present fig. dag for the cancer problem. then the structure of our knowledge-base is represented by the dag in figure this structure together with quantitative knowledge of the conditional probability of every variable given all possible parent states define a causal network that can be used as device to perform efficient inference knowledge about variables as it arrives be able to see the effect on the other variables of one variable taking a particular value and so on. see pearl and lauritzen spiegelhalter p p f f j j sec. causal networks so once a causal network has been built it constitutes an efficient device to perform probabilistic inference. however there remains the previous problem of building such a network that is to provide the structure and conditional probabilities necessary for characterizing the network. a very interesting task is then to develop methods able to learn the net directly from raw data as an alternative to the method of eliciting opinions from the experts. in the problem of learning graphical representations it could be said that the statistical community has mainly worked in the direction of building undirected representations chapter of whittaker provides a good survey on selection of undirected graphical representations up to from the statistical point of view. the program bifrost jsgaard et al. has been developed very recently to obtain causal models. a second literature on model selection devoted to the construction of directed graphs can be found in the social sciences et al. spirtes et al. and the artificial intelligence community herkovsits cooper cooper herkovsits and fung crawford in this section we will concentrate on methods to build a simplified kind of causal structure polytrees connected networks networks where no more than one path exists between any two nodes. polytrees are directed graphs which do not contain loops in the skeleton network without the arrows that allow an extremely efficient local propagation procedure. before describing how to build polytrees from data we comment on how to use a polytree in a classification problem. in any classification problem we have a set of variables that have influence on a distinguished classification the problem is given a particular instantiation of these variables to predict for this task we need a set of examples and their correct classification acting as a training sample. in this context we first estimate from this training sample a network next in propagation mode given a new case with unknown classification we will instantiate and propagate the available information showing the more likely value of the classification variable that is to classify this particular case in one of the possible categories of the value of structure displaying the causal relationships among the variables variable moreover the network shows the variables in value of all the variables in directly have influence on the children of in fact the parents of knowledge of these variables makes parents of the children of the rest of variables in theory to build polytree-based representations for a general set of variables assume that the of to estimate can be represented by some unknown polytree that has the form it is important to note that this classifier can be used even when we do not know the that and the other independent of so the rest of the network could be pruned thus reducing the complexity and increasing the efficiency of the classifier. however since the process of building the network does not take into account the fact that we are only interested in classifying we should expect as a classifier a poorer performance than other classification oriented methods. however the built networks are able to display insights into the classification problem that other methods lack. we now proceed to describe the discrete-value variables we are trying modern statistical techniques skeleton we have the following theorem as a parent. is defined by is the empty set of direct parents of the variable the first step in the process of building a polytree is to learn the skeleton. to build the it is important to keep in mind that a na ve bayes classifier can be represented by a polytree more precisely a tree in which each attribute node has the class at simpler representations than the one displayed in figure the skeleton of the graph involved in that example is not a tree. theorem any maximum weight spanning tree where the weight of the branch connecting then according to key results seen at the beginning of this section we have a causal is nondegenerate meaning that there exists a connected dag that displays all the dependencies and is a polytree. we will assume is representable by a polytree where in and the parents of each variable are mutually independent. so we are aiming network independencies embedded in variable if a nondegenerate and log a will unambiguously recover the skeleton of eracy implies that for any pairs of log p jsj having found the skeleton of the polytree we move on to find the directionality of the branches. to recover the directions of the branches we use the following facts nondegenthat do not have a common descendent p jsjh p jsjh we have we have where we have then and for any of the patterns furthermore for the pattern a a a a a a a n f f a a a a a a a a n f f f a a a g a g a a a a sec. causal networks taking all these facts into account we can recover the head to head patterns which are the really important ones. the rest of the branches can be assigned any direction as long as we do not produce more head to head patterns. the algorithm to direct the skeleton can be found in pearl p usal the program to estimate causal polytrees used in our trials is castle ructures from inductive arning. it has been developed at the university of granada for the esprit project statlog et al. acid et al. see appendix b for availability. example we now illustrate the use of the bayesian learning methodology in a simple model the digit recognition in a calculator. digits are ordinarily displayed on electronic watches and calculators using seven horizontal and vertical lights in on off configurations figure we number the lights to be an eight dimensional as shown in figure we take fig. digits. the we generate examples from a faulty calculator. the data consist of outcomes from vector where denotes theil and when fixing to is a seven dimensional vector of zeros and ones with otherwise. position is on for theil digit and if the light in the the random vector w i where is the class label the digit and assumes the values in with equal probability and the i are zero-one variables. given the value of the i are each independently equal to the and are in error with probability with probabilityd value corresponding to the our aim is to build up the polytree displaying the in j jy jsj ft i q p p jsjk we generate four hundred samples of this distributionand use them as a learning sample. after reading in the sample estimating the skeleton and directing the skeleton the polytree estimated by castle is the one shown in figure castle then tells us what we had expected finally we examine the predictive power of this polytree. the posterior probabilities of each digit given some observed patterns are shown in figure a r modern statistical techniques fig. obtained polytree. digit other recent approaches the methods discussed in this section are available via anonymous ftp from statlib internet address a version of ace for nonlinear discriminant analysis is available fig. probabilitiesl for some digits jwuf mars is available in a fortran version. since these algorithms were not formally included in the statlog trials various reasons we give only a brief introduction. as the s coded functionr ace nonlinear transformation of variables is a commonly used practice in regression problems. the alternating conditional expectation algorithm friedman is a simple iterative scheme using only bivariate conditional expectations which finds those transformations that produce the best fitting additive model. approaches this problem by minimising the squared-error objective suppose we have two random variables the response so that and the predictor w the ace algorithm seek transformationsm for fixedm the minimisingb conversely for fixedb ism the key idea in the ace algorithm is to begin with minimisingm the and we using an automatic smoothing procedure. this constitutes one iteration of the algorithm which terminates when an iteration fails to ace places no restriction on the type of each variable. the transformation functions representing the class labels sec. other recent approaches some starting functions and alternate these two steps until convergence. with multiple n ace seeks to minimise in practice given a dataset estimates of the conditional expectations are constructed in order to stop the iterates from shrinking is scaled to have unit variance in each iteration. also without loss of generality the condition is imposed. the algorithm minimises equation through a series of single-function minimisations involving smoothed estimates of bivariate predictors m to zero functions which trivially minimise the squared error criterion m mu n minimising with conditional expectations. for a given set of functionsb yields a newm respect tom rq m in turn with givenm is minimised for eachbt! and yx uwv withu yielding the solution b-a b m a assume values on the real line but their arguments may assume m ace then finds the transformations that make the relationship ofm to theb as linear as possible. order regression spline function one predictor variable b an approximating obtained by dividing the range of values into disjoint regions separated by degree polynomial in called knots the approximation takes the form of a separate each region constrained so that the function and its derivatives are continuous. each degree polynomial is defined by parameters so there are a total be continuity requirements place constraints at each knot location making a total of constraints. mars the mars adaptive regression spline procedure is based on a generalisation of spline methods for function fitting. consider the case of only is points values on any set so ordered real ordered and unordered categorical and binary variables can all be incorporated in the same regression equation. for categorical variables the procedure can be regarded as estimating optimal scores for each of their values. for use in classification problems the response is replaced by a categorical variable parameters to be adjusted to best fit the data. generally the order of the spline is taken to n n a b a a b b n n a t t t q n a b a a s t t t b n b a a n n modern statistical techniques while regression spline fitting can be implemented by directly solving this constrained minimisation problem it is more usual to convert the problem to an unconstrained optimi the chosen knot locations and performing a linear least squares fit of the response on this basis function set. in this case the approximation takes the form order spline functions are unconstrained and the continu. one such regions and the truncated power functions are defined basis the truncated power basis is comprised of the functions sation by chosing a set of basis functions that span the space of all where the values of the expansion coefficients ity constraints are intrinsically embodied in the basis functions are the knot locations defining the where the flexibility of the regression spline approach can be enhanced by incorporating an automatic knot selection strategy as part of the data fitting process. a simple and effective strategy for automatically selecting both the number and locations for the knots was described by who suggested using the truncated power basis in a numerical minimisation of the least squares criterion max can be regarded as the parameters associated with the multivariate adaptive regression spline method can be viewed as thereby estimating the global amount of smoothing to be applied as well as estimating the separate relative amount of smoothing to be applied locally at different locations. adding or deleting a knot is viewed as adding or deleting the corresponding the strategy involves starting with a very large number of eligible knot we may choose one at every interior data point and considering as candidates to be selected through a statistical variable subset selection procedure. this approach to knot selection is both elegant and here the coefficients ak a multiple linear least squares regression of the response on the variables and locations k max corresponding variables powerful. it automatically selects the number of knots and their locations b ofj a multivariate generalisation of this strategy. an approximating spline function variables is defined analogously to that for one variable. thej space b divided into a set of disjoint regions and within each one inj variables with the maximum degree of any single variable being the approximation region the approximating polynomials in seperate regions along orderj spline functions. function set that spans the space of all and its derivatives are constrained to be everywhere continuous. this places constraints on is is taken to be a polynomial is most easily constructed using a basis boundaries. as in the univariate case b n a a n z n a a a n a b sec. other recent approaches mars implements a forwardbackward stepwise selection strategy. the forward sein each in the model. iteration we consider adding two terms to the model lection begins with only the constant basis functiona is one of the basis functions already chosen wherea not represented ina is one of the predictor variables is a knot location on that variable. the two terms of this form which cause the greatest decrease in the residual sum of squares are added to the model. the forward selection process continues until a relatively large number of basis functions is included in a deliberate attempt to overfit the data. the backward pruning procedure standard stepwise linear regression is then applied with the basis functions representing the stock of variables the best fitting model is chosen with the fit measured by a cross-validation criterion. a and mars is able to incorporate variables of different type continuous discrete and categorical. a machine learning of rules and trees c. feng and d. michie the turing institute and university of strathclyde this chapter is arranged in three sections. section introduces the broad ideas underlying the main rule-learning and tree-learning methods. section summarises the specific characteristics of algorithms used for comparative trials in the statlog project. section looks beyond the limitations of these particular trials to new approaches and emerging principles. rules and trees from data first principles data fit and mental fit of classifiers in a lecture text see carpenter doran a.m.turing identified machine learning as a precondition for intelligent systems. a more specific engineering expression of the same idea was given by claude shannon in and that year also saw the first computational learning experiments by christopher strachey muggleton after steady growth ml has reached practical maturity under two distinct headings as a means of engineering rule-based software example in expert systems from sample cases volunteered interactively and as a method of data analysis whereby rulestructured classifiers for predicting the classes of newly sampled cases are obtained from a training set of pre-classified cases. we are here concerned with heading exemplified by michalski and chilausky s landmark use of the algorithm larson to generate automatically a rule-based classifier for crop farmers. rules for classifying soybean diseases were inductively derived from a training set of records. each comprised a description in the form of attribute-values together with a confirmed allocation to one or another of main soybean diseases. when used to canada donald michie academic research associates inveralmond grove edinburgh addresses for correspondence cao feng department of computer science university of ottowa ottowa u.k. this chapter confines itself to a subset of machine learning algorithms i.e. those that output propositional classifiers. inductive logic programming uses the symbol system of predicate opposed to propositional logic and is described in chapter sec. rules and trees from data first principles classify or so new cases machine-learned rules proved to be markedly more accurate than the best existing rules used by soybean experts. as important as a good fit to the data is a property that can be termed mental fit as statisticians breiman and colleagues see data-derived classifications as serving two purposes to predict the response variable corresponding to future measurement vectors as accurately as possible to understand the structural relationships between the response and the measured variables. ml takes purpose one step further. the soybean rules were sufficiently meaningful to the plant pathologist associated with the project that he eventually adopted them in place of his own previous reference set. ml requires that classifiers should not only classify but should also constitute explicit concepts that is expressions in symbolic form meaningful to humans and evaluable in the head. we need to dispose of confusion between the kinds of computer-aided descriptions which form the ml practitioner s goal and those in view by statisticians. knowledgecompilations meaningful to humans and evaluable in the head are available in michalski chilausky s paper appendix and in shapiro michie their appendix b in shapiro his appendix a and in bratko mozetic lavrac their appendix a among other sources. a glance at any of these computer-authored constructions will suffice to show their remoteness from the main-stream of statistics and its goals. yet ml practitioners increasingly need to assimilate and use statistical techniques. once they are ready to go it alone machine learned bodies of knowledge typically need little further human intervention. but a substantial synthesis may require months or years of prior interactive work first to shape and test the overall logic then to develop suitable sets of attributes and definitions and finally to select or synthesize voluminous data files as training material. this contrast has engendered confusion as to the role of human interaction. like music teachers ml engineers abstain from interaction only when their pupil reaches the concert hall. thereafter abstention is total clearing the way for new forms of interaction intrinsic to the pupil s delivery of what has been acquired. but during the process of extracting descriptions from data the working method of ml engineers resemble that of any other data analyst being essentially iterative and interactive. in ml the knowledge orientation is so important that data-derived classifiers however accurate are not ordinarily acceptable in the absence of mental fit. the reader should bear this point in mind when evaluating empirical studies reported elsewhere in this book. statlog s use of ml algorithms has not always conformed to purpose above. hence the reader is warned that the book s use of the phrase machine learning in such contexts is by courtesy and convenience only. the michalski-chilausky soybean experiment exemplifies supervised learning given a sample of input-output pairs of an unknown class-membership function required a conjectured reconstruction of the function in the form of a rule-based expression human-evaluable over the domain. note that the function s output-set is unordered consisting of categoric rather than numerical values and its outputs are taken to be names of classes. the derived functionexpression is then a classifier. in contrast to the prediction of numerical quantities this book confines itself to the classification problem and follows a scheme depicted in figure constructing ml-type expressions from sample data is known as concept learning machine learning of rules and trees t r a i n i n g d a t a l e a r n i n g a l g o r i t h m c l a s s i f i c a t i o n r u l e s t e s t i n g d a t a fig. classification process from training to testing. the first such learner was described by earl hunt this was followed by hunt marin stone s cls. the acronym stands for concept learning system in ml the requirement for user-transparency imparts a bias towards logical in preference to arithmetical combinations of attributes. connectives such as and or and if-then supply the glue for building rule-structured classifiers as in the following englished form of a rule from michalski and chilausky s soybean study. if then leaf malformation is absent and stem is abnormal and internal discoloration is black diagnosis is charcoal rot example cases training set or learning sample are represented as vectors of attribute-values paired with class names. the generic problem is to find an expression that predicts the classes of new cases test set taken at random from the same population. goodness of agreement between the true classes and the classes picked by the classifier is then used to measure accuracy. an underlying assumption is that either training and test sets are randomly sampled from the same data source or full statistical allowance can be made for departures from such a regime. symbolic learning is used for the computer-based construction of bodies of articulate expertise in domains which lie partly at least beyond the introspective reach of domain experts. thus the above rule was not of human expert authorship although an expert can assimilate it and pass it on. to ascend an order of magnitude in scale kardio s comprehensive treatise on ecg interpretation et al. does not contain a single rule of human authorship. above the level of primitive descriptors every formulation was data-derived and every data item was generated from a computable logic of heartelectrocardiograph interaction. independently constructed statistical diagnosis systems are commercially available in computer-driven ecg kits and exhibit accuracies in the range. here the ml product scores higher being subject to error only if the initial logical model contained flaws. none have yet come to light. but the difference that illuminates the distinctive nature of symbolic ml concerns mental fit. because of its mode of construction kardio is able to support its decisions with insight into causes. statistically derived systems do not. however developments of bayesian treatments ini sec. rules and trees from data first principles tiated by ml-leaning statisticians spiegelhalter and statistically inclined ml theorists pearl may change this. although marching to a different drum ml people have for some time been seen as a possibly useful source of algorithms for certain data-analyses required in industry. there are two broad circumstances that might favour applicability categorical rather than numerical attributes strong and pervasive conditional dependencies among attributes. as an example of what is meant by a conditional dependency let us take the classification of vertebrates and consider two variables namely breeding-ground sea freshwater land and skin-covering scales feathers hair none. as a value for the first sea votes overwhelmingly for fish. if the second attribute has the value none then on its own this would virtually clinch the case for amphibian. but in combination with breeding-ground sea it switches identification decisively to mammal. whales and some other sea mammals now remain the only possibility. breeding-ground and skin-covering are said to exhibit strong conditional dependency. problems characterised by violent attribute-interactions of this kind can sometimes be important in industry. in predicting automobile accident risks for example information that a driver is in the agegroup acquires great significance if and only if sex male. to examine the horses for courses aspect of comparisons between ml neural-net and statistical algorithms a reasonable principle might be to select datasets approximately evenly among four main categories as shown in figure conditional dependencies strong and pervasive weak or absent attributes all or mainly categorical all or mainly numerical key ml expected to do well ml expected to do well marginally ml expected to do poorly marginally fig. relative performance of ml algorithms. in statlog collection of datasets necessarily followed opportunity rather than design so that for light upon these particular contrasts the reader will find much that is suggestive but less that is clear-cut. attention is however called to the appendices which contain additional information for readers interested in following up particular algorithms and datasets for themselves. classification learning is characterised by the data-description language the language for expressing the classifier i.e. as formulae rules etc. and the learning algorithm itself. of these and correspond to the observation language and machine learning of rules and trees hypothesis language respectively of section under we consider in the present chapter the machine learning of if-then rule-sets and of decision trees. the two kinds of language are interconvertible and group themselves around two broad inductive inference strategies namely specific-to-general and general-to-specific specific-to-general a paradigm for rule-learning michalski s and related algorithms were inspired by methods used by electrical engineers for simplifying boolean circuits for example higonnet grea they exemplify the specific-to-general and typically start with a maximally specific rule for assigning cases to a given class for example to the class mammal in a taxonomy of vertebrates. such a seed as the starting rule is called specifies a value for every member of the set of attributes characterizing the problem for example rule if skin-covering hair breathing lungs tail none can-fly y reproduction viviparous legs y warm-blooded y diet carnivorous activity nocturnal then mammal. we now take the reader through the basics of specific-to-general rule learning. as a minimalist tutorial exercise we shall build a mammal-recogniser. the initial rule numbered in the above is so specific as probably to be capable only of recognising bats. specificity is relaxed by dropping attributes one at a time thus rule rule rule rule rule if breathing lungs tail none can-fly y reproduction viviparous legs y warm-blooded y diet carnivorous activity nocturnal then mammal if skin-covering hair tail none can-fly y reproduction viviparous legs y warm-blooded y diet carnivorous activity nocturnal then mammal if skin-covering hair breathing lungs can-fly y reproduction viviparous legs y warm-blooded y diet carnivorous activity nocturnal then mammal if skin-covering hair breathing lungs tail none reproduction viviparous legs y warm-blooded y diet carnivorous activity nocturnal thenmammal if skin-covering hair breathing lungs tail none can-fly y legs y warm-blooded y diet carnivorous activity nocturnal bf then mammal and so on for all the ways of dropping a single attribute followed by all the ways of dropping two attributes three attributes etc. any rule which includes in its cover a negative example i.e. a non-mammal is incorrect and is discarded during the process. the cycle terminates by saving a set of shortest rules covering only mammals. as a classifier such a set is guaranteed correct but cannot be guaranteed complete as we shall see later. sec. rules and trees from data first principles in the present case the terminating set has the single-attribute description rule if skin-covering hair then mammal the process now iterates using a new seed for each iteration for example rule if skin-covering none breathing lungs tail none can-fly n reproduction viviparous legs n warm-blooded y diet mixed activity diurnal then mammal leading to the following set of shortest rules rule rule rule rule if skin-covering none reproduction viviparous then mammal if skin-covering none warm-blooded y then mammal if legs n warm-blooded y then mammal if reproduction viviparous warm-blooded y then mammal of these the first covers naked mammals. amphibians although uniformly naked are oviparous. the second has the same cover since amphibians are not warm-blooded and birds although warm-blooded are not naked assume that classification is done on adult forms. the third covers various naked marine mammals. so far these rules collectively contribute little information merely covering a few overlapping pieces of a large patchwork. but the last rule at a stroke covers almost the whole class of mammals. every attempt at further generalisation now encounters negative examples. dropping warm-blooded causes the rule to cover viviparous groups of fish and of reptiles. dropping viviparous causes the rule to cover birds unacceptable in a mammal-recogniser. but it also has the effect of including the egg-laying mammals monotremes consisting of the duck-billed platypus and two species of spiny ant-eaters. rule fails to cover these and is thus an instance of the earlier-mentioned kind of classifier that can be guaranteed correct but cannot be guaranteed complete. conversion into a complete and correct classifier is not an option for this purely specific-to-general process since we have run out of permissible generalisations. the construction of rule has thus stalled in sight of the finishing line. but linking two or more rules together each correct but not complete can effect the desired result. below we combine the rule yielded by the first iteration with in turn the first and the second rule obtained from the second iteration rule rule rule rule if skin-covering hair then mammal if skin-covering none reproduction viviparous then mammal if skin-covering hair then mammal if skin-covering none warm-blooded y then mammal these can equivalently be written as disjunctive rules machine learning of rules and trees if or then and if or then skin-covering hair skin-covering none reproduction viviparous mammal skin-covering hair skin-covering none warm-blooded y mammal in rule induction following michalskian attribute-test is called a selector a conjunction of selectors is a complex and a disjunction of complexes is called a cover. if a rule is true of an example we say that it covers the example. rule learning systems in practical use qualify and elaborate the above simple scheme including by assigning a prominent role to general-to-specific processes. in the statlog experiment such algorithms are exemplified by niblett and itrule. both generate decision rules for each class in turn for each class starting with a universal rule which assigns all examples to the current class. this rule ought to cover at least one of the examples belonging to that class. specialisations are then repeatedly generated and explored until all rules consistent with the data are found. each rule must correctly classify at least a prespecified percentage of the examples belonging to the current class. as few as possible negative examples i.e. examples in other classes should be covered. specialisations are obtained by adding a condition to the left-hand side of the rule. is an extension of michalski s algorithm aq with several techniques to is the number classified incorrectly and c is the total number of classes. process noise in the data. the main technique for reducing error is to minimise cde fdgih g function where k is the number of examples classified correctly cdjelkenm by a rulek itrule produces rules of the form if then with probability this algorithm contains probabilistic inference through the j-measure which evaluates its candidate rules. j-measure is a product of prior probabilities for each class and the cross-entropy of class values conditional on the attribute values. itrule cannot deal with continuous numeric values. it needs accurate evaluation of prior and posterior probabilities. so when such information is not present it is prone to misuse. detailed accounts of these and other algorithms are given in section decision trees reformulation of the mammal-recogniser as a completed decision tree would require the implicit else not-mammal to be made explicit as in figure construction of the complete outline taxonomy as a set of descriptive concepts whether in rule-structured or tree-structured form would entail repetition of the induction process for bird reptile amphibian and fish. in order to be meaningful to the user to satisfy the mental fit criterion it has been found empirically that trees should be as small and as linear as possible. in fully linear trees such as that of figure an internal node attribute test can be the parent of at most one internal node. all its other children must be end-node or leaves quantitative measures of linearity are discussed by arbab michie who present an algorithm rg for building trees biased towards linearity. they also compare rg with bratko s aocdl directed towards the same end. we now consider the general sec. rules and trees from data first principles skin-covering? none hair scales feathers mammal not-mammal not-mammal viviparous? no yes not-mammal mammal qu fig. translation of a mammal-recognising rule see text into tree form. the attribute-values that figured in the rule-sets built earlier are here set larger in bold type. the rest are tagged with not-mammal labels. properties of algorithms that grow trees from data. general-to-specific top-down induction of trees in common with and itrule but in contrast to the specific-to-general earlier style of michalski s aq family of rule learning decision-tree learning is general-to-specific. in illustrating with the vertebrate taxonomy example we will assume that the set of nine attributes are sufficient to classify without error all vertebrate species into one of mammal bird amphibian reptile fish. later we will consider elaborations necessary in underspecified or in inherently noisy domains where methods from statistical data analysis enter the picture. as shown in figure the starting point is a tree of only one node that allocates all cases in the training set to a single class. in the case that a mammal-recogniser is required this default class could be not-mammal. the presumption here is that in the population there are more of these than there are mammals. unless all vertebrates in the training set are non-mammals some of the training set of cases associated with this single node will be correctly classified and others incorrectly in the terminology of breiman and colleagues such a node is impure each available attribute is now used on a trial basis to split the set into subsets. whichever split minimises the estimated impurity of the subsets which it generates is retained and the cycle is repeated on each of the augmented tree s end-nodes. numerical measures of impurity are many and various. they all aim to capture the degree to which expected frequencies of belonging to given classes estimated for o o o o o o o o o p p p p p p q q q r r r r r r s s s s t t t q q q s q q machine learning of rules and trees example in the two-class mammalnot-mammal problem of figure asv are affected by knowledge of attribute values. in general the goodness of a split into subsets example by skin-covering by breathing organs by tail-type etc. is the weighted mean decrease in impurity weights being proportional to the subset sizes. let us see how these ideas work out in a specimen development of a mammal-recognising tree. to facilitate comparison with the specific-to-general induction shown earlier the tree is represented in figure as an if-then-else expression. we underline class names that label temporary leaves. these are nodes that need further splitting to remove or diminish impurity. cvwexvy this simple taxonomic example lacks many of the complicating factors encountered in classification generally and lends itself to this simplest form of decision tree learning. complications arise from the use of numerical attributes in addition to categorical from the occurrence of error and from the occurrence of unequal misclassification costs. error can inhere in the values of attributes or classes noise or the domain may be deterministic yet the supplied set of attributes may not support error-free classification. but to round off the taxonomy example the following from quinlan gives the simple essence of tree learning contains no cases contains cases that belong to a mixture of classes the decision tree is again a leaf but the class to be associated with the leaf for example the leaf might be chosen in accordance with some background knowledge of the domain such as the overall majority class. to construct a decision tree from a setz of training cases let the classes be denoted d e there are three possibilities contains one or more cases all belonging to a single classb is a leaf identifying class the decision tree forz must be determined from information other thanz in this situation the idea is to refinez d d i outcomes wherez contains all the cases inz the decision tree forz leads to the decision tree constructed from the subsetz into subsets of cases that are or seem to be heading towards single-class collections of cases. a test is chosen based on a single attribute that has two or more mutually exclusive that have outcome oi of the chosen test. consists of a decision node identifying the test and one branch for each possible outcome. the same tree-building machinery is applied recursively to each subset of training cases so that the ith branch d d z of training cases. is partitioned into subsetsz note that this schema is general enough to include multi-class trees raising a tactical problem in approaching the taxonomic material. should we build in turn a set of yesno recognizers one for mammals one for birds one for reptiles etc. and then daisy-chain them into a tree? or should we apply the full multi-class procedure to the data wholesale risking a disorderly scattering of different class labels along the resulting tree s perimeter? if the entire tree-building process is automated as for the later standardised comparisons the second regime is mandatory. but in interactive decision-tree building there is no generally correct answer. the analyst must be guided by context by user-requirements and by intermediate results. h z z z z z sec. rules and trees from data first principles empty attribute-test not-mammal if no misclassifications confirm leaf lines if misclassifications occur choose an attribute for splitting the set for each calculate a purity measure from the tabulations below empty attribute-test not-mammal and exit skin-covering? feathers none hair scales total number of mammals in set number of not-mammals fe yfe sc no ha yno yha ysc breathing? number of mammals in subset number of not-mammals lungs lu ylu tail? gills gi ygi long short none number of mammals in set number of not-mammals lo ylo no yno and so on sh ysh vy vy vy fig. first stage in growing a decision tree from a training set. the single end-node is a candidate to be a leaf and is here drawn with broken lines. it classifies all cases to not-mammal. if correctly the candidate is confirmed as a leaf. otherwise available attribute-applications are tried for their abilities to split the set saving for incorporation into the tree whichever maximises some chosen purity measure. each saved subset now serves as a candidate for recursive application of the same split-and-test cycle. s s s v v v machine learning of rules and trees step construct a single-leaf tree rooted in the empty attribute test if then not-mammal if no impure nodes then exit step construct from the training set all single-attribute trees and for each calculate the weighted mean impurity over its leaves step retain the attribute giving least impurity. assume this to be skin-covering if hair then mammal if feathers then not-mammal if scales then not-mammal if none then not-mammal step if no impure nodes then exit otherwise apply steps and and recursively to each impure node thus step construct from the not-mammal subset of step all single-attribute trees and for each calculate the weighted mean impurity over its leaves step retain the attribute giving least impurity. perfect scores are achieved by viviparous and by warm-blooded giving and if hair then mammal if feathers then not-mammal if scales then not-mammal if none then if viviparous then mammal else not-mammal if hair then mammal if feathers then not-mammal if scales then not-mammal if none then if y then mammal else not-mammal step exit fig. illustration using the mammal problem of the basic idea of decision-tree induction. sec. rules and trees from data first principles either way the crux is the idea of refining t into subsets of cases that are or seem to be heading towards single-class collections of cases. this is the same as the earlier described search for purity. departure from purity is used as the splitting criterion i.e. as the basis on which to select an attribute to apply to the members of a less pure node for partitioning it into purer sub-nodes. but how to measure departure from purity? in practice as noted by breiman et al. overall misclassification rate is not sensitive to the choice of a splitting rule as long as it is within a reasonable class of rules. for a more general consideration of splitting criteria we first introduce the case where total purity of nodes is not attainable i.e. some or all of the leaves necessarily end up mixed with respect to class membership. in these circumstances the term noisy data is often applied. but we must remember that noise irreducible measurement error merely characterises one particular form of inadequate information. imagine the multi-class taxonomy problem under the condition that skin-covering tail and viviparous are omitted from the attribute set. owls and bats for example cannot now be discriminated. stopping rules based on complete purity have then to be replaced by something less stringent. stopping rules and class probability trees one method not necessarily recommended is to stop when the purity measure exceeds some threshold. the trees that result are no longer strictly decision trees for brevity we continue to use this generic term since a leaf is no longer guaranteed to contain a single-class collection but instead a frequency distribution over classes. such trees are known as class probability trees conversion into classifiers requires a separate mapping from distributions to class labels. one popular but simplistic procedure says pick the candidate with the most votes whether or not such a plurality rule makes sense depends in each case on the distribution over the classes in the population from which the training set was drawn i.e. on the priors and differential misclassification costs. consider two errors classifying the shuttle main engine as ok to fly when it is not and classifying it as not ok when it is. obviously the two costs are unequal. use of purity measures for stopping sometimes called forward pruning has had mixed results. the authors of two of the leading decision tree algorithms cart et al. and independently arrived at the opposite philosophy summarised by breiman and colleagues as prune instead of stopping. grow a tree that is much too large and prune it upward this is sometimes called backward pruning these authors definition of much too large requires that we continue splitting until each terminal node either or or is pure contains only identical attribute-vectorsin which case splitting is impossible has fewer than a pre-specified number of distinct attribute-vectors. approaches to the backward pruning of these much too large trees form the topic of a later section. we first return to the concept of a node s purity in the context of selecting one attribute in preference to another for splitting a given node. splitting criteria readers accustomed to working with categorical data will recognise in figure crosstabulations reminiscent of the contingency tables of statistics. for example it only machine learning of rules and trees requires completion of the column totals of the second tabulation to create the standard input to a two-by-two by applying a the hypothesis under test is that the distribution of cases between mammals and not-mammals is independent of the distribution between the two breathing modes. a possible rule says that the smaller the probability obtained test to this hypothesis then the stronger the splitting credentials of the attribute breathing turning to the construction of multi-class trees rather than yesno concept-recognisers an adequate number of fishes in the training sample would under almost any purity criterion ensure early selection of breathing similarly given adequate representation of reptiles taillong would score highly since lizards and snakes account for of living reptiles. the corresponding x contingency table would have the form feg long tail? short none totals table cross-tabulation of classes and tail attribute-values given in table on the hypothesis of no association the expected numbers in the j where longh cells can be got from the marginal totals. thus expected expectedg h expected is distributed as is the total in the training set. then c observed with degrees of freedom equal tocb fdg i.e. in this case. c number in mammal number in bird number in reptile number in amphibian number in fish total suppose however that the tail variable were not presented in the form of a categorical attribute with three unordered values but rather as a number as the ratio for example of the length of the tail to that of the combined body and head. sometimes the first step is to apply some form of clustering method or other approximation. but virtually every algorithm then selects from all the dichotomous segmentations of the numerical scale meaningful for a given node that segmentation that maximises the chosen purity measure over classes. k long short none with suitable refinements the chaid decision-tree algorithm automatic interaction detection uses a splitting criterion such as that illustrated with the foregoing contingency table although not included in the present trials chaid enjoys widespread commercial availability through its inclusion as an optional module in the spss statistical analysis package. other approaches to such tabulations as the above use information theory. we then enquire what is the expected gain in information about a case s row-membership from knowledge of its column-membership? methods and difficulties are discussed by quinlan the reader is also referred to the discussion in section with particular reference to mutual information a related but more direct criterion applies bayesian probability theory to the weighing of evidence good for the classical treatment in a sequential testing framework logarithmic measure is again used namely log-odds or plausibilities k k k k k k k k k k k k k k sec. rules and trees from data first principles of hypotheses concerning class-membership. the plausibility-shift occasioned by each observation is interpreted as the weight of the evidence contributed by that observation. class-membership we ask what expected total weight of evidence bearing on the hypotheses is obtainable from knowledge of an attribute s values over the cells? preference goes to that attribute contributing the greatest expected total michie al attar the sequential bayes criterion has the merit once the tree is grown of facilitating the recalculation of probability estimates at the leaves in the light of revised knowledge of the priors. in their cart work breiman and colleagues initially used an information-theoretic criterion but subsequently adopted their gini index. for a given node and classes with g estimated probabilities c authors note a number of interesting interpretations of this expression. but they also remark that within a wide range of splitting criteria the properties of the final tree selected are surprisingly insensitive to the choice of splitting rule. the criterion used to prune or recombine upward is much more important. d e the index can be writtenf g the c getting a right-sized tree cart s and s pruning starts with growing a tree that is much too large how large is too large as tree-growth continues and end-nodes multiply the sizes of their associated samples shrink. probability estimates formed from the empirical class-frequencies at the leaves accordingly suffer escalating estimation errors. yet this only says that overgrown trees make unreliable probability estimators. given an unbiased mapping from probability estimates to decisions why should their performance as classifiers suffer? performance is indeed impaired by overfitting typically more severely in tree-learning than in some other multi-variate methods. figure typifies a universally observed axis. breiman et al. from whose book the figure has been taken describe this relationship as a fairly rapid initial decrease followed by a long flat valley and then a gradual increase in this long flat valley the minimum is almost constant except for up-down changes relationship between the number of terminal nodes and misclassification rates f se range. meanwhile the performance of the tree on the training sample well within the shown in the figure continues to improve with an increasingly over-optimistic error rate usually referred to as the resubstitution error. an important lesson that can be drawn from inspection of the diagram is that large simplifications of the tree can be purchased at the expense of rather small reductions of estimated accuracy. overfitting is the process of inferring more structure from the training sample than is justified by the population from which it was drawn. quinlan illustrates the seeming paradox that an overfitted tree can be a worse classifier than one that has no information at all beyond the name of the dataset s most numerous class. this effect is readily seen in the extreme example of random data in which the class of each case is quite unrelated to its attribute values. i constructed an artificial dataset of this kind with ten attributes each of which took the value or with equal probability. the class was also binary yes with probability and no with probability one thousand randomly generated cases were split intp a training set of and a test set of from this data s initial tree-building routine f machine learning of rules and trees fig. a typical plot of misclassification rate against different levels of growth of a fitted tree. horizontal axis no. of terminal nodes. vertical axis misclassification rate measured on test data. produces a nonsensical tree of nodes that has an error rate of more than on the test cases the random data above a tree consisting of just the leaf no would have an expected error rate of on unseen cases yet the elaborate tree is noticeably less accurate. while the complexity comes as no surprise the increased error attributable to overfitting is not intuitively obvious. to explain this suppose we have a two-class task in which a case s class is inherently indeterminate with classifier assigns all such cases to this majority class its expected error rate is if on the other hand the classifier assigns a case to the majority its expected of the cases belonging to the majority class no. if a proportion r clearlyf class with probability and to the other class with probabilityf other class c majority classc this is generally greater thanf g and k which comes to k the probability that a case belonging to the other class is assigned to the is at least so the second classifier will have a higher error rate. now the complex decision tree bears a close resemblance to this second type of classifier. the tests are unrelated to class so like a symbolic pachinko machine the tree sends each case randomly to one of the leaves. n g since the probability that a case belonging to the majority class is assigned to the error rate is the sum of l quinlan points out that the probability of reaching a leaf labelled with class c is the same as the relative frequency of c in the training data and concludes that the tree s expected value. error rate for the random data above is h given the acknowledged perils of overfitting how should backward pruning be applied to a too-large tree? the methods adopted for cart and follow different philosophies and other decision-tree algorithms have adopted their own variants. we have now reached the level of detail appropriate to section in which specific features of the various tree and rule learning algorithms including their methods of pruning are examined. before proceeding to these candidates for trial it should be emphasized that their selection was or quite close to the observed h f f g f sec. statlog s ml algorithms necessarily to a large extent arbitrary having more to do with the practical logic of coordinating a complex and geographically distributed project than with judgements of merit or importance. apart from the omission of entire categories of ml with the genetic and ilp algorithms discussed in chapter particular contributions to decision-tree learning should be acknowledged that would otherwise lack mention. first a major historical role which continues today belongs to the assistant algorithm developed by ivan bratko s group in slovenia kononenko and bratko assistant introduced many improvements for dealing with missing values attribute splitting and pruning and has also recently incorporated the m-estimate method and bratko see also dzeroski cesnik and petrovski of handling prior probability assumptions. second an important niche is occupied in the commercialsector of ml by the xpertrule family of packages developed by attar software ltd. facilities for large-scale data analysis are integrated with sophisticated support for structured induction for example attar these and other features make this suite currently the most powerful and versatile facility available for industrial ml. statlog s ml algorithms tree-learning further features of the reader should be aware that the two versions of used in the statlog trials differ in certain respects from the present version which was recently presented in quinlan the version on which accounts in section are based is that of the radical upgrade described in quinlan newid newid is a similar decision tree algorithm to similar to newid inputs a set of satisfies the termination condition then output the current tree and halt. classification. unlike newid does not perform windowing. thus its core procedure is simpler and a classm its output is a decision tree which performs a set of attributes examples set the current examples to if determine the value of the evaluation function. with the attribute for each attribute that has the largest value of this function divide the set values. for each such subset of examples recursively re-enter at step with set to set the subtrees of the current node to be the subtrees thus produced. the termination condition is simpler than i.e. it terminates when the node contains all examples in the same class. this simple-minded strategy tries to overfit the training data and will produce a complete tree from the training data. newid deals with empty leaf nodes as does but it also considers the possibility of clashing examples. if the set of attributes is empty it labels the leaf node as clash meaning that it is impossible to distinguish between the examples. in most situations the attribute set will not be empty. so newid discards attributes that have been used as they can contribute no more information to the tree. into subsets by attribute machine learning of rules and trees tion of newid is the information gain function bkbcm for classification problems where the class values are categorical the evaluation funcit does a similar lookahead to determine the best attribute to split on using a greedy search. it also handles numeric attributes in the same way as does using the attribute subsetting method. numeric class values newid allows numeric class values and can produce a regression tree. for each split it aims to reduce the spread of class values in the subsets introduced by the split instead of trying to gain the most information. formally for each ordered categorical attribute with g values in the set c class of it chooses the one that minimises the value of attribute value of for numeric attributes the attribute subsetting method is used instead. e is a c c when the class value is numeric the termination function of the algorithm will also be different. the criterion that all examples share the same class value is no longer appropriate and the following criterion is used instead the algorithm terminates at a node g fdh is the standard deviation split into fractional examples for each possible value of that attribute. the fractions of the different values sum to they are estimated from the numbers of examples of the same class with a known value of that attribute. user-tunable parameter. missing values there are two types of missing values in newid unknown values and don t-care values. with examples when c where is the original example set and the constantd during the training phase if an example of classm has an unknown attribute value it is consider attribute with values d andk there are examples at the current node in classm with values for e and missing naively we would split the in the ratio to d and however the laplace criterion gives a better estimate of the expected ratio of e tok using the formula feg h m i dkbc e i ck k feg h c e! is the no. examples in classm with attribute i is the total no. examples in classm is the total no. examples in with and similarly for m i dkbcbk don t-care s are intended as a short-hand to cover all the possible values of the don t-care attribute. they are handled in a similar way to unknowns except the example is simply duplicated not fractionalised for each value of the attribute when being inspected. g this latter laplace estimate is used in newid. ck c e e k where f g g d g g g g g k k sec. statlog s ml algorithms thus in a similar case with d s s and the example would be considered as examples one with value d and one with valuek this duplication only occurs when inspecting the split caused by attribute if a different attribute the example with is being considered is only considered as example. note this is an ad hoc method because the duplication of examples may cause the total number of examples at the leaves to add up to more than the total number of examples originally in the training set. and a known value for when a tree is executed and the testing example has an unknown value for the attribute being tested on the example is again split fractionally using the laplace estimate for the ratio but as the testing example s class value is unknown all the training examples at class ratios are the fractional examples arrive. rather than predicting the majority class a probabilistic classification is made for to split the testing example into. the numbers of training examples at the node are found by back-propagating the example counts recorded at the leaves of the subtree beneath the node back to that node. the class predicted at a node is the majority class there a tie with more than one majority class select the first the example may thus be classified the node than just those of classm are used to estimate the appropriate fractions andm wherem and asm say asm are the majority classes at the two leaves where and as andm classifies an example asm example a leaf with for classesm than simply asm for fractional examples the distributions would be weighted and summed for example arrives at leaf at leaf and thus the example is the pruning algorithm works as follows. given a treez examples a further pruning set of examples and a threshold value lying below internal node if the subtree ofz of thez for the pruning examples than node sub-tree and make node is set tof a leaf-node. by default a testing example tested on an attribute with a don t-care value is simply duplicated for each outgoing branch i.e. a whole example is sent down every outgoing branch thus counting it as several examples. tree pruning induced from a set of learning then for each provides better accuracy but one can modify it does labelled by the majority class for the learning examples at that node then leave the subtree unpruned otherwise prune it delete the to suit different tasks. apart from the features described above are more relevant to the version of newid used for statlog newid has a number of other features. newid can have binary splits for each attribute at a node of a tree using the subsetting principle. it can deal with ordered sequential attributes attributes whose values are ordered. newid can also accept a pre-specified ordering of attributes so the more important ones will be considered first and the user can force newid to choose a particular attribute for splitting at a node. it can also deal with structured attributes. is not a single algorithm it is a knowledge acquisition environment for expert systems which enables its user to build a knowledge base or an expert system from the analysis of examples provided by the human expert. thus it placed considerable emphasis on the m machine learning of rules and trees graphical interface. this interface is consisting of graphical editors which enable the user to define the domain to interactively build the data base and to go through the hierarchy of classes and the decision tree. dialog and interaction of the system with the user. the user interacts with via a can be viewed as an extension of a tree induction algorithm that is essentially the same as newid. because of its user interface it allows a more natural manner of interaction with a domain expert the validation of the trees produced and the test of its accuracy and reliability. it also provides a simple fast and cheap method to update the rule and data bases. it produces from data and known rules of the domain either a decision tree or a set of rules designed to be used by expert system. further features of cart cart classification and regression tree is a binary decision tree algorithm et al. which has exactly two branches at each internal node. we have used two different implementations of cart the commercial version of cart and indcart which is part of the ind package see naive bayes section indcart differs from cart as described in breiman et al. in using a different better way of handling missing values in not implementing the regression part of cart and in the different pruning settings. evaluation function for splitting the evaluation function used by cart is different from that in the family of algorithms. consider the case of a problem with two classes and a node has examples from each class the node has maximum impurity. if a split could be found that split the data into one subgroup of and another of then intuitively the impurity has been reduced. the impurity would be completely removed if a split could be found that produced sub-groups and in cart this intuitive idea of impurity is formalised in the gini index for subgroups is summed and the split with the maximum reduction in impurity chosen. for ordered and numeric attributes cart considers all possible splits in the sequence. the current nodem bk icm where is the probability of class inm for each possible split the impurity of the f splits. for categorical attributes cart examines fork values of the attribute there arek all possible binary splits which is the same as attribute subsetting used for fork f splits. at each node cart searches through the values of the attribute there are attributes one by one. for each attribute it finds the best split. then it compares the best single splits and selects the best attribute of the best splits. minimal cost complexity tree pruning apart from the evaluation function cart s most crucial difference from the other machine learning algorithms is its sophisticated pruning mechanism. cart treats pruning as a tradeoff between two issues getting the right size of a tree and getting accurate estimates of the true probabilities of misclassification. this process is known as minimal costcomplexity pruning. g f sec. statlog s ml algorithms is if be a decision tree used to as the cost for each leaf is such that all other subtrees have higher cost complexities or have the same cost complexity it is a two stage method. considering the first stage letz classifyk examples in the training set be the misclassified set of size if bcz let is the number of leaves inz for some parameter the cost complexity ofz e! e bcbz if we regard where is the error estimate ofz is a linear combination of its error estimate and a penalty for its complexity. if small the penalty for having a large number of leaves is small andz will be large. as increases the minimising subtree will decrease in size. now if we convert some subtree to a leaf. the new treez would misclassifyd more examples but would contain bc is the same as that ofz fewer leaves. the cost complexity ofz feg kn dc bc g for any value of which minimises it can be shown that there is a unique subtreez cz as a pruned subtree. and havez there is as above. let this tree bez we can find the subtree such that forz where each subtree is produced by is then a minimising sequence of treesz fromz we examine each pruning upward from the previous subtree. to producez non-leaf subtree ofz and find the minimum value of that value of will be replaced by leaves. the best tree is selected from this series of trees would be this latter stage selects a single tree based on its reliability i.e. classification error. the problem of pruning is now reduced to finding which tree in the sequence is the optimally sized one. chosen. however this is not the case and it tends to underestimate the number of errors. a more honest estimate is therefore needed. in cart this is produced by using crossvalidation. the idea is that instead of using one sample data to build a tree and another sample data to test the tree you can form several pseudo-independent samples from the original sample and use these to form a more accurate estimate of the error. the general method is with the classification error not exceeding an expected error rate on some test set which is done at the second stage. g was unbiased then the largest treez if the error estimate the one or more subtrees with tok form the cross-validation error estimate as randomly split the original sample intok equal subsamples for a build a tree on the training set n x and b determine the error estimate using the pruning set cross-validation and cost complexity pruning is combined to select the value of the method is to estimate the expected error rates of estimates obtained withz values of using cross-validation. from these estimates it is then possible to estimate an optimal value b e of for which the estimated true error rate ofz for all the data is the for all g g g g h k g f d g z z f machine learning of rules and trees is that value of a which minimises the mean the cart methodology therefore involves two quite separate calculations. first the is determined using cross-validation. ten fold cross-validation is recom the value d minimum for all values of cross-validation error estimate. oncez has been determined the tree that is finally suggested for use is that which minimises the cost-complexity using d and all the data. value of d mended. the second step is using this value of and y of a node if the best split of yy on the attributes other than e is the split on the attribute find the split that is most similar to if an example has the value of missing values missing attribute values in the training and test data are dealt with in cart by using surrogate splits. the idea is this define a measure of similarity between any two splits missing decide whether it goes to the left or right sub-tree by using the best surrogate split. if it is missing the variable containing the best surrogate split then the second best is used and so on. to grow the final tree. is especially designed for continuous and ordered discrete valued attributes though an added sub-algorithm is able to handle unordered discrete valued attributes as well. is a decision threshold. similar to other decision tree methods only class areas bounded by hyperplanes parallel to the axes of the feature space are possible. evaluation function for splitting the tree will be constructed sequentially starting with one attribute and branching with other attributes recursively if no sufficient discrimination of classes can be achieved. that let the examples be sampled from the examples expressed withk attributes. separates the examples from thek dimensions into areas represented by subsets g of samples where the classm jc g exists with a probability g cm where f is if at a node no decision for a classm according to the above formula can be made a let be a certain non-leaf node in the tree construction process. at first the attribute with the best local discrimination measure at this node has to be determined. for that two different methods can be used by an option a statistical and an entropy measure respectively. the statistical approach is working without any knowledge about the result of the desired discretisation. for continuous attributes the quotient meyer-br otz sch urmann branch formed with a new attribute is appended to the tree. if this attribute is continuous a discretisation i.e. intervals corresponding to qualitative values has to be used. e is the standard deviation of is the mean value of the square of distances between the classes. this measure has to be computed for each is chosen as the best one for splitting at this node. the entropy measure provided as an evaluation function requires an d y i yk c is a discrimination measure for a single attribute where examples in from the centroid of the attribute value and attribute. the attribute with the least value of d y i yk c intermediate discretisation at n for each attribute using the splitting procedure described f k f g g sec. statlog s ml algorithms are ordered along the axis of the selected the formula for computing this confidence interval can be used to obtain an estimate of the the hypothesis of an already existing interval. discretisation well known entropy measure the attribute with the largest value of all is selected and occurs than the discretisation procedure below leads to a refinement g of information will be computed for k by the below. then the gain the gain is chosen as the best one for splitting at that node. note that at each node d d will be considered again. if available attributes already in the path to reaching the current node all examples new attribute according to increasing values. intervals which contain an ordered set of values of the attribute are formed recursively on the collecting examples from left to right until a class decision can be made on a given level of confidence the number let be a current interval containingk examples of different classes andk thenk of examples belonging to classm g on the current node probability cm g there exists a classm occurring in with cm occurring in holds on a certain level g the inequality cm for all classesm n yields a confidence interval of confidencef a given x long sequence of examples the true value of probability lies within g for cm g and in a an estimation on the levelf cm g with probability cm x bm m labels for each classm see unger wysotski i.e. this hypothesis is true if for each classm now the following meta-decision on the dominance of a class in can be defined as if there exists a classm where is true thenm dominates in the interval if for all classes appearing in in this case the interval will be closed too. a new test with another attribute is if neither nor occurs the interval has to be extended by the next example of the a majority decision will be made. is derived from the tchebyschev inequality by supposing a bernoulli distribution of class i.e. is true if the complete confidence interval lies above the predefined threshold and order of the current attribute. if there are no more examples for a further extension of taking into account this confidence interval the hypotheses and are tested by cm cm cm g g c closed. the corresponding path of the tree is terminated. the threshold. necessary. will be tested against m d e the complete confidence interval is less than the hypothesis is true then no class dominates in is f h k f g f f k g e f f g machine learning of rules and trees merging is removed if the inequality yield the leaf nodes of the decision tree. the same rule is applied for adjacent intervals where no class dominates and which contain identical remaining classes due to the following with the same class label can be merged. the resultant intervals is the total number of different class labels occurring in adjacent intervals k elimination procedure. a class within an interval g is satisfied wherek cm class will be omitted if its probability in distribution of all classes occurring in these resultant intervals yield the intermediate all terminated. note that a majority decision is made at a node if because of a too small nodes in the construction of the decision treefor which further branching will be performed. every intermediate node becomes the start node for a further iteration step repeating the steps from sections to the algorithm stops when all intermediate nodes are a is less than the value of an assumed constant no estimation of probability can be done. discrete unordered attributes to distinguish between the different types of attributes the program needs a special input vector. the algorithm for handling unordered discrete valued attributes is similar to that described in sections to apart from interval construction. instead of intervals discrete points on the axis of the current attribute have to be considered. all examples with the same value of the current discrete attribute are related to one point on the axis. for each point the hypotheses and will be tested and the corresponding actions and performed respectively. if neither nor is true a majority decision will be made. this approach also allows handling mixed and continuous valued attributes. probability threshold and confidence as can be seen from the above two parameters affect the tree construction process the first for accept a node and the second is a predefined confidence level the tree is pre-pruned at should depend on the training pruning set and determines the accuracy of the approximation of the class hyperplane i.e. the admissible error rate. the higher the degree of overlapping of class regions in the feature space the less the threshold has to be for getting a reasonable classification result. the accuracy of the approximation and simultaneously the complexity of the resulting tree can be controlled by the user. in addition to in a class dependent manner taking into account different costs for misclassification of different classes. with other words the influence of a given cost matrix can be taken into account during training if the different costs for misclassification can be reflected by a class dependent threshold vector. one approach has been adopted by is a predefined threshold if the conditional probability of a class exceeds the threshold that node. the choice of therefore by selecting the value of a constant g of the cost matrix will be summed up every column bc the threshold of that class relating to the column for which has to be chosen by the user like in the case of a constant threshold the other thresholds c will be computed by the formula the algorithm allows to choose the threshold is a maximum f h g f g sec. statlog s ml algorithms are proportional to their corresponding column sums of the cost matrix which can be interpreted as a penalty measure for misclassification into those classes. for estimating the appropriate class the better the demanded quality of estimation and the worse the ability to separate intervals since the algorithm is enforced to construct large intervals in order to get sufficient statistics. from experience should be set to one. thus all values of the class dependent thresholds compared with the threshold the confidence level probability has an inversely proportional effect. the less the value of and a suitable approach for the automatically choosing the parameters available. therefore a program for varying the parameter between by default and between by default is used to predefine the best parameter combination i.e. that which gives the minimum cost error rate respectively on a test set. however this procedure may be computationally expensive in relation to the number of attributes and the size of data set. in steps of and is not and bayes tree this is a bayesian approach to decision trees that is described by buntine and is available in the ind package. it is based on a full bayesian approach as such it requires the specification of prior class probabilities based on empirical class proportions and a probability model for the decision tree. a multiplicative probability model for the probability of a tree is adopted. using this form simplifies the problem of computing tree probabilities and the decision to grow a tree from a particular node may then be based on the increase in probability of the resulting tree thus using only information local to that node. of all potential splits at that node that split is chosen which increases the posterior probability of the tree by the greatest amount. post-pruning is done by using the same principle i.e. choosing the cut that maximises the posterior probability of the resulting tree. of all those tree structures resulting from pruning a node from the given tree choose that which has maximum posterior probability. an alternative to post-pruning is to smooth class probabilities. as an example is dropped down the tree it goes through various nodes. the class probabilities of each node visited contribute to the final class probabilities a weighted sum so that the final class probabilities inherit probabilities evaluated higher up the tree. this stabilises the class probability estimates reduces their variance at the expense of introducing bias. costs may be included in learning and testing via a utility function for each class utility is the negative of the cost for the two-class case. rule-learning algorithms this algorithm of clark and niblett s was sketched earlier. it aims to modify the basic aq algorithm of michalski in such a way as to equip it to cope with noise and other complications in the data. in particular during its search for good complexes does not automatically remove from consideration a candidate that is found to include one or more negative example. rather it retains a set of complexes in its search that is evaluated statistically as covering a large number of examples of a given class and few of other classes. moreover the manner in which the search is conducted is general-to-specific. each trial specialisation step takes the form of either adding a new conjunctive term or removing a disjunctive one. having found a good complex the algorithm removes those examples it f is empty then stop and return rule list and add the rule if best cpx then is the most common class of examples covered machine learning of rules and trees covers from the training set and adds the rule if then predict to the end of the rule list. the process terminates for each given class when no more acceptable complexes can be found. clark niblett s algorithm has the following main features the dependence on specific training examples during search feature of the aq algorithm is removed it combines the efficiency and ability to cope with noisy data of decisiontree learning with the if-then rule form and flexible search strategy of the aq family it contrasts with other approaches to modify aq to handle noise in that the basic aq algorithm itself is generalised rather than patched with additional pre- and post-processing techniques and it produces both ordered and unordered rules. and output a set of rules called rule list. the core of is the procedure as follows but it needs to use a sub-procedure to return the value of best cpx let rule list be the empty list inputs a set of training examples let best cpx be the best complex found from if best cpx or remove the examples covered by best cpx from classm to the end of rule list wherem by best cpx re-enter at step this subprocedure is used for producing ordered rules. also produces a set of unordered rules which uses a slightly different procedure. to produce unordered rules the above procedure is repeated for each class in turn. in addition in step only the positive examples should be removed. the procedure for finding the best complex is as follows let the set star contain only the empty complex and best cpx be nil let selectors be the set of all possible selectors if star is empty then return the current best cpx specialise all complexes in star as newstar which is the set star y d b selectors and remove all complexes in newstar that are either in star the unspecialised ones or are null for every complex in newstar if when tested on then replace the current value of best cpx by remove criteria when tested on all worst complexes from newstar until the size of newstar is below the user-defined maximum set star to newstar and re-enter at step is statistically significant significance and better than goodness best cpx according to user-defined as can be seen from the algorithm the basic operation of is that of generating a complex a conjunct of attribute tests which covers is satisfied by a subset of the training examples. this complex forms the condition part of a production rule if condition k then class where class is the most common class in the examples which satisfy the condition. the condition is a conjunction of selectors each of which represents a test on the values of an attribute such as weatherwet the search proceeds in both aq and by repeatedly specialising candidate complexes until one which covers a large number of examples of a single class and few of other classes is located. details of each search are outlined below. sec. statlog s ml algorithms the search for specialisations the algorithm works in an iterative fashion each iteration searching for a complex amples of the current class are called positive examples and the other examples are called negative examples. the complex must be both predictive and reliable as determined by s evaluation functions. having found a good complex those examples it covers are covering a large number of examples of a single classm and few of other classes. exremoved from the training set and the rule if complex then classm is added to the end of the rule list. this greedy process iterates until no more satisfactory complexes can be found. to generate a single rule first starts with the most general rule if true then classc all examples are class c where c is the current class. then searches for complexes by carrying out a general-to-specific beam search. the extent of the beam search for a complex can be regulated by controlling the width number of complexes explored in parallel of the beam. at each stage in the search retains a size-limited the set of all possible selectors with the current star eliminating all the null and unchanged elements in the resulting set of complexes. null complex is one that contains a pair of this set carrying out a beam search of the space of complexes. a complex is specialised by adding a new conjunctive term in one of its selector. each complex can be specialised in several ways and generates and evaluates all such specialisations. the star is trimmed after completion of this step by removing its lowest ranking elements as measured by an evaluation function that we will describe shortly. set or star of complexes explored so far the system examines only specialisations of the implementation of the specialisation step in is to repeatedly intersect incompatible selectors for example used for further specialisation in the goodness is a measure of the quality of the search heuristics there are two heuristics used in the search for the best complexes and both can be tuned by the user depending on the specific domain the significance level and the goodness measure. significance is an absolute threshold such that any complexes below the threshold will not be considered for selecting the best complex they are still complexes so it is used to order the complexes that are above the significance threshold to select the best complex. several difference functions can be chosen to guide the search for a good rule in the system for example number of correctly classified examples divided by total number covered this is the traditional aq evaluation function. entropy similar to the information gain measure used by and other decision tree algorithms. is the number of classes in the problem. g where fdgih the laplacian error estimate cbkk m ck e d is the total number of examples covered by the rulek the intersection of set with set examples covered by the rule andd for example using to abbreviate is the set if we now remove intersected with is unchanged elements in this set we obtain e d is the number of positive k d g k machine learning of rules and trees uses one of these criteria according to the user s choice to order the goodness of rules. to test significance uses the entropy statistic. this is given by e d i is the observed frequency distribution of examples among is the expected frequency distribution of the same number of examples under the assumption that the complex selects examples logc where the distribution classes satisfying a given complex and randomly. this is taken as the w covered examples distributed among classes r with the same probability as that of examples in the entire training set. this statistic provides an information-theoretic measure of the distance between the two distributions. the user provides a threshold of significance below which rules are rejected. missing values similar to newid can deal with unknown or don t-care values. during rule generation a similar policy of handling unknowns and don t-cares is followed unknowns are split into fractional examples and don t-cares are duplicated. each rule produced by is associated with a set of counts which corresponds to the number of examples covered by the rule belonging to each class. strictly speaking for the ordered rules the counts attached to rules when writing the rule set should be those encountered during rule generation. however for unordered rules the counts to attach are generated after rule generation in a second pass following the execution policy of splitting an example with unknown attribute value into equal fractions for each value rather than the laplace-estimated fractions used during rule generation. when normally executing unordered rules without unknowns for each rule which fires the class distribution distribution of training examples among classes attached to the rule is collected. these are then summed. thus a training example satisfying two rules with attached class distributions and has an expected distribution which desired. the built-in rule executer follows the first strategy example is classed simply hff if probabilistic classification is being predicted or m results inm with unordered rules an attribute test whose value is unknown in the training example causes the example to be examined. if the attribute has three values of the example is deemed to have passed the test and thus the final class distribution is weighted by when collected. a similar rule later will again cause of the example to pass the test. a don t-care value is always deemed to have passed the attribute test in full weight the normalisation of the class counts means that an example with a don t-care can only count as a single example during testing unlike newid where it may count as representing several examples. with ordered rules a similar policy is followed except after a rule has fired absorbing say of the testing example only the remaining are sent down the remainder of class frequency to be collected but a second the rule list. the first rule will cause similar rule will cause class frequency to be collected. thus the fraction of the example gets less and less as it progresses down the rule list. a don t-care value always h g m sec. statlog s ml algorithms f evaluations wherek requires optimal split withk passes the attribute test in full and thus no fractional example remains to propagate further down the rule list. numeric attributes and rules for numeric attributes will partition the values into two subsets and test which subset each example belongs to. the drawback with a na ve implementation of this is that it is the number of attribute values. breiman et al. proved that in the special case where there are two class values it is possible to find an f comparisons. in the general case heuristic methods must be used. the aq algorithm produces an unordered set of rules whereas the version of the algorithm used in statlog produces an ordered list of rules. unordered rules are on the whole more comprehensible but require also that they are qualified with some numeric confidence measure to handle any clashes which may occur. with an ordered list of rules clashes cannot occur as each rule in the list is considered to have precedence over all subsequent rules. relation between and aq there are several differences between these two algorithms however it is possible to show that strong relationships exist between the two so much so that simple modifications of the system can be introduced to enable it to emulate the behaviour of the aq algorithm. see michalski larson aq searches for rules which are completely consistent with the training data whereas may prematurely halt specialisation of a rule when no further rules above a certain threshold of statistical significance can be generated via specialisation. thus the behaviour of aq in this respect is equivalent to setting the threshold to zero. when generating specialisations of a rule aq considers only specialisations which exclude a specific negative example from the coverage of a rule whereas considers all specialisations. however specialisations generated by which don t exclude any negative examples will be rejected as they do not contribute anything to the predictive accuracy of the rule. thus the two algorithms search the same space in different ways. whereas published descriptions of aq leave open the choice of evaluation function to use during search the published norm is that of number of correctly classified examples divided by total examples covered the original algorithm uses entropy as its evaluation function. to obtain a synthesis of the two systems the choice of evaluation function can be user-selected during start of the system. aq generates order-independent rules whereas generates an ordered list of rules. to modify to produce order-independent rules requires a change to the evaluation function and a change to the way examples are removed from the training set between iterations of the complex-finding algorithm. the basic searchalgorithm remains unchanged. itrule the hypotheses during decision rule construction. its output is a set of probability rules which are the most informative selected from the possible rules depending on the training data. goodman smyth s itrule algorithm uses a function called the to rank to build rules. it keeps a ranked list of the algorithm iterates through each attribute the class attribute value in turn best rules determined to that point of the machine learning of rules and trees th rule is used as the running minimum to determine whether a new rule should be inserted into the rule list. for each attribute value the algorithm must find all possible conditions to add to the left hand side of an over-general rule to specialise it. or it may decide to drop a condition to generalise an over-specific rule. the rules considered are those limited by the algorithm execution is the size of the beam search. the of minimum running value which prevents the algorithm from searching a large three points should be noted. first itrule produces rules for each attribute value. so it can also capture the dependency relationships between attributes between attributes and classes and between class values. secondly itrule not only specialises existing rules but also generalises them if the need arises. specialisation is done through adding conditions to the left hand side of the rule and generalisation is done through dropping conditions. finally itrule only deals with categorical examples so it generally needs to convert numeric attributes and discrete values. rule space. such estimates can be reasonable accurate. the itrule algorithms uses a maximum entropy estimator evaluation function the and be an attribute with values let be an attribute with values in the set the is a method for calculating the information content in it is g of attribute given the value of attribute oc c c kbc c c g is the a priori g is the conditional probability of given where c these can normally be estimated from the relative probability of frequency of the value of when the distribution is uniform and the data set is sufficient exke e ex and where are parameters of an initial density estimate k in the data and event c c c d g can be interpreted as a measure of the simplicity of the of are zero. the first term c hypothesis that cross-entropy is is dependent on the event of the variable with the condition known to measure the goodness of fit between two distributions see goodman smyth rule searching strategy itrule performs both generalisation and specialisation. it starts with a model driven strategy much like but its rules all have probability attached from the beginning. so a universal rule will be is the total number of is related to the second term the above is true because it takes into account the fact that the probabilities of other values the average information content is therefore defined as c c and c is the number of the is equal to the cross-entropy f f g g g g f e g g g g g g sec. beyond the complexity barrier into the rule list. this process continues until no rule can be produced to cover remaining examples. to it calculates the g m it requires namely the increase in simplicity is sufficiently compensated for i dk then d with probabilityf if dk to specialise a rule such as one with current c all possible values of g for attributem if then it insert the new rule with specialised conditionm generalise a rule with the current value gj c where yk my by the decrease in cross-entropy. c m m beyond the complexity barrier all ml designers whether rule-oriented or tree-oriented agree that to the extent that the data permits mental fit is an indispensible hall-mark. thus discussing requirements of rule learning systems clark niblett state that for the sake of comprehensibility the induced rules should be as short as possible. however when noise is present overfitting can lead to long rules. thus to induce short rules one must usually relax the requirement that the induced rules be consistent with all the training data. such measures constitute the analogue of pruning of trees. but tree pruning and rule-set simplification measures may encounter complexity barriers that limit how much can be done in the direction of mental fit while retaining acceptable accuracy. when this occurs are there other directions in which descriptive adequacy can still be sought? trees into rules a tree that after pruning still remains too big to be comprehensible is a sign that a more powerful description language is required. a modest but often effective step starts by recognising that there is no intrinsic difference in expressive power between rulesets and trees yet rule languages seem to lend themselves more to user-friendliness. a successful exploitation of this idea takes the form of a compressive re-organisation of induced trees into rule-sets. quinlan s trees-into-rules algorithm his book for the most recent version starts with the set formed from a decision tree by identifying each root-to-leaf path with a rule. each rule is simplified by successively dropping conditions in the specific-to-general style illustrated at the beginning of this chapter. the difference lies in the sophistication of criteria used for retracting a trial generalisation when it is found to result in inclusion of cases not belonging to the rule s decision class. in the noise-free taxonomy problem of the earlier tutorial example a single false positive was taken to bar dropping the given condition. as with and some other rule-learners a statistical criterion is substituted. quinlan s is based on forming from the training set pessimistic estimates of the accuracy that a candidate rule would show on a test set. when specific-to-general simplification has run its course for each class in turn a final scan is made over each ruleset for any that in the context of the other rules are not contributing to the ruleset s accuracy. any such passengers are dropped. the end of this stage leaves as many subsets of if-then rules covers in the earlier terminology as there are classes i.e. one subset for each class. these subsets are then ordered prior to use for classifying new cases. the ordering principle first applies the subset which on the g m m g m g m m g machine learning of rules and trees training set gives fewest false positives. the one with most false positives is the last to be applied. by that time some of the false-positive errors that it could have made have been pre-empted by other rule-sets. finally a default class is chosen to which all cases which do not match any rule are to be assigned. this is calculated from the frequency statistics of such left-overs in the training set. whichever class appears most frequently among these left-overs is selected as the default classification. rule-structured classifiers generated in this way turn out to be smaller and better in mental fit than the trees from which the process starts. yet accuracy is found to be fully preserved when assayed against test data. a particularly interesting feature of quinlan s account for which space allows no discussion here is his detailed illustration of the minimum description length principle according to which the storage costs of rulesets and of their exceptions are expressed in a common information-theoretic coinage. this is used to address a simplification problem in building rule-sets that is essentially similar to the regulation of the pruning process in decision trees. the trade-off in each case is between complexity and predictive accuracy. manufacturing new attributes if a user-friendly description still cannot be extracted more radical treatment may be required. the data-description language s vocabulary may need extending with new combinations formed from the original primitive attributes. the effects can be striking. consider the problem of classifying as illegal or legal the chessboard positions formed by randomly placing the three pieces white king white rook and black king. combinatorially there are move. approximately two thirds of the positions are then illegal. two or more pieces may have been placed on the same square or the two kings may be diagonally or directly adjacent. additionally positions in which the black king is in check from the white rook are also illegal that it is white to move. positions or assume that it is white s turn to a problem is presented for inductive analysis as a training set of n cases sampled randomly from the total space of possible placements as shown in table given sufficiently large n table constitutes what mccarthy and hayes termed an epistemologically adequate representation it supplies whatever facts are in principle needed to obtain solutions. but for decision-tree learning the representation is not heuristically adequate michie bain applied a state-of-the-art decision-tree learner of roughly similar power to to training sets of examples. the resulting tree performed on test data with only accuracy not differing significantly from that achievable by making the default conjecture illegal for every case. the next step was to augment the six attributes with fifteen new ones manufactured by forming all possible pairwise differences among the original six. with the augmented attribute set two random partitions of a file of cases were made into a training set of and a test set of trees of and accuracy now resulted with nodes and nodes respectively. for making these very successful constructions the algorithm seized on just six attributes all newly manufactured namely the three pairwise differences among attributes and and the three among attributes and in this way even though in a verbose and contorted style it was able to express in decision-tree language certain key sec. beyond the complexity barrier table the six attributes encode a position according to the scheme filebk rank filewr rankwr filebk rankbk. id no. n class yes no no yes yes no sub-descriptions such as the crucial same-file and same-rank relation between white rook and black king. whenever one of these relations holds it is a good bet that the position is illegal. the gain in classification accuracy is impressive yet no amount of added training data could inductively refine the above excellent bet into a certainty. the reason again lies with persisting limitations of the description language. to define the cases where the classifier s use of samefilewr bk and samerankwr bk lets it down one needs to say that this happens if and only if the wk is between the wr and bk. decision-tree learning with attribute-set augmented as described can patch together subtrees to do duty for samefile and samerank. but an equivalent feat for a sophisticated three-place relation such as between is beyond the expressive powers of an attribute-value propositionallevel language. moreover the decision-tree learner s constructions were described above as very successful on purely operational grounds of accuracy relative to the restricted amount of training material i.e. successful in predictivity. in terms of descriptivity the trees while not as opaque as those obtained with primitive attributes only were still far from constituting intelligible theories. inherent limits of propositional-level learning construction of theories of high descriptivity is the shared goal of human analysts and of ml. yet the propositional level of ml is too weak to fully solve even the problem here illustrated. the same task however was proved to be well within the powers of dr. jane mitchella gifted and experienced human data analyst on the academic staff of strathclyde university and of a predicate-logic ml system belonging to the inductive logic programming family described in chapter the two independently obtained theories were complete and correct. one theory-discovery agent was human namely a member of the academic staff of a university statistics department. the other was an ilp learner based on muggleton feng s golem with closed world specialization enhancements private communication. in essentials the two theories closely approximated to the one shown below in the form of four if-then rules. these are here given in english after back-interpretation into chess terms. neither of the learning agents had any knowledge of the meaning of the task which was simply presented as in table they did not know that it had anything to do with chess nor even with objects placed on plane surfaces. the background knowledge given to the ilp learner was similar machine learning of rules and trees in amount to that earlier given to xpertrule in the form of manufactured attributes. if wr and bk either occupy same file and wk is not directly between or if they occupy the same rank and wk is not directly between then the position is illegal if wk and bk either are vertically adjacent or are horizontally adjacent or are diagonally adjacent then the position is illegal if any two pieces are on the same square then the position is illegal otherwise the position is legal. construction of this theory requires certain key sub-concepts notably of directly between definitions were invented by the machine learner using lower-level concepts such as lessthan as background knowledge. directly between holds among the three co-ordinate pairs if either the first co-ordinates are all equal and the second co-ordinates are in ascending or descending progression or the second co-ordinates are all equal and the first co-ordinates show the progression. bain s ilp package approached the relation piece-wise via invention of between-file and between-rank the human learner doubtless came ready-equipped with some at least of the concepts that the ml system had to invent. none the less with unlimited access to training data and the use of standard statistical analysis and tabulation software the task of theory building still cost two days of systematic work. human learners given hours rather than days constructed only partial theories falling far short even of operational adequacy also muggleton s.h. bain m. hayes-michie j.e. and michie d. bain s new work has the further interest that learning takes place incrementally by successive refinement a style sometimes referred to as non-monotonic generalisations made in the first pass through training data yield exceptions when challenged with new data. as exceptions accumulate they are themselves generalised over to yield sub-theories which qualify the main theory. these refinements are in turn challenged and so forth to any desired level. the krk illegality problem was originally included in statlog s datasets. in the interests of industrial relevance artificial problems were not retained except for expository purposes. no connection however exists between a data-set s industrial importance and its intrinsic difficulty. all of the ml algorithms tested by statlog were of propositional type. if descriptive adequacy is a desideratum none can begin to solve the krk-illegal problem. it would be a mistake however to assume that problems of complex logical structure do not occur in industry. they can be found for example in trouble-shooting complex circuitry in inferring biological activity from specifications of macromolecular structure in the pharmaceutical industry last section of chapter and in many other large combinatorial domains. as inductive logic programming matures and assimilates techniques from probability and statistics industrial need seems set to explore these more powerful ml description languages. sec. beyond the complexity barrier a human-machine compromise structured induction in industrial practice more mileage can be got from decision-tree and rule learning than the foregoing account might lead one to expect. comparative trials like statlog s having a scientific end in view necessarily exclude approaches in which the algorithm s user intervenes interactively to help it. the inability of propositional learning to invent new attributes can be by-passed in practical contexts where human-computer interaction can plug the gap. from this an approach known as structured induction has come to dominate commercial ml. the method originated by shapiro niblett also shapiro assigns the task of attribute-invention to the user in a manner that partitions the problem into a hierarchy of smaller problems. for each smaller problem a solution tree is separately induced. structured induction is closely related to the software discipline of structured programming for large problems the industrial stream of ml work will continue to flow along this human-computer channel. it may for some time remain exceptional for problem complexity to force users to look beyond rule-based ml and multivariate statistics. because the statlog ground-rules of comparative trials necessarily barred the user from substantive importation of domain-specific knowledge structured induction does not figure in this book. but industrially oriented readers may find advantage in studying cases of the method s successful field use. one such account by leech concerned process and quality control in uranium refining. a well-conceived application of structured decisiontree induction transformed the plant from unsatisfactory to highly satisfactory operation and is described in sufficient detail to be used as a working paradigm. similar experience has been reported from other industries michie for review. neural networks r. rohwer m. wynne-jones and f. wysotzki aston university and fraunhofer-institute introduction the field of neural networks has arisen from diverse sources ranging from the fascination of mankind with understanding and emulating the human brain to broader issues of copying human abilities such as speech and the use of language to the practical commercial scientific and engineering disciplines of pattern recognition modelling and prediction. for a good introductory text see hertz et al. or wasserman linear discriminants were introduced by fisher as a statistical procedure for classification. here the space of attributes can be partitioned by a set of hyperplanes each defined by a linear combination of the attribute variables. a similar model for logical processing was suggested by mcculloch pitts as a possible structure bearing similarities to neurons in the human brain and they demonstrated that the model could be used to build any finite logical expression. the mcculloch-pitts neuron figure consists of a weighted sum of its inputs followed by a non-linear function called the em activation function originally a threshold function. formally fe ji if otherwise lk other neuron models are quite widely used for example in radial basis function networks which are discussed in detail in section networks of mcculloch-pitts neurons for arbitrary logical expressions were handcrafted until the ability to learn by reinforcement of behaviour was developed in hebb s book the organisation of behaviour it was established that the functionality of neural networks was determined by the strengths of the connections between neurons hebb s learning rule prescribes that if the network responds in a desirable way to a given input then the weights should be adjusted to increase the probability of a similar m address for correspondence dept. of computer science and applied mathematics aston university birmingham u.k. g h f sec. introduction output npo input vectorrweight vectors weighted sum fig. mcculloch and pitts neuron. response to similar inputs in the future. conversely if the network responds undesirably to an input the weights should be adjusted to decrease the probability of a similar response. a distinction is often made in pattern recognition between supervised and unsupervised learning. the former describes the case where the the training data measurements on the surroundings are accompanied by labels indicating the class of event that the measurements represent or more generally a desired response to the measurements. this is the more usual case in classification tasks such as those forming the empirical basis of this book. the supervised learning networks described later in this chapter are the perceptron and multi layer perceptron the cascade correlation learning architecture and radial basis function networks. unsupervised learning refers to the case where measurements are not accompanied by class labels. networks exist which can model the structure of samples in the measurement or attribute space usually in terms of a probability density function or by representing the data in terms of cluster centres and widths. such models include gaussian mixture models and kohonen networks. once a model has been made it can be used as a classifier in one of two ways. the first is to determine which class of pattern in the training data each node or neuron in the model responds most strongly to most frequently. unseen data can then be classified according to the class label of the neuron with the strongest activation for each pattern. alternatively the kohonen network or mixture model can be used as the first layer of a radial basis function network with a subsequent layer of weights used to calculate a set of class probabilities. the weights in this layer are calculated by a linear one-shot learning algorithm section giving radial basis functions a speed advantage over non-linear training algorithms such as most of the supervised learning methods. the first layer of a radial basis function network can alternatively be initialised by choosing a subset of the training data points to use as centres. s n q k neural networks and targets typically by minimising the total squared error supervised networks for classification in supervised learning we have an instance of data comprising an attribute vectort we processt with a network to produce an outputv which has and a target vectoru the same form as the target vectoru the parameters of the networkw cbv lu it might seem more natural to use a percentage misclassification error measure in classification problems but the total squared error has helpful smoothness and differentiability properties. although the total squared error was used for training in the statlog trials percentage misclassification in the trained networks was used for evaluation. are modified to optimise the match between outputs perceptrons and multi layer perceptrons the activation of the mcculloch-pitts neuron has been generalised to the form h byh the threshold level or bias of equation has been included in the sum with the assumption of an extra component in the vector where the activation function can be any non-linear function. the nodes have been divided into an input layer and an output layer t whose value is fixed at rosenblatt studied the capabilities of groups of neurons in a learning suitable weights for classification problems when single layer and hence all acting on the same input vectors this structure was termed the perceptron and rosenblatt proposed the perceptron learning rule for is a hard threshold function discontinuously jumps from a lower to an upper limiting value equation defines a non-linear function across a hyperplane in the attribute space with a threshold activation function the neuron output is simply on one side of the hyperplane and on the other. when combined in a perceptron structure neurons can segment the attribute space into regions and this forms the basis of the capability of perceptron networks to perform classification. minsky and papert pointed out however that many real world problems do not fall into this simple framework citing the exclusive-or problem as the simplest example. here it is necessary to isolate two convex regions joining them together in a single class. they showed that while this was not possible with a perceptron network it can be done with a two layer perceptron structure papert this formed the multi layer perceptron which is widely in use today although the perceptron learning rule called the delta rule could not be generalised to find weights for this structure. a learning rule was proposed in which allows the multi layer perceptron to learn. this generalised delta rule defines a notion of back-propagation of error derivatives through the network hinton et al. and and enables a large class of models with different connection structures or architectures to be trained. these publications initiated the recent academic interest in neural networks and the field subsequently came to the attention of industrial users. f g i sec. supervised networks for classification output nodes hidden nodes output vector or non-linear weightss weightss non-linear d input nodes input vector fig. mlp structure. multi layer perceptron structure and functionality figure shows the structure of a standard two-layer perceptron. the inputs form the input nodes of the network the outputs are taken from the output nodes. the middle layer of nodes visible to neither the inputs nor the outputs is termed the hidden layer and unlike the input and output layers its size is not fixed. the hidden layer is generally used to make a bottleneck forcing the network to make a simple model of the system generating the data with the ability to generalise to previously unseen patterns. the operation of this network is specified by d via the in a manner parameterised by the two layers of weightsw this specifies how input pattern vector is mapped into output pattern vector d are typically each set to the univariate functions andw hidden pattern vector k tof atl which varies smoothly from at c ex as a threshold function would do abruptly. if the number of hidden layer nodes is less than the number of degrees of freedom inherent in the training data the activations of the hidden nodes tend to form an orthogonal set of variables either linear or non-linear combinations of the attribute variables which span as large a subspace of the problem as possible. with a little extra constraint on r e i g d e i f g g f f neural networks the network these internal variables form a linear or non-linear principal component representation of the attribute space. if the data has noise added that is not an inherent part of the generating system then the principal component network acts as a filter of the lower-variance noise signal provided the signal to noise ratio of the data is sufficiently high. this property gives mlps the ability to generalise to previously unseen patterns by modelling only the important underlying structure of the generating system. the hidden nodes can be regarded as detectors of abstract features of the attribute space. universal approximators and universal computers in the multilayer perceptron such as the two-layer version in equation the the weights it can be shown that the two-layer mlp can approximate an arbitrary continuous mapping arbitrarily closely if there is no limit to the number of hidden nodes. in this sense the mlp is a universal function approximator. this theorem does not imply that more complex mlp architectures are pointless it can be more efficient terms of the number of nodes and weights required to use different numbers of layers for different problems. unfortunately there is a shortage of rigorous principles on which to base a choice of architecture but many heuristic principles have been invented and explored. prominent among these are symmetry principles et al. le cun et al. and constructive algorithms output-layer node valuesv are functions of the input-layer node valuest define a recurrent network by feeding the outputs back to the inputs. the general form of a recurrent perceptron is the mlp is a feedforward network meaning that the output vectorv the input vectort nm for some vector functionm given in detail by in the case. it is also possible to feg d c vjc e feg and some parametersw c pm this is a discrete-time model continuous-time models governed by a differential equation of similar structure are also studied. recurrent networks are universal computers in the sense that given an infinite number of nodes they can emulate any calculation which can be done on a universal turing machine. infinite number of nodes is needed to simulate the infinite turing tape. this result is easily proved for hard-threshold recurrent perceptrons by sketching a network which performs not-and and another which functions as a flip-flop. these elements are all that are required to build a computer. this chapter focuses on feedforward neural network models because they are simpler to use better understood and closely connected with statistical classification methods. however recurrent networks attract a great deal of research interest because of their potential to serve as a vehicle for bringing statistical methods to bear on algorithm design rohwer et al. shastri ajjanagadde we can say is a function of which could be written g w v g d e i g f g g sec. supervised networks for classification the parameters which minimise the error measure in if to the average target usually classification problems are represented using one-out-of-n output coding. one rq cb otherwise training mlps by nonlinear regression in neural network parlancetraining is the process of fitting network parameters weights to given data. the training data consists of a set of examples of corresponding inputs and probabilistic interpretation of mlp outputs if there is a one-to-many relationship between the inputs and targets in the training data then it is not possible for any mapping of the form to perform perfectly. it is straightforward any given network might or not be able to approximate this mapping well but when trained as well as possible it will form its best possible approximation to this mean. many commonly-used error measures in addition to share this property pearlmuter desired outputs or targets let the th example be given by inputy and targetq for input dimension for target dimension usually a least-squares fit is obtained by finding are the output values obtained by substituting the inputsy where for the fit is perfect to show wellekens that if a probability densitys data then the minimum of is attained by the map takingt g describes the output node is allocated for each class and the target vectoru for example is all s except for af on the node indicating the correct class. in this case the value computed belongs to class collectively the outputs by the g this not only provides th training inputt for classification problems. given that the value output by the th target node given the collection of training outputsu g the probability of the entire feg sof nv bw rq g logc log helpful insight but also provides a principle with which neural network models can be combined with other probabilistic models wellekens therefore the cross-entropy can be used as an error measure instead of a sum of squares it happens that its minimum also lies at the average target so the network outputs can still be interpreted probabilistically and furthermore the minimisation of crossentropy is equivalent to maximisation of the likelihood of the training data in classification problems. the cross-entropy has this interpretation when an input can simultaneously be a member of any number of classes and membership of one class provides no information about membership of another. if an input can th target node can be directly interpreted as the probability that the input pattern the probabilistic interpretation of the the output nodes leads to a natural error measure this is the exponential of the cross-entropy is e g t t t g u t g f w y q c f f g z neural networks g first order gradient based methods the probabilistic interpretation of mlp outputs in classification problems must be made with some caution. it only applies if the network is trained to its minimum error and then belongs to a continuous space or a large discrete set because technically a large or infinite amount of data is required. this problem is intimately related to the overtraining and generalisation issues discussed below. for the theoretical reasons given here the cross-entropy is the most appropriate error measure for use in classification problems although practical experience suggests it makes little difference. the sum of squares was used in the statlog neural network trials. minimisation methods so as to minimise an error measure such as in the simplest cases the network outputs are linear in the weights making quadratic. then the minimal error can be found by solving a linear system of equations. this special case is discussed in section in the context of radial basis function networks which have this property. in the generic nonlinear case the minimisation is accomplished using a variant of gradient descent. this but not only if the training data accurately represents the underlying probability the latter condition is problematic ift neural network models are trained by adjusting their weight matrix parametersw produces a local minimum aw necessarily the global minimum of from which any infinitesimal change increases g the gradient g of is the vector field of derivatives of d d a linear approximation to field because the vector depends onw imal vicinity of an arbitrary weight matrixw rw e clearly then at any pointw vector changes a given magnitude which one could make tow points in the direction of fastest increase of in the direction of the most. consequently an adjustment ofw of increases provides the maximum possible decrease in direction for descent changes whenw chosen small enough for descent algorithm requires a step size parameter w w in practice trial and error is used to look for the largest step size which will work. until the error belong to one and only one class then the simple entropy obtained by dropping the terms involving the problem with this method is that the theorem on maximal descent only applies to infinitesimal adjustments. the gradient changes as well as the error so the optimal is adjusted. the pure gradient to be effectively infinitesimal so far as obtaining descent is concerned but otherwise as large as possible in the interests of speed. the weights are repeatedly adjusted by is given by in the infinites of the parameter space space of the network the i.e. of all the infinitesimal a change in the direction compute the gradient and adjust the weights in the opposite direction. the basic strategy in gradient descent is to should be used. fails to descend. with large step sizes the gradient will tend to change dramatically with each step. a t g g c g i g i g g g g g g w g sec. supervised networks for classification w old e the quadratic approximation is the matrix with components popular heuristic is to use a moving average of the gradient vector in order find a systematic tendency. this is accomplished by adding a momentum term to a parameter these methods offer the benefit of simplicity but their performance depends sensitively different values seem to be appropriate for different problems and for different stages of training in one problem. this circumstance has given rise to a plethora of heuristics for adaptive variable step size algorithms silva almeida jacobs second-order methods the underlying difficulty in first order gradient based methods is that the linear approxi to a stationary point of this quadratic form. this may be a minimum maximum or saddle point. if it is a minimum then a step in that direction seems a good idea if not then a positive or negative step has a negative projection is at least not unreasonable. therefore a large class of algorithms has been developed involving the conjugate gradient. is roughly half the square of the number of components so for large networks involving many weights such algorithms lead to impractical computer memory requirements. but one algorithm generally called the conjugate gradient algorithm or the memoryless conjugate gradient algorithm does not. this algorithm f w w here w old refers to the most recent weight change. on the parameters and mation ignores the curvature of g this can be redressed by extending to w w e e where a called the inverse hessian the hessian depending on conventions and the change w w bringsw where on the gradient in the conjugate gradient direction u most of these algorithms require explicit computation or estimation of the hessian the number of components of ofw maintains an estimate of the conjugate direction without directly representing searches for the minimum of g starting from the most recent estimate of the minimum orthogonal to the gradient making the variation of the update rule for the conjugate gradient direction and searching for the minimum in the direction of the current estimate of the conjugate gradient. linesearch algorithms are comparatively easy because the issue of direction choice reduces to a binary choice. but because the linesearch appears in the inner loop of the conjugate gradient algorithm efficiency is important. considerable effort therefore goes into it to the extent that the linesearch is typically the most complicated module of a conjugate gradient implementation. numerical round-off problems are another design consideration in linesearch implementations because the conjugate gradient is often nearly g along the conjugate gradient is the conjugate gradient algorithm uses a sequence of linesearches one-dimensional especially small. where old g g g g g w x w w neural networks to continue. this network architecture was used in the work reported in this book. an implementation of the conjugate gradient algorithm will have several parameters is the polak-ribiere variant there are others. somewhat intricate proofs exist which in practice good performance is often obtained on much more general functions using very imprecise linesearches. it is necessary to augment with a rule but unlike the step size and momentum parameters of the simpler methods the performance of the conjugate gradient method is relatively insensitive to its parameters if they are set within reasonable ranges. all algorithms are sensitive to process for selecting initial weights and many other factors which remain to be carefully isolated. gradient calculations in mlps in the case of an mlp neural network model with an error measure such as the calculation is conveniently organised as a back propagation of error et al. rohwer renals for a network with a single layer of hidden nodes this calculation proceeds by propagating forward from the input to output layers for each training example and related to the output errors backwards through a linearised oldz old old show that if were purely quadratic inw were initialised to the gradient and the linesearches were performed exactly then would converge on the conjugate gradient components ofw and would converge on its minimum after as many iterations of as there are to whenever becomes too nearly orthogonal to the gradient for progress to reset controlling the details of the linesearch and others which define exactly when to reset to it remains to discuss the computation of the gradient then propagating quantities version of the network. products of s and s then give the gradient. in the case of a node output values g a single hidden g and an output or target layer network with an input layerc g the calculation is cbz d rq d d y is summed over training examples while the s andd s refer to nodes and b the index c g c y g d e i f g d e i f g g y i h i y h i y y d y z sec. supervised networks for classification linear output weights non-linear receptive fields in attribute space fig. a radial basis function network. online vs. batch and the gradient are a sum over examples. these could be estimated by randomly selecting a subset of examples for inclusion in the sum. in the extreme a single example might be used for each gradient estimate. this is a stochastic gradient method. if a similar strategy is used without random selection but with the data taken in the order it comes the method is an online one. if a sum over all note that both the error training data is performed for each gradient calculation then the method is a h variety. given function ofw which can be evaluated precisely so that meaningful comparisons can gradient method because it is built on procedures and theorems which assume that online and stochastic gradient methods offer a considerable speed advantage if the approximation is serviceable. for problems with large amounts of training data they are highly favoured. however these approximations cannot be used directly in the conjugate is a be made at nearby arguments. therefore the stochastic gradient and online methods tend to be used with simple step-size and momentum methods. there is some work on finding a compromise method ller radial basis function networks the radial basis function network consists of a layer of units performing linear or non-linear functions of the attributes followed by a layer of weighted connections to nodes whose outputs have the same form as the target vectors. it has a structure like an mlp with one hidden layer except that each node of the the hidden layer computes an arbitrary function of the inputs gaussians being the most popular and the transfer function of each output node is the trivial identity function. instead of synaptic strengths the hidden layer has parameters appropriate for whatever functions are being used for example gaussian widths and positions. this network offers a number of advantages over the multi layer perceptron under certain conditions although the two models are computationally equivalent. these advantages include a linear training rule once the locations in attribute space of the non-linear functions have been determined and an underlying model involving localised functions in the attribute space rather than the long-range functions occurring in perceptron-based models. the linear learning rule avoids problems associated with local minima in particular it provides enhanced ability to make statments about the accuracy of neural networks the probabilistic interpretation of the outputs in section figure shows the structure of a radial basis function the non-linearities comprise a position in attribute space at which the function is located referred to as the function s centre and a non-linear function of the distance of an input point from that centre which and produce an interpolating function using non-localised functions they are often found to have better interpolating properties in the region populated by the training data. can be any function at all. common choices include a gaussian response functionexpci k as well as non-local functions such as thin plate log and multiquadrics splines and inverse multiquadrics although it seems counter-intuitive to try e!m exm the radial basis function network approach involves the expansion or pre-processing of input vectors into a high-dimensional space. this attempts to exploit a theorem of cover which implies that a classification problem cast in a high-dimensional space is more likely to be linearly separable than would be the case in a low-dimensional space. training choosing the centres and non-linearities a number of methods can be used for choosing the centres for a radial basis function network. it is important that the distribution of centres in the attribute space should be similar to or at least cover the same region as the training data. it is assumed that the training data is representative of the problem otherwise good performance cannot be expected on future unseen patterns. a first order technique for choosing centres is to take points on a square grid covering the region of attribute space covered by the training data. alternatively better performance might be expected if the centres were sampled at random from the training data itself using some or all samples since the more densely populated regions of the attribute space would have a higher resolution model than sparser regions. in this case it is important to ensure that at least one sample from each class is used as a prototype centre. in the experiments in this book the number of samples required from each class was calculated before sampling thereby ensuring this condition was met. when centre positions are chosen for radial basis function networks with localised non-linear functions such as gaussian receptive fields it is important to calculate suitable variances or spreads for the functions. this ensures that large regions of space do not occur between centres where no centres respond to patterns and conversely that no pair of centres respond nearly identically to all patterns. this problem is particularly prevalent in high dimensional attribute spaces because volume depends sensitively on radius. for a quantitative discussion of this point see prager fallside in the experiments reported in this book the standard deviations of the gaussian functions were set separately for each coordinate direction to the distance to the nearest centre in that direction multiplied by an arbitrary scaling parameter to other methods include using a principled clustering technique to position the centres such as a gaussian mixture model or a kohonen network. these models are discussed in section training optimising the weights as mentioned in section radial basis function networks are trained simply by solving a linear system. the same problem arises in ordinary linear regression the only difference being that the input to the linear system is the output of the hidden layer of the network not g sec. supervised networks for classification written out in full is then is the lies where the gradient vanishes number of radial basis functions. which has its minimum where the derivative be the correlation matrix of the radial basis function outputs the attribute variables themselves. there are a few subtleties however which are discussed is computed using the weightsi th radial basis function on the th example. the output be the output of thed here. let of each target node as d let the desired output for example on target node beq the error measure rq d ic d b vanishes. let the weight matrixw which minimises thus the problem is solved by inverting the square sition rohwer and et. al. if if the number of training samples is not at least as great as k be the number of training examples. instead of solving the by the derivatives of d unlessk the matrix with elements ofv u v the matrix inversion can be accomplished by standard methods such as lu decompois neither singular nor nearly so. this is typically the case but things can go wrong. if two radial basis function centres are very close together a singular matrix will result and a singular matrix is guaranteed there is no practical way to ensure a non-singular correlation matrix. consequently the safest course of action is to use a slightly more computationally expensive singular value decomposition method. such methods provide an approximate inverse by diagonalising the matrix inverting only the eigenvalues which exceed zero by a parameter-specified margin and transforming back to the original coordinates. this provides an optimal minimum-norm approximation to the inverse in the least-mean-squares sense. another approach to the entire problem is possible lowe let linear system given this method focuses on the linear system embedded in the this is a rectangular system. in general an exact solution does not exist but the optimal solution in the least-squares sense is given by the pseudo-inverse r matrix where error formula itself u i g x i z i q w q y z i q w neural networks u transpose can be applied to to show that the pseudo-inverse method gives the same result as this formula is applied directly. the identityu that an exact expression exists for updating the inverse correlation improving the generalisation of feed-forward networks the requirement to invert or pseudo-invert a matrix dependent on the entire dataset makes this a batch method. however an online variant is possible known as kalman filtering tepedelenlioglu it is based on the somewhat remarkable fact if another example where denotes the matrix is added to the sum which does not require recomputation of the inverse. constructive algorithms and pruning a number of techniques have emerged recently which attempt to improve on the perceptron and multilayer perceptron training algorithms by changing the architecture of the networks as training proceeds. these techniques include pruning useless nodes or weights and constructive algorithms where extra nodes are added as required. the advantages include smaller networks faster training times on serial computers and increased generalisation ability with a consequent immunity to noise. in addition it is frequently much easier to interpret what the trained network is doing. as was noted earlier a minimalist network uses its hidden layer to model as much of the problem as possible in the limited number of degrees of freedom available in its hidden layer. with such a network one can then begin to draw analogies with other pattern classifying techniques such as decision trees and expert systems. to make a network with good generalisation ability we must determine a suitable number of hidden nodes. if there are too few the network may not learn at all while too many hidden nodes lead to over-learning of individual samples at the expense of forming a near optimal model of the data distributions underlying the training data. in this case previously unseen patterns are labeled according to the nearest neighbour rather than in accordance with a good model of the problem. an easy to read introduction to the issues invloved in over-training a network can be found in geman early constructive algorithms such as upstart and the tiling algorithm ezard nadal built multi-layer feed-forward networks of perceptron units which could be applied to problems involving binary input patterns. convergence of such algorithms is guaranteed if the data is linearly separable and use of the pocket algorithm for training allows an approximate solution to be found for non linearly-separable datasets. these networks do not usually include a stopping criterion to halt the creation of new layers or nodes so every sample in the training data is learned. this has strong repercussions if the training set is incomplete has noise or is derived from a classification problem where the distributions overlap. later methods apply to more general problems and are suitable for statistical classification problems fahlman lebiere hanson refenes vithlani and wynne-jones they often build a single hidden layer and incorporate stopping criteria which allow them to converge to solutions with good generalisation u g w u v v v sec. supervised networks for classification ability for statistical problems. cascade correlation lebiere is an example of such a network algorithm and is described below. pruning has been carried out on networks in three ways. the first is a heuristic approach based on identifying which nodes or weights contribute little to the mapping. after these have been removed additional training leads to a better network than the original. an alternative technique is to include terms in the error function so that weights tend to zero under certain circumstances. zero weights can then be removed without degrading the network performance. this approach is the basis of regularisation discussed in more detail below. finally if we define the sensitivity of the global network error to the removal of a weight or node we can remove the weights or nodes to which the global error is least sensitive. the sensitivity measure does not interfere with training and involves only a small amount of extra computational effort. a full review of these techniques can be found in wynne-jones cascade correlation a constructive feed-forward network cascade correlation is a paradigm for building a feed-forward network as training proceeds in a supervised mode lebiere instead of adjusting the weights in a fixed architecture it begins with a small network and adds new hidden nodes one by one creating a multi-layer structure. once a hidden node has been added to a network its input-side weights are frozen and it becomes a permanent feature-detector in the network available for output or for creating other more complex feature detectors in later layers. cascade correlation can offer reduced training time and it determines the size and topology of networks automatically. cascade correlation combines two ideas first the cascade architecture in which hidden nodes are added one at a time each using the outputs of all others in addition to the input nodes and second the maximisation of the correlation between a new unit s output and the residual classification error of the parent network. each node added to the network may be of any kind. examples include linear nodes which can be trained using linear algorithms threshold nodes such as single perceptrons where simple learning rules such as the delta rule or the pocket algorithm can be used or non-linear nodes such as sigmoids or gaussian functions requiring delta rules or more advanced algorithms such as fahlman s quickprop standard mlp sigmoids were used in the statlog trials. at each stage in training each node in a pool of candidate nodes is trained on the residual error of the parent network. of these nodes the one whose output has the greatest correlation with the error of the parent is added permanently to the network. the error the sum over all output units of the magnitude of the candidate unit s value the correlation more precisely the covariance between function minimised in this scheme is for example the residual error observed at output unit and c the quantities are the values of and averaged over all patterns. and each of the weights coming into the nodei in order to maximise thus is defined by the partial derivative of the error is calculated with respect to g g neural networks dc is the sign of the correlation between the candidate s value and the output where is the derivative for pattern of the candidate unit s activation function withe respect to the is the input the candidate unit receives for pattern sum of its inputs and the partial derivatives are used to perform gradient ascent to maximise when no longer improves in training for any of the candidate nodes the best candidate is added to the network and the others are scrapped. in benchmarks on a toy problem involving classification of data points forming two interlocked spirals cascade correlation is reported to be ten to one hundred times faster than conventional back-propagation of error derivatives in a fixed architecture network. empirical tests on a range of real problems honavar indicate a speedup of one to two orders of magnitude with minimal degradation of classification accuracy. these results were only obtained after many experiments to determine suitable values for the many parameters which need to be set in the cascade correlation implementation. cascade correlation can also be implemented in computers with limited precision and in recurrent networks fahlman bayesian regularisation in recent years the formalism of bayesian probability theory has been applied to the treatment of feedforward neural network models as nonlinear regression problems. this has brought about a greatly improved understanding of the generalisation problem and some new techniques to improve generalisation. none of these techniques were used in the numerical experiments described in this book but a short introduction to this subject is provided here. latter technique is marginalisation a reasonable scenario for a bayesian treatment of feedforward neural networks is to through some network and corrupting the output with noise from a stationary source. the network involved is assumed to have been drawn from a probability in this distribution can presume that each target training data vectoru was produced by running the corresponding input training vectort g which is to be estimated. the most probablew be used as the optimal classifier or a more sophisticated average g can be used. at a particular point for examples g would designate this density at the particular pointw ands unsignificantly has the same name as the label index ofs g whens furthermore adopt the common practice of the notation used here for probability densities is somewhat cavalier. in discussions involving several probability density functions the notation should distinguish one density function from another and further notation should be used when such a density is indicated can designate the density function over weights which confusingly and however a tempting opportunity to choose names which introduce this confusion will arise in almost every instance that a density function is mentioned so we shall not only succumb to the temptation but is meant in order to be concise. technically this is an appalling case of using a function argument name is ordinarily arbitrary to designate the function. the bayesian analysis is built on a probabilistic interpretation of the error measure used in training. typically as in equations or it is additive over input-output pairs i g y y w w w g sec. supervised networks for classification i.e. it can be expressed as an integral over all possible target training data sets of the size under consideration. is all the training data the set of input-output pairs in the drawn from a distribution with correspond to different probabilistic interpretations. given this assumption and the assumption that training data samples are produced independently of each other for some function whereu is composed of all the input datat sum.u regarded as fixed and all the target datau function oft regarded as a noise-corruptedw g density assumption g the bayesian argument requires the alone. thus different choices of is a function of the relationship between g ands g can only have the form for some parameter un if in is a function only ofv as is then ofw a result which is useful later the only common form of which does not have which case and together justify the assumption thats f so f and is still independent ofw g depends only on g and imply for that the probability of the weights given the probability of the data given the g likelihood but unfortunately the cbw can be used to converts g from equation and a prior over the weightss into the desired distribution. the probability of the g g is given by the normalisation there is a further technicality the integral over target data must be with respect to uniform measure density can also be derived from somewhat different assumptions using a maximum-entropy argument van den bout it plays a prominent role in thermodynamics and thermodynamics jargon has drifted into the neural networks literature partly in consequence of the analogies it underlies. w this form is the cross-entropy but this is normally used in classification problems in additivity argument does not go through for this. instead bayes rule condition as which may not always be reasonable. is the normalisation term turns out to be independent is of greater interest than the u g g w w t w g u w g g g w w g f w y u z w w t y u z w w w w u g w u g s w g s g g w g t w g s g neural networks w this ensures that the denominator of g must express the g is given by normalisation. assembling all the pieces the posterior probability of the weights given the data is in this case.s g the bayesian method helps with one of the most troublesome steps in the regularisation approach to obtaining good generalisation deciding the values of the regularisation is additive over the weights and an independence assumption like is reasonable so given that the prior depends only on the regularisation term then it has the form notion that some weight matrices are more reasonable a priori than others. as discussed above this is normally expressed through regularisation terms added to the error measure. for example the view that large weights are unreasonable might be expressed by adding a bayesian methods inevitably require a priors to weight decay term of the form w typically the regularisation error b where provided that does not depend onw does not depend onw finds the maximum so the usual training process of minimising hy expresses the relative importance of smoothing and data-fitting parameters. the ratio jg jg c if a uniform priors are those which maximise the jg c opposes the goal of weightsw g the regularisation parameters and imising g one attempts to find a priors w fit the datau well. this objective is not diametrically opposed to the later objective of g under which usually networks selecting the best-fittingw indeed the distributions is one which is concentrated on a single overfitw g which maximises the evidence jg which is given by the denomcbw this is prevented only if the the distribution of weight matrices parameterised by the regularisation parameters does not include such highly concentrated distributions. therefore it remains an art to select reasonable functional forms for the regularisers but once selected the determination of the parameters which deserves to be decided in a principled manner. the bayesian evidence formalism provides a principle and an implementation. it can be computationally demanding if used precisely but there are practicable approximations. the evidence formalism simply assumes a prior distribution over the regularisation inator of note with reference to that the goal of maximising the evidence and the are optimised for opposing purposes. this expresses the bayesian quantification this method of setting regularisation parameters does not provide a guarantee against overfitting but it helps. in setting the regularisation parameters by max parameters and sharpens it using bayes rule is assumed then the most likely regularisation parameters of the compromise between data fitting and smoothing. g g s g f w d u g y u z w d w y y u z d g u u g s g u sec. unsupervised learning themselves is a matter of calculation. the art of selecting regularisation functions has become an interesting research area hinton the calculation of involves an integration which is generally non-trivial but which can be done easily in a gaussian approximation. typically this is good enough. this requires computation of the second derivatives of the error measure which is prohibitive for large problems but in this case a further approximation is possible and often adequate unsupervised learning interest in unsupervised learning has increased greatly in recent years. it offers the possibility of exploring the structure of data without guidance in the form of class information and can often reveal features not previously expected or known about. these might include the division of data that was previously thought to be a single uniform cluster into a number of smaller groups each with separate identifiable properties. the clusters found offer a model of the data in terms of cluster centres sizes and shapes which can often be described using less information and in fewer parameters than were required to store the entire training data set. this has obvious advantages for storing coding and transmitting stochastically generated data if its distribution in the attribute space is known equivalent data can be generated from the model when required. while general unsupervised learning methods such as boltzmann machines are computationally expensive iterative clustering algorithms such as kohonen networks k-means clustering and gaussian mixture models offer the same modelling power with greatly reduced training time. indeed while class labels are not used to constrain the structure learned by the models freedom from this constraint coupled with careful initialisation of the models using any prior information available about the data can yield very quick and effective models. these models known collectively as vector quantizers can be used as the non-linear part of supervised learning models. in this case a linear part is added and trained later to implement the mapping from activation in different parts of the model to probable classes of event generating the data. the k-means clustering algorithm the principle of clustering requires a representation of a set of data to be found which offers a model of the distribution of samples in the attribute space. the k-means algorithm example krishnaiah kanal achieves this quickly and efficiently as a model with a fixed number of cluster centres determined by the user in advance. the cluster centres are initially chosen from the data and each centre forms the code vector for the patch of the input space in which all points are closer to that centre than to any other. this division of the space into patches is known as a voronoi tessellation. since the initial allocation of centres may not form a good model of the probability distribution function of the input space there follows a series of iterations where each cluster centre is moved to the mean position of all the training patterns in its tessellation region. a generalised variant of the k-means algorithm is the gaussian mixture model or adaptive k-means. in this scheme voronoi tessellations are replaced with soft transitions from one centre s receptive field to another s. this is achieved by assigning a variance to each centre thereby defining a gaussian kernel at each centre. these kernels are mixed neural networks fig. k-means clustering within each patch the centre is moved to the mean position of the patterns. together by a set of mixing weights to approximate the pdf of the input data and an efficient algorithm exists to calculate iteratively a set of mixing weights centres and variances for the centres jain and wu chan while the number of centres for these algorithms is fixed in advance in more popular implementations some techniques are appearing which allow new centres to be added as training proceeds. and kohonen networks and learning vector quantizers kohonen s network algorithm also provides a voronoi tessellation of the input space into patches with corresponding code vectors. it has the additional feature that the centres are arranged in a low dimensional structure a string or a square grid such that nearby points in the topological structure string or grid map to nearby points in the attribute space. structures of this kind are thought to occur in nature for example in the mapping from the ear to the auditory cortex and the retinotopic map from the retina to the visual cortex or optic tectum. in training the winning node of the network which is the nearest node in the input space to a given training pattern moves towards that training pattern while dragging with its neighbouring nodes in the network topology. this leads to a smooth distribution of the network topology in a non-linear subspace of the training data. vector quantizers that conserve topographic relations between centres are also particularly useful in communications where noise added to the coded vectors may corrupt the representation a little the topographic mapping ensures that a small change in code vector is decoded as a small change in attribute space and hence a small change at the output. these models have been studied extensively and recently unified under the framework of bayes theory although it is fundamentally an unsupervised learning algorithm the learning vector quantizer can be used as a supervised vector quantizer where network nodes have class labels associated with them. the kohonen learning rule is used when the winning node represents the same class as a new training pattern while a difference in class between sec. the winning node and a training pattern causes the node to move away from the training pattern by the same distance. learning vector quantizers are reported to give excellent performance in studies on statistical and speech data et al. argmax ramnets one of the oldest practical neurally-inspired classification algorithms is still one of the best. it is the n-tuple recognition method introduced by bledsoe browning and bledsoe which later formed the basis of a commercial product known as wisard et al. the algorithm is simple. the patterns to be classified are bit these are the n-tuples. the restriction of a pattern to an n-tuple can be regarded as an n-bit number which constitutes a feature of the pattern. a pattern is classified as belonging to the class for which it has the most features in common with at least pattern in the training data. strings of a given length. several us say sets ofk bit locations are selected randomly. to be precise the class assigned to unclassified pattern xl zz xba db xba d where for is the set of training patterns in classm is the kronecker delta c and otherwise. and if feature of pattern x e th bit of and. ic th bit of the here is the is the classes to distinguish the system can be implemented as a set of with th ram allocated to classm at address of the in which the memory content xa d is set if any pattern of has feature thus and unset otherwise. recognition is accomplished by tallying the set bits in the rams of each class at the addresses given by the features of the unclassified pattern. ramnets are impressive in that they can be trained faster than mlps or radial basis function networks by orders of magnitude and often provide comparable results. experimental comparisons between ramnets and other methods can be found in rohwer cressy rams is th n-tuple. is c for th is the this is something of a hybrid algorithm which has much in common with both logistic discrimination and some of the nonparametric statistical methods. however for historical reasons it is included here. m x g g f f c g g d g x z neural networks introduction is a learning algorithm which constructs an optimised piecewise linear classifier by a two step procedure. in the first step the initial positions of the discriminating hyperplanes are determined by pairwise linear regression. to optimise these positions in relation to the misclassified patterns an error criterion function is defined. this function is then minimised by a gradient descent procedure for each hyperplane separately. as an option in the case of non convex classes if a class has a multimodal probability distribution a clustering procedure decomposing the classes into appropriate subclasses can be applied. this case is really a three step procedure. seen from a more general point of view is a combination of a statistical part with a learning procedure typical for artificial neural nets. compared with most neural net algorithms an advantage of is the possibility to determine the number and initial positions of the discriminating hyperplanes to neurons a priori i.e. before learning starts. using the clustering procedure this is true even in the case that a class has several distinct subclasses. there are many relations and similarities between statistical and neural net algorithms but a systematic study of these relations is still lacking. another distinguishing feature of is the introduction of boolean variables of the normals of the discriminating hyperplanes for the description of class regions on a symbolic level and using them in the decision procedure. this way additional layers of hidden units can be avoided. has some similarity with the madaline-system which is also a piecewise linear classification procedure. but instead of applying a majority function for class decision on the symbolic level in the case of madaline uses more general boolean descriptions of class and subclass segments respectively. this extends the variety of classification problems which can be handled considerably. pairwise linear regression then then for for is correctly classified if follows if if suppose thaty d e g then linear regression is used is the set of data c and by defining the dependent variable b as to discriminate between two classes with c let be the linear regression function c then a pattern g c g misclassifications are summed up. suppose that learning procedure the following criterion function is defined. for all misclassified patterns the squared distances from the corresponding decision hyperplane multiplied by the costs for these defines the decision hyperplane for each pair of classes a discriminating regression function can be calculated. d e e f f g i i e e i sec. algorithm for each decision surface successively. this means that costs are included explicitly in the learning procedure which consists of by a gradient descent i.e. and c and respectively. then let be the set of all misclassified between the classes i.e. k and c be the set of all misclassified patterns g patterns of class let g g be the costs of the misclassification and letmdc of class we then minimise c c into the class of the class feg exmdc mdc minimizing the criterion function with respect toi e d has been partitioned into cb vectors clustering of classes to handle also problems with non convex non simply connected class regions one can apply a clustering procedure before the linear regression is carried out. for solving the clustering problem a minimum squared error algorithm is used. suppose that a class g withd elements and mean clusters d d then the criterion function given by the criterion function is calculated. patterns are moved from one cluster to another if such a move will improve the mean vectors and the criterion function are updated after each pattern move. like hill climbing algorithms in general these approaches guarantee local but not global optimisation. different initial partitions and sequences of the training patterns can lead to different solutions. in the case of clustering the number of two class problems increases correspondingly. we note that by the combination of the clustering algorithm with the regression technique the number and initial positions of discriminating hyperplanes are fixed a priori before learning in a reasonable manner even in the case that some classes have multimodal distributions consist of several subclasses. thus a well known bottleneck of artificial neural nets can at least be partly avoided. description of the classification procedure tained in the training set or not can be classified i.e. the class predicted. for the pairwise e d g the discriminating hyperplanes were calculated then any pattern c hyperplanes the following dimensional fdgih are calculated the discrimination of the classes vector if the function case of clustering the number is changed into e k then the i-th component and discriminates the classes is formed for each class is equal to if and is is equal to if is defined for each pattern equal to in all other cases. on the basis of the discriminant functions a vector function m g f g g g i i f f d c x c c x c i with the function neural networks gig c is the set of integers is defined by c for each class c c is uniquely classified by the discriminating hyperplanes e d a pattern cb into the class c f hyperplanes which discriminate the class i.e. with respect to the g have the same sign for all for all other classes r f classes the pattern is placed in the halfspace belonging to class and c and is valid because at least with respect to the hyperplane which discriminates class g have not the class the pattern is placed in the halfspace of class c a pattern gj max c max g if there is only one in this case all classes were determined with c c such class then will be assigned to this class. if there are several classes letv e d i e for each class all hyperplanes set of the classes with this propertyv x for each class are selected for which discriminating the class against all other classes are found. those of the hyperplanes of hyperplanes is misclassified i.e. for each class a set to all these hyperplanes x are calculated. d e is determined for which of class the euclidian distance of is not in the halfspace is assigned to that class for which the minimum is not uniquely classified if min min is reached. from the other from c same sign. if be the i f f i g g i g f g g f d f f g x x x x x g methods for comparison r. j. henery university of strathclyde estimation of error rates in classification rules in testing the accuracy of a classification rule it is widely known that error rates tend to be biased if they are estimated from the same set of data as that used to construct the rules. at one extreme if a decision tree for example is allowed to grow without limit to the number of leaves in the tree it is possible to classify the given data with accuracy in general at the expense of creating a very complex tree-structure. in practice complex structures do not always perform well when tested on unseen data and this is one case of the general phenomenon of over-fitting data. of course overfitting is of most concern with noisy data i.e. data in which correct classification is impossible in principle as there are conflicting examples. however the problem also arises with noise-free datasets where in principle correct classification is possible. among the statlog datasets for example there is one dataset that is probably noise free and it is possible to classify the given data correctly. however certain classes are represented so infrequently that we cannot be sure what the true classification procedure should be. as a general rule we expect that very simple structures should be used for noisy data and very complex structures only for data that are noise-free. what is clear is that we should adjust the complexity to suit the problem at hand otherwise the procedure will be biased. for example most decision tree procedures as cart by breiman et al. restrict the size of the decision tree by pruning i.e. by cutting out some branches if they do not lead to useful dichotomies of the data. even if some measure of pruning is added to avoid over-fitting the data the apparent error-rate estimated by applying the induced rule on the original data is usually over-optimistic. one way of correcting for this bias is to use two independent samples of data one to learn the rule and another to test it. a method that is more suitable for intermediate sample sizes order is cross-validation which first came to prominence when lachenbruch mickey suggested the leave-one-out procedure. a closely related method which is used for small sample sizes is the bootstrap m address for correspondence department of statistics and modelling science university of strathclyde glasgow u.k. methods for comparison procedure of efron these three methods of estimating error rates are now described briefly. train-and-test the essential idea is this a sample of data training data is given to enable a classification rule to be set up. what we would like to know is the proportion of errors made by this rule when it is up-and-running and classifying new observations without the benefit of knowing the true classifications. to do this we test the rule on a second independent sample of new observations test data whose true classifications are known but are not told to the classifier. the predicted and true classifications on the test data give an unbiased estimate of the error rate of the classifier. to enable this procedure to be carried out from a given set of data a proportion of the data is selected at random about and used as the test data. the classifier is trained on the remaining data and then tested on the test data. there is a slight loss of efficiency here as we do not use the full sample to train the decision rule but with very large datasets this is not a major problem. we adopted this procedure when the number of examples was much larger than allowed the use of a test sample of size or so. we often refer to this method as one-shot train-and-test. cross-validation for moderate-sized samples the procedure we adopted was cross-validation. in its most subsamples. each fdg subsamples. in this way the error rate is estimated efficiently and in an unbiased way. the rule finally used is calculated from all the data. the leave-one-out method of lachenbruch mickey equal to the number of examples. stone describes cross-validation methods for giving unbiased estimates of the error rate. a practical difficulty with the use of cross-validation in computer-intensive methods repetition of the learning cycle which may require elementary form cross-validation consists of dividing the data into sub-sample is predicted via the classification rule constructed from the remainingc subsamples and the estimated error rate is the average error rate from these is of course such as neural networks is the cross-validation with much computational effort. bootstrap the more serious objection to cross-validation is that the error estimates it produces are too scattered so that the confidence intervals for the true error-rate are too wide. the bootstrap procedure gives much narrower confidence limits but the penalty paid is that the estimated error-rates are optimistic are biased downwards. the trade-off between bias and random error means that as a general rule the bootstrap method is preferred when the sample size is small and cross-validation when the sample size is large. in conducting a comparative trial between methods on the same dataset the amount of bias is not so important so long as the bias is the same for all methods. since the bootstrap represents the best way to reduce variability the most effective way to conduct comparisons in small datasets is to use the bootstrap. since it is not so widely used in classification trials as perhaps it should be we give an extended description here although it must be admitted sec. estimation of error rates in classification rules that we did not use the bootstrap in any of our trials as we judged that our samples were large enough to use either cross-validation or train-and-test. in statistical terms the bootstrap is a non-parametric procedure for estimating parameters generally and error-rates in particular. the basic idea is to re-use the original dataset sizek to obtain new datasets also of sizek by re-sampling with replacement. see efron for the definitive introduction to the subject and crawford for an application to cart. breiman et al. note that there are practical difficulties in applying the bootstrap to decision trees. in the context of classification the bootstrap idea is to replicate the whole classification experiment a large number of times and to estimate quantities like bias from these replicate of bootstrap replicate samples are created each sample being a replicate is taken from the original sample by sampling with replacement. sampling with replacement means for of data will not appear in the bootstrap sample. also some data points will appear more than once in the bootstrap sample. each bootstrap sample is used to construct a classification rule which is then used to predict the classes of those original data that were unused in the of the original data will be used as test set. this gives one estimate of the error rate for each bootstrap sample. the average error rates over all bootstrap samples are then combined to give an estimated error rate for the original rule. see efron and crawford for details. the main properties of the bootstrap have been summarised by as follows. properties of cross-validation and bootstrap efron gives the following properties of the bootstrap as an estimator of error-rate. by experiments. thus to estimate the error rate in small samples sizek say a large number chosen of the original sample. that is a random sample of sizek example that some data points will be omitted average aboutfdh training set aboutfdh taking very large recommends approximately the statistical variability in the average error rate efron is small and for small sample sizek will have very much smaller statistical variability than the cross-validation estimate. this means that the bootstrap the bootstrap and cross-validation estimates are generally close for large sample sizes and the ratio between the two estimates approaches unity as the sample size tends to infinity. the bootstrap and cross-validation methods tend to be closer for smoother costfunctions than the loss-function implicit in the error rates discussed above. however the bootstrap may be biased even for large samples. the effective sample size is determined by the number in the smallest classification group. efron quotes a medical example with n cases but primary interest centres on the patients that died. the effective sample size here is for large samples group-wise cross-validation may give better results than the leave one-out method although this conclusion seems doubtful. optimisation of parameters frequently it is desirable to tune some parameter to get the best performance from an algorithm examples might be the amount of pruning in a decision tree or the number of hidden nodes in the multilayer perceptron. when the objective is to minimise the error-rate of the tree or perceptron the training data might be divided into two parts one to build the tree or perceptron and the other to measure the error rate. a plot of error-rate against the methods for comparison parameter will indicate what the best choice of parameter should be. however the error rate corresponding to this choice of parameter is a biased estimate of the error rate of the classification rule when tested on unseen data. when it is necessary to optimise a parameter in this way we recommend a three-stage process for very large datasets hold back as a test sample of the remainder divide into two with one set used for building the rule and the other for choosing the parameter use the chosen parameter to build a rule for the complete training sample of the original data and test this rule on the test sample. thus for example watkins gives a description of cross-validation in the context of testing decision-tree classification algorithms and uses cross-validation as a means of selecting better decision trees. similarly in this book cross-validation was used by backprop in finding the optimal number of nodes in the hidden layer following the procedure outlined above. this was done also for the trials involving cascade. however cross-validation runs involve a greatly increased amount of computational labour increasing the learning time fold and this problem is particularly serious for neural networks. in statlog most procedures had a tuning parameter that can be set to a default value and where this was possible the default parameters were used. this was the case for example with the decision trees generally no attempt was made to find the optimal amount of pruning and accuracy and mental fit chapter is thereby sacrificed for the sake of speed in the learning process. organisation of comparative trials we describe in this section what we consider to be the ideal setup for comparing classification procedures. it not easy to compare very different algorithms on a large number of datasets and in practice some compromises have to be made. we will not detail the compromises that we made in our own trials but attempt to set out the ideals that we tried to follow and give a brief description of the unix-based procedures that we adopted. if a potential trialist wishes to perform another set of trials is able to cast the relevant algorithms into the form that we detail here and moreover is able to work within a unix environment then we can recommend that he uses our test procedures. this will guarantee comparability with the majority of our own results. in the following list of desiderata we use the notation to denote arbitrary files that either provide data or receive output from the system. throughout we assume that files used for trainingtesting are representative of the population and are statistically similar to each other. training phase. the most elementary functionality required of any learning algorithm is to be able to take data from one file assumption contains known classes and create the rules. the resulting rules parameters defining the rule may be saved to another file a cost matrix say can be read in and used in building the rules testing phase. the algorithm can read in the rules and classify unseen data in the following sequence sec. organisation of comparative trials read in the rules or parameters from the training phase passed on directly from the training phase if that immediately precedes the testing phase or read from the file read in a set of unseen data from a file with true classifications that are hidden from the classifier read in a cost matrix from a file and use this cost matrix in the classification procedure output the classifications to a file if true classifications were provided in the test file output to file a confusion matrix whose rows represent the true classifications and whose columns represent the classifications made by the algorithm the two steps above constitute the most basic element of a comparative trial and we describe this basic element as a simple train-and-test procedure. all algorithms used in our trials were able to perform the train-and-test procedure. cross-validation to follow the cross-validation procedure it is necessary to build an outer loop of control procedures that divide up the original file into its component parts and successively use each part as test file and the remaining part as training file. of course the cross-validation procedure results in a succession of mini-confusion matrices and these must be combined to give the overall confusion matrix. all this can be done within the evaluation assistant shell provided the classification procedure is capable of the simple train-and-test steps above. some more sophisticated algorithms may have a cross-validation procedure built in of course and if so this is a distinct advantage. bootstrap the use of the bootstrap procedure makes it imperative that combining of results files etc. is done automatically. once again if an algorithm is capable of simple train-and-test it can be embedded in a bootstrap loop using evaluation assistant perhaps we should admit that we never used the bootstrap in any of the datasets reported in this book. evaluation assistant evaluation assistant is a tool that facilitates the testing of learning algorithms on given datasets and provides standardised performance measures. in particular it standardises timings of the various phases such as training and testing. it also provides statistics describing the trial error rates total confusion matrices etc. etc.. it can be obtained from j. gama of the university of porto. for details of this and other publicly available software and datasets see appendices a and b. two versions of evaluation assistant exist command version interactive version the command version of evaluation assistant consists of a set of basic commands that enable the user to test learning algorithms. this version is implemented as a set of c-shell scripts and c programs. the interactive version of evaluation assistant provides an interactive interface that enables the user to set up the basic parameters for testing. it is implemented in c and methods for comparison the interactive interface exploits x windows. this version generates a customised version of some eac scripts which can be examined and modified before execution. both versions run on a sun sparcstation and other compatible workstations. characterisation of datasets an important objective is to investigate why certain algorithms do well on some datasets and not so well on others. this section describes measures of datasets which may help to explain our findings. these measures are of three types very simple measures such as the number of examples statistically based such as the skewness of the attributes and information theoretic such as the information gain of attributes. we discuss information theoretic measures in section there is a need for a measure which indicates when decision trees will do well. bearing in mind the success of decision trees in image segmentation problems it seems that some measure of multimodality might be useful in this connection. some algorithms have built in measures which are given as part of the output. for example castle measures the kullback-leibler information in a dataset. such measures are useful in establishing the validity of specific assumptions underlying the algorithm and although they do not always suggest what to do if the assumptions do not hold at least they give an indication of internal consistency. the measures should continue to be elaborated and refined in the light of experience. simple measures the following descriptors of the datasets give very simple measures of the complexity or size of the problem. of course these measures might advantageously be combined to give other measures more appropriate for specific tasks for example by taking products ratios or logarithms. numerical continuous or ordered attributes. statistical measures the following measures are designed principally to explain the performance of statistical algorithms but are likely to be more generally applicable. often they are much influenced by the simple measures above. for example the skewness measure often reflects the the total number of attributes in the data as used in the trials. where categorical attributes were originally present these were converted to binary indicator variables. this is the total number of observations in the whole dataset. in some respects it might seem more sensible to count only the observations in the training data but this is generally a large fraction of the total number in any case. number of observations number of attributes number of classes coded as indicator variables. by definition the remaining n bin.att attributes are the total number of classes represented in the entire dataset. number of binary attributes bin.att the total number of number of attributes that are binary categorical attributes sec. characterisation of datasets number of binary attributes and if this is so the skewness and kurtosis are directly related to each other. however the statistical measures in this section are generally defined only for continuous attributes. although it is possible to extend their definitions to include discrete and even categorical attributes the most natural measures for such data are the information theoretic measures discussed in section test statistic for homogeneity of covariances the covariance matrices are fundamental in the theory of linear and quadratic discrimination detailed in sections and and the key in understanding when to apply one and not the other lies in the homogeneity or otherwise of the covariances. one measure of the lack of homogeneity of covariances is the geometric mean ratio of standard deviations of the populations of individual classes to the standard deviations of the sample and is given by th sample covariance matrix and the k d e where are the unbiased estimators of the i expressed as the geometric mean ratio of standard deviations of the individual populations to the pooled standard deviations via the expression have a common covariance structure i.e. to the hypothesis i below. this quantity is related to a test of the hypothesis that all populations b which can be tested via box sv feg log cbk h fdg c he d d and and pooled covariance matrix respectively. this statistic has an asymptotic distribution and the approximation is good if eachk exceeds and if and are both much smaller than everyk in datasets reported in this volume these criteria are not always met but thev statistic can still be computed and used as a characteristic of the data. thev statistic can be reexp b i the b i in every dataset that we looked at thev statistic is significantly different from zero in which case the b i the set of correlations between all pairs of attributes give some indication of the as follows. the correlations between all pairs of attributes are calculated for each class which is a measure of interdependence and over all classes giving the measure corr.abs is strictly greater than unity if the covariances differ and is equal to unity if and only if the m-statistic is zero i.e. all individual covariance matrices are equal to the pooled covariance matrix. interdependence of the attributes and a measure of that interdependence may be calculated mean absolute correlation coefficient corr.abs is significantly greater than unity. separately. the absolute values of these correlations are averaged over all pairs of attributes between attributes. test statistic fdg ck feg v f f c f k f f v methods for comparison if corr.abs is near unity there is much redundant information in the attributes and some procedures such as logistic discriminants may have technical problems associated with this. also castle for example may be misled substantially by fitting relationships to the attributes instead of concentrating on getting right the relationship between the classes and the attributes. canonical discriminant correlations classes form some kind of sequence so that the population means are strung out along some assume that in dimensional space the sample points from one class form clusters of roughly elliptical shape around its population mean. in general if there are classes the f dimensional subspace. on the other hand it happens frequently that the means lie in a f the simplest case of all occurs curve that lies ind dimensional space whered f and the population means lie along a straight line. canonical discriminants whend are a way of systematically projecting the mean vectors in an optimal way to maximise the ratio of between-mean distances to within-cluster distances successive discriminants being orthogonal to earlier discriminants. thus the first canonical discriminant gives the best single linear combination of attributes that discriminates between the populations. the second canonical discriminant is the best single linear combination orthogonal to the first and so on. the success of these discriminants is measured by the canonical correlations. if the canonical discriminant matrix divided by the sum of all the eigenvalues represents the this gives a measure of collinearity of the class means. when the classes form an ordered sequence for example soil types might be ordered by wetness the class means typically proportion of total variation explained by first k canonical discriminants this is based on the idea of describing how the means for the various populations differ in attribute space. each class mean defines a point in attribute space and at its simplest we wish to know if there is some simple relationship between these class the first canonical correlation is close to unity the means lie along a straight line nearly. f th canonical correlation is near zero the means lie ind dimensional space. if thede means for example if they lie along a straight line. the sum of the firstd eigenvalues of variation here is proportion of total variation explained by the firstd canonical discriminants. the total g we calculate as fractk the values of e e d g h lie along a curve in low dimensional space. the s are the squares of the canonical correlations. the significance of the s can be judged from the statistics produced by manova this representation of linear discrimination which is due to fisher is discussed also in section departure from normality the assumption of multivariate normality underlies much of classical discrimination procedures. but the effects of departures from normality on the methods are not easily or clearly understood. moreover in analysing multiresponse data it is not known how robust classical procedures are to departures from multivariate normality. most studies on robustness depend on simulation studies. thus it is useful to have measures for verifying the reasonableness of assuming normality for a given dataset. if available such a measure would be helpful in guiding the subsequent analysis of the data to make it more normally distributed or suggesting the most appropriate discrimination method. andrews et al. e for d d e e e g d f sec. characterisation of datasets whose excellent presentation we follow in this section discuss a variety of methods for assessing normality. with multiresponse data the possibilities for departure from joint normality are many and varied. one implication of this is the need for a variety of techniques with differing sensitivities to the different types of departure and to the effects that such departures have on the subsequent analysis. of great importance here is the degree of commitment one wishes to make to the coordinate system for the multiresponse observations. at one extreme is the situation where the interest is completely confined to the observed coordinates. in this case the marginal distributions of each of the observed variables and conditional distributions of certain of these given certain others would be the objects of interest. at the other extreme the class of all nonsingular linear transformations of the variables would be of interest. one possibility is to look at all possible linear combinations of the variables and find the maximum departure from univariate normality in these combinations mardia et al. give multivariate measures of skewness and kurtosis that are invariant to affine transformations of the data critical values of these statistics for small samples are given in mardia these measures are difficult to compare across datasets with differing dimensionality. they also have the disadvantage that they do not reduce to the usual univariate statistics when the attributes are independent. our approach is to concentrate on the original coordinates by looking at their marginal distributions. moreover the emphasis here is on a measure of non-normality rather than on a test that tells us how statistically significant is the departure from normality. see ozturk romeu for a review of methods for testing multivariate normality. univariate skewness and kurtosis measure is defined via the ratio of the fourth moment about the mean to the fourth power of the standard deviation is generally known as the kurtosis of the distribution. however we will itself as the measure of kurtosis since we only use this measure relative to other measurements of the same quantity within this book this slight abuse of the term kurtosis the usual measure of univariate skewness et al. is which is the ratio of another although for test purposes it is usual to quote the square of this quantity the quantity refer to and and may be tolerated. for the normal distribution the measures are by g as a single in population denote the skewness statistic for attribute c g averaged over all attributes and over all populations. this gives the measure cb for a normal population ed dd y are zero and respectively. similarly we find variables the theoretical values of dd we will say that the skewness is zero and the kurtosis is although the usual definition of kurtosis gives a value of zero for a normal distribution. mean skewness and kurtosis k lk the mean cubed deviation from the mean to the cube of the standard deviation measure of skewness for the whole dataset we quote the mean of the absolute value of is zero for uniform and exponential g h g h i i i methods for comparison cb the mean of the univariate standardised fourth moment and populations. this gives the measure for a normal population the corresponding figures for uniform and exponential variables are and respectively. univariate skewness and kurtosis of correlated attributes the univariate measures above have very large variances if the attributes are highly correlated. it may therefore be desirable to transform to uncorrelated variables before finding the univariate skewness and kurtosis measures. this may be achieved via the symmetric inverse square-root of the covariance matrix. the corresponding kurtosis and skewness exactly and g averaged over all attributes bk say may be more reliable for correlated attributes. by construction these measures reduce to the univariate values if the attributes are uncorrelated. although they were calculated for all the datasets these particular measures are not quoted in the tables as they are usually similar to the univariate statistics. bk and dd measure d information theoretic measures for the most part the statistical measures above were based on the assumption of continuous attributes. the measures we discuss now are motivated by information theory and are most appropriate for discrete indeed categorical attributes although they are able to deal with continuous attributes also. for this reason these measures are very much used by the machine learning community and are often used as a basis for splitting criteria when building decision trees. they correspond to the deviance statistics that arise in the analysis of contingency tables nelder for a basic introduction to the subject of information theory see for example jones entropy of attributes entropy is a measure of randomness in a random variable. in general terms the entropy continuous variable with given variance. maximal entropy is attained for normal takes on the i th value. conventionally logarithms are to base and entropy is then said to be measured in units called information units. in what follows all logarithms are to base the special cases to remember are equal probabilities distribution. the entropy of a discrete random variable the maximal cby g of a discrete random variable x is defined as the sum log is the probability thaty where are equal. if there ared possible values fory is maximal when all entropy is logd variables and this maximal entropy is the attributes we take the logc g averaged over all attributesy in the context of classification schemes the point to note is that an attribute that does not vary at all and therefore has zero entropy contains no information for discriminating between classes. the entropy of a collection of attributes is not simply related to the individual entropies but as a basic measure we can average the entropy over all the attributes and take this as a global measure of entropy of the attributes collectively. thus as a measure of entropy of i g g g y g g examples this means choosing sec. characterisation of datasets this measure is strictly appropriate only for independent attributes. the definition of entropy for continuous distributions is analogous to the discrete case with an integral replacing the summation term. this definition is no use for empirical data however unless some very drastic assumptions are made example assuming that the data have a normal distribution and we are forced to apply the discrete definition to all empirical data. for the measures defined below we discretised all numerical data into equal-length intervals. the number of intervals was chosen so that there was a fair expectation that there would be about ten observations per cell in the two-way table of in many of our datasets some classes have very low probabilities of occurrence and for practical purposes the very infrequent classes play little part in the assessment of classification schemes. it is therefore inappropriate merely to count the number of classes intervals. a more refined procedure would have the number and width of intervals varying from attribute to attribute and from dataset to dataset. unless the data are very extensive the estimated entropies even for discrete variables are likely to be severely biased. blyth discusses methods of reducing the bias. cells in a two-way table of attribute discrete attribute by class. as there are the simplest but not the best procedure is to divide the range of the attribute into equal levels by class classes and there are entropy of classes and use this as a measure of complexity. an alternative is to use the entropy c g of the c log where is the prior probability for class entropy is related to the average length of a for example. since class is essentially discrete the class entropy c when the classes are equally likely so that c g has maximal value d as an effective of classes. a useful way of looking at the entropy c is at most log where is to regard joint entropy of class and attribute c the joint entropy c andy g of two variables and the value of attributey denotes the joint g if combined system of variables i.e. the pair of variablesc probability of observing class c log andy v c g of two variables the mutual informationv c the joint probability of observing class and the value of attributey denotes g is zero. if there is no shared information and the mutual informationv c probability of class is and if the marginal probability of attributey taking on its then the mutual information is defined to be that there is no minus sign value is this is a simple extension of the notion of entropy to the combined system of variables. mutual information of class and attribute is a measure of common information or entropy shared between the two variables. if the two variables are independent is a measure of total entropy of the the joint entropy is number of classes. defined to be if the marginal class probability distribution variable length coding scheme and there are direct links to decision trees jones is the number h f c g g g g y g y y y g y g y y methods for comparison equivalent definitions are since there are many attributes we have tabulated an average of the mutual information defined formally by the equation in which it appears above but it has a distinct meaning namely the entropy randomness or noise of the class variable that is not removed by is zero and this occurs when class and attribute are independent. the maximum mutual information is zero. suppose for example that is zero. this would mean that the value of class is fixed once the in contains all the information needed to specify the class. the logc v c o e cby c c v c cby v c the conditional entropy c v c g for example which we have not yet defined may be knowing the value of the attribute x. minimum mutual informationv c g occurs when one of c g or c v c value ofy is then completely predictable from the attributey the sense that attributey is known. class g are g c cby corresponding limits ofv c g g v c taken over all attributesy d e yh v c v c v c the information required to specify the class is c be completely successful unless it provides at least c g and no classification scheme can g bits of useful information. g of all attributes together vector of that the useful information v c g is greater than the sum of the individual informations g however in the simplest most unrealistic case that all e v c v c y v c e!v c v c g and the average mutual information the ratio between the class entropy c g c en.attr v c of course we might do better by taking the attributes with highest mutual information but in any case the assumption of independent useful bits of information is very dubious in any case so this simple measure is probably quite sufficient this information is to come from the attributes taken together and it is quite possible stands for the this average mutual information gives a measure of how much useful information about classes is provided by the average attribute. mutual information may be used as a splitting criterion in decision tree algorithms and is preferable to the gain ratio criterion of haussler equivalent number of attributes en.attr attributes are independent we would have in this case the attributes contribute independent bits of useful information for classification purposes and we can count up how many attributes would be requiredon average by taking y g g y g c g g y g y g c g y g y g g g y y g y y g y g y y g y g y y g g y y y g e y y g y g e g v c y g y g sec. characterisation of datasets values of the ratio noisiness of attributes ns.ratio if the useful information is only a small fraction of the total information we may say that there is a large amount of noise. thus take about class and cby g as a measure of useful information v c g as a measure as non-useful information. then large ns.ratio imply a dataset that contains much irrelevant information such datasets could be condensed considerably without affecting the performance of the classifier for example by removing irrelevant attributes by reducing the number of discrete levels used to specify the attributes or perhaps by merging qualitative factors. the notation ns.ratio denotes the noise-signal-ratio. note that this is the reciprocal of the more usual signal-noise-ratio irrelevant attributes v c v c cby attribute. this context interpreting the mutual information as a deviance statistic would be useful and we can give a lower bound to statistically significant values for mutual information. and class are in fact statistically independent and suppose is large then it is approximately equal to the chisquare statistic for testing the independence of attribute and class example agresti g between class and attributeyh can be used to judge yh if attributeyh could of itself contribute usefully to a classification scheme. attributes the mutual informationv c g would not by themselves be useful predictors of class. in with small values ofv c suppose that attributey has distinct levels. assuming further that the sample size thaty is well known that the deviance statistic v c d d distribution and order of g has an approximate therefore v c is the number of examples and feg h where the hypothesis testing sense if its value exceedsc of classes in our measures continuous attributes we chose hf number of levels for so-called continuous attributes was less than d distribution as twice the number of degrees of freedom d hf if we adopt with our chosen value of this is of orderfdhf a critical level for the fdg fegih as c magnitude calculations indicate that the mutual information contributes significantly is the number is the number of discrete levels for the is the number of levels for integer or binary attributes and for that on average there were about observations per cell in the two-way table of attribute by class but occasionally the we have not quoted any measure of this form as almost all attributes are relevant in this sense this measure would have little information content!. in any case an equivalent measure would be the difference between the actual number of attributes and the value of en.attr. correlated normal attributes when attributes are correlated the calculation of information measures becomes much more difficult so difficult in fact that we have avoided it altogether. the above univariate for the sake of argument we obtain an approximate critical level for the mutual information for continuous attributes. fdg y g y g v c y g y g y g y c c methods for comparison measures take no account of any lack of independence and are therefore very crude approximations to reality. there are however some simple results concerning the multivariate normal distribution for which the entropy is logc is the determinant of the covariance matrix of the variables. similar results hold for mutual information and there are then links with the statistical measures elaborated in section unfortunately even if such measures were used for our datasets most datasets are so far from normality that the interpretation of the resulting measures would be very questionable. where pre-processing usually there is no control over the form or content of the vast majority of datasets. generally they are already converted from whatever raw data was available into some suitable format and there is no way of knowing if the manner in which this was done was consistent or perhaps chosen to fit in with some pre-conceived type of analysis. in some datasets it is very clear that some very drastic form of pre-processing has already been done see section for example. missing values some algorithms naive bayes cart bayes tree newid can deal with missing values whereas others require that the missing values be replaced. the procedure discrim was not able to handle missing values although this can be done in principle for linear discrimination for certain types of missing value. in order to get comparable results we settled on a general policy of replacing all missing values. where an attribute value was missing it was replaced by the global mean or median for that attribute. if the class value was missing the whole observation was omitted. usually the proportion of cases with missing information was very low. as a separate exercise it would be of interest to learn how much information is lost gained in such a strategy by those algorithms that can handle missing values. unfortunately there are various ways in which missing values might arise and their treatment is quite different. for example a clinician may normally use the results of a blood-test in making a diagnosis. if the blood-test is not carried out perhaps because of faulty equipment the blood-test measurements are missing for that specimen. a situation that may appear similar results from doing measurements on a subset of the population for example only doing pregnancy tests on women where the test is not relevant for men so is missing for men. in the first case the measurements are missing at random and in the second the measurements are structured or hierarchical. although the treatment of these two cases should be radically different the necessary information is often lacking. in at least one dataset it would appear that this problem arises in a very extreme manner as it would seem that missing values are coded as zero and that a large majority of observations is zero. feature selection and extraction some datasets are so large that many algorithms have problems just entering the data and the sheer size of the dataset has to be reduced. in this case to achieve uniformity a data g sec. pre-processing reduction process was performed in advance of the trials. again it is of interest to note which algorithms can cope with the very large datasets. there are several ways in which data reduction can take place. for example the karhunen-loeve transformation can be used with very little loss of information see section for an example. another way of reducing the number of variables is by a stepwise procedure in a linear discriminant procedure for example. this was tried on the dataset in which a version with number of attributes reduced from to was also considered. results for both these versions are presented and make for an interesting paired comparison see the section on paired comparisons for the dataset in section in some datasets particularly image segmentation extra relevant information can be included. for example we can use the prior knowledge that examples which are neighbours are likely to have the same class. a dataset of this type is considered in section in which a satellite image uses the fact that attributes of neighbouring pixels can give useful information in classifying the given pixel. especially in an exploratory study practitioners often combine attributes in an attempt to increase the descriptive power of the resulting decision treerules etc. for example it that is important rather might be conjectured that it is the sum of two attributes than each attribute separately. alternatively some ratios are included such as in our trials we did not introduce any such combinations. on the other hand there existed already some linear combinations of attributes in some of the datasets that we looked at. we took the view that these combinations were included because the dataset provider thought that these particular combinations were potentially useful. although capable of running on attributes with linear dependencies some of the statistical procedures prefer attributes that are linearly independent so when it came to running lda qda and logistic discrimination we excluded attributes that were linear combinations of others. this was the case for the belgian power data which is described in section although in principle the performance of linear discriminant procedures is not affected by the presence of linear combinations of attributes in practice the resulting singularities are best avoided for numerical reasons. g c e as the performance of statistical procedures is directly related to the statistical properties of the attributes it is generally advisable to transform the attributes so that their marginal distributions are as near normal as possible. each attribute is considered in turn and some transformation usually from the power-law family is made on the attribute. most frequently this is done by taking the square-root logarithm or reciprocal transform. these transforms may help the statistical procedures in theory at least they have no effect on non-parametric procedures such as the decision trees or naive bayes. large number of categories we describe now the problems that arise for decision trees and statistical algorithms alike when an attribute has a large number of categories. firstly in building a decision tree a potential split of a categorical attribute is based on some partitioning of the categories one partition going down one side of the split and the remainder down the other. the number of is much larger than ten there is an enormous computational load and the tree takes a very long time to train. however there is a computational shortcut that applies potential splits is where l is the number of different categories of the attribute. clearly if e h methods for comparison to two-class problems clark pregibon for example. the shortcut method is not implemented in all statlog decision-tree methods. with the statistical algorithms a specification of the attribute. categorical attribute with categories needs l f binary variables for a complete as a trivial example with two numerical attributesy andq rq probably see exactly the same predictive value in the pair of attributes q the original pair now it is a fact that decision trees behave differently for categorical and numerical data. two datasets may be logically equivalent yet give rise to different decision trees. statistical algorithms would as in yet the decision trees would be different as the decision boundaries would now be at an angle of degrees. when categorical attributes are replaced by binary variables the decision trees will be very different as most decision tree procedures look at all possible subsets of attribute values when considering potential splits. there is the additional although perhaps not so important point that the interpretation of the tree is rendered more difficult. it is therefore of interest to note where decision tree procedures get almost the same accuracies on an original categorical dataset and the processed binary data. newid as run by isoft for example obtained an accuracy of on the processed dna data and on the original dna data categorical attributes. these accuracies are probably within what could be called experimental error so it seems that newid does about as well on either form of the dna dataset. in such circumstances we have taken the view that for comparative purposes it is better that all algorithms are run on exactly the same preprocessed form. this way we avoid differences in preprocessing when comparing performance. when faced with a new application it will pay to consider very carefully what form of preprocessing should be done. this is just as true for statistical algorithms as for neural nets or machine learning. bias in class proportions first some general remarks on potential bias in credit datasets. we do not know the way in which the credit datasets were collected but it is very probable that they were biased in the following way. most credit companies are very unwilling to give credit to all applicants. as a result data will be gathered for only those customers who were given credit. if the credit approval process is any good at all the proportion of bad risks among all applicants will be significantly higher than in the given dataset. it is very likely also that the profiles of creditors and non-creditors are very different so rules deduced from the creditors will have much less relevance to the target population all applicants. when the numbers of good and bad risk examples are widely different and one would expect that the bad risk examples would be relatively infrequent in a well managed lending concern it becomes rather awkward to include all the data in the training of a classification procedure. on the one hand if we are to preserve the true class proportions in the training sample the total number of examples may have to be extremely large in order to guarantee sufficient bad risk examples for a reliable rule. on the other hand if we follow the common practice in such cases and take as many bad risk examples as possible together with a matching number of good risk examples we are constructing a classification rule with its boundaries in the wrong places. the common practice is to make an adjustment to the boundaries to take account of the true class proportions. in the case of two classes such sec. pre-processing an adjustment is equivalent to allocating different misclassification costs sections and for example if the true bad risk proportion is and a rule is trained on an artificial sample with equal numbers of good and bad risks the recommendation would be to classify as bad risk only those examples whose assessed posterior odds of being bad risk were to to this is equivalent to learning on the artificial sample with the cost of misclassifying bad risks as times that of misclassifying good risk examples. for such a procedure to work it is necessary that a classification procedure returns class probabilities as its output and the user can then allocate according to his prior probabilities according to misclassification costs. many decision trees cart and bayes tree for example now output class probabilities rather than classes. but the majority of decision trees in this project do not do so. and in any case it is by no means true that this artificial procedure is in fact a proper procedure at all. consider again the case where bad risks form of the population and suppose that we are given a single normally distributed variable bank balance on which to classify. for simplicity suppose also that good and bad risk customers differ only in their mean bank balance. when trained on an artificial sample with equal good and bad risks a decision tree method would correctly divide the population into two regions above and below the midpoint between the two mean bank balances. in the artificial sample there will be a proportion say of good examples above this boundary and approximately bad examples below the boundary. so for example probabilities as if a potential customer has bank balance above this boundary we can assess the class for bad. no matter what adjustment is made for the true prior odds of being bad risk it is clear that the allocation rule can only take one of two forms either allocate everyone to being good bad or allocate good or bad according as bank balance is above or below the established boundary. in the situation we have described however it is clear that it is the boundary that should move rather than adjust the probabilities. the way to modify the procedure is to overgrow the tree and then to take the costs andor priors into account when pruning. see michie attar for further details. for being good andf l hierarchical attributes it often happens that information is relevant only to some of the examples. for example certain questions in a population census may apply only to the householder or certain medical conditions apply to females. there is then a hierarchy of attributes primary variables refer to all members is a primary attribute secondary attributes are only relevant when the appropriate primary attribute is applicable is secondary to sex female tertiary variables are relevant when a secondary variable applies of pregnancy is tertiary to pregnant true and so on. note that testing all members of a population for characteristics of pregnancy is not only pointless but wasteful. decision tree methods are readily adapted to deal with such hierarchical datasets and the algorithm has been so designed. and not for others. obviously the machine fault dataset section which was created by isoft is an example of a hierarchical dataset with some attributes being present for one subclass of examples the viewpoint of the other algorithms the dataset is unreadable as it has a variable number of attributes. therefore an alternative version needs to be prepared. of course the flat can deal with this dataset in its original form but from methods for comparison form has lost some of the information that was available in the hierarchical structure of the data. the fact that does best on this dataset when it uses this hierarchical information suggests that the hierarchical structure is related to the decision class. coding of hierarchical attributes hierarchical attributes can be coded into flat format without difficulty in that a one-to-one correspondence can be set up between the hierarchically structured data and the flat format. we illustrate the procedure for an artificial example. consider the primary attribute sex. when sex takes the value male the value of attribute baldness is recorded as one of no but when sex takes the value female the attribute baldness is simply not applicable one way of coding this information in flat format is to give two attributes with value of possible values for and in this formulation the primary variable is explicitly available through the is equal to it is not clear whether this means not bald or not applicable strictly there are three denoting sex and but there is the difficulty here not too serious that when baldness. the three possible triples of values are bald not bald and not applicable the first two possibilities applying only to males. this gives a second formulation in which the two attributes are lumped together into a single attribute whose possible values represent the possible states of the system. in the example the possible states are bald male not bald male and female of course none of the above codings enables ordinary classifiers to make use of the hierarchical structure they are designed merely to represent the information in flat form with the same number of attributes per example. breiman et al. indicate how hierarchical attributes may be programmed into a tree-building procedure. a logical flag indicates if a test on an attribute is permissible and for a secondary attribute this flag is set to true only when the corresponding primary attribute has already been tested. collection of datasets for the most part when data are gathered there is an implicit understanding that the data will be analysed by a certain procedure and the data-gatherer usually sets down the data in a format that is acceptable to that procedure. for example if linear discriminants are to be used it is inappropriate to include linear combinations of existing attributes yet the judicious use of sums or differences can make all the difference to a decision tree procedure. in other cases the data may have some additional structure that cannot be incorporated in the given procedure and this structure must be removed or ignored in some way. preprocessing strategy in statlog the general strategy with datasets was to circulate the datasets exactly as received and datasets were sent out in exactly the same format as they came in. for these datasets the only processing was to permute the order of the examples. in four datasets substantial preprocessing was necessary and in three of these datasets it is possible that the resulting dataset has lost some vital information or has been biased in some way. for example the credit management dataset was processed to make the class proportions representative. another source of potential bias is the way in which categorical attributes are treated a problem that is most acute in the dna dataset. review of previous empirical comparisons r. j. henery university of strathclyde introduction it is very difficult to make sense of the multitude of empirical comparisons that have been made. so often the results are apparently in direct contradiction with one author claiming that decision trees are superior to neural nets and another making the opposite claim. even allowing for differences in the types of data it is almost impossible to reconcile the various claims that are made for this or that algorithm as being faster or more accurate or easier than some other algorithm. there are no agreed objective criteria by which to judge algorithms and in any case subjective criteria such as how easy an algorithm is to program or run are also very important when a potential user makes his choice from the many methods available. nor is it much help to say to the potential user that a particular neural network say is better for a particular dataset. nor are the labels neural network and machine learning particularly helpful either as there are different types of algorithms within these categories. what is required is some way of categorising the datasets into types with a statement that for such-and-such a type of dataset such-and-such a type of algorithm is likely to do well. the situation is made more difficult because rapid advances are being made in all three areas machine learning neural networks and statistics. so many comparisons are made between say a state-of-the-art neural network and an outmoded machine learning procedure like basic toolbox of algorithms before discussing the various studies let us make tentative proposals for candidates in future comparative trials i.e. let us say what in our opinion form the basis of a toolbox of good classification procedures. in doing so we are implicitly making a criticism of any comparative studies that do not include these basic algorithms or something like them. most are available as public domain software. any that are not can be made available m address for correspondence department of statistics and modelling science university of strathclyde glasgow u.k. review of empirical comparisons from the database of algorithms administered from porto appendix b. so there is no excuse for not including them in future studies! we should probably always include the linear discriminant rule as it is sometimes best but for the other good reason that is a standard algorithm and the most widely available of all procedures. winner if there are scaling problems it was sometimes outright loser too! on the basis of our results thed neighbour method was often the outright so it would seem sensible to included neighbour in any comparative studies. although the generally good performance ofd neighbour is well known it is in many cases whered neighbour did badly the decision-tree methods did surprising how few past studies have involved this procedure especially as it is so easy to program. relatively well for example in the credit datasets. so some kind of decision tree should be included. yet again some of the newer statistical procedures got very good results when all other methods were struggling. so we would also recommend the inclusion of say smart as a modern statistical procedure. representing neural networks we would probably choose lvq andor radial basis functions as these seem to have a distinct edge over the version of backpropagation that we used. however as the performance of lvq seems to mirror that of k-nn rather closely we would recommend inclusion of rbf rather than lvq if k-nn is already included. any comparative study that does not include the majority of these algorithms is clearly not aiming to be complete. also any comparative study that looks at only two procedures cannot give reliable indicators of performance as our results show. difficulties in previous studies bearing in mind our choice of potential candidates for comparative studies it will quickly become obvious that most previous studies suffer from the major disadvantage that their choice of algorithms is too narrow. there are many other sources of difficulty and before giving detailed consideration of past empirical studies we list the pitfalls that await anyone carrying out comparative studies. of course our own study was not entirely free from them either. the choice of algorithms is too narrow in many cases the authors have developed their own pet algorithm and are expert in their own field but they are not so expert in other methods resulting in a natural bias against other methods the chosen algorithms may not represent the state of the art the datasets are usually small or simulated and so not representative of real-life applications there is a substantial bias in the choice of dataset in simulations especially giving a substantial bias in favour of certain algorithms often the choice of criteria is biased in favour of one type of algorithm sometimes even using unrealistic cost criteria. sec. previous empirical comparisons especially across comparative studies there may be problems due to differences in the way the data were pre-processed for example by removing or replacing missing values or transforming categorical to numerical attributes. the class definitions may be more suited to some algorithms than others. also the class proportions in the training set may well differ substantially from the population values often deliberately so. some comparative studies used variant but not identical datasets and algorithms. we have attempted to minimise the above problems in our own study for example by adopting a uniform policy for missing values and a uniform manner of dealing with categorical variables in some but not all of the datasets. previous empirical comparisons while it is easy to criticise past studies on the above grounds nonetheless many useful comparative studies have been carried out. what they may lack in generality they may gain in specifics the conclusion being that for at least one dataset algorithm a is superior or more accurate than algorithm b. other studies may also investigate other aspects more fully than we did here for example by studying learning curves i.e. the amount of data that must be presented to an algorithm before it learns something useful. in studying particular characteristics of algorithms the role of simulations is crucial as it enables controlled departures from assumptions giving a measure of robustness etc.. we have used some simulated data in our study namely the belgian datasets this was done because we believed that the simulations were very close to the real-world problem under study and it was hoped that our trials would help in understanding this particular problem. here we will not discuss the very many studies that concentrate on just one procedure or set of cognate procedures rather we will look at cross-disciplinary studies comparing algorithms with widely differing capabilities. among the former however we may mention comparisons of symbolic procedures in clark boswell sammut quinlan et al. and aha statistical procedures in cherkaoui cleroux titterington et al. and remme et al. and neural networks in huang et al. fahlman xu et al. and ersoy hong several studies use simulated data to explore various aspects of performance under controlled conditions for example cherkaoui cleroux and remme et al. individual results particular methods may do well in some specific domains and for some performance well in recognising handwritten characters and but not as well on the sonar-target task sejnowski measures but not in all applications. for exampled neighbour performed very machine learning vs. neural network with the recent surge in interest in both machine learning and neural networks there are many recent studies comparing algorithms from these two areas. commonly such studies do not include any statistical algorithms for example fisher mckusick and shavlik et al. and shavlik et al. used a relatively old symbolic algorithm review of empirical comparisons which has been repeatedly shown to be less effective than its successors and in this book. kirkwood et al. found that a symbolic algorithm performed better than discriminant analysis for classifying the gait cycle of artificial limbs. tsaptsinos et al. also found that was more preferable on an engineering control problem than two neural network algorithms. however on different tasks other researchers found that a higher order neural network performed better than reid and back-propagation did better than cart et al. gorman sejnowski reported that back-propagation outperformed nearest neighbour for classifying sonar targets whereas some bayes algorithms were shown to be better on other tasks d argenio more extensive comparisons have also been carried out between neural network and symbolic methods. however the results of these studies were inconclusive. for example whereas weiss kulikowski and weiss kapouleas reported that backpropagation performed worse than symbolic methods cart and pvm fisher mckusick and shavlik et al. indicated that back-propagation did as well or better than since these are the most extensive comparisons to date we describe their findings briefly and detail their limitations in the following two paragraphs. first fisher mckusick compared the accuracy and learning speed the number of example presentations required to achieve asymptotic accuracy of and backpropagation. this study is restricted in the selection of algorithmsevaluation measures and data sets. whereas cannot tolerate noise several descendants of can tolerate noise more effectively example quinlan which would improve their performance on many noisy data sets. furthermore their measure of speed which simply counted the number of example presentations until asymptotic accuracy was attained unfairly favours whereas the training examples need be given to only once they were repeatedly presented to back-propagation to attain asymptotic accuracies. however their measure ignored that back-propagation s cost per example presentation is much lower than s. this measure of speed was later addressed in fisher et al. where they defined speed as the product of total example presentations and the cost per presentation. finally the only data set with industrial ramifications used in fisher mckusick is the garvan institute s thyroid disease data set. we advocate using more such data sets. second mooney et al. and shavlik et al. compared similar algorithms on a larger collection of data sets. there were only three algorithms involved perceptron and back-propagation. although it is useful to compare the relative performance of a few algorithms the symbolic learning and neural network fields are rapidly developing there are many newer algorithms that can also solve classification tasks example boswell and radial basis networks girosi many of these can outperform the algorithms selected here. thus they should also be included in a broader evaluation. in both fisher mckusick mooney et al. and shavlik et al. data sets were separated into a collection of training and test sets. after each system processed a training set its performance in terms of error rate and training time was measured on the corresponding test set. the final error rate was the geometric means of separate tests. mooney et al. and shavlik et al. measured speed differently from fisher et al. they used the length of sec. studies involving ml k-nn and statistics training. in both measures mooney et al. and shavlik et al. and fisher et al. found that back-propagation was significantly slower than other significant characteristics are they varied the number of training examples and studied the effect on the performance that this will have and they degenerated data in several ways and investigated the sensitivity of the algorithms to the quality of data. studies involving ml k-nn and statistics thrun mitchell and cheng conducted a co-ordinated comparison study of many algorithms on the monk s problem. this problem features simulated robots classified into two classes using six attributes. although some algorithms outperformed others there was no apparent analysis of the results. this study is of limited practical interest as it involved simulated data and even less realistically was capable of error-free classification. other small-scale comparisons include huang lippmann bonelli parodi and sethi otten who all concluded that the various neural networks performed similarly to or slightly better than symbolic and statistical algorithms. weiss kapouleas involved a few discriminants and ignored much of the new development in modern statistical classification methods. ripley compared a diverse set of statistical methods neural networks and a decision tree classifier on the tsetse fly data. this is a restricted comparison because it has only one data set and includes only one symbolic algorithm. however some findings are nevertheless interesting. in accuracy the results favoured nearest neighbour the decision tree algorithm back-propagation and projection pursuit. the decision tree algorithm rapidly produced most interpretable results. more importantly ripley also described the degree of frustration in getting some algorithms to produce the eventual results others for example fisher mckusick and shavlik et al. did not. the neural networks were bad in this respect they were very sensitive to various system settings example hidden units and the stopping criterion and they generally converged to the final accuracies slowly. of course the inclusion of statistical algorithms does not of itself make the comparisons valid. for example statisticians would be wary of applying a bayes algorithm to the four problems involved in weiss kapouleas because of the lack of basic information regarding the prior and posterior probabilities in the data. this same criticism could be applied to many if not most of the datasets in common use. the class proportions are clearly unrealistic and as a result it is difficult to learn the appropriate rule. machine learning algorithms in particular are generally not adaptable to changes in class proportions although it would be straightforward to implement this. some empirical studies relating to credit risk as this is an important application of machine learning methods we take some time to mention some previous empirical studies concerning credit datasets. traditional and statistical approaches an empirical study of a point awarding approach to credit scoring is made by h aussler fahrmeir et al. compare the results of a point awarding approach with the results obtained by the linear discriminant. in von stein ziegler the authors use thed neighbour approach to analyse the problem of prognosis and review of empirical comparisons surveillance of corporate credit risk. linear discriminant is applied by bretzger to early risk recognition in disposition credits. in a comprehensive study of corporate credit granting reported in srinivisan kim the authors evaluate various approaches including parametric nonparametric and judgemental classification procedures. within the nonparametric approaches they use a recursive partitioning method based on the decision tree concept. their results show that this recursive partitioning approach performs better than the others. machine learning and neural networks several empirical studies deal with credit-scoring problem using machine learning and neural networks. the cart method et al. is used by hofmann to analyse consumer credit granting. hofmann concludes that cart has major advantages over discriminant analysis and emphasises the ability of cart to deal with mixed datasets containing both qualitative and quantitative attributes. carter catlett use machine learning in assessing credit card applications. besides decision trees they also apply probability trees produce probability values to the final nodes of the tree. this means that the algorithm is able decide for a good or bad credit risk with a certain probability attached as well as incorporating costs. one example of the application of neural networks to solving the credit scoring problem is reported in schumann et al. michie reports a case where the aim of the credit-granting procedure was to keep the bad debt rate among those granted credit down to while some procedures accepted only of applications the ml procedure was able to double the proportion of acceptances while keeping the bad-debt rate within bounds. ml procedures almost always output a yes-no decision and this may be inconvenient in situations where costs may vary from applicant to applicant. in some situations the bad-debt risk could be allowed to rise to say but it would be necessary to re-train the decision tree using a different pruning parameter. dataset descriptions and results various statlog partners see appendix c for a full list introduction we group the dataset results according to domain type although this distinction is perhaps arbitrary at times. there are three credit datasets of which two follow in the next section the third dataset credit involved a cost matrix and so is included in section with other cost matrix datasets. several of the datasets involve image data of one form or another. in some cases we are attempting to classify each pixel and thus segment the image and in other cases we need to classify the whole image as an object. similarly the data may be of raw pixel form or else processed data. these datasets are given in section the remainder of the datasets are harder to group and are contained in section see the appendices for general availability of datasets algorithms and related software. the tables contain information on time memory and error rates for the training and test sets. the time has been standardised for a sun ipc workstation at specs and for the cross-validation studies the quoted times are the average for each cycle. the unit of memory is the maximum number of pages used during run time. this quantity is obtained from the set time unix command and includes the program requirements as well as data and rules stored during execution. ideally we would like to decompose this quantity into memory required by the program itself and the amount during the training and testing phase but this was not possible. a page is currently bytes but the quoted figures are considered to be very crude. indeed both time and memory measurements should be treated with great caution and only taken as a rough indication of the truth. in all tables we quote the error rate for the default rule in which each observation is allocated to the most common class. in addition there is a rank column which orders the algorithms on the basis of the error rate for the test data. note however that this is not the only measure on which they could be ranked and many practitioners will place great importance on time memory or interpretability of the algorithm s classifying rule we use the notation for missing not applicable information and fd to indicate that m address for correspondence charles taylor department of statistics university of leeds leeds u.k. dataset descriptions and results an algorithm failed on that dataset. we tried to determine reasons for failure but with little success. in most cases it was a segmentation violation probably indicating a lack of memory. in section we present both the statistical and information-based measures for all of the datasets and give an interpreation for a few of the datasets. credit datasets credit management this dataset was donated to the project by a major british engineering company and comes from the general area of credit management that is to say assessing methods for pursuing debt recovery. credit scoring is one way of giving an objective score indicative of credit risk it aims to give a numerical score usually containing components from various factors indicative of risk by which an objective measure of credit risk can be obtained. the aim of a credit scoring system is to assess the risk associated with each application for credit. being able to assess the risk enables the bank to improve their pricing marketing and debt recovery procedures. inability to assess the risk can result in lost business. it is also important to assess the determinants of the risk lawrence smith state that payment history is the overwhelming factor in predicting the likelihood of default in mobile home credit cases. risk assessment may influence the severity with which bad debts are pursued. although it might be thought that the proper end product in this application should be a risk factor or probability assessment rather than a yes-no decision the dataset was supplied with pre-allocated classes. the aim in this dataset was therefore to classify customers simple train-and-test into one of the two given classes. the classes can be interpreted as the method by which debts will be retrieved but for the sake of brevity we refer to classes as good and bad risk. table previously obtained results for the original credit management data with equal class proportions supplied by the turing institute supplied by the dataset providers. algorithm newid neural net error rate the original dataset had examples of each class. to make this more representative of the population as a whole approximately of credit applicants were assessed by a human as bad risk the dataset used in the project had examples with of these being class credit risk and class credit risk. as is common when the proportion of bad credits is very small the default rule grant credit to all applicants achieves a small error rate is clearly in this case. in such circumstances the credit-granting company may well adopt the default strategy for the sake of good customer relations see lawrence smith however most decision tree algorithms do worse than the default if they are allowed to train on the given data which is strongly biased towards bad credits decision tree algorithms have an error rate of around error rate. this problem disappears if the training set has the proper class proportions. for example a version of cartthe splus module tree obtained an error rate sec. credit data table results for the credit management dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd test fd error rate test fd train fd rank of on the supplied data but only on the dataset with proper class proportions whereas linear discriminants obtained an error rate of on the supplied data and on the modified proportions. supplier of the credit management dataset quotes error rates for neural nets and decision trees of around also when trained on the dataset. note that the effective bias is in favour of the non-statistical algorithms here as statistical algorithms can cope to a greater or lesser extent with prior class proportions that differ from the training proportions. in this dataset the classes were chosen by an expert on the basis of the given attributes below and it is hoped to replace the expert by an algorithm rule in the future. all attribute values are numeric. the dataset providers supplied the performance figures for algorithms which have been applied to the data drawn from the same source.note that the figures given in table were achieved using the original dataset with equal numbers of examples of both classes. the best results terms of error rate were achieved by smart and the tree algorithms and smart is very time consuming to run however with credit type datasets small improvements in accuracy can save vast amounts of money so dataset descriptions and results this has to be considered if sacrificing accuracy for time. k-nn did badly due to irrelevant attributes with a variable selection procedure it obtained an error rate of castle kohonen itrule and quadisc perform poorly result for quadisc equalling the default rule. castle uses only attribute to generate the rule concluding that this is the only relevant attribute for the classification. kohonen works best for datasets with equal class distributions which is not the case for the dataset as preprocessed here. at the cost of significantly increasing the cpu time the performance might be improved by using a larger kohonen net. this dataset. and the best result for the decision tree algorithms was obtained by which used the smallest tree with nodes. used nodes and achieved a similar error rate newid used and nodes respectively which suggests that they over trained on australian credit table results for the australian credit dataset classes attributes observations cross-validation. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd test fd error rate test fd train fd rank the aim is to devise a rule for assessing applications for credit cards. the dataset has been studied before interpretation of the results is made difficult because the attributes and classes have been coded to preserve confidentiality however sec. image data object recognition examples of likely attributes are given for another credit data set in section for our purposes we replaced the missing values by the overall medians or means of the examples had some missing information. due to the confidentiality of the classes it was not possible to assess the relative costs of errors nor to assess the prior odds of good to bad customers. we decided therefore to use the default cost matrix. the use of the default cost matrix is not realistic. in practice it is generally found that it is very difficult to beat the simple rule give credit if only if the applicant has a bank account we do not know with this dataset what success this default rule would have. the results were obtained by cross validation. the best result here was obtained by which used only an average of less than and newid used around nodes and achieved higher error rates which suggests that pruning is necessary. nodes in its decision tree. by contrast image datasets handwritten digits this dataset consists of examples of the digits to gathered from postcodes on letters in germany. the handwritten examples were digitised onto images with pixels and grey levels. they were read by one of the automatic address readers built by a german company. these were initially scaled for height and width but not thinned or rotated in a standard manner. an example of each digit is given in figure fig. hand-written digits from german postcodes x pixels. the dataset was divided into a training set with examples per digit and a test set with examples per digit. due to lack of memory very few algorithms could cope with the full dataset. in order to get comparable results we used a version with attributes prepared by averaging over neighbourhoods in the original images. for the k-nn classifier this averaging resulted in an increase of the error rate from to whereas for discrim the error rate increased from to backprop could also cope with all attributes but when presented with all examples in the training set took an excessively long time to train two cpu days. the fact that k-nn and lvq do quite well is probably explained by the fact that they make the fewest restrictive assumptions about the data. discriminant analysis on the other hand assumes that the data follows a multi-variate normal distribution with the attributes obeying a common covariance matrix and can model only linear aspects of the data. the fact that quadisc using a reduced version of the dataset does better than discrim using either the full version or reduced version shows the advantage of being able to model non-linearity. castle approximates the data by a polytree and this assumption is too restrictive in this case. naive bayes assumes the attributes are conditionally independent. that naive bayes does so badly is explained by the fact that the attributes are clearly not conditionally independent since neighbouring pixels are likely to have similar grey levels. it is surprising that cascade does better than backprop and this may be attributed to the dataset descriptions and results observations. table results for the digit dataset classes attributes test time train test train error rate test discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage itrule kohonen backprop rbf lvq cascade default baytree naivebay rank backprop procedure being trapped in a local minimum or to having insufficient time to train. either way backprop should really do better here and one suggestion would be to start the backprop procedure with the parameters found from cascade. in this project we ran all algorithms independently without reference to others and we did not try to hybridise or run procedures in tandem although there is no doubt that there would be great benefit from pooling the results. the above dataset is close to raw pixel data. a minimum of processing has been carried out and the results could almost certainly be improved upon using deformable templates or some other statistical pattern recognition technique. note however that comparison of performance across handwritten digit datasets should not be made since they vary widely in quality. in this dataset only zeroes and sevens with strokes are used and there are a few intentional mistakes for example a digitised is classified as a and the capital b is classed as an the original attribute dataset has been analysed by kressel using a multilayer perceptron with one hidden layer and linear discriminants with selected sec. image data object recognition quadratic terms. both methods achieved about error rates on the test set. for the linearquadratic classifier and errors for the mlp. hidden layer. karhunen-loeve digits table results for the kl digits dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd fd baytree naivebay itrule kohonen backprop rbf lvq cascade default time train fd fd test fd fd train fd error rate test fd fd fd rank using the first principal components. it is interesting that with the exception of cascade correlation the order of performance of the algorithms is virtually unchanged table and that the error rates are now very similar to those obtained available using an alternative data reduction technique the averaging above was carried out the original pixels. the results for the digits dataset and the kl digits dataset are very similar so are treated together. most algorithms perform a few percent better on the kl digits dataset. the kl digits dataset is the closest to being normal. this could be predicted beforehand as it is a linear transformation of the attributes that by the central limit theorem would be closer to normal than the original. because there are very many attributes in each linear combination the kl digits dataset is very close to normal kurtosis as against the exact normal values of kurtosis dataset descriptions and results in both digits datasets dataset k-nn comes top and rbf and also do fairly well in fact failed and an equivalent kernel method with smoothing parameter asymptotically chosen was used. these three algorithms are all closely related. kohonen also does well in the digits dataset for some reason failed on kl digits kohonen has some similarities with k-nn type algorithms. the success of such algorithms suggests that the attributes are equally scaled and equally important. quadisc also does well coming second in both datasets. the kl version of digits appears to be well suited to quadisc there is a substantial difference in variances ratio while at the same time the distributions are not too far from multivariate normality with kurtosis of order backprop and lvq do quite well on the digits dataset bearing out the oft repeated claim in the neural net literature that neural networks are very well suited to pattern recognition problems hecht-nelson the decision tree algorithms do not do very well on these digits datasets. the tree sizes are typically in the region of nodes. vehicle silhouettes fig. vehicle silhouettes prior to high level feature extraction. these are clockwise from top left double decker bus opel manta saab and chevrolet van. a problem in object recognition is to find a method of distinguishing objects within a image by application of an ensemble of shape feature extractors to the silhouettes of the objects. this data was originally gathered at the turing institute in by j.p. siebert. four corgi model vehicles were used for the experiment a double decker bus chevrolet van saab and an opel manta this particular combination of vehicles was chosen with the expectation that the bus van and either one of the cars would be readily distinguishable but it would be more difficult to distinguish between the cars. the vehicles were rotated and a number of image silhouettes were obtained from a variety of orientations and angles. all images were captured with a spatial resolution of sec. image data object recognition pixels quantised to grey levels. these images were cleaned up binarised and subsequently processed to produce variables intended to characterise shape. for example circularity radius ratio compactness scaled variance along major and minor axes etc. a total of examples were obtained but were retained in case of dispute so the trials reported here used only examples and the algorithms were run using cross-validation to obtain error rates given in table table results for the vehicle dataset classes attributes observations cross-validation. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage itrule kohonen backprop rbf lvq cascade default baytree naivebay time train test train error rate test rank one would expect this dataset to be non-linear since the attributes depend on the angle at which the vehicle is viewed. therefore they are likely to have a sinusoidal dependence although this dependence was masked by issuing the dataset in permuted order. quadisc does very well and this is due to the highly non-linear behaviour of this data. one would have expected the backprop algorithm to perform well on this dataset since it is claimed backprop can successfully model the non-linear aspects of a dataset. however backprop is not straightforward to run. unlike discriminant analysis which requires no choice of free parameters backprop requires essentially two free parameters the number of hidden dataset descriptions and results nodes and the training time. neither of these is straightforward to decide. this figure for backprop was obtained using hidden nodes and a training time of four hours for the training time in each of the nine cycles of cross-validation. however one can say that the sheer effort and time taken to optimise the performance for backprop is a major disadvantage compared to quadisc which can achieve a much better result with a lot less effort. does nearly as well as quadisc. as compared with backprop it performs better and is quicker to run. it determines the number of nodes neurons and the initial weights by a reasonable procedure at the beginning and doesn t use an additional layer of hidden units but instead a symbolic level. the poor performance of castle is explained by the fact that the attributes are highly correlated. in consequence the relationship between class and attributes is not built strongly into the polytree. the same explanation accounts for the poor performance of naive bayes. k-nn which performed so well on the raw digits dataset does not do so well here. this is probably because in the case of the digits the attributes were all commensurate and carried equal weight. in the vehicle dataset the attributes all have different meanings and it is not clear how to build an appropriate distance measure. the attributes for the vehicle dataset unlike the other image analysis were generated using image analysis tools and were not simply based on brightness levels. this suggests that the attributes are less likely to be equally scaled and equally important. this is confirmed by the lower performances of k-nn lvq and radial basis functions which treat all attributes equally and have a built in mechanism for normalising which is often not optimal. did not perform well here and so an alternative kernel method was used which allowed for correlations between the attributes and this appeared to be more robust than the other three algorithms although it still fails to learn the difference between the cars. the original siebert paper showed machine learning performing better and were and nodes respectively. than k-nn but there is not much support for this in our results. the tree sizes for the high value of table might indicate that linear discrimination could be based on just two discriminants. this may relate to the fact that the two cars are not easily distinguishable so might be treated as one dimensionality of the mean vectors to however although the fraction of discriminating power for the third discriminant is low it is still statistically significant so cannot be discarded without a small loss of discrimination. letter recognition the dataset was constructed by david j. slate odesta corporation evanston il the objective here is to classify each of a large number of black and white rectangular pixel displays as one of the capital letters of the english alphabet. train and test was used for the classification. the character images produced were based on different fonts and each letter within these fonts was randomly distorted to produce a file of unique images. for each image numerical attributes were calculated using edge counts and measures of statistical moments which were scaled and discretised into a range of integer values from to perfect classification performance is unlikely to be possible with this dataset. one of the fonts used gothic roman appears very different from the others. sec. image data object recognition table results for the letters dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd test fd error rate test fd train fd rank quadisc is the best of the classical statistical algorithms on this dataset. this is perhaps not surprising since the measures data gives some support to the assumptions underlying the method. discrim does not perform well although the logistic version is a significant improvement. smart is used here with a term model and its poor performance is surprising. a number of the attributes are non linear combinations of some others and smart might have been expected to model this well. achieves the best performance of all with k-nn close behind. in this dataset all the attributes are pre scaled and all appear to be important so good performance from k-nn is to be expected. castle constructs a polytree with only one attribute contributing to the classification which is too restrictive with this dataset. naive bayes assumes conditional independence and this is certainly not satisfied for a number of the attributes. newid and on examples drawn from the full training set and that in part explains their rather uninspiring performance. newid builds a huge tree containing over nodes while the tree is about half the size. this difference probably explains some of the difference in their respective results. and also build complex trees while generates rules in order to classify the training set. itrule is the poorest algorithm on this dataset. were only trained dataset descriptions and results generally we would not expect itrule to perform well on datasets where many of the attributes contributed to the classification as it is severely constrained in the complexity of the rules it can construct. of the neural network algorithms kohonen and lvq would be expected to perform well for the same reasons as k-nn. seen in that light the kohonen result is a little disappointing. in a previous study frey slate investigated the use of an adaptive classifier system and achieved a best error rate of just under rank chromosomes table results for the chromosome dataset classes attributes test observations. max. algorithm storage fd fd time train fd fd test fd fd error rate test fd fd train fd fd discrim quadisc logdisc smart k-nn castle cart indcart newid baytree naivebay itrule kohonen backprop rbf lvq default this data was obtained via the mrc human genetics unit edinburgh from the routine amniotic cell data set c. lundsteen righospitalet copenhagen. in our trials we used only features examples which are a subset of a larger database which has features and nearly examples. the subset was selected to reduce the scale of the problem and selecting the features defined as level directly from the chromosome image and level requiring the axis e.g. length to be specified. we omitted observations with an unknown class as well as features with level both axis and profile and knowledge of the chromosome polarity sec. image data segmentation and level both the axis and both the polarity and the centrometre location. classification was done using one-shot train-and-test. the result for is very poor and the reason for this is not clear. an alternative kernel classifier a cauchy kernel to avoid numerical difficulties gave an error rate of which is much better. although quadratic discriminants do best here there is reason to believe that its error rate is perhaps not optimal as there is clear evidence of non-normality in the distribution of the attributes. the best of decision tree results is obtained by which has rules. and by contrast newid has terminal nodes but does about as well as have and terminal nodes respectively and yet obtain very differnt error rates. further details of this dataset can be found in piper granum who have done extensive experiments on selection and measurement of variables. for the dataset which resembled the one above most closely they achieved an error rate of landsat satellite image the original landsat data for this database was generated from data purchased from nasa by the australian centre for remote sensing and used for research at the university of new south wales. the sample database was generated taking a small section rows and columns from the original data. the classification for each pixel was performed on the basis of an actual site visit by ms. karen hall when working for professor john a. richards at the centre for remote sensing. the database is a sub-area of a scene consisting of pixels each pixel covering an area on the ground of approximately metres. the information given for each pixel consists of the class value and the intensities in four spectral bands the green red and infra-red regions of the spectrum. the original data are presented graphically in figure the first four plots row and bottom left show the intensities in four spectral bands spectral bands and are in the green and red regions of the visible spectrum while spectral bands and are in the infra-red shadings represent greatest intensity. the middle bottom diagram shows the land use with shadings representing the seven original classes in the order red soil cotton crop vegetation stubble mixture types present grey soil damp grey soil and very damp grey soil with red as lightest and very damp grey as darkest shading. also shown right are the classes as predicted by linear discriminants. note that the most accurate predictions are for cotton crop region bottom left of picture and that the predicted boundary damp-vary damp grey soil top left of picture is not well positioned. so that information from the neighbourhood of a pixel might contribute to the classification of that pixel the spectra of the eight neighbours of a pixel were included as attributes together with the four spectra of that pixel. each line of data corresponds to a square neighbourhood of pixels completely contained within the sub-area. thus each line contains the four spectral bands of each of the pixels in the neighbourhood and the class of the central pixel which was one of red soil cotton crop grey soil damp grey soil soil with vegetation stubble very damp grey soil. the mixed-pixels of which there were were removed for our purposes so that there are only six classes in this dataset. the examples were randomised and certain lines were deleted so that simple reconstruction of the original image was not possible. the data were divided into a train set and dataset descriptions and results spectral band spectral band spectral band spectral band land use land use fig. satellite image dataset. spectral band intensities as seen from a satellite for a small km region of australia. also given are the actual land use as determined by on-site visit and the estimated classes as given by linear discriminants. a test set with examples in the train set and in the test set and the error rates are given in table in the satellite image dataset k-nn performs best. not surprisingly radial basis functions lvq and also do fairly well as these three algorithms are closely related. fact failed on this dataset so an equivalent method using an asymptotically chosen bandwidth was used. their success suggests that all the attributes are equally scaled and equally important. there appears to be little to choose between any of the other algorithms except that naive bayes does badly its close relative castle also does relatively badly. the decision tree algorithms perform at about the same level with cart giving the used trees with and nodes respectively which suggests more pruning is desired for these algorithms. best result using nodes. and this dataset has the highest correlation between attributes this may partly explain the failure of naive bayes attributes are conditionally independent and castle if several attributes contain equal amounts of information. note that only three canonical discriminants are sufficient to separate all six class means sec. image data segmentation table results for the satellite image dataset classes attributes test observations. algorithm discrim quadisc logdisc smart k-nn castle cart indcart newid baytree naivebay itrule kohonen backprop rbf lvq cascade default maximum storage fd time train fd test fd train error rate test fd fd rank this may be interpreted as evidence of seriation with the three classes grey soil damp grey soil and very damp grey soil forming a continuum. equally this result can be interpreted as indicating that the original four attributes may be successfully reduced to three with no loss of information. here information should be interpreted as mean square distance between classes or equivalently as the entropy of a normal distribution. the examples were created using a neighbourhood so it is no surprise that there is a very large correlation amongst the variables. the results from castle suggest that only three of the variables for the centre pixel are necessary to classify the observation. however other algorithms found a significant improvement when information from the neighbouring pixels was used. image segmentation the instances were drawn randomly from a database of outdoor colour images. these were hand segmented to create a classification for every pixel as one of brickface sky region for example summary measures of contrast in the vertical and horizontal directions. foliage cement window path grass. there were attributes appropriate for each dataset descriptions and results table results for the image segmentation dataset classes attributes observations cross-validation. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage baytree naivebay itrule kohonen backprop rbf lvq default time train test error rate test train rank average error rates were obtained via cross-validation and are given in table did very well here and used an average of nodes in its decision trees. it is interesting here that does so much better than k-nn. the reason for this is that has a variable selection option which was initially run on the data and only of the original attributes were finally used. when variables were used the error rate increased to indeed a similar attribute selection procedure increased the performance of k-nn to a very similar error rate. this discrepancy raises the whole issue of preprocessing the data before algorithms are run and the substantial difference this can make. it is clear that there will still be a place for intelligent analysis alongside any black-box techniques for quite some time! cut this dataset was supplied by a statlog partner for whom it is commercially confidential. the dataset was constructed during an investigation into the problem of segmenting individual characters from joined written text. figure shows an example of the word eins for one. each example consists of a number of measurements made on the text relative to a potential cut point along with a decision on whether to cut the text at that sec. image data segmentation fig. the german word eins with an indication of where it should be cut to separate the individual letters. point or not. as supplied the dataset contained examples with real valued attributes. in an attempt to assess the performance of algorithms relative to the dimensionality of the problem a second dataset was constructed from the original using the best attributes selected by stepwise regression on the whole dataset. this was the only processing carried out on this dataset. the original and reduced datasets were tested. in both cases training sets of examples and test sets of were used in a single train-and-test procedure to assess accuracy. although individual results differ between the datasets the ranking of methods is broadly the same and so we shall consider all the results together. the default rule in both cases would give an error rate of around but since kohonen the only unsupervised method in the project achieves an error rate of for both datasets it seems reasonable to choose this value as our performance threshold. this is a dataset on which k nearest neighbour might be expected to do well all attributes are continuous with little correlation and this proves to be the case. indeed with a variable selection option k-nn obtained an error rate of only conversely the fact that k-nn does well indicates that many variables contribute to the classification. approaches k-nn performance by undersmoothing leading to overfitting on the training set. while this may prove to be an effective strategy with large and representative training sets it is not recommended in general. quadisc castle and naive bayes perform poorly on both datasets because in each case assumptions underlying the method do not match the data. quadisc assumes multi variate normality and unequal covariance matrices and neither of these assumptions is supported by the data measures. castle achieves default performance using only one variable in line with the assumption implicit in the method that only a small number of variables will determine the class. naive bayes assumes conditional independence amongst the attributes and this is unlikely to hold for a dataset of this type. machine learning algorithms generally perform well although with wide variation in tree sizes. baytree and indcart achieve low error rates at the expense of building trees containing more than nodes. performs almost as well though building a tree containing terminal nodes. produces a very parsimonious tree containing only nodes for the dataset which is very easy to understand. and newid build trees dataset descriptions and results table comparative results for the dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd test fd error rate test fd train fd rank with and nodes respectively. itrule like castle cannot deal with continuous attributes directly and also discretises such variables before processing. the major reason for poor performance though is that tests were restricted to conjunctions of up to two attributes. which tested conjunctions of up to attributes achieved a much better error rate. subsample. could not handle the full dataset and the results reported are for a it is interesting that almost all algorithms achieve a better result on than this suggests that the attributes excluded from the reduced dataset contain significant discriminatory power. achieves its better performance by building a tree five times larger than that for newid and and nodes and classify more accurately with them. uses a tree with nodes with a slight improvement in accuracy. similarly discovers a smaller set of rules for which deliver improved performance. this general improvement in performance underlines the observation that what is best or optimal in linear regression terms may not be best for other algorithms. both build significantly smaller trees sec. cost datasets table results for the dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd test fd train fd error rate test fd rank datasets with costs the following three datasets were all tackled using cross-validation. the error rates that have been used as a measure of performance are now replaced by average costs per observation over all cycles in cross-validation. the average cost is obtained for all algorithms by multiplying the confusion matrix by the cost matrix summing the entries and dividing by the number of observations. in the case of a cost matrix in which all errors have unit cost normally referred to as no cost matrix this measure of average cost is the same as the error rates quoted previously. note that some algorithms did not implement the cost matrix although in principle this would be straightforward. however we still include all of the algorithms in the tables partly for completeness but primarily to show the effect of ignoring the cost matrix. in general those algorithms which do worse than the default rule are those which do not incorporate costs into the decision making process. head injury the data set is a series of patients with severe head injury collected prospectively by neurosurgeons between and this head injury study was initiated in the institute dataset descriptions and results of neurological sciences glasgow. after years netherlands centres and groningen joined the study and late data came also from los angeles. the details of the data collection are given in jennet et al. the original purpose of the head injury study was to investigate the feasibility of predicting the degree of recovery which individual patients would attain using data collected shortly after injury. severely head injured patients require intensive and expensive treatment even with such care almost half of them die and some survivors remain seriously disabled for life. clinicians are concerned to recognise which patients have potential for recovery so as to concentrate their endeavours on them. outcome was categorised according to the glasgow outcome scale but the five categories described therein were reduced to three for the purpose of prediction. these were dv dead or vegetative sev severe disability mg moderate disability or good recovery. table gives the different cost of various possible misclassifications. table misclassification costs for the head injury dataset. the column represents the predicted class and the row the true class. dv sev mg dv sev mg the dataset had a very large number of missing values for patients and these were replaced with the median value for the appropriate class. this makes our version of the data considerably easier for classification than the original data and has the merit that all procedures can be applied to the same dataset but has the disadvantage that the resulting rules are unrealistic in that this replacement strategy is not possible for real data of unknown class. nine fold cross-validation was used to estimate the average misclassification cost. the predictive variables are age and various indicators of the brain damage as reflected in brain dysfunction. these are listed below. indicators of brain dysfunction can vary considerably during the few days after injury. measurements were therefore taken frequently and for each indicant the best and worst states during each of a number of successive time periods were recorded. the data supplied were based on the best state during the first hours after the onset of coma. the emv score in the table is known in the medical literature as the glasgow coma scale. d d i the sum of e m and v scores i.e. emv score i.e. age grouped into decades eye opening in response to stimulation motor response of best limb in response to stimulation verbal response to stimulation motor response pattern. an overall summary of the motor responses in all four limbs change in neurological function over the first hours f f sec. cost datasets eye indicant. a summary of sem ocs and ovs i.e. spontaneous eye movements oculocephalics oculovestibulars pupil reaction to light table results for the head injury dataset classes attributes observations cross-validation. algorithms in italics have not incorporated costs. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage itrule kohonen backprop rbf lvq cascade default baytree naivebay ac time train test average costs test train rank smart and are the only algorithms that as standard can utilise costs directly in the training phase used in our results a modified version of backprop that could utilise costs but this is very experimental. however although these two algorithms do reasonably well they are not the best. logistic regression does very well and so do discrim and quadisc cart indcart bayes tree and are the only decision trees that used a cost matrix here and hence the others have performed worse than the default rule. cart and nodes. however using error rate as a criterion we cannot judge whether these algorithms both had trees of around nodes whereas and newid both had around dataset descriptions and results were under-pruning since no cost matrix was used in the classifier. but for interpretability the smaller trees are preferred. titterington et al. compared several discrimination procedures on this data. our dataset differs by replacing all missing values with the class median and so the results are not directly comparable. heart disease table results for the heart disease dataset classes attributes observations cross-validation. algorithms in italics have not incorporated costs. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage itrule kohonen backprop rbf lvq cascade default baytree naivebay ac time test train average costs test train rank this database comes from the cleveland clinic foundation and was supplied by robert detrano m.d. ph.d. of the v.a. medical center long beach ca. it is part of the collection of databases at the university of california irvine collated by david aha. the purpose of the dataset is to predict the presence or absence of heart disease given the results of various medical tests carried out on a patient. this database contains attributes which have been extracted from a larger set of the database originally contained examples but of these contained missing class values and so were discarded leaving of these were retained in case of dispute leaving a final total of there are two classes presenceand absenceof heart-disease. this is a reduction of the number of classes sec. cost datasets in the original dataset in which there were four different degrees of heart-disease. table gives the different costs of the possible misclassifications. nine fold cross-validation was used to estimate the average misclassification cost. naive bayes performed best on the heart dataset. this may reflect the careful selection of attributes by the doctors. of the decision trees cart and performed the best. tuned the pruning parameter and not take the cost matrix into account so the prefered pruning is still an open question. used an average of nodes in the trees whereas this data has been studied in the literature before but without taking any cost matrix into account and so the results are not comparable with those obtained here. table misclassification costs for the heart disease dataset. the columns represent the predicted class and the rows the true class. used nodes. however did absent present absent present german credit table cost matrix for the german credit dataset. the columns are the predicted class and the rows the true class. good bad good bad the original dataset by professor dr. hans hofmann universit at hamburg contained some categoricalsymbolic attributes. for algorithms that required numerical attributes a version was produced with several indicator variables added. the attributes that were ordered categorical were coded as integer. this preprocessed dataset had numerical attributes and cross-validation was used for the classification and for uniformity all algorithms used this preprocessed version. it is of interest that newid did the trials with both the preprocessed version and the original data and obtained nearly identical error rates and but rather different tree sizes and nodes. the attributes of the original dataset include status of existing current account duration of current account credit history reason for loan request new car furniture credit amount savings accountbonds length of employment installment rate in percentage of disposable income marital status and sex length of time at presentresidence age and job. dataset descriptions and results results are given in table the providers of this dataset suggest the cost matrix of table it is interesting that only algorithms do better than the default. the results clearly demonstrate that some decision tree algorithms are at a disadvantage when costs are taken into account. that it is possible to include costs into decision trees is demonstrated by the good results of and cart et al. achieved a good result with an average of only nodes which would lead to very transparent rules. of those algorithms that did not include costs used a tree with nodes an error rates of and respectively. table results for the german credit dataset classes attributes observations cross-validation. algorithms in italics have not incorporated costs. and newid used an average of over nodes error rate of whereas algorithm discrim quadisc logdisc smart k-nn castle cart indcart newid ac baytree naivebay itrule kohonen backprop rbf lvq default maximum storage time train test average costs test train rank other datasets this section contains rather a mixed bag of datasets mostly of an industrial application. shuttle control the dataset was provided by jason catlett who was then at the basser department of computer science university of sydney n.s.w. australia. the data originated from nasa and concern the position of radiators within the space shuttle. the problem sec. miscellaneous data appears to be noise-free in the sense that arbitrarily small error rates are possible given sufficient data. rad_flow rad_flow high x rad_flow high fig. shuttle data attributes and for the two classes rad flow and high only. the symbols and denote the state rad flow and high respectively. the examples are classified correctly by the decision tree in the right diagram. the data was divided into a train set and a test set with examples in the train set and in the test set. a single train-and-test was used to calculate the accuracy. with samples of this size it should be possible to obtain an accuracy of approximately of the data belong to class at the other extreme there are only examples of class in the learning set. the shuttle dataset also departs widely from typical distribution assumptions. the attributes are numerical and appear to exhibit multimodality do not have a good statistical test to measure this. some feeling for this dataset can be gained by looking at figure it shows that a rectangular box sides parallel to the axes may be drawn to enclose all examples in the class high although the lower boundary of this box less than is so close to examples of class rad flow that this particular boundary cannot be clearly marked to the scale of figure in the whole dataset the data seem to consist of isolated islands or clusters of points each of which is pure to only one class with one class comprising several such islands. however neighbouring islands may be very close and yet come from different populations. the boundaries of the islands seem to be parallel with the coordinate axes. if this picture is correct and the present data do not contradict it as it is possible to classify the combined dataset with accuracy using a decision tree then it is of interest to ask which of our algorithms are guaranteed to arrive at the correct classification given an arbitrarily large learning dataset. in the following we ignore practical matters such as training times storage requirements etc. and concentrate on the limiting behaviour for an infinitely large training set. dataset descriptions and results table results for the shuttle dataset with error rates are in classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd test fd error train fd test rank fd procedures which might therefore be expected to find a perfect rule for this dataset would seem to be k-nn backprop and failed here and the result obtained by another kernel method a sphered transformation of the data was far from perfect. rbf should also be capable of perfect accuracy but some changes would be required in the particular implementation used in the project avoid singularities. using a variable selection method of the attributes k-nn achieved an error rate of decision trees will also find the perfect rule provided that the pruning parameter is properly set but may not do so under all circumstances as it is occasionally necessary to override the splitting criterion et al. although a machine learning procedure may find a decision tree which classifies perfectly it may not find the simplest representation. the tree of figure which was produced by the splus procedure tree gets accuracy with five terminal nodes whereas it is easy to construct an equivalent tree with only three terminal nodes that the same structure occurs in both halves of the tree in figure it is possible to classify the full examples with only errors using a linear decision tree with nine terminal nodes. since there are seven classes this sec. miscellaneous data is a remarkably simple tree. this suggests that the data have been generated by a process that is governed by a linear decision tree that is a decision tree in which tests are applied sequentially the result of each test being to allocate one section of the data to one class and to apply subsequent tests to the remaining section. as there are very few examples of class in the whole dataset it would require enormous amounts of data to construct reliable classifiers for class the actual trees produced by the algorithms are rather small as expected diabetes has nodes and both and cart have nodes. this dataset was originally donated by vincent sigillito applied physics laboratory johns hopkins university laurel md and was constructed by constrained selection from a larger database held by the national institute of diabetes and digestive and kidney diseases. it is publicly available from the machine learning database at uci appendix a. all patients represented in this dataset are females at least years old of pima indian heritage living near phoenix arizona usa. the problem posed here is to predict whether a patient would test positive for diabetes according to world health organization criteria if the patients hour post load plasma glucose is at least mgdl. given a number of physiological measurements and medical test results. the attribute details are given below number of times pregnant plasma glucose concentration in an oral glucose tolerance test diastolic blood pressure mmhg triceps skin fold thickness mm serum insulin mu uml body mass index kgm diabetes pedigree function age years this is a two class problem with class value being interpreted as tested positive for diabetes there are examples of class and of class twelve fold cross validation was used to estimate prediction accuracy. the dataset is rather difficult to classify. the so-called class value is really a binarised form of another attribute which is itself highly indicative of certain types of diabetes but does not have a one to one correspondence with the medical condition of being diabetic. no algorithm performs exceptionally well although and k-nn seem to be the poorest. automatic smoothing parameter selection in can make poor choices for datasets with discrete valued attributes and k-nn can have problems scaling such datasets. overall though it seems reasonable to conclude that the attributes do not predict the class well. uses only nodes in its decision tree whereas newid which performs less well has nodes. generates rules although there is not very much difference in the error rates here. this dataset has been studied by smith et al. using the adap algorithm. using examples as a training set adap achieved an error rate of on the remaining instances. and have and nodes repectively and dataset descriptions and results table results for the diabetes dataset classes attributes observations cross-validation. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage baytree naivebay itrule kohonen backprop rbf lvq default time train test error rate test train rank dna this classification problem is drawn from the field of molecular biology. splice junctions are points on a dna sequence at which superfluous dna is removed during protein creation. the problem posed here is to recognise given a sequence of dna the boundaries between exons parts of the dna sequence retained after splicing and introns parts of the dna that are spliced out. the dataset used in the project is a processed version of the irvine primate splice-junction database. each of the examples in the database consists of a window of nucleotides each represented by one of four symbolic values and the classification of the middle point in the window as one of intron extron boundary extron intron boundary or neither of these. processing involved the removal of a small number of ambiguous examples conversion of the original symbolic attributes to or binary attributes and the conversion of symbolic class labels to numeric labels section the training set of was chosen randomly from the dataset and the remaining examples were used as the test set. this is basically a partitioning problem and so we might expect in advance that decision tree algorithms should do well. the classes in this problem have a heirarchical sec. miscellaneous data table results for the dna dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd test fd error rate test fd train fd rank structure the primary decision is whether the centre point in the window is a splice junction or not. if it is a splice junction then the secondary classification is as to its type intron extron or extron intron. unfortunately comparisons between algorithms are more difficult than usual with this dataset as a number of methods were tested with a restricted number of attributes some were tested with attribute values converted to binary values and some to binary values. castle and cart only used the middle binary variables. newid and used the original categorical variables and k-nn kohonen lvq backprop and rbf used the one of four coding. the classical statistical algorithms perform reasonable well achieving roughly error rate. k-nn is probably hampered by the large number of binary attributes but naive bayes does rather well helped by the fact that the attributes are independent. surprisingly machine learning algorithms do not outperform classical statistical algorithms on this problem. castle and cart were at a disadvantage using a smaller window although performing reasonably. indcart used attributes and improved on the cart error rate by around itrule and are the poorest performers in this dataset descriptions and results itrule using only uni variate and bi variate tests is too restricted and is group. probably confused by the large number of attributes. of the neural network algorithms kohonen performs very poorly not helped by unequal class proportions in the dataset. constructs an effective set of piecewise linear decision boundaries but overall rbf is the most accurate algorithm using centres. it is rather worrying here that lvq claimed an error rate of and this result was unchanged when the test data had the classes permuted. no reason could be found for this phenomenon presumably it was caused by the excessive number of attributes but that the algorithm should lie with no explanation or warning is still a mystery. this problem did not occur with any other dataset. in order to assess the importance of the window size in this problem we can examine in a little more detail the performance of one of the machine learning algorithms. classified the training set using rules involving tests on from to attributes and misclassifying examples. table shows how frequently attributes in different ranges appeared in those rules. from the table it appears that a window of size contains the table frequency of occurrence of attributes in rules generated by for the dna training set. class class class total most important variables. attributes just after the middle of the window are most important in determining class and those just before the middle are most important in determining class for class variables close to the middle on either side are equally important. overall though variables throughout the attribute window do seem to contribute. the question of how many attributes to use in the window is vitally important for procedures that include many parameters quadisc gets much better results rate of on the test set if it is restricted to the middle categorical attributes. it is therefore of interest to note that decision tree procedures get almost the same accuracies on the original categorical data and the processed binary data. newid obtained an error rate of on the preprocessed data variables and on the original data categorical attributes. these accuracies are probably within what could be called experimental error so it seems that newid does about as well on either form of the dataset. there is a little more to the story however as the university of wisconsin ran several algorithms on this dataset. in table we quote their results alongside ours for nearest neighbour. in this problem and newid are probably equivalent and the slight discrepancies in error rates achieved by at wisconsin compared to newid in this study are attributable to the different random samples used. this cannot be the explanation for the differences between the two nearest neighbour results there appears to be an irreconcilable difference perhaps due to preprocessing perhaps due to distance being measured in a conditional dependent manner. certainly the kohonen algorithm used here encountered a problem when defining dis sec. miscellaneous data c cb tances in the attribute space. when using the coding of attributes the euclidean distances between pairs were not the same squared distances were for pairs g but only for the pairs involvingz therefore kohonen needs the coding of attributes. this coding was also adopted by other algorithms using distance measures lvq. table dna dataset error rates for each of the three classes splice junction is intron extron extron intron or neither. all trials except the last were carried out by the university of wisconsin sometimes with local implementations of published algorithms using ten-fold cross-validation on examples randomly selected from the complete set of the last trial was conducted with a training set of examples and a test set of examples. g c algorithm kbann backprop pebls perceptron cobweb n neighbour n neighbour neither ei ie overall technical table the four most common classes in the technical data classified by the value of attribute very little is known about this dataset as the nature of the problem domain is secret. it is of commercial interest to daimler-benz ag germany. the dataset shows indications of some sort of preprocessing probably by some decision-tree type process before it was received. to give only one instance consider only the four most common classes and consider only one attribute by simply tabulating the values of attribute it becomes obvious that the classifications are being made according to symmetrically placed boundaries on specifically the two boundaries at and and also the boundaries at and these boundaries divide the range of into five regions and if we look at the classes contained in these regions we get the frequency table in table the symmetric nature of the boundaries suggests strongly that the classes have been defined by their attributes and that the class definitions are only concerned with inequalities on the attributes. needless to say such a system is perfectly suited to decision trees and we may remark in passing that the above table was discovered range of g g c z g c z g c z dataset descriptions and results by a decision tree when applied to the reduced technical dataset with all attributes but with only the four most common classes other words the decision tree could classify the reduced dataset with error in examples using only one attribute. table results for the technical dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage fd fd fd fd fd baytree naivebay itrule kohonen backprop rbf lvq default time train fd fd fd fd fd test fd fd fd fd fd error rate test fd fd fd fd fd train fd fd fd fd fd rank the dataset consists of examples with attributes and classes. the attributes are all believed to be real however the majority of attribute values are zero. this may be the numerical value or more likely not relevant not measured or not applicable one-shot train and test was used to calculate the accuracy. the results for this dataset seem quite poor although all are significantly better than the default error rate of several algorithms failed to run on the dataset as they could not cope with the large number of classes. the decision tree algorithms indcart preprocessing which made the dataset more suited to decision trees algorithms. however the output produced by the tree algorithms is surprisingly difficult to interpret newid gave the best results in terms of error rates. this reflects the nature of the has newid and has a tree with terminal nodes has nodes has nodes and nodes. statistical algorithms gave much poorer results with quadisc giving the highest error rate of all. they appear to over-train slightly as a result of too many parameters. sec. miscellaneous data belgian power table results for the belgian power i classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage baytree naivebay itrule kohonen backprop rbf lvq cascade default time train test error rate test train rank the object of this dataset is to find a fast and reliable indicator of instability in large scale power systems. the dataset is confidential to statlog and belongs to t. van cutsem and l. wehenkel university of liege institut montefiore sart-tilman liege belgium. the emergency control of voltage stability is still in its infancy but one important aspect of this control is the early detection of critical states in order to reliably trigger automatic corrective actions. this dataset has been constructed by simulating up to five minutes of the system behaviour. basically a case is labelled stable if all voltages controlled by on-load tap changers are successfully brought back to their set-point values. otherwise the system becomes unstable. there are examples of stable and unstable states each with attributes which involve measurements of voltage magnitudes active and reactive power flows and injections. statistical algorithms cannot be run on datasets which have linearly dependent attributes and there are such attributes in the belgian power dataset. these have to be removed when running the classical statistical algorithms. no other form of pre-processing was done to this dataset. train and test sets have dataset descriptions and results kohonen map belgian power data fig. kohonen map of the belgian power data showing potential clustering. both classes and appear to have two distinct clusters. examples each and single train-and-test is used for the classification. the statistical algorithms smart and logdisc produced results which are significantly better than the other algorithms tested on this dataset. logdisc is approximately times quicker at training than smart and still produced an error rate of less than also gives a fairly low error rate and is not time consuming to run. k-nn was confused by irrelevant attributes and a variable selection option reduced the error rate to the kohonen map of this data may help to understand this dataset. the clustering apparent in fig. shows for example that there may be two distinct types of stable state by the decision trees did not do so well here. it is interesting that the smallest tree was produced by with nodes and the largest tree was produced by newid with nodes and yet the error rates are very similar at and respectively. information about class clusters can be incorporated directly into the model and helps to produce more accurate results. there is a more technical description of this dataset in van cutsem et al. belgian power ii this dataset is drawn from a larger simulation than the one which produced the belgian power dataset. the objective remains to find a fast and reliable indicator of instability in large scale power systems. this dataset is also confidential and belongs to the university sec. miscellaneous data table results for the belgian power ii dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage baytree naivebay itrule kohonen backprop rbf lvq default time train test error rate test train rank of liege and electricite de france. the training set consists of examples with attributes. the test set contains examples and there are two classes. no pre-processing was done and one-shot train-and-test was used to calculate the accuracy. as for the previous belgian power dataset smart comes out top in terms of test error rate it takes far longer to run than the other algorithms considered here. logdisc hasn t done so well on this larger dataset. k-nn was again confused by irrelevant attributes and a variable selection option reduced the error rate to the machine there is a detailed description of this dataset and related results in wehenkel et al. machine faults due to the confidential nature of the problem very little is known about this dataset. it was donated to the project by the software company isoft chemin de moulon learning algorithms indcart newid results. the tree sizes here were more similar with and newid using nodes. naive bayes is worst and along with kohonen and itrule give poorer results than the default rule for the test set error rate baytree and give consistently good using nodes nodes dataset descriptions and results table results for the machine faults dataset classes attributes observations cross-validation. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage baytree naivebay itrule kohonen backprop rbf lvq default time train test error rate test train rank gif sur yvette france. the only information known about the dataset is that it involves the financial aspect of mechanical maintenance and repair. the aim is to evaluate the cost of repairing damaged entities. the original dataset had multiple attribute values and a few errors. this was processed to split the attributes into the original train and test sets supplied by isoft were concatenated and the examples permuted randomly to form a dataset with examples. the pre-processing of hierarchical data is discussed further in section there are numerical attributes and classes and classification was done using cross-validation. this is the only hierarchical dataset studied here. compared with the other algorithms trials were done on the original dataset whereas the other algorithms on the project used a transformed dataset because they cannot handle dataset was preprocessed in order that other algorithms could handle the dataset. this preprocessing was done without loss of information on the attributes but the hierarchy between attributes was destroyed. the dataset of this application has been designed to run gives the best error rate. the in other words this datasets expressed in the knowledge representation language of thus all the knowledge entered has been used by the program. this explains with and underlines the importance of structuring the knowledge part the performance of sec. miscellaneous data for an application. although this result is of interest it was not strictly a fair comparison used domain-specific knowledge which the other algorithms did not for the most part could not. in addition it should be pointed out that the cross-validation involved a different splitting method that preserved the class proportions so this will also bias the result somewhat. the size of the tree produced by is nodes whereas and newid used trees with nodes and nodes since procedure used with respectively. kohonen gives the poorest result which is surprising as this neural net algorithm should do better on datasets with nearly equal class numbers. it is interesting to compare this with the results for k-nn. the algorithm should work well on all datasets on which any algorithm similar to the nearest neighbour algorithm a classical cluster analysis works well. the fact the k-nn performs badly on this dataset suggests that kohonen will too. tsetse fly distribution zimbabwe tsetse fly distribution e d u t t a l i longitude fig. tsetse map the symbols and denote the presence and absence of tsetse flies respectively. tsetse flies are one of the most prevalent insect hosts spreading disease tripanosomiasis from cattle to humans in africa. in order to limit the spread of disease it is of interest to predict the distribution of flies and types of environment to which they are best suited. the tsetse dataset contains interpolated data contributed by csiro division of forrestry australia et al. and was donated by trevor h. booth po box dataset descriptions and results queen victoria terrace canberra act australia. tsetse files were eradicated from most of zimbabwe but a map of presenceabsence was constructed before any eradication programme and this provides the classified examples. for a total of squares of side data has been collected from maps climatic databases and remotely sensed information. the main interest is in the environmental conditions under which the tsetse fly thrives and the dataset used here consisted of attributes related to this below. the classes are presence or absence of flies and the classification was done using one-shot train-and-test. the training set had examples and the test set had both had roughly equal numbers in both classes. all attribute values are numeric and indicated below. the original data had measurements of latitude and longitude as attributes which were used to construct the map. these attributes were dropped as the purpose is to identify the environmental conditions suitable for flies. elevation annual average nvdi vegetation index nvdi vegetation index for february nvdi vegetation index for september max min nvdi index annual evaporation annual rainfall max of monthly mean temperature maxima max of monthly mean temperature mean of monthly means min of monthly means minima min of monthly means max of monthly mean temperature maxima min of monthly means minima the machine learning algorithms produce the best and worst results for all give rise to number of months with temperature degrees this dataset. the decision tree algorithms cart newid and fairly accurate classification rules. the modern statistical algorithms smart and k-nn do significantly better than the classical statistical algorithms quadisc and logdisc. with a variable selection procedure k-nn obtains an error rate of again indicating some unhelpful attributes. similar work has been done on this dataset by booth et al. and ripley the dataset used by ripley was slightly different in that the attributes were normalised to be in the range over the whole dataset. also the train and test sets used in the classification were both samples of size taken from the full dataset which explains the less accurate results achieved. for example linear discriminants had an error rate of an algorithm similar to smart had neighbour had and backprop had the best results for lvq was and for tree algorithms an error rate of was reduced to on pruning. however the conclusions of both studies agree. the nearest neighbour and lvq algorithms work well they provide no explanation of the structure in the dataset. sec. measures table results for the tsetse dataset classes attributes test observations. discrim quadisc logdisc smart k-nn castle cart indcart newid max. algorithm storage baytree naivebay itrule kohonen backprop rbf lvq default time train test error rate test train rank the results of that the tree-based methods provide a very good and interpretable fit can be seen from cart and newid. similar error rates were obtained for used nodes used nodes and newid used nodes. however used only nodes and achieved a slightly higher error rate which possibly suggests over-pruning. castle has a high error rate compared with the other algorithms it appears to use only one attribute to construct the classification rule. the mlp result is directly comparable with the result achieved by ripley values were normalised and gave a slightly better result rate lower. however the overall conclusion is the same in that mlps did about the same as lvq and nearest-neighbour both of which are much simpler to use. statistical and information measures we give in tables and the statistical and information measures as described in section and for all of the datasets. as the calculation of the measures involved substantial computations some of the measures were calculated for reduced datasets. for example the measures for kl-digits are based on the training examples only. the following notes are made for a few of the datasets only and are not meant to be dataset descriptions and results comprehensive. rather some instructive points are chosen for illustrating the important ideas contained in the measures. kl-digits dataset the dataset that looks closest to being normal is the karhunen-loeve version of digits. this could be predicted beforehand as it is a linear transformation of the attributes that by the central limit theorem would be closer to normal than the original. because there are very many attributes in each linear combination the kl-digits dataset is very close to normal with skewness and kurtosis as against the exact normal values of skewness and kurtosis rather interestingly the multivariate kurtosis statisticd for kl digits show a very marked departure from multivariate normality despite the fact that the univariate statistics are close to normal kurtosis this is not too surprising it is possible to take a linear transform from karhunen-loeve space back to the original highly non-normal dataset. this shows the practical desirability of using a multivariate version of kurtosis. d the kl version of digits appears to be well suited to quadratic discriminants there is a substantial difference in variances ratio while at the same time the distributions are not too far from multivariate normality with kurtosis of order also and more importantly there are sufficient examples that the many parameters of the quadratic discriminants can be estimated fairly accurately. vehicle silhouettes in the vehicle dataset the high value of might indicate that discrimination could be based on just two discriminants. this may relate to the fact that the two cars are not easily distinguishable so might be treated as one dimensionality of the mean vectors to however although the fraction of discriminating power for the third discriminant is low it is still statistically significant so cannot be discarded without a small loss of discrimination. this dataset also illustrates that using mean statistics may mask significant differences in behaviour between classes. for example in the vehicle dataset for some of the populations types and mardia s kurtosis statistic is not significant. however for both vehicle types and the univariate statistics are very significantly low indicating marked departure from normality. mardia s statistic does not pick this up partly because the also the kl version appears to have a greater difference in variances ratio than the raw digit data ratio this is an artefact the digits data used here had several attributes with zero variances in some classes giving rise to an infinite value for sd ratio. is got by summing over a set of pixels. the original digits data with attributes the total of the individual mutual informations for the kl dataset is namely these datasets are ultimately derived from the same dataset so it is no surprise that these totals are rather close. however most algorithms found the kl attributes more informative about class so obtained reduced error rates. and this figure can be compared with the corresponding total for the digit dataset sec. measures cred.man cr.aust table table of measures for datasets kl segm letter chrom satim vehicle cut n p k bin.att cost sd corr.abs skewness kurtosis c v c n p k bin.att cost sd corr.abs skewness kurtosis c cby v c g g y g g g y g dataset descriptions and results n p k bin.att cost sd corr.abs skewness kurtosis c v c table table of measures for datasets head cr.ger heart shuttle diab dna tech belg belgii faults tsetse n p k bin.att cost sd corr.abs skewness kurtosis c v c g g y g g g y g sec. measures number of attributes is fairly large in relation to the number of examples per class and partly because mardia s statistic is less efficient than the univariate statistics. head injury among the datasets with more than two classes the clearest evidence of collinearity is in the head injury dataset. here the second canonical correlation is not statistically different from zero with a critical level of it appears that a single linear discriminant is sufficient to discriminate between the classes precisely a second linear discriminant does not improve discrimination. therefore the head injury dataset is very close to linearity. this may also be observed from the value of implying that the three class means lie close to a straight line. in turn this suggests that the class values reflect some underlying continuum of severity so this is not a true discrimination problem. note the similarity with fisher s original use of discrimination as a means of ordering populations. perhaps this dataset would best be dealt with by a pure regression technique either linear or logistic. if so manova gives the best set of scores for the three categories of injury as indicating that the middle group is slightly nearer to category than but not significantly nearer. it appears that there is not much difference between the covariance matrices for the three populations in the head dataset ratio so the procedure quadratic discrimination is not expected to do much better than linear discrimination will probably do worse as it uses many more parameters. heart disease the leading correlation coefficient in the heart dataset is not very high that gives a measure of predictability. therefore the discriminating power of the linear discriminant is only moderate. this ties up with the moderate success of linear discriminants for this dataset for the training data of in mind that it is correlation satellite image dataset the satellite image data is the only dataset for which there appears to be very large correlations between the attributes although there may be some large correlations in the vehicle dataset not too many presumably since here corr.abs note that only three linear discriminants are sufficient to separate all six class means this may be interpreted as evidence of seriation with the three classes grey soil damp grey soil and very damp grey soil forming a continuum. equally this result can be interpreted as indicating that the original attributes may be successfully reduced to three with no loss of information. here information should be interpreted as mean square distance between classes or equivalently as the entropy of a normal distribution. is and this figure gives an effective number of classes of which is approximately this can be interpreted as follows. although shuttle control the class entropy c jd g dataset descriptions and results there are six classes in the shuttle dataset some class probabilities are very low indeed so low in fact that the complexity of the classification problem is on a par with a two-class problem. technical although all attributes are nominally continuous there are very many zeroes so many that we can regard some of the attributes as nearly constant equal to zero. this is shown which is substantially less than one bit. by the average attribute entropy cby the average mutual information carried by each attribute so that although the attributes contain little information content this information contains relatively little noise. and this is about half of the information belgian power ii the belgian power ii dataset is a prime candidate for data compression as the ratio of noise to useful information is very high substantial reduction in the size of the dataset is possible without affecting the accuracy of any classification procedure. this does not mean that the dataset is noisy in the sense of not allowing good prediction. the better algorithms achieve an error rate of less than on the existing dataset and would achieve the same error rate on the condensed dataset. this is particularly true for the decision trees typically they use only a small number of attributes. g v c y g analysis of results p. b. brazdil and r. j. henery university of porto and university of strathclyde introduction we analyse the results of the trials in this chapter using several methods the section on results by subject areas shows that neural network and statistical methods do better in some areas and machine learning procedures in others. the idea is to give some indication of the subject areas where certain methods do best. the various methods. both algorithms and datasets using the performance of every combination multidimensional scaling is a method that can be used to point out similarities in algorithm dataset as a basis. the aim here is to understand the relationship between we also describe a simple-minded attempt at exploring the relationship between pruning and accuracy of decision trees. a principal aim of statlog was to relate performance of algorithms interpreted as accuracy or error-rate to characteristics or measures of datasets. here the aim is to give objective measures describing a dataset and to predict how well any given algorithm will perform on that dataset. we discuss several ways in which this might be done. this includes an empirical study of performance related to statistical and information-theoretic measures of the datasets. in particular one of the learning algorithms under study is used in an ingenious attempt to predict performance of all algorithms from the measures on a given dataset. the performance of an algorithm may be predicted by the performance of similar algorithms. if results are already available for a few yardstick methods the hope is that the performance of other methods can be predicted from the yardstick results. in presenting these analyses we aim to give many different views of the results so that a reasonably complete perhaps not always coherent picture can be presented of a very complex problem namely the problem of explaining why some algorithms do better m address for correspondence laboratory of ai and computer science university of porto r. campo alegre porto portugal analysis of results on some datasets and not so well on others. these differing analyses may give conflicting and perhaps irreconcilable conclusions. however we are not yet at the stage where we can say that this or that analysis is the final and only word on the subject so we present all the facts in the hope that the reader will be able to judge what is most relevant to the particular application at hand. results by subject areas to begin with the results of the trials will be discussed in subject areas. this is partly because this makes for easier description and interpretation but more importantly because the performance of the various algorithms is much influenced by the particular application. several datasets are closely related and it is easier to spot differences when comparisons are made within the same dataset type. so we will discuss the results under four headings datasets involving costs credit risk datasets image related datasets others of course these headings are not necessarily disjoint one of our datasets credit was a credit dataset involving costs. the feature dominating performance of algorithms is costs so the german credit dataset is listed under the cost datasets. we do not attempt to give any absolute assessment of accuracies or average costs. but we have listed the algorithms in each heading by their average ranking within this heading. algorithms at the top of the table do well on average and algorithms at the bottom do badly. to illustrate how the ranking was calculated consider the two credit datasets. because for example is ranked in the australian.credit and in the credit management dataset has a total rank of which is the smallest total of all and is therefore top of the listing in the credit datasets. similarly has a total rank of and so is in the list. of course other considerations such as memory storage time to learn etc. must not be forgotten. in this chapter we take only error-rate or average cost into account. credit datasets we have results for two credit datasets. in two of these the problem is to predict the creditworthiness of applicants for credit but they are all either coded or confidential to a greater or lesser extent. so for example we do not know the exact definition of uncreditworthy or bad risk possible definitions are more than one month late with the first payment more than two months late with the first payment or even the credit manager has already refused credit to this person credit management. credit management data from the uk german. credit risk data from germany. australian. credit risk data from it may be that these classifications are defined by a human if so then the aim of the decision rule is to devise a procedure that mimics the human decision process as closely as possible. machine learning procedures are very good at this and this probably reflects a natural sec. results by subject areas tendency for human decisions to be made in a sequential manner. it is then correspondingly easy for a human to understand the decision tree methods as this best reflects the human decision process. costs of misclassification in two of our credit datasets we were unable to assess either the prior odds of good-bad or the relative costs of making the wrong decisions. however in the german credit data we were given an independent assessment that the relative cost of granting credit to a bad risk customer was times that of turning down an application from a good risk customer or is the cost of misclassifying a bad credit risk as good and is the cost of misclassifying a good credit risk as bad. we assume that the proportions of good-bad risks in the training sample reflect those in the population. also in the credit management dataset it was explicitly stated by the dataset provider that errors of either type were equally important a statement that we interpreted to mean that the cost-ratio was unity. mdcb mdcb mdc gih on the other hand the definition of bad risk may be defined by the lateness of payments or non-payment. the task here is to assess the degree of risk. most datasets of this nature lose much useful information by binarising some measure of badness. for example a customer may be classed as a bad risk if the first repayment is more than one month late whereas a more natural approach would be to predict the number of months before the first payment is made. the statlog versions of machine learning methods were not generally well adapted to prediction problems however. apart from anything else prediction problems involve some cost function but not necessarily quadratic the important point is that some errors are more serious than others. generally in credit risk assessment the cost of misclassification is a vital element. the classification of a bad credit risk as good usually costs more than classification of a good credit risk as bad. unfortunately credit institutes cannot give precise estimates of the cost of misclassification. on the other hand many of the algorithms in this study cannot use a cost matrix in performing the classification task although there have recently been some attempts to consider misclassification costs in learning algorithms such newid and knoll if we were to judge learning algorithms solely on the basis of average misclassification cost this would penalise the ml algorithms. in some of the datasets therefore we used the average error rate instead this is equivalent to average misclassification cost in a very special case as we will now show. is misclassification as the error rates in the classification of bad and good risks respectively. denoting the prior is the cost of misclassifying a bad credit risk as good andmdcb recall thatmdc g and g are the cost of misclassifying a good credit risk as bad. suppose also that probabilities of good and bad risks by and we can calculate the expected cost of g and as mentioned above in practice it is very difficult to find out the values ofmdc g for example srinivisan sim because of this it is often assumed that mdcb mdc mdc exmdcb g g g g g g g g g g g analysis of results using assumption one can get the expected misclassification cost k from equation is the same for all algorithms so one can use the c e! total error rate in equation the ex c as an equivalent evaluation criterion when comparing the performance of algorithms. results and conclusions table error rates for credit datasets ordered by their average rank over the datasets. credit logdisc smart indcart bprop discrim rbf baytree itrule k-nn naivebay castle cart newid lvq kohonen quadisc default cr.aus cr.man the table of error rates for the credit datasets is given in table in reading this table the reader should beware that not much can be inferred from only two cases re the suitability of this or that algorithm for credit datasets generally in real credit applications differential misclassification costs tend to loom large if not explicitly then by implication. it is noteworthy that three of the top six algorithms are decision trees and indcart while the algorithm in second place is akin to a neural network. we may conclude that decision trees do reasonably well on credit datasets. this conclusion g g g g g g sec. results by subject areas would probably be strengthened if we had persuaded cart to run on the credit management dataset as it is likely that the error rate for cart would be fairly similar to indcart s value and then cart would come above indcart in this table. however where values were missing as is the case with cart the result was assumed to be the default value an admittedly very conservative procedure so cart appears low down in table by itself the conclusion that decision trees do well on credit datasets while giving some practical guidance on a specific application area does not explain why decision trees should be successful here. a likely explanation is that both datasets are partitioning datasets. this is known to be true for the credit management dataset where a human classified the data on the basis of the attributes. we suspect that it holds for the other credit dataset also in view of the following facts they are both credit datasets they are near each other in the multidimensional scaling representation of all datasets and they are similar in terms of number of attributes number of classes presence of categorical attributes etc. part of the reason for their success in this subject area is undoubtedly that decision tree methods can cope more naturally with a large number of binary or categorical attributes the number of categories is small. they also incorporate interaction terms as a matter of course. and perhaps more significantly they mirror the human decision process. image datasets image classification problems occur in a wide variety of contexts. in some applications the entire image an object in the image must be classified whereas in other cases the classification proceeds on a pixel-by-pixel basis with extra spatial information. one of the first problems to be tackled was of landsat data where switzer considered classification of each pixel in a spatial context. a similar dataset was used in our trials whereby the attributes not the class of neighbouring pixels was used to aid the classification a further image segmentation problem of classifying each pixel is considered in section an alternative problem is to classify the entire image into one of several classes. an example of this is object recognition for example classifying a hand-written character or a remotely sensed vehicle another example in our trials is the classification of chromosomes based on a number of features extracted from an image. there are different levels of image data. at the simplest level we can consider the grey values at each pixel as the set of variables to classify each pixel or the whole image. our trials suggest that the latter are not likely to work unless the image is rather small for example classifying a hand-written number on the basis off most of our algorithms. the pixel data can be further processed to yield a sharper image or other information which is still pixel-based for example a gradient filter can be used to extract edges. a more promising approach to classify images is to extract and select appropriate features and the vehicle silhouette and chromosome datasets are of this type. the issue of extracting the right features is a harder problem. the temptation is to measure everything which may be useful but additional information which is not relevant may spoil the performance of a classifier. for example the nearest neighbour method typically treats all variables with equal weight and if some are of no value then very poor results can occur. other algorithms are more robust to this pitfall. grey levels defeated for presentation purposes we will categorise each of the nine image datasets as being f analysis of results one of segmentation or object recognition and we give the results of the two types separately. results and conclusions object recognition table error rates for object recognition datasets. algorithms are listed in order of their average ranking over the five datasets. algorithms near the top tend to do well at object recognition. object quadisc k-nn lvq logdiscr discrim smart rbf baytree backprop newid indcart cascade kohonen castle cart itrule naivebay default kl digits vehic chrom letter table gives the error-rates for the five object recognition datasets. it is believed that this group contains pure discrimination datasets vehicle and letter recognition. on these datasets standard statistical procedures and neural networks do well overall. it would be wrong to draw general conclusions from only five datasets but we can make the following points. the proponents of backpropagation claim that it has a special ability to model non-linear behaviour. some of these datasets have significant non-linearity and it is true that backpropagation does well. however in the case of the digits it performs only marginally better than quadratic discriminants which can also model non-linear behaviour and in the case of the vehicles it performs significantly worse. when one considers the large amount of extra effort required to optimise and train backpropagation one must ask whether it really offers an advantage over more traditional algorithms. ripley also raises some important points on the use and claims of neural net methods. sec. results by subject areas castle performs poorly but this is probably because it is not primarily designed for discrimination. its main advantage is that it gives an easily comprehensible picture of the structure of the data. it indicates which variables influence one another most strongly and can identify which subset of attributes are the most strongly connected to the decision class. however it ignores weak connections and this is the reason for its poor performance in that weak connections may still have an influence on the final decision class. smart and linear discriminants perform similarly on these datasets. both of these work with linear combinations of the attributes although smart is more general in that it takes non-linear functions of these combinations. however quadratic discriminants performs rather better which suggests that a better way to model non-linearity would be to input selected quadratic combinations of attributes to linear discriminants. the nearest neighbour algorithm does well if all the variables are useful in classification and if there are no problems in choosing the right scaling. raw pixel data such as the satellite data and the hand-written digits satisfy these criteria. if some of the variables are misleading or unhelpful then a variable selection procedure should precede classification. the algorithm used here was not efficient in cpu time since no condensing was used. results from ripley indicate that condensing does not greatly affect the classification performance. paired comparison on digits data kl and the digits data represent different preprocessed versions of one and the same original dataset. not unexpectedly there is a high correlation between the error-rates with two missing values cart and kohonen on kl. of much more interest is the fact that the statistical and neural net procedures perform much better on the kl version than on the version. on the other hand machine learning methods perform rather poorly on the version and do even worse on the kl version. it is rather difficult to account for this phenomenon. ml methods by their nature do not seem to cope with situations where the information is spread over a large number of variables. by construction the karhunen-loeve dataset deliberately creates variables that are linear combinations of the original pixel gray levels with the first variable containing most information the second variable containing the maximum information orthogonal to the first etc.. from one point of view therefore the first kl attributes contain more information than the complete set of attributes in the digit dataset the latter is a particular set of linear combinations of the original data and the improvement in error rates of the statistical procedures is consistent with this interpretation. results and conclusions segmentation table gives the error rates for the four segmentation problems. machine learning procedures do fairly well in segmentation datasets and traditional statistical methods do very badly. the probable explanation is that these datasets originate as partitioning problems. paired comparison of and the dataset consists of the first attributes in the dataset ordered by importance in a stepwise regression procedure. one would therefore expect and generally one observes that performance deteriorates when the number of attributes is decreased that the information content is decreased. one exception to this rule is quadratic discrimination which does badly in the dataset and even worse in the data. this is the converse of the paired comparison in the digits analysis of results table error rates for segmentation datasets. algorithms are listed in order of their average ranking over the four datasets. algorithms near the top tend to do well in image segmentation problems. segment baytree k-nn newid indcart lvq rbf backprop smart logdisc cart kohonen discrim castle quadisc default naivebay itrule cascade satim segm dataset it appears that algorithms that are already doing badly on the most informative set of attributes do even worse when the less informative attributes are added. similarly machine learning methods do better on the dataset but there is a surprise they use smaller decision trees to achieve greater accuracy. this must mean that some of the less significant attributes contribute to the discrimination by means of interactions non-linearities. here the phrase less significant is used in a technical sense referring to the least informative attributes in linear discriminants. clearly attributes that have little information for linear discriminants may have considerable value for other procedures that are capable of incorporating interactions and non-linearities directly. k-nn is best for images perhaps the most striking result in the images datasets is the performance of k-nearest neighbour with four outright top places and two runners-up. it would seem that in terms of error-rate best results in image data are obtained by k-nearest neighbour. sec. datasets with costs results by subject areas there are two medical datasets and one credit dataset in this section. these are illustrative of the application areas where costs are important. there are two ways in which algorithms can incorporate costs into a decision rule at the learning stage or during the test stage. most statistical procedures are based on estimates of probabilities and incorporate costs only at the final test stage evaluating the expected cost of misclassification. however some procedures can incorporate costs into the learning stage. one simple way to do this might be to give extra weight to observations from classes with high costs of misclassification. results and conclusions table average costs for datasets with cost matrices. algorithms are listed in order of their average ranking over the three datasets. algorithms near the bottom cannot cope with costs. costs discrim logdisc castle quadisc cart naivebay smart k-nn cascade backprop baytree indcart default itrule lvq newid kohonen rbf head heart cr.ger the average costs of the various algorithms are given in table there are some surprises in this table particularly relating to the default procedure and the performance of most machine learning and some of the neural network procedures. overall it would seem that the ml procedures do worse than the default granting credit to everyone or declaring everyone to be seriously ill. analysis of results other datasets table error rates for remaining datasets. the shuttle error rates are in algorithms are listed in order of their average ranking over the eight datasets. most of the problems in the table are partitioning problems so it is fairly safe to say that algorithms near the top of the table are most suited to partitioning problems. others baytree newid indcart smart logdisc cart backprop rbf discrim quadisc naivebay castle k-nn itrule lvq kohonen default belg newbel tset diab dna faults shutt tech of the remaining datasets at least two and technical are pure partitioning problems with boundaries characteristically parallel to the attribute axes a fact that can be judged from plots of the attributes. two are simulated datasets and belgian power ii and can be described as somewhere between prediction and partitioning. the aim of the tsetse dataset can be precisely stated as partitioning a map into two regions so as to reproduce a given partitioning as closely as possible. the tsetse dataset is also artificial insofar as some of the attributes have been manufactured an interpolation from a small amount of information. the diabetes dataset is a prediction problem. the nature of the other datasets machine faults i.e. whether we are dealing with partitioning prediction or discrimination is not known precisely. results and conclusions table gives the error-rates for these eight datasets. it is perhaps inappropriate to draw general conclusions from such a mixed bag of datasets. however it would appear from the performance of the algorithms that the datasets are best dealt with by machine learning sec. top five algorithms or neural network procedures. how much relevance this has to practical problems is debatable however as two are simulated and two are pure partitioning datasets. top five algorithms in table we present the algorithms that came out top for each of the datasets. only the top five algorithms are quoted. the table is quoted for reference only so that readers can see which algorithms do well on a particular dataset. the algorithms that make the top five most frequently are times discrim logdiscr and quadisc but not too much should be made of these figures as they depend very much on the mix of problems used. table top five algorithms for all datasets. first fourth second third quadisc quadisc lvq cascade discrim logdiscr dataset kl satim vehic head heart belg segm diab cr.ger chrom cr.aus shutt dna tech newbel isoft tset cr.man letter k-nn k-nn k-nn quadisc logdiscr naivebay smart logdiscr discrim quadisc newid rbf newid smart baytree k-nn smart logdiscr itrule baytree indcart indcart baytree k-nn k-nn fifth bprop cart lvq cascade rbf lvq logdiscr quadisc discrim logdiscr quadisc discrim bprop newid baytree smart discrim rbf castle lvq discrim logdiscr discrim discrim baytree discrim indcart baytree lvq k-nn cart quadisc newid bprop logdiscr cart newid newid bprop quadisc table gives the same information as table but here it is the type of algorithm machine learning or neural net that is quoted. in the head injury dataset the top five algorithms are all statistical whereas the top five are all machine learning for the shuttle and technical datasets. between these two extremes there is a variety. table orders the datasets by the number of machine learning statistical or neural network algorithms that are in the top five. from inspection of the frequencies in table it appears that neural networks and statistical procedures do well on the same kind of datasets. in other words neural nets tend to do well when statistical procedures do well and vice versa. as an objective measure of this tendency a correspondence analysis can be used. correspondence analysis attempts analysis of results table top five algorithms for all datasets by type machine learning statistics and neural net dataset kl satim vehic head heart belg segm diab cr.ger chrom cr.aus shutt dna tech newbel isoft tset cr.man letter first stat stat stat stat stat stat stat stat stat stat stat ml ml nn ml stat ml ml ml stat stat stat second third stat nn nn stat stat stat nn ml stat stat stat stat ml stat ml ml stat ml ml stat ml nn stat stat nn nn nn stat stat ml nn stat nn ml ml nn ml ml nn ml stat ml nn stat fourth nn nn nn stat stat stat nn ml stat stat nn stat ml stat ml ml stat ml stat ml ml stat fifth nn stat stat nn ml stat stat nn nn nn stat nn ml stat ml ml nn ml ml ml nn ml to give scores to the rows datasets and columns procedure types of an array with positive entries in such a way that the scores are mutually consistent and maximally correlated. for a description of correspondence analysis see hill and mardia et al. it turns out that the optimal scores for columns and net and statistical procedures are virtually identical but these are quite different from the score of column ml procedures. it would appear therefore that neural nets are more similar to statistical procedures than to ml. in passing we may note that the optimal scores that are given to the datasets may be used to give an ordering to the datasets and this ordering can be understood as a measure of how suited the dataset is to ml procedures. if the same scores are allocated to neural net and statistical procedures the corresponding ordering of the datasets is exactly that given in the table with datasets at the bottom being more of type ml. dominators it is interesting to note that some algorithms always do better than the default the datasets we have looked at. there are nine such discrim logdisc smart k-nn cart and cascade. these algorithms dominate the default strategy. also in the seven datasets on which cascade was run itrule is dominated by cascade. the only other case of an algorithm being dominated by others is kohonen it sec. multidimensional scaling table datasets ordered by algorithm type. datasets at the top are most suited to statistical and neural net procedures datasets at the bottom most suited to machine learning. dataset ml nn stat heart cr.ger kl vehic belg diab chrom dna satim head letter isoft cr.aus cr.man segm newbel shutt tech tset is dominated by cascade and lvq. these comparisons do not include datasets where results is missing so we should really say where results are available kohonen is always worse than and lvq since we only have results for cascade trials the comparison cascade-kohonen is rather meaningless. multidimensional scaling it would be possible to combine the results of all the trials to rank the algorithms by overall success rate or average success rate but not without some rather arbitrary assumptions to equate error rates with costs. we do not attempt to give such an ordering as we believe that this is not profitable. we prefer to give a more objective approach based on multidimensional scaling equivalent procedure would be correspondence analysis. in so doing the aim is to demonstrate the close relationships between the algorithms and at the same time the close similarities between many of the datasets. multidimensional scaling has no background theory it is an exploratory tool for suggesting relationships in data rather than testing pre-chosen hypotheses. there is no agreed criterion which tells us if the scaling is successful although there are generally accepted guidelines. analysis of results scaling of algorithms to apply multidimensional scaling the first problem paradoxically is to scale the variables. the idea is to scale the error-rates and average costs in such a way that each dataset carries equal weight. this is not easy. in each dataset we rescaled so that the error-rate average cost had a minimum of zero and a maximum of unity. such a rescaling is arbitrary and can only be justified a posteriori insofar as the results confirm known relationships. once the initial scaling has been done distances between all pairs of algorithms must be computed. distance was taken to be the euclidean distance between the rescaled error-rates on the datasets. this results in a distance matrix representing distances between all pairs of algorithms in space. the distance matrix can then be decomposed by an orthogonal decomposition into distances in a reduced space. most conveniently the dimensions of the reduced space are chosen to be two so that the algorithms can be represented as points in a plot. this plot is given in figure multidimensional scaling of algorithms datasets cascade logdiscr discrim quadisc smart bprop knn cart baytree lvq rbf indcart kohonen castle e t i a n d r o o c g n i l a c s d n o c e s newid naivebay itrule first scaling coordinate fig. multidimensional scaling representation of algorithms in the space dimension is an error rate or average cost measured on a given dataset. points near to each other in this plot are not necessarily close in whether the plot is a good picture of space can be judged from a comparison of the set of distances in compared to the set of distances in one simple way to measure the goodness of the representation is to compare the total squared distances. let be the total of the squared distances taken over all pairs of points in the plot and let be the total squared distances over all pairs of points in the stress is defined to be for figure the stress figure is considering the number of initial dimensions is very high this is a reasonably small stress although we should say that conventionally the stress is sec. multidimensional scaling said to be small when less than with a representation the stress factor would be indicating that it would be more sensible to think of algorithms differing in at least a three-dimensional representation would raise the prospect of representing all results in terms of three scaling coordinates which might be interpretable as error-rates of three notional algorithms. because the stress figure is low relative to the number of dimensions points near each other in figure probably represent algorithms that are similar in performance. for example the machine learning methods newid and indcart are very close to each other and in general all the machine learning procedures are close in figure before jumping to the conclusion that they are indeed similar it is as well to check the tables of results the stress is low it is not zero so the distances in figure are approximate only. looking at the individual tables the reader should see that for example newid and indcart tend to come at about the same place in every table apart from a few exceptions. so strong is this similarity that one is tempted to say that marked deviations from this general pattern should be regarded with suspicion and should be double checked. hierarchical clustering of algorithms hierarchical clustering algorithms datasets i c s d a u q l e u r t i e l t s a c y a b e v a n i q v l n e n o h o k n n k c o l l a f b r c c a m i r c s d i i r c s d g o l t r a m s e d a c s a c t r a c l a c p o r p b l o p d i e e r t y a b t r a c d n i n c i d w e n fig. hierarchical clustering of algorithms using standardised error rates and costs. there is another way to look at relationships between the algorithms based on the set of paired distances namely by a hierarchical clustering of the algorithms. the resulting figure does indeed capture known similarities and logistic discriminants are very close and is very suggestive of other relationships. it is to be expected that some of the similarities picked up by the clustering procedure analysis of results will be accidental. in any case algorithms should not be declared as similar on the basis of empirical evidence alone and true understanding of the relationships will follow only when theoretical grounds are found for similarities in behaviour. finally we should say something about some dissimilarities. there are some surprising errors in the clusterings of figure for example cart and indcart are attached to slightly different clusterings. this is a major surprise and we do have ideas on why this is indeed true but nonetheless cart and indcart were grouped together in tables to facilitate comparisons between the two. scaling of datasets the same set of re-scaled error rates may be used to give a plot of datasets. from a formal point of view the multidimensional scaling procedure is applied to the transpose of the matrix of re-scaled error rates. the default algorithm was excluded from this exercise as distances from this to the other algorithms were going to dominate the picture. multidimensional scaling of datasets algorithms e t i a n d r o o c g n i l a c s d n o c e s cr.aus ml belg stat isoft ml diab stat cr.ger stat head stat heart stat cr.man nn newbel stat dna nn vehic stat satim stat chrom stat tech ml shutt ml segm stat ml stat tset ml letter stat stat kl stat first scaling coordinate fig. multidimensional scaling representation of the datasets in space dimension is an error rate and cost achieved by a particular algorithms. the symbols ml nn and stat below each dataset indicate which type of algorithm achieved the lowest error-rate or cost on that dataset. datasets near to each other in this plot are not necessarily close in figure is a multidimensional scaling representation of the error rates and costs given in tables each dataset in tables is described by a point in space the coordinates of which are the error rates or costs of the various algorithms. to help visualise the relationships between the points they have been projected down to in such a way as to preserve their mutual sec. multidimensional scaling distances as much as possible. this projection is fairly successful as the stress factor is only value of is regarded as excellent a value of is good. again a representation might be more acceptable with a stress factor of such a representation could be interpreted as saying that datasets differ in three essentially orthogonal ways and is suggestive of a description of datasets using just three measures. this idea is explored further in the next subsection. several interesting similarities are obvious from figure the costs datasets are close to each other as are the two types of image datasets. in addition the credit datasets are all at the top of the diagram for the german credit data which involves costs. the two pathologically partitioned datasets shuttle and technical are together at the extreme top right of the diagram. in view of these similarities it is tempting to classify datasets of unknown origin by their proximities to other datasets of known provenance. for example the diabetes dataset is somewhere between a partitioning type dataset credit data and a prediction type dataset head injury. interpretation of scaling coordinates the plotting coordinates for the description of datasets in figure are derived by orthogonal transformation of the original error ratescosts. these coordinates clearly represent distinctive features of the datasets as similar datasets are grouped together in the diagram. this suggests either that the scaling coordinates might be used as characteristics of the datasets or equivalently might be related to characteristics of the datasets. this suggests that we look at these coordinates and try to relate them to the dataset measures that we defined in chapter for example it turns out that the first scaling coordinate is positively correlated with the number of examples in the dataset. in figure this means that there is a tendency for the larger datasets to lie to the right of the diagram. the second is the number of classes. this implies that a dataset with small kurtosis and large number of classes will tend to lie in the bottom half of figure however the correlations are quite weak and in any case only relate to a subspace of two dimensions with a stress of so we cannot say that these measures capture the essential differences between datasets. scaling coordinate is correlated with the curious ratio kurtosis where that particular dataset. for example the algorithm type ml comes out top on the best algorithms for datasets in figure each dataset has been labelled by the type of algorithm that does best on faults dataset so the dataset faults has the label ml attached. inspecting figure a very clear pattern emerges. machine learning procedures generally do best on datasets at the top or at the extreme right of the diagram. statistical and neural network procedures do best on datasets in the lower half and to the left of the diagram. of course this pattern is very closely related to the fact that datasets from particular application areas are clustered together. in the spirit of correspondence analysis it would be possible to use the scaling coordinates of datasets or algorithms to come up with a mutually consistent set of coordinates that express the relationships between datasets and algorithms. this can be done but there are too many missing values in the tables for the usual version of correspondence analysis missing values allowed. analysis of results clustering of datasets starting from the distances in a standard clustering algorithm the furthest neighbour option gives the clustering of figure hierarchical clustering datasets on algorithms a n d t t u h s h c e t m o r h c t r a e dh a e h r e g r c m i t a s r e t t e l t e s t m g e s t u c t u c i c h e v b a d i s u a r c l g e b t f o s i l e b w e n n a m r c l k g d i fig. hierarchical clustering of datasets based on standardised error rates and costs. performance related to measures theoretical there are very few theoretical indicators for algorithm accuracy. what little there are make specific distributional assumptions and the only question is whether these specific assumptions are valid. in such cases it is possible to build checks into the algorithm that give an indication if the assumptions are valid. normal distributions the statistical measures were defined in section with a view to monitoring the success of the two discriminant procedures that are associated with the normal distribution namely linear and quadratic discriminants. within the class of normal distributions the measure provides a guide as to the relative suitability of linear and quadratic if sample sizes are so large that covariance matrices can be accurately discrimination. measured it would be legitimate to use the quadratic version exclusively as it reduces to the linear rule in the special case of equality of covariances. practically speaking the advice must be reversed use linear discriminants unless the sample size is very large the distribution is known to be nearly normal and the covariances are very different. so we consider now when to use quadratic discriminants. it should be noted that this advice is absolute in the sense that it is based only on measures related to the dataset. sec. performance related to measures theoretical absolute performance quadratic discriminants in theory quadratic discrimination is the best procedure to use when the data are normally distributed especially so if the covariances differ. because it makes very specific distributional assumptions and so is very efficient for normal distributions it is inadvisable to use quadratic discrimination for non-normal distributions common situation with parametric procedures they are not robust to departures from the assumptions and because it uses many more parameters it is also not advisable to use quadratic discrimination when the sample sizes are small. we will now relate these facts to our measures for the datasets. tributed dataset with widely differing covariance matrices. the ideal dataset for quadratic discrimination would be a very large normally disin terms of the measures kurtosis and sd ratio much greater than unity. skewness skewness kurtosis this is near and most importantly sd ratio this is much greater than unity. this dataset is nearest ideal so it is predictable that quadratic discrimination will achieve the lowest error rate. in fact quadratic discriminants achieve an error rate of and this is only bettered by k-nn with an error rate of and by with an error rate of ideally we want the most normal dataset in our study is the kl digits dataset as this is small skewness large kurtosis near and to make matters worse the sd ratio this is not much greater than unity. therefore we can predict that this is the least appropriate dataset for quadratic discrimination and it is no surprise that quadratic discriminants achieve an error rate of which is worst of all our results for the shuttle dataset. the decision tree methods get error rates smaller than this by a factor of at the other extreme the least normal dataset is probably the shuttle dataset with the important proviso should always be borne in mind that there must be enough data to estimate all parameters accurately. relative performance logdisc vs. another fruitful way of looking at the behaviour of algorithms is by making paired comparisons between closely related algorithms. this extremely useful device is best illustrated by comparing logistic discrimination and from their construction we can see that and logistic discrimination have exactly the same formal decision procedure in one special case namely the case of two-class problems in which there is no clustering both classes are pure where the two differ then will be in multi-class problems as the digits or letters datasets or in two-class problems in which the classes are impure as the belgian power dataset. with this in mind it is of interest to compare the performance of when it does not use clustering with the performance of logistic discrimination as is done in table the accuraciesaverage costs quoted for logistic discrimination are those in the main tables of chapter those quoted for are for the no-clustering version of dipol and so are different in general from those in the main tables. either in table or in the main tables it is clear that sometimes one procedure is better and sometimes the other. from what is known about the algorithms however we should look at the two-class problems separately and if this is done a pattern emerges. indeed from table it analysis of results table logistic discriminants vs. with no clustering. dataset belgian chromosome credit aus credit ger credit man dna diabetes faults kl digit letter new.belg sat. image segmentation shuttle technical tsetse vehicle logdisc clustering no. classes seems that generally logdisc is better than for two-class problems. knowing this we can look back at the main tables and come to the following conclusions about the relative performance of logdisc and rules comparing logdisc to we can summarise our conclusions viz-a-viz logistic and dipol by the following rules which amount to saying that is usually better than logdisc except for the cases stated. if number of examples is small or if cost matrix involved or if number of classes and if no distinct clusters within classes then logdisc is better than else is better than logdisc pruning of decision trees this section looks at a small subset of the trials relating to decision tree methods. the specific aim is to illustrate how error rate cost is related to the complexity of nodes of the decision tree. there is no obvious way of telling if the error-rate of a decision tree is near optimal indeed the whole question of what is to be optimised is a very open one. in practice a sec. performance related to measures theoretical hypothetical error rates for three algorithms dataset i dataset ii r o r r e nodes fig. hypothetical dependence of error rates on number of end nodes so on pruning for three algorithms on two datasets. balance must be struck between conflicting criteria. one way of achieving a balance is the use of cost-complexity as a criterion as is done by breiman et al. this balances complexity of the tree against the error rate and is used in their cart procedure as a criterion for pruning the decision tree. all the decision trees in this project incorporate some kind of pruning and the extent of pruning is controlled by a parameter. generally a tree that is overpruned has too high an error rate because the decision tree does not represent the full structure of the dataset and the tree is biased. on the other hand a tree that is not pruned has too much random variation in the allocation of examples. in between these two extremes there is usually an optimal amount of pruning. if an investigator is prepared to spend some time trying different values of this pruning parameter and the error-rate is tested against an independent test set the optimal amount of pruning can be found by plotting the error rate against the pruning parameter. equivalently the error-rate may be plotted against the number of end nodes. usually the error rate drops quite quickly to its minimum value as the number of nodes increases increasing slowly as the nodes increase beyond the optimal value. the number of end nodes is an important measure of the complexity of a decision tree. if the decision tree achieves something near the optimal error-rate the number of end nodes is also measure of the complexity of the dataset. although it is not to be expected that all decision trees will achieve their optimal error-rates with the same number of end-nodes it seems reasonable that most decision trees will achieve their optimal error-rates when the number of end-nodes matches the complexity of the dataset. considerations like these lead us to expect that the error-rates of different algorithms analysis of results on the same dataset will behave as sketched in figure to achieve some kind of comparability between datasets all the curves for one dataset can be moved horizontally and vertically on the logarithmic scale. this amounts to rescaling all the results on that dataset so that the global minimum error rate is unity and the number of nodes at the global minimum is unity. when no attempt is made to optimise the amount of pruning we resort to the following plausible argument to compare algorithms. consider for example the dataset. four algorithms were tested with very widely differing error rates and nodes as shown in table as the lowest error rate is achieved by make everything relative to so that the relative number opt of nodes and relative error rates opt are given in table these standardised results for the dataset are plotted in figure along table error rates and number of end nodes for four decision trees on the dataset. note that achieves the lowest error rate so we speculate that the optimal number of end nodes for decision trees is about algorithm no. end nodes error rate newid newid that are not near this optimal point. note that appears most frequently in the left of the figure it has less table error rates and number of end nodes for four algorithms relative to the values for with standardised results from other datasets for which we had the relevant information with the name of the algorithm as label. of course each dataset will give rise to at least algorithm and but we are here concerned with the results appear most frequently in the are biased often use very one point with nodes than the best algorithm and both newid and deliberately to obtain trees with simple structure whereas newid and has struck the right balance but it does seem clear that newid and right of the diagram they have too many nodes. it would also appear that is most likely to use the best number of nodes and this is very indirect evidence that the amount of pruning used by is correct on average although this conclusion is based on a small number of datasets. one would expect that a well-trained procedure should attain the optimal number of nodes on average but it is clear that is biased towards small numbers may be done towards more complex trees. in the absence of information on the relative weights to be attached to complexity of nodes or cost rate we cannot say whether sec. rule based advice on algorithm application excess error rate vs. excess no. nodes newid newid newid newid newid newid newid newid newid newid newid newid newid newid o i t a r r o r r e node.ratio fig. error rate and number of nodes for datasets. results for each dataset are scaled separately so that the algorithm with lowest error rate on that dataset has unit error rate and unit number of nodes. complex structures with no compensation in reduced error rate. rule based advice on algorithm application many different statistical and machine learning algorithms have been developed in the past. if we are interested in applying these algorithms to concrete tasks we have to consider which learning algorithm is best suited for which problem. a satisfactory answer requires a certain know-how of this area which can be acquired only with experience. we consider here if machine learning techniques themselves can be useful in organizing this knowledge specifically the knowledge embedded in the empirical results of the statlog trials. the aim is to relate the performance of algorithms to the characteristics of the datasets using only the empirical data. the process of generating a set of rules capable of relating these two concepts is referred to as meta-level learning. objectives it appears that datasets can be characterised using certain features such as number of attributes their types amount of unknown values or other statistical parameters. it is reasonable to try to match the features of datasets with our past knowledge concerning the algorithms. if we select the algorithm that most closely matches the features of the dataset then we increase the chances of obtaining useful results. the advantage is that not all algorithms need to be tried out. those algorithms that do not match the data can be excluded and so a great deal of effort can be saved. analysis of results in order to achieve this aim we need to determine which dataset features are relevant. after that various instances of learning tasks can be examined with the aim of formulating a theory concerning the applicability of different machine learning and statistical algorithms. the knowledge concerning which algorithm is applicable can be summarised in the form of rules stating that if the given dataset has certain characteristics then learning a particular algorithm may be applicable. each rule can in addition be qualified using a certain measure indicating how reliable the rule is. rules like this can be constructed manually or with the help of machine learning methods on the basis of past cases. in this section we are concerned with this latter method. the process of constructing the rules represents a kind of meta-level learning. as the number of tests was generally limited few people have attempted to automate the formulation of a theory concerning the applicability of different algorithms. one exception was the work of aha who represented this knowledge using the following rule schemas lon lon gchfk one example of such a rule schema is where ghg means that algorithm is predicted to have significantly higher accuracies than algorithm our approach differs from aha s in several respects. the main difference is that we are not concerned with just a comparison between two algorithms but rather a group of them. our aim is to obtain rules which would indicate when a particular algorithm works better than the rest. a number of interesting relationships have emerged. however in order to have reliable results we would need quite an extensive set of test results certainly much more than the datasets considered in this book. as part of the overall aim of matching features of datasets with our past knowledge of algorithms we need to determine which dataset features are relevant. this is not known a priori so for exploratory purposes we used the reduced set of measures given in table this includes certain simple measures such as number of examples attributes and classes and more complex statistical and information-based measures. some measures represent derived quantities and include for example measures that are ratios of other measures. these and other measures are given in sections using test results in metalevel learning here we have used all of the available results as listed in chapter the results for each dataset were analysed with the objective of determining which algorithms achieved low error rates costs. all algorithms with low error rates were considered applicable to e sec. rule based advice on algorithm application table measures used in metalevel learning. definition number of examples number of attributes number of classes number of binary attributes cost matrix indicator standard deviation ratio mean mean absolute correlation of attributes entropy of class mean entropy of attributes first canonical correlation fraction separability due to skewness mean ofi kurtosis mean ofi jlk jqk equivalent number of attributest n xykznyn xykvn noise-signal ratioj mean mutual information of class and attributes jlkzn measure simple n p q bin.att cost statistical sd corr.abs skewness kurtosis information theory n jlkvn xykzn en.attr ns.ratio this dataset. the other algorithms were considered inapplicable. this categorisation of the test results can be seen as a preparatory step for the metalevel learning task. of course the categorisation will permit us also to make prediction regarding which algorithms are applicable on a new dataset. of course the question of whether the error rate is high or low is rather relative. the error rate of may be excellent in some domains while may be bad in others. this problem is resolved using a method similar to subset selection in statistics. first the best algorithm is identified according to the error rates. then an acceptable margin of tolerance is calculated. all algorithms whose error rates fall within this margin are considered applicable while the others are labelled as inapplicable. the level of tolerance can reasonably be defined in terms of the standard deviation of the error rate but since each algorithm achieves a different error rate the appropriate standard deviation will vary across algorithms. then the standard deviation is defined by to keep things simple we will quote the standard deviations for the error rate of the best algorithm i.e. that which achieves the lowest error rate. denote the lowest error rate by c where fall within the intervalj xo n are considered applicable. of course we still need to choose a value for which determines the size of the interval. this affects the value of confidence that the truly best algorithm appears in the group considered. the larger the is the number of examples in the test set. then all algorithms whose error rates the higher the confidence that the best algorithm will be in this interval. t u t u w u w u t u w u w w w analysis of results for example let us consider the tests on the segmentation dataset consisting of which is in this example we can say with high confidence that the best algorithms the interval is relatively examples. the best algorithm appears to be with the error rate of n then are in the group with error rates between and bayestree apart from small of j if p and includes only two other algorithms all the algorithms that lie in this interval can be considered applicable to this dataset and the others inapplicable. if we enlarge the margin by considering larger values we get a more relaxed notion of applicability table table classified test results on image segmentation dataset for n margin margin for algorithm error class appl appl bayestree appl newid appl margin for margin for appl cart appl appl appl indcart appl lvq appl smart appl backprop appl kohonen rbf k-nn appl appl appl appl margin for margin for margin for logdisc non-appl castle non-appl discrim non-appl non-appl quadisc bayes non-appl non-appl itrule default non-appl the decision as to where to draw the line choosing a value for is of course rather subjective. in this work we had to consider an additional constraint related to the purpose we had in mind. as our objective is to generate rules concerning applicability of w sec. rule based advice on algorithm application algorithms we have opted for the more relaxed scheme of appplicability or so as to have enough examples in each class non-appl. some of the tests results analysed are not characterised using error rates but rather costs. consequently the notion of error margin discussed earlier has to be adapted to costs. the standard error of the mean cost can be calculated from the confusion matrices by testing and the cost matrix. the values obtained for the leading algorithm in the three relevant datasets were dataset german credit heart disease head injury algorithm discrim discrim logdisc mean cost standard error of mean in the experiments reported later the error margin was simply set to the values and respectively irrespective of the algorithm used. joining data relative to one algorithm the problem of learning was divided into several phases. in each phase all the test results relative to just one particular algorithm example cart were joined while all the other results to other algorithms were temporarily ignored. the purpose of this strategy was to simplify the class structure. for each algorithm we would have just two classes and non-appl. this strategy worked better than the obvious solution that included all available data for training. for example when considering the cart algorithm and a margin of v we get the scheme illustrated in figure the classified test cart-non-appl cart-non-appl cart-non-appl cart-non-appl cart-non-appl cart-non-appl cart-non-appl cart-non-appl kl chrom shut tech cut cr.man letter cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl cart-appl satim vehic head heart belg segm diab cr.ger cr.aust dna belgii faults tsetse fig. classified test results relative to one particular algorithm results are then modified as follows. the dataset name is simply substituted by a vector containing the corresponding dataset characteristics. values which are not available or missing are simply represented by this extended dataset is then used in the meta-level learning. choice of algorithm for learning a question arises as to which algorithm we should use in the process of meta-level learning. we have decided to use for the following reasons. first as our results have fig. decision tree generated by relative to cart. the right hand side of each leaf are either of the form or where n represents the total number of examples satisfying the conditions of the associated branch and e the number of examples of other classes that have been erroneously covered. if the data contains unknown values the numbers n and e may be fractional. it has been argued that rules are more legible than trees. the decision tree shown earlier can be transformed into a rule form using a very simple process where each branch of a tree is simply transcribed as a rule. the applicability of cart can thus be characterised using the rules in figure cart-appl cart-non-appl cart-non-appl n skewg ng n skew analysis of results demonstrated this algorithm achieves quite good results overall. secondly the decision tree generated by can be inspected and analysed. this is not the case with some statistical and neural learning algorithms. so for example when has been supplied with the partial test results relative to cart algorithm it generated the decision tree in figure the figures that appear on wfe bd dt c we l dt dt fig. rules generated by relative to cart. quinlan has argued that rules obtained from decision trees can be improved upon in various ways. for example it is possible to eliminate conditions that are irrelevant or even drop entire rules that are irrelevant or incorrect. in addition it is possible to reorder the rules according to certain criteria and introduce a default rule to cover the cases that have not been covered. the program includes a command that permits the user to transform a decision tree into a such a rule set. the rules produced by the system are characterised using error rate estimates. as is shown in the next section error rate its estimate is not an ideal measure however. this is particularly evident when dealing with continuous classes. this problem has motivated us to undertake a separate evaluation of all candidate rules and characterise them using a new measure. the aim is to identify those rules that appear to be most informative. characterizing predictive power the rules concerning applicability of a particular algorithm were generated on the basis of only about examples case represents the results of particular test on a particular dataset. of these only a part represented positive examples corresponding to the datasets on which the particular algorithm performed well. this is rather a modest number. also the set of dataset descriptors used may not be optimal. we could thus expect that the rules generated capture a mixture of relevant and fortuitous regularities. w l w l sec. rule based advice on algorithm application in order to strengthen our confidence in the results we have decided to evaluate the rules generated. our aim was to determine whether the rules could actually be used to make useful predictions concerning its applicability. we have adopted a leave-one-out procedure and applied it to datasets such as the one shown in table following this procedure we used all but one items in training while the remaining item was used for testing. of course the set of rules generated in each pass could be slightly different but the form of the rules was not our primary interest here. we were interested to verify how successful the rules were in predicting the applicability non-applicability of the algorithm. let us analyse an example. consider for example the problem of predicting the applicability of cart. this can be characterised using confusion matrices such as the ones shown in figure showing results relative to the error margin note that an extra dataset has been used in the following calculations and tables which is why the sum is now appl non-appl appl non-appl fig. evaluation of the meta-rules concerning applicability of cart. the rows represent the true class and the columns the predicted class. the confusion matrix shows that the rules generated were capable of correctly predicting the applicability of cart on an unseen dataset in cases. incorrect prediction was made only in case. similarly if we consider non-applicability we see that correct prediction is made in cases and incorrect one in this gives a rather good overall success rate of we notice that success rate is not an ideal measure however. as the margin of larger more cases will get classified as applicable. if we consider an extreme case when the margin covers all algorithms we will get an apparent success rate of of course we are not interested in such a useless procedure! this apparent paradox can be resolved by adopting the measure called information score bratko in the evaluation. this measure takes into account prior probabilities. the information score associated with a definite positive classification represents the prior probability of class c. the information scores can be used to weigh all classifier answers. in our case we have two classes appl and non-appl. the weights can be represented conveniently in the form of an information score matrix as shown in figure applicability is extended making log n where n is defined as log j appln logj c a j applnn fig. information score matrix. the rows represent the true class and the columns the predicted class. non- appl logj j non-applnn log j non- appln appl appl non-appl the information scores can be used to calculate the total information provided by a rule analysis of results on the given dataset. this can be done simply by multiplying each element of the confusion matrix by the corresponding element of the information score matrix. quencies. if we consider the frequency of appl and non-appl for all algorithms of the algorithm in question we get a kind of absolute reference point. this enables us to make comparisons right across different algorithms. the quantities j appln and j non-appln can be estimated from the appropriate frefor example for the value of log j appln we consider a dataset consisting of cases algorithms the information associated with j appln similarly the is value of logj is log j non-appln the examples of applicable cases are relatively common. of applicability of consequently the information concerning applicability has a somewhat smaller weight than the information concerning non-applicability if we multiply the elements of the confusion matrix for cart by the corresponding we notice that due to the distribution of this data by a relatively large margin datasets. as it happens cases fall into the class appl. elements of the information score matrix we get the matrix shown in figure logj appl non-appl appl non-appl fig. adjusted confusion matrix for cart. the rows represent the true class and the columns the predicted class. this matrix is in a way similar to the confusion matrix shown earlier with the exception that the error counts have been weighted by the appropriate information scores. to obtain an estimate of the average information relative to one case we need to divide all elements by the number of cases considered this way we get the scaled matrix in figure appl non-appl appl non-appl bits. bits. fig. rescaled adjusted confusion matrix for cart. this information provided by the classification of appl is the information provided by classification of non-appl is similarly this information obtained in the manner described can be compared to the information provided by a default rule. this can be calculated simply as follows. first we need to decide whether the algorithm should be applicable or non-applicable by default. this is quite simple. we just look for the classification which provides us with the highest information. is because the information associated with this default isj which is greater than the information associated with the converse rule that if we consider the previous example the class appl is the correct default for cart. this sec. cart is non-appl. rule based advice on algorithm application how can we decide whether the rules involved in classification are actually useful? this is quite straightforward. a rule can be considered useful if it provides us with more information than the default. if we come back to our example we see that the classification for appl provides us with bits while the default classification provides only bits. this indicates that the rules used in the classification are more informative than the default. in consequence the actual rule should be kept and the default rule discarded. rules generated in metalevel learning figure contains some rules generated using the method described. as we have not used a uniform notion of applicability throughout each rule is qualified by additional represents the concept of applicability derived on the each rule also shows the information score. this parameter gives an estimate of the usefulness of each rule. the rules presented could be supplemented by another set generated on the basis of the worst error rate the error rate associated with the choice of most information. the symbol appl o basis of the best error rate. in case of appl the interval of applicability isj best error rate best error rate std sn and the interval of non-applicability isj best error rate std s the interval of applicability isj best error common class or worse. in the case of appl y rate default error rate std sn and the interval of non-applicability isj default error rate std s recognised do not have any conditions on the right hand side of minimally useful information scoreg a few more rules which are a bit less informative inf. scores down to cart are also shown as these were discussed earlier. in the implemented system we use each rule included shows also the normalised information score. this parameter gives an estimate of the usefulness of each rule. only those rules that could be considered have been included here. all rules for the set of rules generated includes a number of default rules which can be easily discussion the problem of learning rules for all algorithms simultaneously is formidable. we want to obtain a sufficient number rules to qualify each algorithm. to limit the complexity of the problem we have considered one algorithm at a time. this facilitated the construction of rules. considering that the problem is difficult what confidence can we have that the rules generated are minimally sensible? one possibility is to try to evaluate the rules by checking whether they are capable of giving useful predictions. this is what we have done in one of the earlier sections. note that measuring simply the success rate has the disadvantage that it does not distinguish between predictions that are easy to make and those that are more difficult. this is why we have evaluated the rules by examining how informative they are in general. for example if we examine the rules for the applicability of cart we observe that the rules provide us with useful information if invoked. these measures indicate that the rules generated can indeed provide us with useful information. instead of evaluating rules in the way shown we could present them to some expert to see if he would find them minimally sensible. on a quick glance the condition n analysis of results statistical algorithms decision tree and rule algorithms n kurtosisg n skewg ng k ng ng n ng kg n n kg newid-appl y cart-appl y cart-appl cart-non-appl indcart-appl itrule-non-appl y itrule-non-appl discrim-appl discrim-non-appl discrim-non-appl quadisc-appl y logdisc-appl logdisc-non-appl y k-nn-appl bayes-non-appl y bayes-non-appl baytree-appl k baytree-non-appl kg castle-non-appl y ng cost castle-non-appl bin.att y rbf-non-appl lvq-appl backprop-appl kohonen-non-appl y cascade-non-appl cascade-non-appl neural network algorithms n fig. some rules generated in meta-level learning. inf. score sec. rule based advice on algorithm application is a bit puzzling. why should cart perform reasonably well if the number of examples is less than this number? is necessary to note that the condition n obviously as the rules were generated on the basis of a relatively small number of examples the rules could contain some fortuitous features. of course unless we have more data available it is difficult to point out which features are or are not relevant. however it is not an absolute one. rules should not be simply interpreted as the algorithm performs well if such and such condition is satisfied the correct interpretation is something like the algorithm is likely to compete well under the conditions stated provided no other more informative rule applies this view helps also to understand better the rule for discrim algorithm generated by the system. discrim-appl the condition n does not express all the conditions of applicability of algorithm discrim and could appear rather strange. however the condition does make sense. some algorithms have a faster learning rate than others. these algorithms compete well with others provided the number of examples is small. the fast learning algorithms may however be overtaken by others later. experiments with learning curves on the satellite image dataset show that the discrim algorithm is among the first six algorithms in terms of error rate as long as the number of examples is relatively small etc.. this algorithm seems to pick up quickly what is relevant and so we could say it competes well under these conditions. when the number of examples is larger however discrim is overtaken by other algorithms. with the full training set of examples discrim is in place in the ranking. this is consistent with the rule generated by our system. the condition generated by the system is not so puzzling as it seems at first glance! there is of course a well recognised problem that should be tackled. many conditions contain numeric tests which are either true or false. it does not make sense to consider the discrim algorithm applicable if the number of examples is less than and inapplicable if this number is just a bit more. a more flexible approach is needed example using flexible matching. application assistant rules generated in the way described permit us to give recommendations as to which classification algorithm could be used with a given dataset. this is done with the help of a kind of expert system called an application assistant this system contains a knowledge base which is interpreted by an interpreter. the knowledge base contains all the rules shown in the previous section. the interpreter is quite standard but uses a particular method for resolution of conflicts. we notice that the knowledge base may contain potentially conflicting rules. in general several rules may apply some of which may recommend the use of a particular algorithm while others may be against it. some people believe that knowledge bases should always be cleaned up so that such situations would not arise. this would amount to obliterating certain potentially useful information and so we prefer to deal with the problem in the following way. for every algorithm we consider all the rules satisfying the conditions and sum all the information scores. the information scores associated with the recommendation to apply analysis of results an algorithm are taken with a positive sign the others with a negative one. for example if we get a recommendation to apply an algorithm with an indication that this is apparently bits worth and if we also get an opposite recommendation not to apply this algorithm with an indication that this is bits worth we will go ahead with the recommendation but decrease the information score accordingly to bits. the output of this phase is a list of algorithms accompanied by their associated overall information scores. a positive score can be interpreted as an argument to apply the algorithm. a negative score can be interpreted as an argument against the application of the algorithm. moreover the higher the score the more informative is the recommendation in general. the information score can be then considered as a strength of the recommendation. the recommendations given are of course not perfect. they do not guarantee that the first algorithm in the recommendation ordering will have the best performance in reality. however our results demonstrate that the algorithms accompanied by a strong recommendation do perform quite well in general. the opposite is also true. the algorithms that have not been recommended have a poorer performance in general. in other words we observe that there is a reasonable degree of correlation between the recommendation and the actual test results. this is illustrated in figure which shows the recommendations generated for one particular dataset t e a r s s e c c u s k-nn lvq baytree quadisc newid castle kohonen logdisc rbf discrim smart backprop information score fig. recommendations of the application assistant for the letters dataset. the recommendations were generated on the basis of a rules set similar to the one shown in figure rule set included just a few more rules with lower information scores. the top part shows the algorithms with high success rates. the algorithms on the right are accompanied by a strong recommendation concerning applicability. we notice that sec. rule based advice on algorithm application several algorithms with high success rates apear there. the algorithm that is accompanied by the strongest reccomendation for this dataset is score bits. this algorithm has also the highest success rate of the second place in the ordering of algorithms recommended is k-nn shared by k-nn and we note that k-nn is a very good choice while is not too bad either. the correlation between the information score and success rate could of course be better. the algorithm castle is given somewhat too much weight while baytree which is near the top is somewhat undervalued. the correlation could be improved in the first place by obtaining more test results. the results could also be improved by incorporating a better method for combining rules and the corresponding information scores. it would be beneficial to consider also other potentially useful sets of rules including the ones generated on the basis of other values of k or even different categorisation schemes. for example all algorithms with a performance near the default rule could be considered non-applicable while all others could be classified as applicable. despite the fact that there is room for possible improvements the application assistant seems to produce promising results. the user can get a recommendation as to which algorithm could be used with a new dataset. although the recommendation is not guaranteed always to give the best possible advice it narrows down the user s choice. criticism of metalevel learning approach before accepting any rules generated by or otherwise it is wise to check them against known theoretical and empirical facts. the rules generated in metalevel learning could contain spurious rules with no foundation in theory. if the rule-based approach has shortcomings how should we proceed? would it be better to use another classification scheme in place of the metalevel learning approach using as there are insufficient data to construct the rules the answer is probably to use an interactive method capable of incorporating prior expert knowledge knowledge. as one simple example if it is known that an algorithm can handle cost matrices this could simply be provided to is the system. as another example the knowledge that the behaviour of newid and could then be likely to be similar could also be useful to the system. the rules for constructed from the rule for newid by adding suitable conditions concerning for example the hierarchical structure of the attributes. also some algorithms have inbuilt checks on applicability such as linear or quadratic discriminants and these should be incorporated into the learnt rules. criticism of measures some of the statistical measures are in fact more complex in structure than the learning the rules. for example the programming effort in calculating sd ratio is greater than that in establishing the linear discriminant rule. indeed to find sd ratio requires virtually all the quantities needed in finding the quadratic discriminant. this poses the question if it is easier to run say linear discriminants and newid why not run them and use the performance of these procedures as yardsticks by which to judge the performance of other algorithms? the similarities evident in the empirical results strongly suggest that the best predictor for logistic regression is linear discriminants logistic regression doing that is very similar to newid there is no hierarchy and little better on average and analysis of results so on. this idea can be formalised as we indicate in the next section. prediction of performance what is required is a few simple yardstick methods readily available in the public domain that can be run quickly on the given dataset. we also need a set of rules that will predict the performance of all other algorithms from the yardstick results. as a first suggestion consider discrim indcart and k-nn. they contain a statistical a decisiontree and a non-parametric method so represent the main strands. the question is this can they represent the full range of algorithms? in the terminology of multidimensional scaling do they span the reduced space in which most algorithm results reside? the multidimensional scaling diagram in figure suggests that a three- or even two-dimensional subspace is sufficient to represent all results. to give a few examples. let discrim k-nn and indcart represent the error rates achieved by the respective methods. to predict the accuracy of logdisc from these three reference figures we can use a multiple regression of logdisc on the three variables discrim k-nn and indcart no intercept term. after dropping non-significant terms from the regression this produces the formula with a squared correlation coefficient of see table for a summary of the regression formulae for all the algorithms discrim k-nn and indcart naturally. d table predictors for error-rates based on discrim k-nn and indcart. algorithm discrim k-nn indcart r-square quadisc logdisc smart castle cart newid n trials baytree naivebay itrule kohonen bprop cascade rbf lvq the discrim coefficient of in the logdisc example shows that logdisc is generally about more accurate than discrim and that the performance of the other two reference methods does not seem to help in the prediction. with an r-squared value of we can sec. prediction of performance be quite confident that logdisc does better than discrim. this result should be qualified with information on the number of attributes normality of variables etc and these are quantities that can be measured. in the context of deciding if further trials on additional algorithms are necessary take the example of the shuttle dataset and consider what action to recommend after discovering discrim indcart and k-nn it does not look as if the error rates of either logdisc or smart will get anywhere near indcart s value and the best prospect of improvement lies in the decision tree methods. consider now. there appears to be no really good predictor as the r-squared value is relatively small this means that is doing something outside the scope of the three reference algorithms. the best single predictor is discrim apparently indicating that is usually much better than discrim not so much better that it would challenge indcart s good value for the shuttle dataset. this formula just cannot be true in general however all we can say is that for datasets around the size in statlog has error rates about one third that of discrim but considerable fluctuation round this value is possible. if we have available the three reference results the formula would suggest that should be tried unless either k-nn or cart gets an accuracy much lower than a third of discrim. knowing the structure of we can predict a good deal more however. when there are just two classes of our datasets were problems and if does not use clustering is very similar indeed to logistic regression optimise on slightly different criteria. so the best predictor for in problems with no obvious clustering will be logdisc. at the other extreme if many clusters are used in the initial stages of then the performance is bound to approach that of say radial basis functions or lvq. also while on the subject of giving explanations for differences in behaviour consider the performance of compared to k-nn. from table it is clear that usually outperforms k-nn. the reason is probably due to the mechanism within whereby irrelevant attributes are dropped or perhaps because a surrogate was substituted for when it performed badly. if such strategies were instituted for k-nn it is probable that their performances would be even closer. finally we should warn that such rules should be treated with great caution as we have already suggested in connection with the rules derived by it is especially dangerous to draw conclusions from incomplete data as with cart for example for the reason that a not available result is very likely associated with factors leading to high error rates such as inability to cope with large numbers of categories or large amounts of data. empirical rules such as those we have put forward should be refined by the inclusion of other factors in the regression these other factors being directly related to known properties of the algorithm. for example to predict quadisc a term involving the measures sd ratio would be required that is not too circular an argument. ml on ml vs. regression two methods have been given above for predicting the performance of algorithms based respectively on rule-based advice using dataset measures on ml and comparison with reference algorithms it is difficult to compare directly the success rates of the respective predictions as the former is stated in terms of proportion of correct predictions analysis of results formula which is based on the assumption of equal numbers of non-appl and appl and the latter in terms of squared correlation. we now give a simple method of comparing from the predictability of performance from the two techniques. the r-squared value regression and the generated rule error rate can be compared by the following when the error rate is as pure as it should this formula gives a correlation ofz guesswork would get half the cases correct. to give an example in using this formula the cart rules had errors in with an error rate of j c on zj c a and an approximate r-square value of this is somewhat less than the value of this section. obtained using the regression techniques n conclusions of leeds d. michie d. j. spiegelhalter and c. c.taylor university of strathclyde mrc biostatistics unit cambridge and university introduction in this chapter we try to draw together the evidence of the comparative trials and subsequent analyses comment on the experiences of the users of the algorithms and suggest topics and areas which need further work. we begin with some comments on each of the methods. it should be noted here that our comments are often directed towards a specific implementation of a method rather than the method per se. in some instances the slowness or otherwise poor performance of an algorithm is due at least in part to the lack of sophistication of the program. in addition to the potential weakness of the programmer there is the potential reported on previous chapters were based on a version programmed in lisp. a version is now available in the c language which cuts the cpu time by a factor of in terms of error rates observed differences in goodness of result can arise from inexperience of the user. to give an example the trials of different suitabilities of the basic methods for given datasets different sophistications of default procedures for parameter settings different sophistication of the program user in selection of options and tuning of parameters occurrence and effectiveness of pre-processing of the data by the user the stronger a program in respect of then the better buffered against shortcomings in alternatively if there are no options to select or parameters to tune then item is not important. we give a general view of the ease-of-use and the suitable applications of the algorithms. some of the properties are subject to different interpretations. for example in general a decision tree is considered to be less easy to understand than decision rules. however both are much easier to understand than a regression formula which contains only coefficients and some algorithms do not give any easily summarised rule at all example k-nn. address for correspondence department of statistics university of leeds leeds u.k. conclusions the remaining sections discuss more general issues that have been raised in the trials such as time and memory requirements the use of cost matrices and general warnings on the interpretation of our results. user s guide to programs here we tabulate some measures to summarise each algorithm. some are subjective quantities based on the user s perception of the programs used in statlog and may not hold for other implementations of the method. for example many of the classical statistical algorithms can handle missing values whereas those used in this project could not. this would necessitate a front-end to replace missing values before running the algorithm. similarly all of these programs should be able to incorporate costs into their classification procedure yet some of them have not. in table we give information on various basic capabilities of each algorithm. statistical algorithms discriminants it can fairly be said that the performance of linear and quadratic discriminants was exactly as might be predicted on the basis of theory. when there was sufficient data and the class covariance matrices quite dissimilar then quadratic discriminant did better although at the expense of some computational costs. several practical problems remain however the problem of deleting attributes if they do not contribute usefully to the discrimination between classes mclachlan the desirability of transforming the data and the possibility of including some quadratic terms in the linear discriminant as a compromise between pure linear and quadratic discrimination. much work needs to be done in this area. we found that there was little practical difference in the performance of ordinary and logistic discrimination. this has been observed before fienberg quotes an example where the superiority of logistic regression over discriminant analysis is slight and is related to the well-known fact that different link functions in generalised linear models often fit empirical data equally well especially in the region near classification boundaries where the curvature of the probability surface may be negligible. mclachlan quotes several empirical studies in which the allocation performance of logistic regression was very similar to that of linear discriminants. in view of the much greater computational burden required the advice must be to use linear or quadratic discriminants for large datasets. the situation may well be different for small datasets. this algorithm was never intended for the size of datasets considered in this book and it often failed on the larger datasets with no adequate diagnostics. it can accept attribute data with both numeric and logical values and in this respect appears superior to the other statistical algorithms. the cross-validation methods for parameter selection are too cumbersome for these larger datasets although in principle they should work. an outstanding problem here is to choose good smoothing parameters this program uses a sec. statistical algorithms table users guide to the classification algorithms. algorithm mv cost interp. compreh. params user-fr. data discrim quadisc logdisc smart k-nn castle cart indcart newid baytree naivebay itrule kohonen backprop rbf lvq cascade n n n n n n n y y y y y y y y n y n n n n n n t t t lt lt t t t t n n t t n n n lt n lt t n n t y y y n n n y y y y y n y y y n y n n n n n n n n n nc nc n nc nc nc nc nch nc n nc nc nc nc n nc n n n n key mv cost interp. compreh. params user-fr. data whether the program accepts missing values whether the program has a built-in facility to deal with a cost matrix at learning testing or not at all whether the program gives an easily understood classifier very easy to interpret whether the principle of the method is easily understood very easy to grasp whether the program has good user-guidelines or automatic selection of important parameters. whether the program is user-friendly type of data allowed in the attributes numerical c categorical h hierarchical. however note that categorical data can always be transormed to numerical. conclusions multiplicative kernel which may be rather inflexible if some of the attributes are highly correlated. fukunaga suggests a pre-whitening of the data which is equivalent to using a multivariate normal kernel with parameters estimated from the sample covariance matrix. this method has shown promise in some of the datasets here although it is not very robust and of course still needs smoothing parameter choices. has a slightly lower error-rate than k-nn and uses marginally less storage but takes about twice as long in training and testing k-nn is already a very slow this may not generally be true. is a special case of the kernel method so it should be expected to do better. algorithm. however since k-nn was always set to indeed nearest neighbour although this method did very well on the whole as expected it was slowest of all for the very large datasets. however it is known that substantial time saving can be effected at the expense of some slight loss of accuracy by using a condensed version of the training data. an area that requires further study is in fast data-based methods for choosing appropriate distance measures variable selection and the appropriate number of neighbours. the program in these trials normally used just the nearest neighbour which is certainly not optimal. a simulation study on this problem was carried out by enas choi it is clear from many of the results that substantial improved accuracy can be obtained with careful choice of variables but the current implementation is much too slow. indeed lvq has about the same error-rate as k-nn but is about times faster and uses about less storage. where scaling of attributes is not important such as in object recognition datasets k-nearest neighbour is first in the trials. yet the explanatory power of k-nearest neighbour might be said to be very small. smart smart is both a classification and regression type algorithm which is most easily used in batch mode. it is a very slow algorithm to train but quite quick in the classification stage. the output is virtually incomprehensible to a non-statistician but a graphical frontend could be written to improve the interpretability. see the example in section in addition there are some difficulties in choosing the number of terms to include in the model. this is a similar problem to choosing the smoothing parameter in kernel methods or the number of neighbours in a nearest neighbour classifier. a major advantage smart has over most of the other algorithms is that it accepts a cost matrix in its training as well as in its testing phase which in principle ought to make it much more suited for tackling problems where costs are important. naive bayes naive bayes can easily handle unknown or missing values. the main drawback of the algorithm is perhaps its na vety i.e. it uses directly bayes theorem to classify examples. in addition for those not fluent with the statistical background there is generally little indication of why it has classified some examples in one class or the other. theory indicates and our experience confirms that naive bayes does best if the attributes are conditionally independent given the class. this seems to hold true for many sec. decision trees medical datasets. one reason for this might be that doctors gather as many different independent bits of relevant information as possible but they do not include two attributes where one would do. for example it could be that only one measure of high blood pressure diastolic would be quoted although two and systolic would be available. castle in essence castle is a full bayesian modelling algorithm i.e. it builds a comprehensive probabilistic model of the events this case attributes of the empirical data. it can be used to infer the probability of attributes as well as classes given the values of other attributes. the main reason for using castle is that the polytree models the whole structure of the data and no special role is given to the variable being predicted viz. the class of the object. however instructive this may be it is not the principal task in the above trials is to produce a classification procedure. so maybe there should be an option in castle to produce a polytree which classifies rather than fits all the variables. to emphasise the point it is easy to deflect the polytree algorithm by making it fit irrelevant bits of the tree are strongly related to each other but are irrelevant to classification. castle can normally be used in both interactive and batch modes. it accepts any data described in probabilities and events including descriptions of attributes-and-class pairs of data such as that used here. however all attributes and classes must be discretised to categorical or logical data. the results of castle are in the form of a polytree that provides a graphical explanation of the probabilistic relationships between attributes and classes. thus it is better in term of comprehensibility compared to some of the other statistical algorithms in its explanation of the probabilistic relationships between attributes and classes. the performance of castle should be related to how tree-like the dataset is. a major criticism of castle is that there is no internal measure that tells us how closely the empirical data are fitted by the chosen polytree we recommend that any future implementation of castle incorporates such a polytree measure. it should be straightforward to build a goodness-of-fit measure into castle based on a standard test. as a classifier castle did best in the credit datasets where generally only a few attributes are important but its most useful feature is the ability to produce simple models of the data. unfortunately simple models fitted only a few of our datasets. decision trees there is a confusing diversity of decision tree algorithms but they all seem to perform at about the same level. five of the decision trees considered in this book are similar in structure to the original algorithm with partitions being made by splitting on an attribute and with an entropy measure for the splits. there are no indications that this or that splitting criterion is best but the case for using some kind of pruning is overwhelming although again our results are too limited to say exactly how much pruning to use. it was hoped to relate the performance of a decision tree to some measures of complexity and pruning specifically the average depth of the tree and the number of terminal nodes in a sense cart s cost-complexity pruning automates this. has generally much fewer nodes so gives a simpler tree. many more nodes and occasionally scores a success because of that. the fact that all newid indcart generally has conclusions the decision trees perform at the same accuracy with such different pruning procedures suggests that much work needs to be done on the question of how many nodes to use. on the basis of our trials on the tsetse fly data and the segmentation data we speculate that decision tree methods will work well compared to classical statistical methods when the data are multimodal. their success in the shuttle and technical datasets is due to the special structure of these datasets. in the case of the technical dataset observations were partly pre-classified by the use of a decision tree and in the shuttle dataset we believe that this may also be so although we have been unable to obtain confirmation from the data provider. among the decision trees indcart cart and method emerge as superior to others because they incorporate costs into decisions. both cart and indcart can deal with categorical variables and cart has an important additional feature in that it has a systematic method for dealing with missing values. however for the larger datasets the commercial package cart often failed where the indcart implementation did not. in common with all other decision trees cart indcart and have the advantage of being distribution free. incorporating prior knowledge about the dataset in particular certain forms of hierarchical structure see chapter we looked at one dataset that was hierarchical in nature in newid and classifiers is very close. the main reason for choosing of the which and newid are direct descendants of and empirically their performance as would be to use other aspects package for example the interactive graphical package and the possibility of showed considerable advantage over other methods see section newid is based on ross quinlan s original program which generates decision trees from examples. it is similar to in its interface and command system. similar to newid can be used in both interactive and batch mode. the interactive mode is its native mode and to run in batch mode users need to write a unix shell script as for newid accepts attribute-value data sets with both logical and numeric data. newid has a post-pruning facility that is used to deal with noise. it can also deal with unknown values. newid outputs a confusion matrix. but this confusion matrix must be used with care because the matrix has an extra row and column for unclassified examples some examples are not classified by the decision tree. it does not accept or incorporate a cost matrix. different from the usual format mainly due to the need to express hierarchical attributes when there are such. but for non-hierarchical data there is very limited requirement for data is an extension to style of decision tree classifiers to learn structures from a predefined hierarchy of attributes. similarly to it uses an attribute-value based format for examples with both logical and numeric data. because of its hierarchical representation it can also encode some relations between attribute values. it can be run in interactive mode and data can be edited visually under its user interface. conversion. user interacts with uses an internal format that is can deal with unknown values in examples and multi-valued attributes. via a graphical interface. this interface consists of graphical it is also able to deal with knowledge concerning the studied domain but with the exception of the machine faults dataset this aspect was deliberately not studied in this book. the sec. decision trees editors which enable the user to define the knowledge of the domain to interactively build the example base and to go through the hierarchy of classes and the decision tree. produces decision trees which can be very large compared to the other decision tree algorithms. the trials reported here suggest that is relatively slow. this older version used common lisp and has now been superseded by a c version resulting in a much faster program. is the direct descendent of it is run in batch mode for training with attribute-value data input. for testing both interactive and batch modes are available. both logical and numeric values can be used in the attributes it needs a declaration for the types and range of attributes and such information needs to be placed in a separate file. is very easy to set up and run. in fact it is only a set of unix commands which should be familiar to all unix users. there are very few parameters. apart from the pruning criterion no major parameter adjustment is needed for most applications in the trials reported here the windowing facility was disabled. produces a confusion matrix from classification results. however it does not incorporate a cost matrix. allows the users to adjust the degree of the tracing information displayed while the algorithm is running. this facility can satisfy both the users who do not need to know the internal operations of the algorithm and the users who need to monitor the intermidate steps of tree construction. note that has a rule-generating module which often improves the error rate and almost invariably the user-transparancy but this was not used in the comparative trials reported in chapter cart and indcart cart and indcart are decision tree algorithms based on the work of breiman et al. the statlog version of cart is the commercial derivative of the original algorithm developed at caltech. both are classification and regression algorithms but they treat regression and unknown values in the data somewhat differently. in both systems there are very few parameters to adjust for new tasks. the noise handling mechanism of the two algorithms are very similar. both can also deal with unknown values though in different ways. the algorithms both output a decision tree and a confusion matrix as output. but only cart incorporates costs it does so in both training and test phases. note that cart failed to run in many of trials involving very large datasets. is a numeric value decision tree classifier using statistical methods. thus discrete values have to be changed into numeric ones. is very easy to set up and run. it has a number of menus to guide the user to complete operations. however there are a number of parameters and for novice users the meanings of these parameters are not very easy to understand. the results from different parameter settings can be very different but tuning of parameters is implemented in a semi-automatic manner. the decision trees produced by are usually quite small and are reasonably easy to understand compared to algorithms such as when used with default settings of conclusions pruning parameters. occasionally from the point of view of minimising error rates the tree is over-pruned though of course the rules are then more transparent. produces a confusion matrix and incorporates a cost matrix. bayes tree our trials confirm the results reported in buntine bayes trees are generally slower in learning and testing but perform at around the same accuracy as say or newid. however it is not so similar to these two algorithms as one might expect sometimes being substantially better the cost datasets sometimes marginally better the segmented image datasets and sometimes noticeably worse. bayes tree also did surprisingly badly for a decision tree on the technical dataset. this is probably due to the relatively small sample sizes for a large number of the classes. samples with very small a priori probabilities are allocated to the most frequent classes as the dataset is not large enough for the a priori probabilities to be adapted by the empirical probabilities. apart from the technical dataset bayes trees probably do well as a result of the explicit mechanism for pruning via smoothing class probabilities and their success gives empirical justification for the at-first-sight-artificial model of tree probabilities. rule-based methods the rule-based algorithm also belongs to the general class of recursive partitioning algorithms. of the two possible variants ordered and unordered rules it appears that unordered rules give best results and then the performance is practically indistinguishable from the decision trees while at the same time offering gains in mental fit over decision trees. however performed badly on the datasets involving costs although this should not be difficult to fix. as a decision tree may be expressed in the form of rules viceversa there appears to be no practical reason for choosing rule-based methods except when the complexity of the data-domain demands some simplifying change of representation. this is not an aspect with which this book has been concerned. can be used in both interactive and batch mode. the interactive mode is its native mode and to run in batch mode users need to write a unix shell script that gives the algorithm a sequence of instructions to run. the slight deviation from the other algorithms is that it needs a set of declarations that defines the types and range of attribute-values for each attribute. in general there is very little effort needed for data conversion. is very easy to set up and run. in interactive mode the operations are completely menu driven. after some familiarity it would be very easy to write a unix shell script to run the algorithm in batch mode. there are a few parameters that the users will have to choose. however there is only one parameter rule types which may have significant effect on the training results for most applications. itrule strictly speaking itrule is not a classification type algorithm and was not designed for large datasets or for problems with many classes. it is an exploratory tool and is best regarded as a way of extracting isolated interesting facts rules from a dataset. the facts are not meant to cover all examples. we may say that itrule does not look for sec. neural networks the best set of rules for classification for any other purpose. rather it looks for a set of best rules each rule being very simple in form restricted to conjunctions of two conditions with the rules being selected as having high information content the sense of having high within these limitations and also with the limitation of discretised variates the search for the rules is exhaustive and therefore time-consuming. therefore the number of rules found is usually limited to some small number which can be as high as or more however. for use in classification problems if the preset rules have been exhausted a default rule must be applied and it is probable that most errors are committed at this stage. in some datasets itrule may generate contradictory rules rules with identical condition parts but different conclusions and this may also contribute to a high error-rate. this last fact is connected with the asymmetric nature of the compared to the usual entropy measure. the algorithm does not incorporate a cost matrix facility but it would appear a relatively simple task to incorporate costs as all rules are associated with a probability measure. multi-class problems approximate costs would need to be used because each probability measure refers to the odds of observing a class or not. neural networks with care neural networks perform very well as measured by error rate. they seem to provide either the best or near to best predictive performance in nearly all cases the notable exceptions are the datasets with cost matrices. in terms of computational burden and the level of expertise required they are much more complex than say the machine learning procedures. and there are still several unsolved problems most notably the problems of how to incorporate costs into the learning phase and the optimal choice of architecture. one major weakness of neural nets is the lack of diagnostic help. if something goes wrong it is difficult to pinpoint the difficulty from the mass of inter-related weights and connectivities in the net. because the result of learning is a completed network with layers and nodes linked together with nonlinear functions whose relationship cannot easily be described in qualitative terms neural networks are generally difficult to understand. these algorithms are usually very demanding on the part of the user. he will have to be responsible for setting up the initial weights of the network selecting the correct number of hidden layers and the number of nodes at each layer. adjusting these parameters of learning is often a laborious task. in addition some of these algorithms are computationally inefficient. a notable exception here is lvq which is relatively easy to set up and fast to run. backprop this software package contains programs which implement mult-layer perceptrons and radial basis functions as well as several neural network models which are not discussed here including recurrent networks. it is reasonably versatile and flexible in that it can be used to train a variety of networks with a variety of methods using a variety of training data formats. however its functionality is not embellished with a friendly user interface so its users need at least a cursory familiarity with unix and neural networks and a significant block of time to peruse the documentation and work through the demonstrations. the package is also modular and extensible by anyone willing to write source code for conclusions new modules based on existing templates and hooks one of the fundamental modules provides routines for manipulating matrices submatrices and linked lists of submatrices. it includes a set of macros written for the unix utility which allows complicated array-handling routines to be written using relatively simple source code which in turn is translated into c source by all memory management is handled dynamically. there are several neural network modules written as applications to the minimisation module. these include a special purpose mlp a fully-connected recurrent mlp a fully-connected recurrent mlp with an unusual training algorithm almeida and general mlp with architecture specified at runtime. there is also an rbf network which shares the io routines but does not use the minimiser. there is a general feeling especially among statisticians that the multilayer perceptron is just a highly-parameterised form of non-linear regression. this is not our experience. in practice the backprop procedure lies somewhere between a regression technique and a decision tree sometimes being closer to one and sometimes closer to the other. as a result we cannot make general statements about the nature of the decision surfaces but it would seem that they are not in any sense local there would be a greater similarity with k-nn. generally the absence of diagnostic information and the inability to interpret the output is a great disadvantage. kohonen and lvq kohonen s net is an implementation of the self-organising feature mapping algorithm based on the work of kohonen kohonen nets have an inherent parallel feature in the evaluation of links between neurons so this program is implemented by luebeck university of germany on a transputer with an ibm pc as the front-end for user interaction. this special hardware requirement thus differs from the norm and makes comparison of memory and cpu time rather difficult. kohonen nets are more general than a number of other neural net algorithms such as backpropagation. in a sense it is a modelling tool that can be used to model the behaviour of a system with its input and output variables all modelled as linked neuronal. in this respect it is very similar to the statistical algorithm castle both can be used in wider areas of applications including classification and regression. in this book however we are primarily concerned with classification. the network can accept attribute-value data with numeric values only. this makes it necessary to convert logical or categorical attributes into numeric data. in use there are very few indications as to how many nodes the system should have and how many times the examples should be repeatedly fed to the system for training. all such parameters can only be decided on a trial-and-error basis. kohonen does not accept unknown values so data sets must have their missing attribute-values replaced by estimated values through some statistical methods. similar to all neural networks the output of the kohonen net normally gives very little insight to users as to why the conclusions have been derived from the given input data. the weights on the links of the nodes in the net are not generally easy to explain from a viewpoint of human understanding. lvq is also based on a kohonen net and the essential difference between these two programs is that lvq uses supervised training so it should be no surprise that in all the trials the exception of the dna dataset the results of lvq are better than those of sec. memory and time kohonen. so the use of kohonen should be limited to clustering or unsupervised learning and lvq should always be preferred for standard classification tasks. unfortunately lvq has at least one bug that may give seriously misleading results so the output should be checked carefully reported error rates of zero!. radial basis function neural network the radial basis function neural network for short is similar to other neural net algorithms. but it uses a different error estimation and gradient descent function i.e. the radial basis function. similar to other neural net algorithms the results produced by rbf are very difficult to understand. rbf uses a cross-validation technique to handle the noise. as the algorithm trains it continually tests on a small set called the cross-validation set when the error on this set starts to increase it stops training. thus it can automatically decide when to stop training which is a major advantage of this algorithm compared to other neural net algorithms. however it cannot cope with unknown values. the algorithm is fairly well implemented so it is relatively easy to use compared to many neural network algorithms. because it only has one parameter to adjust for each new application the number of centres of the radial basis function it is fairly easy to use. this algorithm has been included as a neural network and is perhaps closest to madaline but in fact it is rather a hybrid and could also have been classified as a nonparametric statistical algorithm. it uses methods related to logistic regression in the first stage except that it sets up a discriminating hyperplane between all pairs of classes and then minimises an error function by gradient descent. in addition an optional clustering procedure allows a class to be treated as several subclasses. this is a new algorithm and the results are very encouraging. although it never quite comes first in any one trial it is very often second best and its overall performance is excellent. it would be useful to quantify how much the success of is due to the multi-way hyperplane treatment and how much is due to the initial clustering and it would also be useful to automate the selection of clusters present the number of subclasses is a user-defined parameter. it is easy to use and is intermediate between linear discriminants and multilayer perceptron in ease of interpretation. it strengthens the case for other hybrid algorithms to be explored. memory and time so far we have said very little about either memory requirements or cpu time to train and test on each dataset. on reason for this is that these can vary considerably from one implementation to another. we can however make a few comments. memory in most of these large datasets memory was not a problem. the exception to this was the full version of the hand-written digit dataset see section this dataset had variables and examples and most algorithms on an mb machine could conclusions not handle it. however such problems are likely to be rare in most applications. a problem with the interpretation of these figures is that they were obtained from the unix command set time and for a simple fortran program for example the output is directly related to the dimension declarations. so an edited version could be cut to fit the given dataset and produce a smaller memory requirement a more sensible way to quantify memory would be in terms of the size of the data. for example in the sas manual it states that the memory required for nearest neighbour is for most situations of order if similar results could be stated for all our algorithms this would make comparisons much more transparent and also enable predictions for new datasets. as far as our results are concerned it is clear that the main difference in memory requirements will depend on whether the algorithm has to store all the data or can process it in pieces. the theory should determine this as well as the numbers but it is clear that linear and quadratic discriminant classifiers are the most efficient here. p c i.e. time again the results here are rather confusing. the times do not always measure the same thing for example if there are parameters to select there are two options. user may decide may decide to choose the parameters by cross-validation and reduce the error rate at the to just plug in the parameters and suffer a slight loss in accuracy of the classifier. user expense of a vastly inflated training time. it is clear then that more explanation is required and a more thorough investigation to determine selection of parameters and the trade-off between time and error rate in individual circumstances. there are other anomalies for example smart often quotes the smallest time to test and the amount of computation required is a superset of that required for discrim which usually takes longer. so it appears that the interpretation of results will again be influenced by the implementation. it is of interest that smart has the largest ratio of training to testing time in nearly all of the datasets. as with memory requirements a statement that time is proportional to some function of the data size would be preferred. for example the sas manual quotes the time is the number of observations in the training data. the above warnings should make us cautious in drawing conclusions in that some algorithms may not require parameter selection. however if we sum the training and testing times we can say generally that for the nearest neighbour classifier to test as proportional to where indcart takes longer than cart among the statistical algorithms the nonparametric ones take longer especially k-nn smart and among the decision tree algorithms and itrule take longer among the neural net algorithms is probably the quickest general issues cost matrices if a cost matrix is involved be warned that only cart the statistical procedures and some of the neural nets take costs into account at all. even then with the exception of j sec. general issues and smart they do not use costs as part of the learning process. of those algorithms which do not incorporate costs many output a measure which can be interpreted as a probability and costs could therefore be incorporated. this book has only considered three datasets which include costs partly for the very reason that some of the decision tree programs cannot cope with them. there is a clear need to have the option of incorporating a cost matrix into all classification algorithms and in principle this should be a simple matter. interpretation of error rates the previous chapter has already analysed the results from the trials and some sort of a pattern is emerging. it is hoped that one day we can find a set of measures which can be obtained from the data and then using these measures alone we can predict with some degree of confidence which algorithms or methods will perform the best. there is some theory here for example the similarity of within-class covariance matrices will determine the relative performance of linear and quadratic discriminant functions and also the performance of these relative to decision tree methods conditional dependencies will favour trees. however from an empirical perspective there is still some way to go both from the point of view of determining which measures are important and how best to make the prediction. the attempts of the previous chapter show how this may be done although more datasets are required before confidence can be attached to the conclusions. the request for more datasets raises another issue what kind of datasets? it is clear that we could obtain very biased results if we limit our view to certain types and the question of what is representative is certainly unanswered. section outlines a number of different dataset types and is likely that this consideration will play the most important r ole in determining the choice of algorithm. the comparison of algorithms here is almost entirely of a black-box nature. so the recommendations as they stand are really only applicable to the na ve user. in the hands of an expert the performance of an algorithm can be radically different and of course there is always the possibility of transforming or otherwise preprocessing the data. these considerations will often outweigh any choice of algorithm. structuring the results much of the analysis in the previous chapter depends on the scaling of the results. it is clear that to combine results across many datasets care will need to be taken that they are treated equally. in sections and the scaling was taken so that the error rates costs for each dataset were mapped to the interval x whereas in section the scaling was done using an estimated standard error for the error rates costs. the different approaches makes the interpretation of the comparison in section rather difficult. the pattern which emerges from the multidimensional scaling and associated hierarchical clustering of the algorithms is very encouraging. it is clear that there is a strong similarity between the construction and the performance of the algorithms. the hierarchical clustering of the datasets is not so convincing. however the overall picture in figure confirms the breakdown of analysis by subject area section in that convex hulls which do not overlap can be drawn around the datasets of the specific subject areas. conclusions an outlier here is the tsetse fly data which could also easily been placed in the category of image datasetssegmentation since the data are of a spatial nature although it is not a standard image! the analysis of section is a promising one though there is not enough data to make strong conclusions or to take the rules too seriously. however it might be better to predict performance on a continuous scale rather than the current approach which discretises the algorithms into applicable and non-applicable indeed the choice of section is very much larger than the more commonly used or standard errors in hypothesis testing. that the error rate for could be predicted by taking the attempts to predict performance using the performance of benchmark algorithms section is highly dependent on the choice of datasets used. also it needs to be remembered that the coefficients reported in table are not absolute. they are again based on a transformation of all the results to the unit interval. so for example the result the error rate for k-nn takes into account the error rates for all of the other algorithms. if we only consider this pair and then we get a coefficient of but this is still influenced by one or two observations. an alternative is to consider the average percentage improvement of which is but none of these possibilities takes account of the different sample sizes. or removal of irrelevant attributes there are many examples where the performance of algorithms may be improved by removing irrelevant attributes. a specific example is the dna dataset where the middle of the nominal attributes are by far the most relevant. if a decision tree for example is presented with this middle section of the data it performs much better. the same is true of quadratic discriminants and this is a very general problem with black-box procedures. there are ways of removing variables in linear discriminants for example but these did not have much effect on accuracy and this variable selection method does not extend to other algorithms. diagnostics and plotting very few procedures contain internal consistency checks. even where they are available in principle they have not been programmed into our implementations. for example quadratic discrimination relies on multivariatenormality and there are tests for this but they are programmed separately. similarly castle should be able to check if the assumption of polytree structure is a reasonable one but this is not programmed in. the user must then rely on other ways of doing such checks. an important but very much underused method is simply to plot selected portions of the data for example pairs of coordinates with the classes as labels. this often gives very important insights into the data. the manova procedure multidimensional scaling principal components and projection pursuit all give useful ways in which multidimensional data can be plotted in two dimensions. exploratory data if the object of the exercise is to explore the process underlying the classifications themselves for example by finding out which variables are important or by gaining an insight sec. general issues into the structure of the classification process then neural nets k-nearest neighbour and are unlikely to be much use. no matter what procedure is actually used it is often best to prune radically by keeping only two or three significant terms in a regression or by using trees of depth two or using only a small number of rules in the hope that the important structure is retained. less important structures can be added on later as greater accuracy is required. it should also be borne in mind that in exploratory work it is common to include anything at all that might conceivably be relevant and that often the first task is to weed out the irrelevant information before the task of exploring structure can begin. special features if a particular application has some special features such as missing values hierarchical structure in the attributes ordered classes presence of known subgroups within classes of classes etc. etc. this extra structure can be used in the classification process to improve performance and to improve understanding. also it is crucial to understand if the class values are in any sense random variables or outcomes of a chance experiment as this alters radically the approach that should be adopted. the procrustean approach of forcing all datasets into a common format as we have done in the trials of this book for comparative purposes is not recommended in general. the general rule is to use all the available external information and not to throw it away. from classification to knowledge organisation and synthesis in chapter it was stressed that machine learning classifiers should possess a mental fit to the data so that the learned concepts are meaningful to and evaluable by humans. on this criterion the neural net algorithms are relatively opaque whereas most of the statistical methods which do not have mental fit can at least determine which of the attributes are important. however the specific black-box use of methods would never take place and it is worth looking forwards more speculatively to ai uses of classification methods. for example kardio s comprehensive treatise on ecg interpretation et al. does not contain a single rule of human authorship. seen in this light it becomes clear that classification and discrimination are not narrow fields within statistics or machine learning but that the art of classification can generate substantial contributions to organise improve human knowledge even as in kardio to manufacture new knowledge. another context in which knowledge derived from humans and data is synthesised is in the area of bayesian expert systems et al. in which subjective judgments of model structure and conditional probabilities are formally combined with likelihoods derived from data by bayes theorem this provides a way for a system to smoothly adapt a model from being initially expert-based towards one derived from data. however this representation of knowledge by causal nets is necessarily rather restricted because it does demand an exhaustive specification of the full joint distribution. however such systems form a complete model of a process and are intended for more than simply classification. indeed they provide a unified structure for many complex stochastic problems with connections to image processing dynamic modelling and so on. knowledge representation claude sammut university of new south wales introduction in bruner goodnow and austin published their book a study of thinking which became a landmark in psychology and would later have a major impact on machine learning. the experiments reported by bruner goodnow and austin were directed towards understanding a human s ability to categorise and how categories are learned. we begin with what seems a paradox. the world of experience of any normal man is composed of a tremendous array of discriminably different objects events people impressions...but were we to utilise fully our capacity for registering the differences in things and to respond to each event encountered as unique we would soon be overwhelmed by the complexity of our environment... the resolution of this seeming paradox is achieved by man s capacity to categorise. to categorise is to render discriminably different things equivalent to group objects and events and people around us into classes... the process of categorizing involves an act of invention... if we have learned the class house as a concept new exemplars can be readily recognised. the category becomes a tool for further use. the learning and utilisation of categories represents one of the most elementary and general forms of cognition by which man adjusts to his environment. the first question that they had to deal with was that of representation what is a concept? they assumed that objects and events could be described by a set of attributes and were concerned with how inferences could be drawn from attributes to class membership. categories were considered to be of three types conjunctive disjunctive and relational. one learns to categorise a subset of events in a certain way one is doing more than simply learning to recognise instances encountered. one is also learning a rule that may be applied to new instances. the concept or category is basically this rule of grouping and it is such rules that one constructs in forming and attaining concepts. address for correspondence school of computer science and engineeringartificialintelligence laboratory university of new south wales po box kensigton nsw australia sec. learning measurement and representation the notion of a rule as an abstract representation of a concept in the human mind came to be questioned by psychologists and there is still no good theory to explain how we store concepts. however the same questions about the nature of representation arise in machine learning for the choice of representation heavily determines the nature of a learning algorithm. thus one critical point of comparison among machine learning algorithms is the method of knowledge representation employed. in this chapter we will discuss various methods of representation and compare them according to their power to express complex concepts and the effects of representation on the time and space costs of learning. and some input learning measurement and representation a learning program is one that is capable of improving its performance through experience. a normal program would yield the same result given a program j after every application. however a learning program can alter its initial state p so that its performance is modified with each application. thus we can say j given the initial state the that is goal of learning is to construct a new initial so that the program alters its behaviour to give a more accurate or quicker result. thus one way of thinking about what a learning program does is that it builds an increasingly accurate approximation to a mapping from input to output. is the result of applying program to input the most common learning task is that of acquiring a function which maps objects that share common properties to the same class value. this is the categorisation problem to which bruner goodnow and austin referred and much of our discussion will be concerned with categorisation. learning experience may be in the form of examples from a trainer or the results of trial and error. in either case the program must be able to represent its observations of the world and it must also be able to represent hypotheses about the patterns it may find in those observations. thus we will often refer to the observation language and the hypothesis language. the observation language describes the inputs and outputs of the program and the hypothesis language describes the internal state of the learning program which corresponds to its theory of the concepts or patterns that exist in the data. the input to a learning program consists of descriptions of objects from the universe and in the case of supervised learning an output value associated with the example. the universe can be an abstract one such as the set of all natural numbers or the universe may be a subset of the real-world. no matter which method of representation we choose descriptions of objects in the real world must ultimately rely on measurements of some properties of those objects. these may be physical properties such as size weight colour etc or they may be defined for objects for example the length of time a person has been employed for the purpose of approving a loan. the accuracy and reliability of a learned concept depends heavily on the accuracy and reliability of the measurements. a program is limited in the concepts that it can learn by the representational capabilities of both observation and hypothesis languages. for example if an attributevalue list is used to represent examples for an induction program the measurement of certain attributes and not others clearly places bounds on the kinds of patterns that the learner can find. the learner is said to be biased by its observation language. the hypothesis language also places knowledge representation constraints on what may and may not be learned. for example in the language of attributes and values relationships between objects are difficult to represent. whereas a more expressive language such as first order logic can easily be used to describe relationships. unfortunately representational power comes at a price. learning can be viewed as a search through the space of all sentences in a language for a sentence that best describes the data. the richer the language the larger the search space. when the search space is small it is possible to use brute force search methods. if the search space is very large additional knowledge is required to reduce the search. we will divide our attention among three different classes of machine learning algo rithms that use distinctly different approaches to the problem of representation instance-based learning algorithms learn concepts by storing prototypic instances of the concept and do not construct abstract representations at all. function approximation algorithms include connectionist and statistics methods. these algorithms are most closely related to traditional mathematical notions of approximation and interpolation and represent concepts as mathematical formulae. symbolic learning algorithms learn concepts by constructing a symbolic which describes a class of objects. we will consider algorithms that work with representations equivalent to propositional logic and first-order logic. prototypes the simplest form of learning is memorisation. when an object is observed or the solution to a problem is found it is stored in memory for future use. memory can be thought of as a look up table. when a new problem is encountered memory is searched to find if the same problem has been solved before. if an exact match for the search is required learning is slow and consumes very large amounts of memory. however approximate matching allows a degree of generalisation that both speeds learning and saves memory. for example if we are shown an object and we want to know if it is a chair then we compare the description of this new object with descriptions of typical chairs that we have encountered before. if the description of the new object is close to the description of one of the stored instances then we may call it a chair. obviously we must defined what we mean by typical and close to better understand the issues involved in learning prototypes we will briefly describe three experiments in instance-based learning by aha kibler albert ibl learns to classify objects by being shown examples of objects described by an attributevalue list along with the class to which each example belongs. experiment in the first experiment to learn a concept simply required the program to store every example. when an unclassified object was presented for classification by the program it used a simple euclidean distance measure to determine the nearest neighbour of the object and the class given to it was the class of the neighbour. this simple scheme works well and is tolerant to some noise in the data. its major disadvantage is that it requires a large amount of storage capacity. sec. experiment prototypes the second experiment attempted to improve the space performance of in this case when new instances of classes were presented to the program the program attempted to classify them. instances that were correctly classified were ignored and only incorrectly classified instances were stored to become part of the concept. while this scheme reduced storage dramatically it was less noise-tolerant than the first. experiment the third experiment used a more sophisticated method for evaluating instances to decide if they should be kept or not. is similar to with the following additions. maintains a record of the number of correct and incorrect classification attempts for each saved instance. this record summarised an instance s classification performance. uses a significance test to determine which instances are good classifiers and which ones are believed to be noisy. the latter are discarded from the concept description. this method strengthens noise tolerance while keeping storage requirements down. discussion fig. the extension of an ibl concept is shown in solid lines. the dashed lines represent the target concept. a sample of positive and negative examples is shown. adapted from aha kibler and albert knowledge representation is strongly related to the neighbour methods described in section here is the main contribution of aha kibler and albert is the attempt to achieve satisfactory accuracy while using less storage. the algorithms presented in chapter assumed that all training data are available. whereas and examine methods for forgetting instances that do not improve classification accuracy. figure shows the boundaries of an imaginary concept in a two dimensions space. the dashed lines represent the boundaries of the target concept. the learning procedure attempts to approximate these boundaries by nearest neighbour matches. note that the boundaries defined by the matching procedure are quite irregular. this can have its advantages when the target concept does not have a regular shape. learning by remembering typical examples of a concept has several other advantages. if an efficient indexing mechanism can be devised to find near matches this representation can be very fast as a classifier since it reduces to a table look up. it does not require any sophisticated reasoning system and is very flexible. as we shall see later representations that rely on abstractions of concepts can run into trouble with what appear to be simple concepts. for example an abstract representation of a chair may consist of a description of the number legs the height etc. however exceptions abound since anything that can be sat on can be thought of as a chair. thus abstractions must often be augmented by lists of exceptions. instance-based representation does not suffer from this problem since it only consists exceptions and is designed to handle them efficiently. one of the major disadvantages of this style of representation is that it is necessary to define a similarity metric for objects in the universe. this can often be difficult to do when the objects are quite complex. another disadvantage is that the representation is not human readable. in the previous section we made the distinction between an language of observation and a hypothesis language. when learning using prototypes the language of observation may be an attributevalue representation. the hypothesis language is simply a set of attributevalue or feature vectors representing the prototypes. while examples are often a useful means of communicating ideas a very large set of examples can easily swamp the reader with unnecessary detail and fails to emphasis important features of a class. thus a collection of typical instances may not convey much insight into the concept that has been learned. function approximation as we saw in chapters and statistical and connectionist approaches to machine learning are related to function approximation methods in mathematics. for the purposes of illustration let us assume that the learning task is one of classification. that is we wish to find ways of grouping objects in a universe. in figure we have a universe of objects that belong to either of two classes or by function approximationwe describe a surface that separates the objects into different regions. the simplest function is that of a line and linear regression methods and perceptrons are used to find linear discriminant functions. section described the perceptron pattern classifier. given a binary input vector x a weight vector w and a threshold value if g sec. function approximation fig. a linear discrimination between two classes. then the output is indicating membership of a class otherwise it is indicating exclusion from the class. clearly w x describes a hyperplane and the goal of perceptron learning is to find a weight vector w that results in correct classification for all training examples. the perceptron is an example of a linear threshold unit a single ltu can only recognise one kind of pattern provided that the input space is linearly separable. if we wish to recognise more than one pattern several ltu s can be combined. in this case instead of having a vector of weights we have an array. the output will now be a vector m jq on where each element of u indicates membership of a class and each row in w is the set of weights for one ltu. this architecture is called a pattern associator. ltu s can only produce linear discriminant functions and consequently they are limited in the kinds of classes that can be learned. however it was found that by cascading pattern associators it is possible to approximate decision surfaces that are of a higher order than simple hyperplanes. in cascaded system the outputs of one pattern associator are fed into the inputs of another thus to facilitate learning a further modification must be made. rather than using a simple threshold as in the perceptron multi-layer networks usually use a non-linear threshold such as a sigmoid function. like perceptron learning back-propagation attempts to reduce the errors between the output of the network and the desired result. despite the non-linear threshold multi-layer networks can still be thought of as describing a complex collection of hyperplanes that approximate the required decision surface. knowledge representation x fig. a pole balancer. discussion function approximation methods can often produce quite accurate classifiers because they are capable of constructing complex decision surfaces. the observation language for algorithms of this class is usually a vector of numbers. often preprocessing will convert raw data into a suitable form. for example pomerleau accepts raw data from a camera mounted on a moving vehicle and selects portions of the image to process for input to a neural net that learns how to steer the vehicle. the knowledge acquired by such a system is stored as weights in a matrix. therefore the hypothesis language is usually an array of real numbers. thus the results of learning are not easily available for inspection by a human reader. moreover the design of a network usually requires informed guesswork on the part of the user in order to obtain satisfactory results. although some effort has been devoted to extracting meaning from networks the still communicate little about the data. connectionist learning algorithms are still computationally expensive. a critical factor in their speed is the encoding of the inputs to the network. this is also critical to genetic algorithms and we will illustrate that problem in the next section. genetic algorithms genetic algorithms perform a search for the solution to a problem by generating candidate solutions from the space of all solutions and testing the performance of the candidates. the search method is based on ideas from genetics and the size of the search space is determined by the representation of the domain. an understanding of genetic algorithms will be aided by an example. a very common problem in adaptive control is learning to balance a pole that is hinged on a cart that can move in one dimension along a track of fixed length as show in figure the control must use bang-bang control that is a force of fixed magnitude can be applied to push the cart to the left or right. before we can begin to learn how to control this system it is necessary to represent it somehow. we will use the boxes method that was devised by michie chambers q sec. genetic algorithms x x. q q fig. discretisation of pole balancer state space. and its velocity. rather than treat the four variables as continuous values michie and chambers chose to discretise each dimension of the state space. one possible discretisation is shown in figure the measurements taken of the physical system are the angle of the pole and its angular velocity and the position of the cart this discretisation results in boxes that partition the state space. h boxes there are each box has associated with it an action setting which tells the controller that when the system is in that part of the state space the controller should apply that action which is a push to the left or a push to the right. since there is a simple binary choice and there are possible control strategies for the pole balancer. the simplest kind of learning in this case is to exhaustively search for the right combination. however this is clearly impractical given the size of the search space. instead we can invoke a genetic search strategy that will reduce the amount of search considerably. in genetic learning we assume that there is a population of individuals each one of which represents a candidate problem solver for a given task. like evolution genetic algorithms test each individual from the population and only the fittest survive to reproduce for the next generation. the algorithm creates new generations until at least one individual is found that can solve the problem adequately. each problem solver is a chromosome. a position or set of positions in a chromosome is called a gene. the possible values a fixed set of symbols of a gene are known as alleles. in most genetic algorithm implementations the set of symbols is chromosome lengths are fixed. most implementations also use fixed population sizes. the most critical problem in applying a genetic algorithm is in finding a suitable encoding of the examples in the problem domain to a chromosome. a good choice of representation will make the search easy by limiting the search space a poor choice will result in a large search space. for our pole balancing example we will use a very simple encoding. a chromosome is a string of boxes. each box or gene can take values push left or push right. choosing the size of the population can be tricky since a small population size provides an insufficient sample size over the space of solutions for a problem and large population requires a lot of evaluation and will be slow. in this example is a suitable population size. and knowledge representation each iteration in a genetic algorithm is called a generation. each chromosome in a population is used to solve a problem. its performance is evaluated and the chromosome is given some rating of fitness. the population is also given an overall fitness rating based on the performance of its members. the fitness value indicates how close a chromosome or population is to the required solution. for pole balancing the fitness value of a chromosome may be the number of time steps that the chromosome is able to keep the pole balanced for. new sets of chromosomes are produced from one generation to the next. reproduction takes place when selected chromosomes from one generation are recombined with others to form chromosomes for the next generation. the new ones are called offspring. selection of chromosomes for reproduction is based on their fitness values. the average fitness of population may also be calculated at end of each generation. for pole balancing individuals whose fitness is below average are replaced by reproduction of above average chromosomes. the strategy must be modified if two few or two many chromosomes survive. for example at least and at most must survive. operators that recombine the selected chromosomes are called genetic operators. two common operators are crossover and mutation. crossover exchanges portions of a pair of chromosomesat a randomly chosen point called the crossover point. some implementations and have more than one crossover point. for example if there are two chromosomesk and the crossover point is the resulting offspring are offspring produced by crossover cannot contain information that is not already in the population so an additional operatormutation is required. mutation generates an offspring by randomly changing the values of genes at one or more gene positions of a selected chromosome. for example if the following chromosome h k is mutated at positions and then the resulting offspring is the number of offspring produced for each new generation depends on how members are introduced so as to maintain a fixed population size. in a pure replacement strategy the whole population is replaced by a new one. in an elitist strategy a proportion of the population survives to the next generation. in pole balancing all offspring are created by crossover when more the will survive for more than three generations when the rate is reduced to only being produced by crossover. mutation is a background operator which helps to sustain exploration. each offspring produced by crossover has a probability of of being mutated before it enters the population. if more then will survive the mutation rate is increased to the number of offspring an individual can produce by crossover is proportional to its fitness o d j o sec. propositional learning systems v_small small medium large v_large red orange yellow green blue violet fig. discrimination on attributes and values. where the number of children is the total number of individuals to be replaced. mates are chosen at random among the survivors. the pole balancing experiments described above were conducted by odetayo this may not be the only way of encoding the problem for a genetic algorithm and so other solutions may be possible. however this requires effort on the part of the user to devise a clever encoding. propositional learning systems rather than searching for discriminant functions symbolic learning systems find expressions equivalent to sentences in some form of logic. for example we may distinguish objects according to two attributes size and colour. we may say that an object belongs to class if its colour is red and its size is very small to medium. following the notation of michalski the classes in figure may be written as c k v d z d v j v note that this kind of description partitions the universe into blocks unlike the function approximation methods that find smooth surfaces to discriminate classes. interestingly one of the popular early machine learning algorithms aq had its origins in switching theory. one of the concerns of switching theory is to find ways of minimising logic circuits that is simplifying the truth table description of the function of a circuit to a simple expression in boolean logic. many of the algorithms in switching theory take tables like figure and search for the best way of covering all of the entries in the table. aq uses a covering algorithm to build its concept description ed e knowledge representation f v d? fig. decision tree learning. v n the best expression is usually some compromise between the desire to cover as many positive examples as possible and the desire to have as compact and readable a representation as possible. in designing aq michalski was particularly concerned with the expressiveness of the concept description language. a drawback of the aq learning algorithm is that it does not use statistical information present in the training sample to guide induction. however decision tree learning algorithms do. the basic method of building a decision tree is summarised in figure an simple attributevalue representation is used and so like aq decision trees are incapable of representing relational information. they are however very quick and easy to build. f and create a decision node. the algorithm operates over a set of training instances if all instances in create a node are in class partition the traning instances in into subsets according to the values apply the algorithm recursively to each if the subsets of of f. and stop. otherwise select a feature e sec. propositional learning systems fig. the dashed line shows the real division of objects in the universe. the solid lines show a decision tree approximation. decision tree learning algorithms can be seen as methods for partitioning the universe into successively smaller rectangles with the goal that each rectangle only contains objects of one class. this is illustrated in figure discussion michalski has always argued in favour of rule-based representations over tree structured representations on the grounds of readability. when the domain is complex decision trees can become very bushy and difficult to understand whereas rules tend to be modular and can be read in isolation of the rest of the knowledge-base constructed by induction. on the other hand decision trees induction programs are usually very fast. a compromise is to use decision tree induction to build an initial tree and then derive rules from the tree thus transforming an efficient but opaque representation into a transparent one it is instructive to compare the shapes that are produced by various learning systems when they partition the universe. figure demonstrates one weakness of decision tree and other symbolic classification. since they approximate partitions with rectangles the universe is there is an inherent inaccuracy when dealing with domains with continuous attributes. function approximation methods and ibl may be able to attain higher accuracy but at the expense of transparency of the resulting theory. it is more difficult to make general comments about genetic algorithms since the encoding method knowledge representation fig. generalisation as set covering. will affect both accuracy and readability. as we have seen useful insights into induction can be gained by visualising it as searching for a cover of objects in the universe. unfortunately there are limits to this geometric interpretation of learning. if we wish to learn concepts that describe complex objects and relationships between the objects it becomes very difficult to visualise the universe. for this reason it is often useful to rely on reasoning about the concept description language. as we saw the cover in figure can be expressed as clauses in propositional logic. we can establish a correspondence between sentences in the concept description language hypothesis language and a diagrammatic representation of the concept. more importantly we can create a correspondence between generalisation and specialisation operations on the sets of objects and generalisation and specialisation operations on the sentences of the language. for example figure shows two sets labelled class and class it is clear that class is a generalisation of class since it includes a larger number of objects in the universe. we also call class a specialisation of class by convention we say the description of class is a generalisation of the description of class thus is a generalisation of c c k once we have established the correspondence between sets of objects and their descriptions it is often convenient to forget about the objects and only consider that we are working with expressions in a language. the reason is simple. beyond a certain point of complexity it is not possible to visualise sets but it is relatively easy to apply simple transformations on sentences in a formal language. for example clause can be generalised very easily to clause by dropping one of the conditions. sec. relations and background knowledge in the next section we will look at learning algorithms that deal with relational information. in this case the emphasis on language is essential since geometric interpretations no longer provide us with any real insight into the operation of these algorithms. relations and background knowledge inductions systems as we have seen so far might be described as what you see is what you get that is the output class descriptions use the same vocabulary as the input examples. however we will see in this section that it is often useful to incorporate background knowledge into learning. we use a simple example from banerji to the use of background knowledge. there is a language for describing instances of a concept and another for describing concepts. suppose we wish to represent the binary number by a left-recursive binary tree of digits and head and tail are the names of attributes. their values follow the colon. the concepts of binary digit and binary number are defined as v d vd d j j z c d j j z d n thus an object belongs to a particular class or concept if it satisfies the logical expression in the body of the description. predicates in the expression may test the membership of an object in a previously learned concept. banerji always emphasised the importance of a description language that could grow that is its descriptive power should increase as new concepts are learned. this can clearly be seen in the example above. having learned to describe binary digits the concept of digit becomes available for use in the description of more complex concepts such as binary number. and an instance extensibility is a natural and easily implemented feature of horn-clause logic. in addition a description in horn-clause logic is a logic program and can be executed. for example to recognise an object a horn clause can be interpreted in a forward chaining manner. suppose we have a set of clauses clause recognises the first two terms in expression reducing it to v clause reduces this to that is clauses and recognise expression as the description of an instance of concept when clauses are executed in a backward chaining manner they can either verify that the input object belongs to a concept or produce instances of concepts. in other words knowledge representation largerhammer feather. denserhammer feather. heaviera b densera b largera b. heavierhammer feather. heaviera b densera b largera b. heavierhammer feather. denserhammer feather. largerhammer feather. denser hammer feather larger hammer feather largerhammer feather. fig. a resolution proof tree from muggleton feng we attempt to prove an assertion is true with respect to a background theory. resolution provides an efficient means of deriving a solution to a problem giving a set of axioms which define the task environment. the algorithm takes two terms and resolves them into a most general unifier as illustrated in figure by the execution of a simple prolog program. the box in the figure contains clauses that make up the theory or knowledge base and the question to be answered namely is it true that a hammer is heavier than a feather a resolution proof is a proof by refutation. that is answer the question we assume that it is false and then see if the addition to the theory of this negative statement results in a contradiction. the literals on the left hand side of a prolog clause are positive. those on the left hand side are negative. the proof procedure looks for complimentary literals in two clauses n and i.e. literals of opposite sign that unify. in the example in figure x k unify to create the first resolvent o k xo k a side effect of unification is to create variable substitutions by continued application of resolution we can eventually derive the empty clause which indicates a contradiction. plotkin s work originated with a suggestion of r.j. popplestone that since unification is useful in automatic deduction by the resolution method its dual might prove helpful for induction. the dual of the most general unifier of two literals is called the least general generalisation at about the same time that plotkin took up this idea j.c. reynolds was also developing the use of least general generalisations. reynolds also recognised the connection between deductive theorem proving and inductive learning sec. relations and background knowledge robinson s unification algorithm allows the computation of the greatest common instance of any finite set of unifiable atomic formulas. this suggests the existence of a dual operation of least common generalisation it turns out that such an operation exists and can be computed by a simple algorithm. such that the least general generalisation of background information which may assist generalisation. suppose we are given two instances of a concept cuddly pet buntine pointed out that simple subsumption is unable to take advantage of if there is a substitution the method of least general generalisations is based on subsumption. a clause subsumes or is more general than another clause jq x o jl n xo n jl xkvn under the substitution is equivalent to and under the substitution is equivalent to therefore the least general generalisation of jq x and is jl xkvn and results in the inverse substitution jl n xo n o d jqkvn o d jqkvn jqkvn jqkvn jqkvn o d jqkvn o d jqkvn jlkvn since unmatched literals are dropped from the clause. however given the background knowledge we can see that this is an over-generalisation. a better one is the moral being that a generalisation should only be done when the relevant background knowledge suggests it. so observing use clause as a rewrite rule to produce a generalisation which is clause which also subsumes clause buntine drew on earlier work by sammut banerji in constructing his generalised subsumption. muggleton buntine took this approach a step further and realised that through the application of a few simple rules they could invert resolution as plotkin and reynolds had wished. here are two of the rewrite rules in propositional form given a set of clauses the body of one of which is completely contained in the bodies according to subsumption the least general generalisation of and is suppose we also know the following o jlkvn of the others such as z k knowledge representation the absorption operation results in intra-construction takes a group of rules all having the same head such as and replaces them with z z z c these two operations can be interpreted in terms of the proof tree shown in figure resolution accepts two clauses and applies unification to find the maximal common unifier. in the diagram two clauses at the top of a v are resolved to produce the resolvent at the apex of the v absorption accepts the resolvent and one of the other two clauses to produce the third. thus it inverts the resolution step. intra-construction automatically creates a new term in its attempt to simplify descriptions. this is an essential feature of inverse resolution since there may be terms in a theory that are not explicitly shown in an example and may have to be invented by the learning program. discussion these methods and others feng quinlan have made relational learning quite efficient. because the language of horn-clause logic is more expressive than the other concept description languages we have seen it is now possible to learn far more complex concepts than was previously possible. a particularly important application of this style of learning is knowledge discovery. there are now vast databases accumulating information on the genetic structure of human beings aircraft accidents company inventories pharmaceuticals and countless more. powerful induction programs that use expressive languages may be a vital aid in discovering useful patterns in all these data. for example the realities of drug design require descriptive powers that encompass stereo-spatial and other long-range relations between different parts of a molecule and can generate in effect new theories. the pharmaceutical industry spends over million for each new drug released onto the market. the greater part of this expenditure reflects today s unavoidably scatter-gun synthesis of compounds which might possess biological activity. even a limited capability to construct predictive theories from data promises high returns. the relational program golem was applied to the drug design problem of modelling structure-activity relations et al. training data for the program was trimethoprim analogues and their observed inhibition of e. coli dihydrofolate reductase. a further compounds were used as unseen test data. golem obtained rules that were statistically more accurate on the training data and also better on the test data than a hansch linear regression model. importantly relational learning yields understandable rules k k k k sec. conclusion that characterise the stereochemistry of the interaction of trimethoprim with dihydrofolate reductase observed crystallographically. in this domain relational learning thus offers a new approach which complements other methods directing the time-consuming process of the design of potent pharmacological agents from a lead compound variants of which need to be characterised for likely biological activity before committing resources to their synthesis. conclusions we have now completed a rapid tour of a variety of learning algorithms and seen how the method of representing knowledge is crucial in the following ways knowledge representation determines the concepts that an algorithm can and cannot learn. knowledge representation affects the speed of learning. some representations lend themselves to more efficient implementation than others. also the more expressive the language the larger is the search space. knowledge representation determines the readability of the concept description. a representation that is opaque to the user may allow the program to learn but a representation that is transparent also allows the user to learn. thus when approaching a machine learning problem the choice of knowledge representation formalism is just as important as the choice of learning algorithm. learning to control dynamic systems tanja urban ci c and ivan bratko jo zef stefan institute and and university of ljubljana introduction the emphasis in controller design has shifted from the precision requirements towards the following objectivesleitch francis enterline verbruggen and astr om astr om sammut michie control without complete prior knowledge extend the range of automatic control applications reliability robustness and adaptivity provide successful performance in the realworld environment transparency of solutions enable understanding and verification generality facilitate the transfer of solutions to similar problems realisation of specified characteristics of system response please customers. these problems are tackled in different ways for example by using expert systems neural networks et al. hunt et al. fuzzy control and genetic algorithms nordvik however in the absence of a complete review and comparative evaluations the decision about how to solve a problem at hand remains a difficult task and is often taken ad hoc. leitch has introduced a step towards a systematisation that could provide some guidelines. however most of the approaches provide only partial fulfilment of the objectives stated above. taking into account also increasing complexity of modern systems together with real-time requirements one must agree with schoppers that designing control means looking for a suitable compromise. it should be tailored to the particular problem specifications since some objectives are normally achieved at the cost of some others. another important research theme is concerned with the replication of human operators subconscious skill. experienced operators manage to control systems that are extremely difficult to be modelled and controlled by classical methods. therefore a natural choice would be to mimic such skilful operators. one way of doing this is by modelling the address for correspondence jo zef stefan institute univerza v lubljani ljubljana slovenia sec. introduction operator s strategy in the form of rules. the main problem is how to establish the appropriate set of rules while gaining skill people often lose their awareness of what they are actually doing. their knowledge is implicit meaning that it can be demonstrated and observed but hardly ever described explicitly in a way needed for the direct transfer into an automatic controller. although the problem is general it is particularly tough in the case of control of fast dynamic systems where subconscious actions are more or less the prevailing form of performance. dynamic system learning system control rule partial knowledge dynamic system learning system control rule operator dynamic system learning system control rule fig. three modes of learning to control a dynamic system exploiting partial knowledge extracting human operator s skill. learning from scratch the aim of this chapter is to show how the methods of machine learning can help in the construction of controllers and in bridging the gap between the subcognitive skill and its machine implementation. first successful attempts in learning control treated the controlled system as a black box example michie chambers and a program learnt to control it by trials. due to the black box assumption initial control decisions are practically random resulting in very poor performance in the first experiments. on the basis of experimental evidence control decisions are evaluated and possibly changed. learning takes place until a certain success criterion is met. later on this basic idea was implemented in different ways ranging from neural networks example barto learning to control dynamic systems et al. anderson to genetic algorithms example odetayo mcgregor recently the research concentrated on removing the deficiencies inherent to these methods like the obscurity and unreliability of the learned control rules sammut michie sammut cribb and time-consuming experimentation while still presuming no prior knowledge. until recently this kind of learning control has remained predominant. however some of the mentioned deficiences are closely related to the black box assumption which is hardly ever necessary in such a strict form. therefore the latest attempts take advantage of the existing knowledge being explicit and formulated at the symbolic level example urban ci c bratko bratko var sek et al. or implicit and observable just as operator s skill et al. sammut et al. camacho michie michie camacho the structure of the chapter follows this introductory discussion. we consider three modes of learning to control a system. the three modes illustrated in figure are the learning system learns to control a dynamic system by trial and error without any prior knowledge about the system to be controlled from scratch. as in but the learning system exploits some partial explicit knowledge about the dynamic system. the learning system observes a human operator and learns to replicate the operator s skill. experiments in learning to control are popularly carried out using the task of controlling the pole-and-cart system. in section we therefore describe this experimental domain. sections and describe two approaches to learning from scratch boxes and genetic learning. in section the learning system exploits partial explicit knowledge. in section the learning system exploits the operator s skill. experimental domain the main ideas presented in this chapter will be illustrated by using the pole balancing problem miller as a case study. so let us start with a description of this control task which has often been chosen to demonstrate both classical and nonconventional control techniques. besides being an attractive benchmark it also bears similarities with tasks of significant practical importance such as two-legged walking and satellite attitude control michie the system consists of a rigid pole and a cart. the cart can move left and right on a bounded track. the pole is hinged to the top of the cart so that it can swing in the vertical plane. in the ai literature the task is usually just to prevent the pole from falling and to keep the cart position within the specified limits while the control regime is that of bang-bang. the control force has a fixed magnitude and all the controller can do is to change the force direction in regular time intervals. classical methods example kwakernaak sivan can be applied to controlling the system under several assumptions including complete knowledge about the system that is a differential equations model up to numerical values of its parameters. alternative approaches tend to weaken these assumptions by constructing control rules in two essentially different ways by learning from experience and by qualitative reasoning. the first one will be presented in more detail later in this chapter. the second one will be described here only up to the level needed for comparison and understanding giving a general idea about two solutions of this kind sec. experimental domain critical critical critical critical left left left left critical critical critical critical right right right right fig. makarovi c s rule for pole balancing. a solution distinguished by its simplicity was derived by makarovi c figure rules of the same tree structure but with the state variables ordered in different ways were experimentally studied by d zeroski he showed that no less than seven permutations of state variables yielded successful control rules. we is a permutation of the variables determining their top-down order. another solution was inferred by bratko from a very simple qualitative model of the inverted pendulum system. the derived control rule is described by the following denote such rules as where relations ref goal ref goal goal ref and where values required for successful control and goal ref denote reference values to be reached ref goal and goal denote goal denotes a monotonically increasing learning to control dynamic systems be simplified and normalised resulting in function passing through the point- when the system is to be controlled under the bang-bang regime control action. is determined by the sign of force assuming without loss of generality equations can where if and ref sign are numerical parameters. both makarovi c s and bratko s rule successfully control the inverted pendulum provided the appropriate values of the numerical parameters are chosen. moreover there exists a set of parameter values that makes bratko s rule equivalent to the bang-bang variant of a classical control rule using the sign of pole-placement controller output zeroski then. else. learning to control from scratch boxes in learning approaches trials are performed in order to gain experimental evidence about different control decisions. a trial starts with the system positioned in an initial state chosen from a specified region and lasts until failure occurs or successful control is performed for a prescribed maximal period of time. failure occurs when the cart position or pole inclination exceeds the given boundaries. the duration of a trial is called survival time. learning is carried out by performing trials repeatedly until a certain success criterion is met. typically this criterion requires successful control within a trial to exceed a prescribed period of time. initial control decisions are usually random. on the basis of experimental evidence they are evaluated and possibly changed thus improving control quality. this basic idea has been implemented in many different ways for example in boxes chambers adaptive critic reinforcement method et al. cart utgoff multilayer connectionist approach and many others. geva and sitte provide an exhaustive review. here two methods will be described in more detail boxes chambers and genetic learning of control sek et al. the choice of methods presented here is subjective. it was guided by our aim to describe recent efforts in changing or upgrading the original ideas. we chose boxes because it introduced a learning scheme that was inspirational to much further work. boxes the boxes program chambers learns a state-action table i.e. a set of rules that specify action to be applied to the system in a given state. of course this would not be possible for the original infinite state space. therefore the state space is divided into boxes a box is defined as the cartesian product of the values of the system variables where all the values belong to an interval from a predefined partition. a typical giving boxes. all the points within a box are mapped to the same control decision. during one trial the state-action table is fixed. when a failure is detected a trial ends. decisions are evaluated with respect to the accumulated numeric information partition of the four dimensional state space into boxes distinguish values of of and of of sec. learning to control from scratch boxes how many times the system entered a particular state how successful it was after particular decisions etc. the following information is accumulated for each box left life weighted sum of survival times after left decision was taken in this state right life the same for the right decision left usage weighted sum of the number of left decisions taken in this state during previous trials during previous trials ded fgd dih fh trial. the program chooses the action with the higher estimate to be applied in the box during the performance of boxes is generally described by the number of trials needed for first achieving step survival. figures vary considerably from paper to paper and are between sitte and although interesting these figures are not sufficient to validate the learning results. reliability robustness and characteristics of the controller performance are important as well and are discussed in many papers devoted to boxes. times steps at which the system enters this state during the current after a trial the program updates these figures. for the states in which decision left was taken the new values are right usage the same for right decisions where the meaning of the parameters is as follows number of entries into the state during the run dlder-sut dzhr-sut fgder sut fhr sut dldnmpoq dzhmpoq fgdnmo_q mpoq fh sut constant that weighs recent experience relative to earlier experience for the whole systemb global life andb mpo_q der sut each trialb mo_q ofbg ced dih ci fh analogous updates are made for the states with decision right is constant that weighs global experience relative to local experience. deh dlh finishing time of the trial. dld fgd wheret the next trial. these values are used for a numeric evaluation of the success for both actions. the estimates are computed after a trial for each qualitative state suta global usage are computed after j j k v j j y d h d b j y b h b t b h t g t b h t learning to control dynamic systems variablesded action lifetimedih refinements of boxes sammut describes some recent refinements of the basic michie-chambers learning scheme. the central mechanism of learning in boxes is the decision rule based on the experience of each box. the experience for each individual box is accumulated in the for the right action. the michie-chambers rule determines the decision between left and right action depending on these variables. the rule is designed so that it combines two possibly conflicting interests exploitation and exploration. the first is to perform the action that in the past produced the best results is maximum lifetime and the second is to explore the alternatives. the alternatives may in the future turn out in fact to be superior to what appears to be best at present. action usagefgd andfh the original michie-chambers formulas find a particular compromise between these two interests. the compromise can be adjusted by varying the parameters in the formulas. sammut describes a series of modifications of the original michie-chambers rule. the following elegant rule after law sammut experimentally performed the best in terms of learning rate and stability of learning fdlh-fhn dedeh dihn if an action has not been tested then choose that action is a user defined parameter that adjusts the relative importance of exploitation and is this corresponds to pure exploitation the system s mentality changes towards experimentalist. then the system is willing to experiment with actions that from past experience look inferior. else ifdedeh-dzhn else iffdlh-fhn exploration. the lowest reasonable value fort without any desire to explore the untested. by increasingt a suitable compromise fort pole-and-cart problem it was experimentally found thatt rate is relatively stable for values oft whereas the law sammut rule needed trials in trying to test the stability of the law sammut rule it was found thatt was slightly but not significantly is needed for overall good performance. for the classical is optimal. the learning between and and it degrades rapidly when decreases below or increases above the following improvement of the law sammut rule with respect to the michie chambers rule was reported on the average over experiments the original boxes needed trials to learn to control the system sensitive to small changes in the learning problem such as changing the number of boxes from to or introducing asymmetry in the force push twice the right push. else choose an action at random then choose left then choose right geva and sitte carried out exhaustive experiments concerning the same topic. with the appropriate parameter setting the boxes method performed as well as the adaptive critic reinforcement learning et al. they got an average of trials out of learning experiments deviation was learning to control from scratch genetic learning genetic algorithms are loosely based on darwinian principles of evolution reproduction genetic recombination and the survival of the fittest goldberg they maintain a set of candidate solutions called a population. candidate solutions t o t sec. learning to control from scratch genetic learning are usually represented as binary coded strings of fixed length. the initial population is generated at random. what happens during cycles called generations is as follows. each member of the population is evaluated using a fitness function. after that the population undergoes reproduction. parents are chosen stochastically but strings with a higher value of fitness function have higher probability of contributing an offspring. genetic operators such as crossover and mutation are applied to parents to produce offspring. a subset of the population is replaced by the offspring and the process continues on this new generation. through recombination and selection the evolution converges to highly fit population members representing near-optimal solutions to the considered problem. when controllers are to be built without having an accurate mathematical model of the system to be controlled two problems arise first how to establish the structure of the controller and second how to choose numerical values for the controller parameters. in the following we present a three-stage framework proposed by var sek et al. cq ieee. first control rules represented as tables are obtained without prior knowledge about the system to be controlled. next if-then rules are synthesized by structuring information encoded in the tables yielding comprehensible control knowledge. this control knowledge has adequate structure but it may be non-operational because of inadequate settings of its numerical parameters. control knowledge is finally made operational by fine-tuning numerical parameters that are part of this knowledge. the same fine-tuning mechanism can also be applied when available partial domain knowledge suffices to determine the structure of a control rule in advance. in this approach the control learning process is considered to be an instance of a combinatorial optimisation problem. in contrast to the previously described learning approach in boxes where the goal is to maximise survival time here the goal is to maximise survival time and simultaneously to minimise the discrepancy between the desired and actual system behaviour. this criterion is embodied in a cost function called the raw fitness function used to evaluate candidate control rules during the learning process. y max mw is calculated as follows raw fitnessrtsvup max is the normalised survival timez is the normalised error wherex trials performed to evaluate a candidate solutiony is the survival time in the trial y max is the maximal duration of a trial and is the cumulative error of the trial. after completing the learning process solutions were thoroughly evaluated by performing trials with maximal duration of a trial set to steps corresponding to over hours of simulated time. note that the maximal duration of a trial most frequently found in the ai literature is seconds. is the number of r x y x y k v w y z k v w y v y learning to control dynamic systems phase obtaining control without prior knowledge and during this phase boxes-like decision rules were learned. for each of the pole-cart variables each decision rule is then represented as a four-dimensional array where each the domain is partitioned into three labelled entry represents a control action. in addition two partitioning thresholds are required for each system variable. candidate solutions comprising a decision rule along with the corresponding thresholds are represented as binary strings. to calculate a fitness value for each individual trials were carried out with the maximal duration of a trial set to steps. populations of size were observed for generations. the experiment was repeated ten times. on average after about generations individualsrepresenting rules better than makarovi c s phase inducing rule structure discovered. rule were action positive or negative control force. the obtained rules are very close in form to makarovi c s rule. from the rules shown to automatically synthesize comprehensible rules obtained during phase an inductive learning technique was employed. a derivative of the algorithm niblett named ginesys pc c gams was used to compress the ga-induced boxes-like rules into the if-then form. the learning domain for the compression phase was described in terms of four attributes and the class. the attribute values were interval and the class represented the corresponding labels for the pole-cart variables by d zeroski to successfully control the pole-cart system rules and were discovered automatically. the performance of the compressed rules decreased with respect to the original ga-induced boxes-like rules due to inaccurate interpretation of the interval labels. as in the case of table the failure rate of the compressed rule indicates that this rule was never able to balance the system for steps. since the defining thresholds were learned during phase to perform well with the original ga-induced rules these thresholds should be adapted to suit the new compressed rules. and phase fine-tuning by optimizing control performance in phase the interpretation of symbolic values i.e. and left unchanged throughout the optimisation process. interval labels appearing in the found in phase was adjusted to maximise the control quality. for this purpose a ga was employed again. this time each chromosome qualitative rule represented four binary coded thresholds while the rule structure was set to to calculate a fitness value for each individual only trials were carried out with maximal duration of a trial set to steps. populations of size were evolved for generations. after generations individuals representing rules better than those obtained during phase were generated. through the extensive evaluation the fine-tuned rules were shown reliable results in table additional experiments were carried out. the robustness of learning from scratch was robustness and adaptation tested by performing the experiment twice first with force s n n and sec. exploiting partial explicit knowledge table cq ieee control performance of ga-induced boxes-like rule compressed rule and the original makarovi c s rule fine-tuned rule failures avg. survival rule time ga-based compressed fine-tuned makarovi c s fitness performing two further fine-tuning experiments. second with asymmetrical force n the possibility of adaptation of s n obtained for symmetrical force s the qualitative rule n n and the new conditions n was examined by n n s table cq ieee control performance of ga-induced boxes-like rules for n and rule n s fine-tuned for n s n table shows the performance of four rules obtained in these experiments. it can be seen that gas can successfully learn to control the pole-cart system also under modified conditions. s n and n and failures avg. survival n n s s n to rule time fitness to summarise successful and comprehensible control rules were synthesized automatically in three phases. here a remark should be made about the number of performed trials. in this research it was very high due to the following reasons. first the emphasis was put on the reliability of learned rules and this of course demands much more experimentation in order to ensure good performance on a wide range of initial states. in our recent experiments with a more narrow range of initial states the number of trials was considerably reduced without affecting the reliability. second the performance of the rules after the first phase was practically the same as that of the rules after the third phase. maybe the same controller structure could be obtained in the second phase from less perfect rules. however it is difficult to know when the learned evidence suffices. to conclude the exhaustiveness of these experiments was conciously accepted by the authors in order to show that reliable rules can be learned from scratch. exploiting partial explicit knowledge boxes with partial knowledge to see how adding domain knowledge affects speed and results of learning three series of experiments were done by urban ci c bratko the following variants of learning control rules with program boxes were explored learning to control dynamic systems a. without domain knowledge b. with partial domain knowledge considered as definitely correct and c. with partial initial domain knowledge allowed to be changed during learning. the following rule served as partial domain knowledge if else if d then action right d then action left although the rule alone is not effective at all survival was steps it considerably decreased the number of trials needed for achieving survival time steps at the same time the reliability the percentage of trials with the learned state-action table surviving more than simulation steps increased from to more detailed description of the experiments is available in urban ci c bratko table experimental results showing the influence of partial knowledge. version length of learning av. reliability av. survival num. of trials a. b. c. exploiting domain knowledge in genetic learning of control domain knowledge can be exploited to bypass the costly process of learning a control rule from scratch. instead of searching for both the structure of a rule and the values of numerical parameters required by the rule we can start with a known rule structure derived by bratko from a qualitative model of pole and cart. then we employ a ga to tune the parameters and appearing in the rule. to calculate a fitness value of an individual trials were carried out with maximal duration of a trial set to steps corresponding to seconds of simulated time. populations of size were evolved for generations. the ga was run times. in all the runs the parameter settings that ensured maximal survival of the system for all initial states were found. table gives the best three obtained parameter settings along with their fitness values. n the parameter tuning and evaluation procedures were repeated identically for two modified versions of the pole-cart system one being controlled with symmetrical force sv problems were found no harder for the ga than the n and the other with asymmetrical force s n it can be noted that in this case the genetic algorithm is applied just to tune a controller with known structure. in a similar way other types of controllers can be tuned for example the classical pid controller ci c et al. s n n case. n the exploiting operator s skill learning to pilot a plane sammut et al. and michie sammut describe experiments in extracting by machine learning the pilot s subcognitive component of the skill of flying a plane. in i g i g sec. table cq ieee control performance of bratko s control rule with parameter values found by a ga and with parameter values that make the rule equivalent to the bang-bang variant of the classical control rule. exploiting operator s skill parameters failures avg. survival parameters time fitness failures avg. survival time fitness these experiments a simulator of the cessna airplane was used. human pilots were asked to fly the simulated plane according to a well defined flight plan. this plan consisted of seven stages including manouevres like take off flying to a specified point turning lining up with the runway descending to the runway and landing. the pilots control actions during flight were recorded as events each event record consisted of the plane s state variables and the control action. the values of state variables belonging to an event were actually taken a little earlier than the pilot s action. the reason for this was that the action was assumed to be the pilot s response with some delay to the current state of the plane variables. sammut et al. stated that it remains debatable what a really appropriate delay is between the state of the plane variables and control action invoked by that state the action was performed some time later in response to the stimulus. but how do we know what the stimulus was? unfortunately there is no way of knowing. the plane s state variables included elevation elevation speed azimuth azimuth speed airspeed etc. the possible control actions affected four control variables rollers elevator thrust and flaps. the problem was decomposed into four induction problems one for each of the four control variables. these four learning problems were assumed independent. the control rules were induced by the induction program the total data set consisted of events collected from three pilots and flights by each pilot. the data was segmented into seven stages of the complete flight plan and separate rules were induced for each stage. separate control rules were induced for each of the three pilots. it was decided that it was best not to mix the data corresponding to different individuals because different pilots carry out their manouevres in different styles. there was a technical difficulty in using in that it requires discrete class values whereas in the flight problem the control variables are mostly continuous. the continuous ranges therefore had to be converted to discrete classes by segmentation into intervals. this segmentation was done manually. a more natural learning tool for this induction task would therefore be one that allows continuous class such as the techniques of learning regression trees implemented in the programs cart et al. and retis c sammut et al. state that control rules for a complete flight were successfully synthesized resulting in an inductively constructed autopilot. this autopilot flies the cessna learning to control dynamic systems in a manner very similar to that of the human pilot whose data was used to construct the rules. in some cases the autopilot flies more smoothly than the pilot. we have observed a clean-up effect noted in michie bain and hayes-michie the flight log of any trainer will contain many spurious actions due to human inconsistency and corrections required as a result of inattention. it appears that effects of these examples are pruned away by leaving a control rule which flies very smoothly. it is interesting to note the comments of sammut et al. regarding the contents of the induced rules one of the limitations we have encountered with existing learning algorithms is that they can only use the primitive attributes supplied in the data. this results in control rules that cannot be understood by a human expert. the rules constructed by are purely reactive. they make decisions on the basis of the values in a single step of simulation. the induction program has no concept of time and causality. in connection with this some strange rules can turn up. learning to control container cranes the world market requires container cranes with as high capacity as possible. one way to meet this requirement is to build bigger and faster cranes however this approach is limited by construction problems as well as by unpleasant feelings drivers have when moving with high speeds and accelerations. the other solution is to make the best of the cranes of reasonable size meaning in the first place the optimisation of the working cycle and efficient swing damping. it is known that experienced crane drivers can perform very quickly as long as everything goes as expected while each subsequent correction considerably affects the time needed for accomplishing the task. also it is very difficult to drive for hours and hours with the same attention not to mention the years of training needed to gain required skill. consequently interest for cooperation has been reported by chief designer of metalna machine builders steel fabricators and erectors maribor which is known world-wide for its large-scale container cranes. they are aware of insufficiency of classical automatic controllers example sakawa shinido which can be easily disturbed in the presence of wind or other unpredictable factors. this explains their interest in what can be offered by alternative methods. impressive results have been obtained by predictive fuzzy control yasunobu hasegawa their method involves steps such as describing human operator strategies defining the meaning of linguistic performance indices defining the models for predicting operation results and converting the linguistic human operator strategies into predictive fuzzy control rules. in general these tasks can be very time consuming so our focus of attention was on the automated synthesis of control rules directly from the recorded performance of welltrained operators. in this idea we are following the work of michie et al. sammut et al. and michie camacho who confirmed the findings of sammut et using the acm public-domain simulation of an combat plane. when al. trying to solve the crane control problem in a manner similar to their autopilot construction sec. exploiting operator s skill we encountered some difficulties which are to be investigated more systematically if the method is to become general. to transport a container from shore to a target position on a ship two operations are to be performed positioning of the trolley bringing it above the target load position and rope operation bringing the load to the desired height. the performance requirements are as follows basic safety obstacles must be avoided swinging must be kept within prescribed limits stop-gap accuracy the gap between the final load position and the target position must be within prescribed limits high capacity time needed for transportation is to be minimised. the last requirement forces the two operations to be performed simultaneously. the task parameters specifying stop-gap accuracy swinging limits and capacity are given by the customer and vary from case to case. is specified by six variables instead of a real crane a simulator was used in our experiments. the state of the system trolley position and its velocity and rope inclination angle and its angular velocity and rope length and the length velocity and forces are applied direction of the rope. dk is applied to the trolley in the horizontal direction and time is measured in steps. at each step the state of the system is measured and two control in the is the force in the vertical direction. the next state is computed using runge-kutta numerical simulation of fourth order taking into account the dynamic equations of the system. parameters of the system heights masses etc. are the same as those of the real container cranes in port of koper. simulation runs on ibm pc compatible computers and is real-time for mhz or faster with a mathematical co-processor. when experimenting with the simulator one can choose input mode record play or auto output mode picture or instruments where one strike at the step. similarly arrows and in the record mode the values of the current control forces are read from the keyboard for a certain predefined or means a decrease or increase ofn indicate the change of d a file containing all control actions together with the corresponding times and system states is recorded. in the play mode recorded experiments can be viewed again using the recorded files as input. when auto mode is chosen the current values of control forces are determined by a procedure representing an automatic controller. the choice of the output mode enables the graphical representation of the scene picture or the variant where the six state variables and the force values are presented as columns with dynamically changing height imitating measuring instruments. six students volunteered in an experiment where they were asked to learn to control the crane simulator simply by playing with the simulator and trying various control strategies. d learning to control dynamic systems they were given just the instrument version in fact they didn t know which dynamic system underlied the simulator. in spite of that they succeeded to learn the task although the differences in time needed for this as well as the quality of control were remarkable. to learn to control the crane reasonably well it took a subject between about and trials. this amounts to about to hours of real time spent with the simulator. our aim was to build automatic controllers from human operators traces. we applied retis a program for regression tree construction c to the recorded data. the first problem to solve was how to choose an appropriate set of learning examples out of this enormous set of recorded data. after some initial experiments we found as in sammut et al. that it was beneficial to use different trials performed by the same student since it was practically impossible to find trials perfect in all aspects even among the successful cases. in the preparation of learning data performance was sampled each second. the actions were related to the states with delay which was also second. the performance of the best autodriver induced in these initial experiments can be seen in figure it resulted from learning examples for and examples for d the control strategy it uses is rather conservative minimising the swinging but at the cost of time. in further experiments we will try to build an autodriver which will successfully cope with load swinging resulting in faster and more robust performance. diffx times g e d m e c n a t s d i n k e c r o f l o r t n o c times fx fig. the crane simulator response to the control actions of the autodriver. these experiments indicate that further work is needed regarding the following questions what is the actual delay between the system s state and the operator s action robustness of induced rules with respect to initial states comprehensibility of induced control rules inducing higher level conceptual description of control strategies. conclusions conclusions in this chapter we have treated the problem of controlling a dynamic system mainly as a classification problem. we introduced three modes of learning to control depending on the information available to the learner. this information included in addition to the usual examples of the behaviour of the controlled system also explicit symbolic knowledge about the controlled system and example actions performed by a skilled human operator. one point that the described experiments emphasise is the importance of incomplete partial knowledge about the controlled system. methods described in this chapter enable natural use of partial symbolic knowledge. although incomplete this knowledge may drastically constrain the search for control rules thereby eliminating in advance large numbers of totally unreasonable rules. our choice of the approaches to learning to control in this chapter was subjective. among a large number of known approaches we chose for more detailed presentation those that first we had personal experimental experience with and second that enable the use of partial symbolic prior knowledge. in all the approaches described there was an aspiration to generate comprehensible control rules sometimes at the cost of an additional learning stage. an interesting theme also described is behavioural cloning where a human s behavioural skill is cloned by a learned rule. behavioural cloning is interesting both from the practical and the research points of view. much further work is needed before behavioural cloning may become routinely applicable in practice. behavioural cloning is essentially the regression of the operator s decision function from examples of hisher decisions. it is relevant in this respect to notice a similarity between this and traditional top-down derivation of control from a detailed model of the system to be controlled. this similarity is illustrated by the fact that such a top-down approach for the pole-and-cart system gives the known linear control rule which looks just like regression equation. as stated in the introduction there are several criteria for and goals of learning to control and several assumptions regarding the problem. as shown by the experience with various learning approaches it is important to clarify very precisely what these goals and assumptions really are in the present problem. correct statement of these may considerably affect the efficiency of the learning process. for example it is important to consider whether some symbolic knowledge exists about the domain and not to assume automatically that it is necessary or best to learn everything from scratch. in some approaches reviewed such incomplete prior knowledge could also result from a previous stage of learning when another learning technique was employed. acknowledgements this work was supported by the ministry of science and technology of slovenia. the authors would like to thank donald michie for comments and suggestions. appendices a dataset availability the public domain datasets are listed below with an anonymous ftp address. if you do not have access to these then you can obtain the datasets on diskette from dr. p. b. brazdil university of porto laboratory of ai and computer science r. campo alegre porto potugal. the main source of datasets is ics.uci.edu the uci repository of machine learning databases and domain theories which is managed by d. w. aha. the following datasets many others are in pubmachine-learningdatabases australian credit statlogaustralian diabetes dna heart disease statlogheart letter recognition image segmentation shuttle control landsat satellite image vehicle recognition the datasets were often processed and the processed form can be found in the statlog subdirectory where mentioned above. in addition the processed datasets used in this book can also be obtained from ftp.strath.ac.uk in directory stamsstatlog. these datasets are australiandiabetesdnagermanheartlettersatimage segmentshuttleshuttle and there are associated files as well as a split into train and test set used in the statlog project for the larger datasets. b software sources and details many of the classical statistical algorithms are available in standard statistical packages. here we list some public domain versions and sources and some commercial packages. if a simple rule has been adopted for parameter selection then we have also described this. b. software sources and details is a fortran program available from j. hermans dept. of medical statistics niels bohrweg ca leiden university of leiden the netherlands. smart is a collection of fortran subroutines developed by j. h. friedman dept. of statistics sequoia hall stanford university stanford ca usa. castle can be obtained from r. molina dept of computer science and a.i. faculty of science university of granada. spain. indcart bayes tree and naive bayes. are part of the ind package which is available from w. buntine nasa ames research center ms moffett field ca usa. p e x l and is available from f. wysotzki fraunhofer-institute kurstrasse berlin germany. for the number of clusters has to be fixed by the user with some systematic experimentation. all other parameters are determined by the algorithm. for the confidence level for estimation and the threshold for tree pruning were optimised either by hand or a special c shell. an entropy measure to choose the best discrimination attribute at each current node was used. logistic discriminants quadratic discrminants and logistic discriminants are fortran programs available from r. j. henery department of statistics and modelling science university of strathclyde glasgow uk. there are also available by anonymous ftp from ftp.strath.ac.uk in directory stamsstatlogprograms. is available from h. perdrix isoft chemin de moulon gif sur yvette france. the user must choose between evaluation functions e b e b i e e e in the reported results the fourth option was chosen. backprop cascade correlation and radial basis function are fortran programs available from r. rohwer department of computer science and applied mathematics aston university birmingham uk. the inputs for all datasets were normalised to zero mean and unit variance. the outputs problem was represented as an n-dimensional vector with all components equal to except the multilayer perceptron simulations were done with autonet on sun unix workstations. autonet is commercial software available from paul gregory recognition research church lane marple stockport uk were converted to a representation ie. the th class of an n-class classification the th which is e e e runs were made with of the runs was best. random number seed for each run was run number having picked the best net by cross validation within the training e t the settings were i e e learning to control dynamic systems set these nets were then used for supplying the performance figures on the whole training set and on the test set. the figures averaged for cross validation performance measures were also for the best nets found during local cross-validation within the individual training sets. training proceeds in four stages with different stages using different subsets of the training data larger each time. training proceeds until no improvement in error is achieved for a run of updates. the rrnn simulator provided the radial basis function code. this is freely available at the time of writing by anonymous ftp from uk.ac.aston.cs this package also contains mlp code using the conjugate gradient algorithm as does autonet and several other algorithms. reports on benchmark excercises are available for some of these mlp programs in rohwer the centres for the radial basis functions were selected randomly from the training data except that centres were allocated to each class in proportion to the number of representatives of that class in the dataset with at least one centre provided to each class in any case. each gaussian radius was set to the distance to the nearest neighboring centre. the linear system was solved by singular value decomposition. for the small datasets the number of centres and thier locations were selected by training with various numbers of centres using different random number seeds for each number and evaluating with a cross validation set withheld from the training data precisely as was done for the mlps. for the large datasets time constraints were met by compromising rigour in that the test set was used for the cross-validation set. results for these sets should therefore be viewed with some caution. this was the case for all data sets until those for which cross-validation was explicitly required diabetes german isoft segment were repeated with cross-validation to select the number of centres carried out within the training set only. the rough guideline followed for deciding on numbers of centres to try is that the number should be about times the dimension of the input space unless that would be more than of the size of the dataset. lvq is available from the laboratory of computer science and information science helsinki university of technology rakentajanaukio c sf espoo finland. it can also be obtained by anonymous ftp from cochlea.hut.fi cart is a licensed product of california statistical software inc. yorkshire court lafayette ca usa. is availbale from j.r. quinlan dept. of computer science madsen building university of sydney new south wales new south wales. the parameters used were the defaults. the heuristic was information gain. e p i e a e e b p l e however since the statlog project was completed there is a more recent version of so the results contained in this book may not be exactly reproducable. c. contributors for e newid and are available from robin boswell and tim niblett respectively at the turing institute george house north hanover street glasgow uk. for newid v e i p p i e b i p i e p e p i e e e u b k-nn is still under development. for all datasets except the satellite image dataset although the two belgian power datasets were run with the above parameters set to and kohonen was written by j. paul dhamstr. schmallenberg germany for a pc with an attached transputer board. itrule is available from prof. r. goodman california institute of technology electrical engineering mail code pasadena ca usa. for most of the datasets the parameters used were distance was scaled in a class dependent manner using the standard deviation. further details can be obtained from c. c. taylor department of statistics university of leeds leeds uk. e p c contributors this volume is based on the statlog project which involved many workers at over institutions. in this list we aim to include those who contributed to the project and the institutions at which they were primarily based at that time. g. nakhaeizadeh j. graf a. merkel h. keller laue h. ulrich g. kressel daimler benz ag r.j. henery d. michie j.m.o. mitchell a.i. sutherland r. king s. haque c. kay d. young w. buntine b. d. ripley university of strathclyde s.h. muggleton c. feng t. niblett r. boswell turing institute h. perdrix t. brunet t. marre j-j cannat isoft j. stender p. ristau d. picu i. chorbadjiev c. kennedy g. ruedke f. boehme s. schulze-kremer brainware gmbh p.b. brazdil j. gama l. torgo university of porto r. molina n. p erez de la blanca s. acid l. m. de campos gonzalez university of granada f. wysotzki w. mueller der buhlau schmelowski funke villman h. herzheim b. schulmeister fraunhofer institute learning to control dynamic systems t. bueckle c. ziegler m. surauer messerschmitt boelkow blohm j. paul p. von goldammer univeristy of l ubeck c.c. taylor x. feng university of leeds r. rohwer m. wynne-jones aston university d. spiegelhalter mrc cambridge references acid s. campos l. m. d. gonz alez a. molina r. and p erez de la blanca n. bayesian learning algorithms in castle. report no. university of granada. acid s. campos l. m. d. gonz alez a. molina r. and p erez de la blanca n. castle causal structures from inductive learning. release report no. university of granada. agresti a. categorical data analysis. wiley new york. aha d. generalising case studies a case study. in int. conf. on machine learning pages san mateo cal. morgan kaufmann. aha d. w. kibler d. and albert m. k. instance-based learning algorithms. machine learning preprints of the ifacifipimacs international symposium on artificial intelligence in real-time control. delft the netherlands pages. aitchison j. and aitken c. g. g. multivariate binary discrimination by the kernel method. biometrika al-attar a. structured decision tasks methodology. attar software ltd. new lands house newlands road leigh lancs. aleksander i. thomas w. v. and bowden p. a. wisard a radical step forward in image recognition. sensor review anderson c. w. strategy learning with multilayer connectionist representations. in lengley p. editor proceedings of the international workshop on machine learning pages morgan kaufmann. anderson c. w. and miller w. t. challenging control problems. in miller w. t. sutton r. s. and werbos p. j. editors neural networks for control pages the mit press. anderson j. a. regression and ordered categorical variables. j. r. statist. soc. b anderson t. w. an introduction to multivariate statistical analysis. john wiley new york. references andrews d. f. and herzberg a. m. data a collection of problems from many fields for the student and research worker. springer-verlag new york. arbab b. and michie d. generating expert rules from examples in prolog. in hayes j. e. michie d. and richards j. editors machine intelligence pages oxford university press oxford. ash t. dynamic node creation in back-propagation networks. ics report institute of cognitive science university of california san diego la jolla california usa. astr om k. j. intelligent control. in proceedings of the ecc european control conference pages grenoble. atlas l. connor j. and park d. et al.. a performance comparison of trained multi-layer perceptrons and trained classification trees. in systems man and cybernetics proceedings of the ieee international conference pages cambridge ma. hyatt regency. bain m. machine-learned rule-based control. in grimble m. mcghee j. and mowforth p. editors knowledge-based systems in industrial control pages stevenage. peter peregrinus. bain m. communication. learning logical exceptions in chess. phd thesis university of strathclyde glasgow. banerji r. b. artificial intelligence a theoretical approach. north holland new york. barto a. g. sutton r. s. and anderson c. w. neuronlike adaptive elements that can solve difficult learning control problems. ieee transactions on systems man and cybernetics begg c. b. and gray r. calculation of polychotomous logistic regression param eters using individualized regressions. biometrika bilbro g. and den bout d. v. maximum entropy and learning theory. neural computation bledsoe w. w. further results on the n-tuple pattern recognition method. ire trans. comp. bledsoe w. w. and browning i. pattern recognition and reading by machine. in proceedings of the eastern joint computer conference pages boston. blyth c. r. note on estimating information. annals of math. stats. bonelli p. and parodi a. an efficient classifier system and its experimental comparisons with two representative learning methods on three medical domains. in genetic algorithms proceedings of the fourth international conference pages san mateo ca. morgan kaufmann. booth t. h. stein j. a. hutchinson m. f. and nix h. a. identifying areas within a country climatically suitable for particular tree species an example using zimbabwe. international tree crops journal bourlard h. and wellekens c. j. links between markov models and multilayer perceptrons. ieee transactions on pattern analysis and machine intelligence bratko i. generating human-understandable decision rules. technical report ljubljana university slovenia. references bratko i. qualitative modelling learning and control. in proceedings of the czechoslovak conference on artificial intelligence. prague. bratko i. qualitative reasoning about control. in proceedings of the etfa conference. cairns australia. bratko i. mozetic i. and lavrac l. kardio a study in deep and qualitative knowledge for expert systems. mit press cambridge ma and london. breiman l. and friedman j. h. estimating optimal transformations for multiple regression and correlation discussion. journal of the american statistical association no. breiman l. friedman j. h. olshen r. a. and stone c. j. classification and regression trees. wadsworth and brooks monterey ca. breiman l. meisel w. and purcell e. variable kernel estimates of multivariate densities. technometrics bretzger t. m. die anwendung statistischer verfahren zur risikofruherkennung bei dispositionskrediten. phd thesis universitat hohenheim. broomhead d. s. and lowe d. multi-variable functional interpolation and adaptive networks. complex systems bruner j. s. goodnow j. j. and austin g. a. a study of thinking. wiley new york. buntine w. ind package of machine learning algorithms ind technical report ms research institute for advanced computer science nasa ames research center moffett field ca buntine w. generalized subsumption and its applications to induction and redun dancy. artificial intelligence buntine w. learning classification trees. statistics and computing camacho r. and michie d. an engineering model of subcognition. in proceedings of the issek workshop bled slovenia. carpenter b. e. and doran r. w. editors a. m. turing s ace report and other papers. mit press cambridge ma. carter c. and catlett j. assessing credit card applications using machine learning. ieee expert intelligent systems and their applications cestnik b. and bratko i. on estimating probabilities in tree pruning. in ewsl porto portugal berlin. springer-verlag. cestnik b. kononenko i. and bratko i. assistant a knowledge-elicitation tool for sophisticated users. in progress in machine learning proceedings of pages bled yugoslavia. sigma press. cherkaoui o. and cleroux r. comparative study of six discriminant analysis procedures for mixtures of variables. in proceedings of interface conference morgan kaufmann. clark l. a. and pregibon d. tree-based models. in chambers j. and hastie t. editors statistical models in s. wadsworth brooks pacific grove california. clark p. and boswell r. rule induction with some recent improvements. in ewsl porto portugal pages berlin. springer-verlag. references clark p. and niblett t. the induction algorithm. machine learning clarke w. r. lachenbruch p. a. and broffitt b. how nonnormality affects the quadratic discriminant function. comm. statist. theory meth. connell m. e. and utgoff p. e. learning to control a dynamic physical system. in proceedings of the national conference on artificial intelligence pages morgan kaufmann. cooper g. f. nestro a computer-based medical diagnostic that integrates causal and probabilistic knowledge. report no. stanford university stanford california. cooper g. f. and herkovsits e. a bayesian method for the induction of proba bilistic networks from data. technical report stanford university. cover t. m. geometrical and statistical properties of systems of linear inequalities with applications in pattern recognition. ieee transactions on electronic computers cox d. r. some procedures associated with the logistic qualitative response curve. in david f. n. editor research papers on statistics festschrift for j. neyman pages john wiley new york. crawford s. l. extensions to the cart algorithm. int. j. man-machine studies cutsem van t. wehenkel l. pavella m. heilbronn b. and goubin m. decision trees for detecting emergency voltage conditions. in second international workshop on bulk power system voltage phenomena voltage stability and security pages usa. mchenry. davies e. r. training sets and a priori probabilities with the nearest neighbour method of pattern recognition. pattern recognition letters day n. e. and kerridge d. f. a general maximum likelihood discriminant. biometrics devijver p. a. and kittler j. v. pattern recognition. a statistical approach. prentice hall englewood cliffs. djeroski s. cestnik b. and petrovski i. using the m-estimate in rule induction. j. computing and inf. technology dubes r. and jain a. k. clustering techniques the user s dilemma. pattern recognition duin r. p. w. on the choice of smoothing parameters for parzen estimators of probability density functions. ieee transactions on computers dvorak d. l. expert systems for monitoring and control. technical report technical report artificial intelligence laboratory the university of texas at austin. d zeroski s. control of inverted pendulum. b.sc. thesis faculty of electrical engineering and computer science university of ljubljana slovenian. efron b. estimating the error rate of a prediction rule improvements on cross validation. j. amer. stat. ass. references enas g. g. and choi s. c. choice of the smoothing parameter and efficiency of nearest neighbour classification. comput. math. applic. enterline l. l. strategic requirements for total facility automation. control engi the neering ersoy o. k. and hong d. parallel self-organizing hierarchical neural networks for vision and systems control. in kaynak o. editor intelligent motion control proceedings of the ieee international workshop new york. ieee. fahlman s. e. an empirical study of learning speed in back-propagation. tech nical report carnegie mellon university usa. fahlman s. e. faster learning variation on back-propagation an empirical study. in proccedings of the connectionist models summer school. morgan kaufmann. fahlman s. e. the cascade-correlation learning algorithm on the monk s problems. in thrun s. bala j. bloedorn e. and bratko i. editors the monk s problems a performance comparison of different learning algorithms pages carnegie mellon university computer science department. fahlman s. e. the recurrent cascade-correlation architecture. technical report carnegie mellon university. fahlman s. e. and lebiere c. the cascade correlation learning architecture. in tourzetsky d. s. editor advances in neural information processing systems pages morgan kaufmann. fahrmeir l. haussler w. and tutz g. diskriminanzanalyse. in fahrmeir l. and hamerle a. editors multivariate statistische verfahren. verlag de gruyter berlin. fienberg s. the analysis of cross-classified categorical data. mit press cam bridge mass. fisher d. h. and mckusick k. b. an empirical comparison of and backpropagation in ijcai pages san mateo ca. morgan kaufmann. fisher d. h. and mckusick k. b. et al.. processing issues in comparisons of symbolic and connectionist learning systems. in spatz b. editor proceedings of the sixth international workshop on machine learning cornell university ithaca new york pages san mateo ca. morgan kaufmann. fisher r. a. the use of multiple measurements in taxonomic problems. annals of eugenics fisher r. a. the statistical utilisation of multiple measurements. ann. eugen. fix e. and hodges j. l. discriminatory analysis nonparametric estimation consistency properties. report no. project no. uasf school of aviation medicine randolph field texas. frean m. short paths and small nets optimizing neural computation. phd thesis university of edinburgh uk. frean m. the upstart algorithm a method for constructing and training feed forward neural networks. neural computation frey p. w. and slate d. j. letter recognition using holland-style adaptive classifiers. machine learning references friedman j. regularized discriminant analysis. j. amer. statist. assoc. friedman j. h. smart user s guide. tech. report laboratory of computational statistics department of statistics stanford university. friedman j. h. multivariate adaptive regression splines discussion. annals of statistics friedman j. h. and stuetzle w. projection pursuit regression. j. amer. statist. assoc. fukunaga k. introduction to statistical pattern recognition. academic press edition. fukunaga k. and narendra p. m. a branch and bound algorithm for computing nearest neighbours. ieee trans. comput. networks. neural networks funahashi k. on the approximate realization of continuous mappings by neural fung r. m. and crawford s. l. constructor a system for the induction of probabilistic models. in proceedings eighth of the conference on artificial intelligence pages boston massachussetts. gallant s. i. the pocket algorithm for perceptron learning. technical report northeastern university college of computer science usa. gates g. w. the reduced nearest neighbour rule. ieee transactions on information theory geman s. neural networks and the biasvariance dilemma. neural computation geva s. and sitte j. boxes revisited. in proceedings of the icann amster dam. geva s. and sitte j. the cart-pole experiment as a benchmark for trainable controllers. submitted to ieee control systems magazine. gilbert e. s. the effect of unequal variance covariance matrices on fisher s linear discriminant function. biometrics glymour c. scheines r. spirtes p. and kelley k. discovering causal structures statistics and search. academic press new york. goldberg d. e. genetic algorithms in search optimization and machine learning. addison-wesley. good i. j. probability and the weighing of evidence. griffin london. goodman r. m. and smyth p. the induction of probabilistic rule sets the itrule algorithm. in spatz b. editor proceedings of the sixth international workshop on machine learning. pages san mateo ca. morgan kaufmann. gorman r. p. and sejnowski t. j. analysis of hidden units in a layered network trained to classify sonar targets. neural networks habbema j. d. f. hermans j. and van der burght a. t. cases of doubt in allocation problems. biometrika hampshire j. and pearlmuter b. equivalence proofs for the multilayer perceptron classifier and the bayes discriminant function. in proceedings of the connectionist models summer school san mateo ca. morgan kaufmann. references hand d. j. discrimination and classification. john wiley chichester. hand d. j. and batchelor b. g. an edited nearest neighbour rule. information sciences hanson s. j. meiosis networks. in tourzetsky d. s. editor advances in neural information processing systems pages morgan kaufmann. hart p. e. the condensed nearest neighbour rule. ieee transactions on information theory h aussler w. m. empirische ergebnisse zur diskriminationsverfahren bei kred itscoringsystemen. zeitschrift fur operations research. serie b h aussler w. m. methoden der punktebewertung fur kreditscoringsysteme. zeitschrift fur operations research h aussler w. m. punktebewertung bei kreditscoringsystemen. knapp frankfurt. hebb d. o. the organisation of behaviour. john wiley and sons. hecht-nielsen r. neurocomputing. addison-wesley reading mass. herkovsits e. and cooper g. f. kutat o an entropy-driven system for the construction of probabilistic expert systems from databases. report stanford university. hermans j. habbema j. d. f. kasanmoentalib t. k. d. and raatgeven j. w. manual for the discriminant analysis program. leiden the netherlands. hertz j. krogh a. and palmer r. introduction to the theory of neural compu tation. addison-wesley. higonnet r. a. and grea r. a. logical design of electrical circuits. mcgraw-hill book co. ltd. hill m. correspondence analysis. in encyclopaedia of statistical sciences vol ume pages wiley new york. hinton g. e. rumelhart d. e. and williams r. j. learning internal representations by back-propagating errors. in rumelhart d. e. mcclelland j. l. and the pdp research group editors parallel distributed processing explorations in the microstructure of cognition volume chapter mit press cambridge ma. hinton g. e. rumelhart d. e. and williams r. j. learning representatinos by back-propagating errors. nature hoehfeld m. and fahlman s. e. learning with limited precision using the cascadecorrelation algorithm. technical report carnegie mellon university. hofmann h. j. die anwendung des cart-verfahrens zur statistischen bonitatsanalyse von konsumentenkrediten. zeitschrift fur betriebswirtschaft h jsgaard s. skj th f. and thiesson b. user s guide to bifrost. aalborg university aalborg denmark. holland j. h. adaptation in natural and artificial systems. university of michigan press ann arbor michigan. holland j. h. adaptation in natural and artificial systems. university of michi gan press ann arbor mi. references huang h. h. zhang c. lee s. and wang h. p. implementation and comparison of neural network learning paradigms back propagation simulated annealing and tabu search. in dagli c. kumara s. and shin y. c. editors intelligent engineering systems through artificial neural networks proceedings of the artificial neural networks in engineering conference new york. american society of mechanical engineers. huang w. y. and lippmann r. p. comparisons between neural net and conventional classifiers. in proceedings of the ieee first international conference on neural networks pages piscataway nj. ieee. hunt e. b. concept learning an information processing problem. wiley. hunt e. b. martin j. and stone p. i. experiemnts in induction. academic press new york. hunt k. j. sbarbaro d. zbikovski r. and gawthrop p. j. neural networks for control systems a survey. automatica jacobs r. increased rates of convergence through learning rate adaptation. neural networks jennet b. teasdale g. braakman r. minderhoud j. heiden j. and kurzi t. prognosis of patients with severe head injury. neurosurgery jones d. s. elementary information theory. clarendon press oxford. karali c a. employing linear regression in regression tree leaves. in proceedings of the european conference on artificial intelligence pages wiley sons. wien austria. karali c a. and gams m. implementation of the gynesis pc inductive learning system. in proceedings of the etan conference pages novi sad slovenian. kass g. v. an exploratory technique for investigating large quantities of categorical data. appl. statist. kendall m. g. stuart a. and ord j. k. the advanced theory of statistics vol design and analysis and time series. chapter griffin london fourth edition. king r. d. lewis r. a. muggleton s. h. and sternberg m. j. e. drug design by machine learning the use of inductive logic programming to model the structure-activity relationship of trimethoprim analogues binding to dihydrofolate reductase. proceedings of the national academy science kirkwood c. andrews b. and mowforth p. automatic detection of gait events a case study using inductive learning techniques. journal of biomedical engineering knoll u. kostenoptimiertes prunen in entscheidungsbaumen. daimler-benz forschung und technik ulm. kohonen t. self-organization and associative memory. springer verlag berlin. kohonen t. self-organization and associative memory. springer-verlag berlin edition. kohonen t. barna g. and chrisley r. statistical pattern recognition with neural networks benchmarking studies. in ieee international conference on neural networks volume pages new york. diego ieee. references kononenko i. and bratko i. information-based evaluation criterion for classifier s performance. machine learning kressel u. the impact of the learning set size in handwritten digits recognition. in proceedings of the international conference on artifical neural networks helsinki finland. krishnaiah p. and kanal l. editors classification pattern recognition and reduction of dimensionality volume of handbook of statistics. north holland amsterdam. kwakernaak h. and sivan r. linear optimal control systems. john wiley. lachenbruch p. and mickey r. estimation of error rates in discriminant analysis. technometrics lachenbruch p. a. and mickey m. r. discriminant analysis. hafner press new york. lang k. j. waibel a. h. and hinton g. e. a time-delay neural network architecture for isolated word recognition. neural networks lauritzen s. l. and spiegelhalter d. j. local computations with probabilities on graphical structures and their application to expert systems discussion. j. royal statist. soc. series b lawrence e. c. and smith l. d. an analysis of default risk in mobile home credit. j. banking and finance le cun y. boser b. denker j. s. henderson d. howard r. e. hubbard w. and d. j. l. backpropagation applied to handwritten zip code recognition. neural computation lee c. fuzzy logic in control systems fuzzy logic controller part part ieee transactions on systems man and cybernetics leech w. j. a rule based process control method with feedback. advances in instrumentation leitch r. knowledge based control selecting the right tool for the job. in preprints of the ifacifipimacs international symposium on artificial intelligence in real-time control pages delft the netherlands. leitch r. r. and francis j. c. towards intelligent control systems. in mamdani a. and efstathiou j. editors expert systems and optimisation in process control pages aldershot england. gower technical press. luttrell s. p. derivation of a class of training algorithms. ieee transactions on neural networks luttrell s. p. a bayesian analysis of vector quantization algorithms. submitted to neural computation. machado s. g. two statistics for testing for multivariate normality. biometrika mackay d. the evidence framework applied to classification networks. neural computation mackay d. a practical bayesian framework for backpropagation networks. neural computation references makarovi c a. a qualitative way of solving the pole balancing problem. technical report memorandum university of twente. also in machine intelligence j.hayes d.michie e.tyugu oxford university press pp. mardia k. v. applications of some measures of multivariate skewness and kurtosis in testing normality and robustness studies. sankhya b mardia k. v. kent j. t. and bibby j. m. multivariate analysis. academic press london. marks s. and dunn o. j. discriminant functions when covariance matrices are unequal. j. amer. statist. assoc. mccarthy j. and hayes p. j. some philosophical problems from the standpoint of artificial intelligence. in meltzer b. and michie d. editors machine intelligence pages eup edinburgh. mccullagh p. and nelder j. a. generalized linear models. chapman and hall london edition. mcculloch w. s. and pitts w. a logical calculus of the ideas immanent in nervous activity forms. bulletin of methematical biophysics mclachlan g. j. discriminant analysis and statistical pattern recognition. john wiley new york. meyer-br otz g. and sch urmann j. methoden der automatischen zeichenerken nung. akademie-verlag berlin. m ezard m. and nadal j. p. learning in feed-forward layered networks the tiling algorithm. journal of physics a mathematics general m.g. kendall a. s. and ord j. the advanced theory of statistics vol distri bution theory. griffin london fourth edition. michalski r. s. on the quasi-minimal solution of the general covering problem. in proc. of the fifth internat. symp. on inform. processing pages bled slovenia. michalski r. s. discovering classification rules using variable valued logic system in third international joint conference on artificial intelligence pages michalski r. s. a theory and methodology of inductive learning. in r. s. michalski j. g. c. and mitchell t. m. editors machine learning an artificial intelligence approach. tioga palo alto. michalski r. s. and chilauski r. l. knowledge acquisition by encoding expert rules versus computer induction from examples a case study involving soybean pathology. int. j. man-machine studies michalski r. s. and larson j. b. selection of the most representative training examples and incremental generation of hypothesis the underlying methodology and the description of programs esel and technical report dept. of computer sciencence u. of illinois urbana. michie d. problems of computer-aided concept formation. in quinlan j. r. editor applications of expert systems volume pages addison-wesley london. michie d. personal models of rationality. j. statist. planning and inference references michie d. methodologies from machine learning in data analysis and software. computer journal michie d. and al attar a. use of sequential bayes with class probability trees. in hayes j. michie d. and tyugu e. editors machine intelligence pages oxford university press. michie d. and bain m. machine acquisition of concepts from sample data. in kopec d. and thompson r. b. editors artificial intelligence and intelligent tutoring systems pages ellis horwood ltd. chichester. michie d. bain m. and hayes-michie j. cognitive models from subcognitive skills. in grimble m. mcghee j. and mowforth p. editors knowledge-based systems in industrial control pages stevenage. peter peregrinus. michie d. and camacho r. building symbolic representations of intuitive realtime skills from performance data. to appear in machine intelligence and inductive learning vol. furukawa k. and muggleton s. h. new series of machine intelligence ed. in chief d. michie oxford oxford university press. michie d. and chambers r. a. boxes an experiment in adaptive control. in dale e. and michie d. editors machine intelligence oliver and boyd edinburgh. michie d. and chambers r. a. boxes an experiment in adaptive control. in dale e. and michie d. editors machine intelligence pages edinburgh university press. michie d. and sammut c. machine learning from real-time input-output behaviour. in proceedings of the international conference design to manufacture in modern industry pages miller w. t. sutton r. s. and werbos p. j. editors neural networks for control. the mit press. minsky m. c. and papert s. perceptrons. mit press cambridge ma usa. m ller m. a scaled conjugate gradient algorithm for fast supervised learning. neural networks mooney r. shavlik j. towell g. and gove a. an experimental comparison of symbolic and connectionist learning algorithms in ijcai proceedings of the eleventh international joint conference on artificial intelligence detroit mi pages san mateo ca. morgan kaufmann for international joint conferences on artificial intelligence. muggleton s. h. logic and learning turing s legacy. in muggleton s. h. and michie d. furukaw k. editors machine intelligence oxford university press oxford. muggleton s. h. bain m. hayes-michie j. e. and michie d. an experimental comparison of learning formalisms. in sixth internat. workshop on mach. learning pages san mateo ca. morgan kaufmann. muggleton s. h. and buntine w. machine invention of first-order predicates by inverting resolution. in r. s. michalski t. m. m. and carbonell j. g. editors proceedings of the fifth international machine. learning conference pages morgan kaufmann ann arbor michigan. references muggleton s. h. and feng c. efficient induction of logic programs. in first international conference on algorithmic learning theory pages tokyo japan. japanese society for artificial intellligence. neapolitan e. probabilistic reasoning in expert systems. john wiley. nowlan s. and hinton g. simplifying neural networks by soft weight-sharing. neural computation odetayo m. o. balancing a pole-cart system using genetic algorithms. master s thesis department of computer science university of strathclyde. odetayo m. o. and mcgregor d. r. genetic algorithm for inducing control rules for a dynamic system. in proceedings of the international conference on genetic algorithms pages morgan kaufmann. ozturk a. and romeu j. l. a new method for assessing multivariate normality with graphical applications. communications in statistics simulation pearce d. the induction of fault diagnosis systems from qualitative models. in proc. seventh nat. conf. on art. intell. pages st. paul minnesota. pearl j. probabilistic reasoning in intelligent systems networks of plausible inference. morgan kaufmann san mateo. piper j. and granum e. on fully automatic feature measurement for banded chromosome classification. cytometry plotkin g. d. a note on inductive generalization. in meltzer b. and michie d. editors machine intelligence pages edinburgh university press. poggio t. and girosi f. networks for approximation and learning. proceedings of the ieee pomerleau d. a. alvinn an autonomous land vehicle in a neural network. in touretzky d. s. editor advances in neural information processing systems. morgan kaufmann publishers san mateo ca. prager r. w. and fallside f. the modified kanerva model for automatic speech recognition. computer speech and language press w. h. flannery b. p. teukolsky s. a. and vettering w. t. numerical recipes in c the art of scientific computing. cambridge university press cambridge. quinlan j. r. induction of decision trees. machine learning quinlan j. r. generating production rules from decision trees. in international joint conference on artificial intelligence pages milan. quinlan j. r. generating production rules from decision trees. in proceedings of the tenth international joint conference on artificial intelligence pages morgan kaufmann san mateo ca. quinlan j. r. simplifying decision trees. int j man-machine studies quinlan j. r. learning logical definitions from relations. machine learning quinlan j. r. programs for machine learning. morgan kaufmann san mateo ca. quinlan j. r. compton p. j. horn k. a. and lazarus l. inductive knowledge acquisition a case study. in proceedings of the second australian conference on references applications of expert systems pages sydney. new south wales institute of technology. reaven g. m. and miller r. g. an attempt to define the nature of chemical diabetes using a multidimensional analysis. diabetologia refenes a. n. and vithlani s. constructive learning by specialisation. in proceed ings of the international conference on artificial neural networks helsinki finland. remme j. habbema j. d. f. and hermans j. a simulative comparison of linear quadratic and kernel discrimination. j. statist. comput. simul. renals s. and rohwer r. phoneme classification experiments using radial basis functions. in proceedings of the international joint conference on neural networks volume i pages washington dc. renders j. m. and nordvik j. p. genetic algorithms for process control a survey. in preprints of the ifacifipimacs international symposium on artificial intelligence in real-time control pages delft the netherlands. reynolds j. c. transformational systems and the algebraic structure of atomic formulas. in meltzer b. and michie d. editors machine intelligence pages edinburgh university press. ripley b. statistical aspects of neural networks. in barndorff-nielsen o. cox d. jensen j. and kendall w. editors chaos and networks statistical and probabilistic aspects. chapman and hall. robinson j. a. a machine oriented logic based on the resolution principle. journal of the acm rohwer r. description and training of neural network dynamics. in pasemann f. and doebner h. editors neurodynamics proceedings of the summer workshop clausthal germany. world scientific. rohwer r. neural networks for time-varying data. in murtagh f. editor neural networks for statistical and economic data pages statistical office of the european communities luxembourg. rohwer r. time trials on second-order and variable-learning-rate algorithms. in lippmann r. moody j. and touretzky d. editors advances in neural information processing systems volume pages san mateo ca. morgan kaufmann. rohwer r. a representation of representation applied to a discussion of variable binding. technical report dept. of computer science and applied maths. aston university. rohwer r. and cressy d. phoneme classification by boolean networks. in proceedings of the european conference on speech communication and technology pages paris. rohwer r. grant b. and limb p. r. towards a connectionist reasoning system. british telecom technology journal rohwer r. and renals s. training recurrent networks. in personnaz l. and dreyfus g. editors neural networks from models to applications pages i. d. s. e. t. paris. rosenblatt f. psychological review rosenblatt f. principles of neurodynamics. spartan books new york. references rumelhart d. e. hinton g. e. and j. w. r. learning internal representations by error propagation. in rumelhart d. e. and mcclelland j. l. editors parallel distributed processing volume pages mit press cambridge ma. sakawa y. and shinido y. optimal control of container crane. automatica sammut c. experimental results from an evaluation of algorithms that learn to control dynamic systems. in laird j. editor proceedings of the fifth international conference on machine learning. ann arbor michigan pages san mateo ca. morgan kaufmann. sammut c. recent progress with boxes. to appear in machine intelligence and inductive learning vol. furukawa k. and muggleton s. h. new series of machine intelligence ed. in chief d. michie oxford oxford university press. sammut c. and cribb j. is learning rate a good performance criterion of learning? in proceedings of the seventh international machine learning conference pages austin texas. morgan kaufmann. sammut c. hurst s. kedzier d. and michie d. learning to fly. in sleeman d. and edwards p. editors proceedings of the ninth international workshop on machine learning pages morgan kaufmann. sammut c. and michie d. controlling a black box simulation of a space craft. ai magazine sammut c. a. and banerji r. b. learning concepts by asking questions. in r. s. michalski j. c. and mitchell t. editors machine learning an artificial intelligence approach vol pages morgan kaufmann los altos california. sas statistical analysis system. sas institute inc. cary nc version edition. scalero r. and tepedelenlioglu n. a fast new algorithm for training feedforward neural networks. ieee transactions on signal processing schalkoff r. j. pattern recognotion statistical structural and neural ap proaches. wiley singapore. schoppers m. real-time knowledge-based control systems. communications of the acm schumann m. lehrbach t. and bahrs p. versuche zur kreditwurdigkeitsprognose mit kunstlichen neuronalen netzen. universitat gottingen. scott d. w. multivariate density estimation theory practice and visualization. john wiley new york. sethi i. k. and otten m. comparison between entropy net and decision tree classifiers. in proceedings of the international joint conference on neural networks pages ann arbor mi. ieee neural networks council. shadmehr r. and d argenio z. a comparison of a neural network based estimator and two statistical estimators in a sparse and noisy environment. in proceedings of the international joint conference on neural networks pages ann arbor mi. ieee neural networks council. shapiro a. d. structured induction in expert systems. addison wesley london. references shapiro a. d. and michie d. a self-commenting facility for inductively synthesized end-game expertise. in beal d. f. editor advances in computer chess pergamon oxford. shapiro a. d. and niblett t. automatic induction of classification rules for a chess endgame. in clarke m. r. b. editor advances in computer chess pergamon oxford. shastri l. and ajjangadde v. from simple associations to systematic reasoning a connectionist representation of rules variables and dynamic bindings using temporal synchrony. behavioral and brain sciences. to appear. shavlik j. mooney r. and towell g. symbolic and neural learning algorithms an experimental comparison. machine learning siebert j. p. vehicle recognition using rule based methods. turing institute. silva f. m. and almeida l. b. acceleration techniques for the backpropagation algorithm. in almeida l. b. and wellekens c. j. editors lecture notes in computer science neural networks pages springer-verlag berlin. silverman b. w. density estimation for statistics and data analysis. chapman and hall london. smith j. w. everhart j. e. dickson w. c. knowler w. c. and johannes r. s. using the adap learning algorithm to forecast the onset of diabetes mellitus. in proceedings of the symposium on computer applications and medical care pages ieee computer society press. smith p. l. curve fitting and modeling with splines using statistical variable selection techniques. technical report nasa langley research center hampton va. snedecor w. and cochran w. g. statistical methods edition. iowa state university press iowa u.s.a. spiegelhalter d. j. dawid a. p. lauritzen s. l. and cowell r. g. bayesian analysis in expert systems. statistical science spikovska l. and reid m. b. an empirical comparison of and honns for distortion invariant object recognition. in tools for artificial intelligence proceedings of the international ieee conference los alamitos ca. ieee computer society press. spirtes p. scheines r. glymour c. and meek c. tetradii tools for discovery. srinivisan v. and kim y. h. credit granting a comparative analysis of classifi cation procedures. the journal of finance statsci s-plus user s manual. technical report statsci europe oxford. u.k. stein von j. h. and ziegler w. the prognosis and surveillance of risks from commercial credit borrowers. journal of banking and finance stone m. cross-validatory choice and assessment of statistical predictions. j. roy. statist. soc. discussion. switzer p. extensions of linear discriminant analysis for statistical classification of remotely sensed satellite imagery. j. int. assoc. for mathematical geology references switzer p. some spatial statistics for the interpretation of satellite data. bull. int. stat. inst. thrun s. b. mitchell t. and cheng j. the monk s comparison of learning algorithms introduction and survey. in thrun s. bala j. bloedorn e. and bratko i. editors the monk s problems a performance comparison of different learning algorithms pages carnegie mellon university computer science department. titterington d. m. murray g. d. murray l. s. spiegelhalter d. j. skene a. m. habbema j. d. f. and gelpke g. j. comparison of discrimination techniques applied to a complex data set of head injured patients discussion. j. royal statist. soc. a nearest neighbour method the influence of data transformations and metrics. chemometrics intell. labor. syst. todeschini r. toolenaere t. supersab fast adaptive back propagation with good scaling prop erties. neural networks tsaptsinos d. mirzai a. and jervis b. comparison of machine learning paradigms in a classification task. in rzevski g. editor applications of artificial intelligence in engineering v proceedings of the fifth international conference berlin. springer-verlag. turing a. m. lecture to the london mathematical society on february in carpenter b. e. and doran r. w. editors a. m. turing s ace report and other papers. mit press cambridge ma. unger s. and wysotzki f. lernf ahige klassifizierungssysteme. akademie-verlag berlin. urban ci c t. and bratko i. knowledge acquisition for dynamic system control. in sou cek b. editor dynamic genetic and chaotic programming pages wiley sons. urban ci c t. juri ci c d. filipi c b. and bratko i. automated synthesis of control for non-linear dynamic systems. in preprints of the ifacifipimacs international symposium on artificial intelligence in real-time control pages delft the netherlands. var sek a. urban ci c t. and filipi c b. genetic algorithms in controller design and tuning. ieee transactions on systems man and cybernetics. verbruggen h. b. and astr om k. j. artificial intelligence and feedback control. in proceedings of the second ifac workshop on artificial intelligence in real-time control pages shenyang prc. wald a. sequential analysis. chapman hall london. wasserman p. d. neural computing theory and practice. van nostrand reinhold. watkins c. j. c. h. combining cross-validation and search. in bratko i. and lavrac n. editors progress in machine learning pages wimslow. sigma books. wehenkel l. pavella m. euxibie e. and heilbronn b. decision tree based transient stability assessment a case study. volume proceedings of ieeepes winter meeting columbus oh janfeb. pages paper wm pwrs. references weiss s. m. and kapouleas i. an empirical comparison of pattern recognition neural nets and machine learning classification methods in ijcai proceedings of the eleventh international joint conference on artificial intelligence detroit mi pages san mateo ca. morgan kaufmann. weiss s. m. and kulikowski c. a. computer systems that learn classification and prediction methods from statistics neural networks machine learning and expert systems. morgan kaufmann san mateo ca. werbos p. beyond regression new tools for prediction and analysis in the behavioural sciences. phd thesis harvard university. also printed as a report of the harvard mit cambridge project. whittaker j. graphical models in applied multivariate analysis. john wiley chichester. widrow b. generalization and information in networks of adaline neurons. in yovits j. and goldstein editors self-organizing systems washington. spartan books. wolpert d. h. a rigorous investigation of evidence and occam factors in bayesian reasoning. technical report the sante fe institute old pecos trail suite a sante fe nm usa. wu j. x. and chan c. a three layer adaptive network for pattern density estimation and classification. international journal of neural systems wynne-jones m. constructive algorithms and pruning improving the multi layer perceptron. in proceedings of imacs the world congress on computation and applied mathematics dublin volume pages wynne-jones m. node splitting a constructive algorithm for feed-forard neural networks. in moody j. e. hanson s. j. and lippmann r. p. editors advances in neural information processing systems pages morgan kaufmann. wynne-jones m. node splitting a constructive algorithm for feed-forward neural networks. neural computing and applications xu l. krzyzak a. and oja e. neural nets for dual subspace pattern recognition method. international journal of neural systems yang j. and honavar v. experiments with the cascade-correlation algorithm. technical report department of computer science iowa state university ames ia usa. yasunobu s. and hasegawa t. evaluation of an automatic container crane operation system based on predictive fuzzy control. control-theory and advanced technology index accuracy ace algorithms function approximation algorithms instance-based algorithms symbolic learning alternating conditional expectation analysis of results aocdl aq aq architectures assistant attribute coding attribute entropy attribute noise attribute reduction attribute types attribute vector attributes australian credit dataset background knowledge backprop bayes minimum cost rule bayes rule bayes rule bayes theorem bayes tree bayes tree bayes-tree bayesian evidence bayesian methods bayesian networks bayesian regularisation cascade correlation behavioural cloning belgian power i dataset belgian power ii dataset bias bifrost binary attributes binomial bootstrap boxes canonical correlation canonical discriminants canonical variates cart cascade cascade correlation castle categorical variables causal network causal networks chaid chernobyl chi-square test of independence choice of variables chromosome dataset class class definitions class entropy class probability tree class probability trees classes classical discrimination techniques classification classification rule classification definition cls clustering code vector coding of categories combination of attributes combinations of variables comparative trials complex comprehensibility concept concept learning concept learning system concept-recognisers condensed nearest neighbour conditional dependency conjugate gradient constructive algorithms constructive algorithms pruning container cranes index controller design corr abs correlation correspondence analysis cost datasets cost matrices cost matrix costs covariance covariance matrix cover covering algorithm credit datasets credit management dataset credit scoring cross validation cross-entropy dataset dataset dag acyclic graph data soybean dataset australian credit dataset belgian power i dataset belgian power ii dataset chromosomes dataset credit management dataset cut dataset diabetes dataset dna dataset german credit dataset dataset hand-written digits dataset head injury index dataset heart disease dataset image segmentation dataset karhunen-loeve digits dataset letter recognition dataset machine faults dataset satellite image dataset shuttle control dataset technical dataset technical dataset tsetse fly distribution dataset vehicle recognition dataset credit management dataset cut dataset karhunen-loeve digits dataset shuttle control dataset shuttle dataset characterisation dataset collection decision class decision problems decision trees default default rule density estimates density estimation diabetes dataset digits dataset directed acyclic graph discrim discrimination distance distribution-free methods dna dataset domain knowledge dominators ea ecg edited nearest neighbour en.attr entropy entropy estimation entropy of attributes entropy of classes epistemologically adequate equivalent number of attributes error rate error rate estimation evaluation assistant examples of classifiers expert systems extensions to linear discrimination features feed-forward networks feedforward network first order logic fisher s linear discriminant fract k fractk gaussian distribution general-to-specific generalised delta rule generalised linear models genetic genetic algorithms genetic algorithms german credit gini function gini index glim golem golem gradient descent gradient descent mlp gradient descent second-order gradient methods head dataset head injury dataset heart dataset heuristically adequate hidden nodes hierarchical clustering hierarchical structure hierarchy human brain hypothesis language ilp image datasets image segmentation impure impure node impurity ind package ind package indcart indicator variables inductive learning inductive logic programming inductive logic programming inductive logic programming information measures information score information theory instatnce-based learning iris data irrelevant attributes isoft dataset itrule j-measure index jackknife joint entropy k nearest neighbour k-means clustering k-means clustering k-nearest neighbour k-nearest neighbour k-nearest neighbour k-nn k-nn cross validation k-r-k problem kalman filter kardio kernel classifier kernel window width kernel density kernel density estimation kernel function kernels kl digits dataset kohonen kohonen networks kohonen self-organising net kullback-leibler information kurtosis layer hidden layer input layer output learning curves learning graphical representations learning vector quantization learning vector quantizer learning vector quantizers leave-one-out letters dataset likelihood ratio linear decision tree index linear discriminant linear discrimination linear independent linear regression linear threshold unit linear transformation linear trees linesearches link function log likelihood logdisc logistic discriminant logistic discrimination logistic discrimination programming lvq m statistic machine faults dataset machine learning approaches machine learning approaches to classifica tion madaline manova many categories marginalisation mars maximum conditional likelihood maximum likelihood mcculloch-pitts neuron mdl measure of collinearity measures measures information-based measures statistical measures of normality medical datasets memory mental fit mental fit metalevel learning minimisation methods minimum cost rule minimum description length prin ciple minimum risk rule misclassification costs missing values ml on ml mlp mntal fit multi layer perceptron multi layer perceptron functionality multi-class trees multidimensional scaling multimodality multivariate analysis of variance multivariate kurtosis multivariate normality multivariate skewness mutual information naive bayes nearest neighbour nearest neighbour example neural network approaches neural networks neurons newid no data rule node hidden node impure node input node output node purity node winning noise noise signal ratio noisy noisy data nonlinear regression nonparametric density estimator nonparametric methods nonparametric statistics normal distribution ns.ratio object recognition datasets observation language odds optimisation ordered categories over-fitting overfitting parametric methods partitioning as classification parzen window pattern recognition perceptron performance measures performance prediction plug-in estimates polak-ribiere pole balancing polytrees polytrees polytrees as classifiers pooled covariance matrix prediction as classification preprocessing primary attribute prior uniform prior probabilities probabilistic inference products of attributes projection pursuit projection pursuit projection pursuit classification propositional learning systems index prototypes pruning pruning backward pruning cost complexity pruning forward purity purity measure purity measure quadisc quadiscr quadratic discriminant quadratic discriminants quadratic functions of attributes radial basis function radial basis function radial basis function network ramnets rbf recurrent networks recursive partitioning reduced nearest neighbour reference class regression tree regularisation relational learning retis rg risk assessment rule-based methods rule-learning satellite image dataset scaling parameter scatterplot smoother sdratio secific-to-general secondary attribute segmentation dataset selector time time to learn time to test train-and-test training optimisation training set transformation transformation of attributes transformations of variables tree-learning trees-into-rules tsetse dataset tuning of parameters uk credit dataset uniform distribution univariate kurtosis univariate skewness universal approximators universal computers unsupervised learning upstart user s guide to algorithms vector quantizers vehicle vehicle dataset vertebrate vertebrate species voronoi tessellation xpertrule yardstick methods zero variance index shuttle shuttle dataset simulated digits data skew abs skewness smart smoothing parameter smoothing parameters snr specific-to-general speed splitiing criteria splitting criteria splitting criterion splus statistical approaches to classification statistical measures statlog statlog collection of data statlog objectives statlog preprocessing stepwise selection stochastic gradient storage structured induction subset selection sum of squares supervised learning supervised networks supervised vector supervisor symbolic learning symbolic ml taxonomic taxonomy technical dataset tertiary attribute test environment test set three-mile island tiling algorithm